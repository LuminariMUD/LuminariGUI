<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>NyyLIB</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Mud Setup</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tog minimap</name>
					<script>mud:send("TOG minimap")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You will no longer see the mini-map when moving.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>minimap display</name>
					<script>echoDebug("&lt;red&gt;[Trigger: minimap display (entry)]")

if matches[2] == "\t\t\t" then
  -- closing \t\t\t arrived
  return
end

selectCurrentLine()
copy()
appendBuffer("minimapBuffer")

if charData:get("winMinimap") then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>minimap marker</name>
					<script>if isActive("minimap display", "trigger") ~= 0 then
  -- minimap is currently active, the closing \t\t\t\n just arrived
  disableTrigger("minimap display")  

  if charData:get("winMinimap") then
    eraseLine()
  end

  miniMap:update()
else
  -- opening \t\t\t\n just arrived. It may contain a prompt.
  --eraseLine()
  enableTrigger("minimap display") -- minimap display gag
  --clearWindow("minimapBuffer")
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?\t\t\t$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>replace tab trigger</name>
					<script>while selectString("\t",1) &gt; -1 do
  replace("     ")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\t</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>topgags</name>
					<script>-- You lack the proper component to use this power.

eraseLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>YiPeE! You can't see me</string>
						<string>Unsplit Coins: </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Type the # or name of a character above to login or choose an action below.</name>
					<script>scriptInitialized=nil

-- Disable single letter aliases
disableAlias("movement commands")
--disableAlias("p")
--disableAlias("g")
disableAlias("l (look)")

disableTrigger("resend practice")

if whoami() ~= nil then
  if not noreconnect then
    if charData:get("reconnect") ~= false then
      send(charData:get("reconnect") )
    end
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Type the # or name of a character above to login or choose an action below.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Enemy position display turned OFF.</name>
					<script>-- mud configuration

mud:send("display enemypos")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Enemy position display turned OFF.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>to get started. You can then link all of your characters to your new account</name>
					<script>map:hide()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>  to get started. You can then link all of your characters to your new account$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Position display turned OFF.</name>
					<script>mud:send("display position")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Position display turned OFF.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Spell slots display turned OFF.</name>
					<script>mud:send("display slots")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Spell slots display turned OFF.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hear tells</name>
					<script>-- You can now hear Tells.
-- You are now deaf to Tells.

canHear = matches[2]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You can now (hear) Tells.</string>
						<string>You are now (deaf) to Tells.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tog rescue-assist</name>
					<script>--enable: tog rescue-assist
-- You will no longer auto-assist after being rescued.
-- You will no longer auto-assist after being rescued.

mud:send("tog rescue-assist")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You will no longer auto-assist after being rescued.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Pardon? bandaid</name>
					<script>if commandSent == "" then
  gagLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Pardon[?]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Combo display turned OFF.</name>
					<script>
if checkMask("hex") then
  mud:send("display combo")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?Combo display turned OFF.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Smartprompt toggled on.</name>
					<script>--mud configuration

mud:send("tog smartprompt")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?Smartprompt toggled on.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>enable newprompt</name>
					<script>-- mud configuration

mud:send("TOG newprompt")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You will now see the classic prompt.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>enable newline</name>
					<script>-- mud configuration

mud:send("PROMPT options newline", false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?Prompt option newline disabled.$</string>
						<string>^(?:&lt; .* &gt; )?Prompt layout set.$</string>
						<string>^(?:&lt; .* &gt; )?You will now see the new prompt.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>PromptCapture</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>T/TC/EC/EP/P</name>
						<script>--display("T/TC/EC/EP/P")
--display(matches)
--{"&lt; T: Wopur TC: few scratches E: lithe EC: awful EP: rcl P: std &gt;", 
-- "Wopur ", "few scratches ", "lithe", "awful ", "rcl ", "std" }
-- &lt; P: std &gt;    

-- &lt; 823h/845H 166v/166V T: Rrassulis TC: few scratches E: lithe EC: few scratches EP: std P: std &gt; 

prompt:set("tank", matches[2]:trim())
prompt:set("tankcondition", matches[3]:trim())
prompt:set("enemy", matches[4]:trim())

if prompt:get("enemy") ~= "" then
  setEnemy( string.title(prompt:get("enemy")) )
end

prompt:set("enemycondition", matches[5]:trim())
prompt:set("enemyposition", matches[6]:trim())
prompt:set("position", matches[7]:trim())
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^&lt;.*?(?:T: ([A-Za-z ]+))? ?(?:TC: ([A-Za-z ]+))? ?(?:E: ([A-Za-z '-]+))? ?(?:EC: ([A-Za-z ]+))? ?(?:EP: ([A-Za-z ]+))? P: ([A-Za-z ]+).*&gt;</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>capture nameplates</name>
						<script>-- &lt; [Tank: Wopur  94%  rcl] [Target: graceful  68%] EP: std P: rcl &gt; 
-- &lt; [Tank: Tutenef  94%] [Target: lithe  65%  rcl] EP: rcl P: std &gt;
-- &lt; [Tank: Tutenef  90%] [Target: lithe  24%] EP: std P: std &gt;
-- &lt; [Tank: Tutenef  100%] [Target: willa  29%] EP: std P: std &gt;
--display(matches)

prompt:set("tank", matches[2]:trim())
-- prompt:set("tankcondition", matches[3]:trim())
prompt:set("enemy", matches[4]:trim())

if prompt:get("enemy") ~= "" then
  setEnemy( string.title(prompt:get("enemy")) )
end

-- prompt:set("enemycondition", matches[5]:trim())

prompt:set("enemyposition", matches[6]:trim())
prompt:set("position", matches[7]:trim())
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^&lt; .*\[Tank: ([A-Za-z '-]+)  ([0-9]+)%.*\] \[Target: ([A-Za-z '-]+)  ([0-9]+)%.*\] ?(?:EP: ([A-Za-z ]+))? ?(?:P: ([A-Za-z ]+)).*&gt;</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hH/pP/vV/combo</name>
						<script>--display("HH/pP/vV/combo")
--display(matches)

if matches[2] ~= "" then
  prompt:set("hp", tonumber(matches[2]))
end

if matches[3] ~= "" then
  prompt:set("maxhp", tonumber(matches[3]))
end

if matches[4] ~= "" then
  prompt:set("psp", tonumber(matches[4]))
else
  prompt:set("psp", nil)
end

if matches[5] ~= "" then
  prompt:set("maxpsp", tonumber(matches[5]))
else
  prompt:set("maxpsp", nil)
end

if matches[6] ~= "" then
  prompt:set("mv", tonumber(matches[6]))
end

if matches[7] ~= "" then
  prompt:set("maxmv", tonumber(matches[7]))
end

-- matches[8] is hex combo charges
if matches[8] ~= "" then
  prompt:set("combo", tonumber(matches[8]))
else
  prompt:set("combo", "")
end

groupList:setHP(whoami(), prompt:get("hp"), prompt:get("maxhp") )

-- add percent to table
prompt:set("hp%", prompt:get("hp") / prompt:get("maxhp") * 100 )

if charData:get("condensed", true)["powersbar"] then
  local start,stop= string.find( matches[1], "|.+|" )
  
  if start then
    selectSection(start-1, stop-start+2)
    replace("")
  end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^&lt;.+?(?:(\d+)h)\/?(?:(\d+)H) ?(?:(\d+)p)?\/?(?:(\d+)P)? ?(?:(\d+)v)?\/?(?:(\d+)V)? ?(?:.*\((\d)\))?.*?&gt;</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>powers prompt</name>
						<script>--display("pp")
--display(matches[2])

-- &lt; |hb   +|df   +|se   +|mb   +|su   x|hs   x|bf   x|vf   x|vs   x|fa   +| &gt;

if matches[2] ~= "" and matches[2] ~= nil then
  prompt:decodePowers(matches[2])
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^&lt;.+?[\|]((?:[0-9 ]*[a-z]+ +[0-9x+]+\|)+).*?&gt;</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>spellslots</name>
						<script>--display("ss")
if matches[2] ~= "" then
  --display(matches[10])
  prompt:decodeSpellSlots(matches[2])
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^&lt;.*[\|]((?:[0-9 ]\|)+).*&gt;</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>end of prompt sequence</name>
						<script>raiseEvent("promptEvent")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>&gt;\t\n$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>firstprompt</name>
						<script>if not scriptInitialized then
  raiseEvent("promptEvent")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^&lt; .* &gt;.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>identify mob</name>
				<script>--&lt; 814h/814H 110v/110V T: Vori TC: excellent E: lavis EC: nasty wounds EP: std P: std &gt;

--Vori sends Lavis Ryl sprawling with a powerful bash.
--[Error: Trying to set Vori as enemy!]
-- "&lt; 814h/814H 110v/110V T: Vori TC: excellent E: forell EC: small wounds EP: std P: std &gt; Vori"


-- Dagrathigon barely wounds a githyanki soldier with his massive pierce.
-- error, same


-- The spirit wolf barely wounds an elite barbazu soldier with its mighty drain.

-- A red abishai patrol member barely wounds Ferifle with his weak slash.
-- a minion of Moander 


if matches[2] == "Someone" or matches[3] == "someone" then
  return
end


local enemy
local player


if groupList:ingroup(matches[2]) then
  enemy=matches[3]
  player=matches[2]
else
  enemy=matches[2]
  player=matches[3]
end

if enemy ~= nil then
  enemy=idMob(enemy)
else
  cecho("&lt;red&gt;\n[Error: nil enemy]\n")
  return
end


if groupList:ingroup(enemy) then
  cecho("&lt;red&gt;\n[Error: Trying to set " .. enemy .. " as enemy!]\n")
  --display( matches[2] )
  --display( matches[3] )

  return
end

if groupList:ingroup(player) then
  if getEnemy() == "" then
    setEnemy( enemy )
  end
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>([A-Za-z]+) sends (.*) sprawling with a powerful bash.</string>
					<string>([A-Za-z]+) barely wounds (.*) with .*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>reset variables</name>
				<script>-- clear enteredportal count

enteredPortal = {}

assistSent = nil

-- spell:setCurrent()
-- it's possible to send look+cast, and have look return first

fleeAttempt = 0

sendingStatus = false</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Exits: (.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Demonnic</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Tabbed Chat</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>GSAY</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
  chatCapture=true

  demonnic.chat:append("GSAY", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+)?/?([A-Za-z ]+ )group-says? ('.*')$</string>
							<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+)?/?([A-Za-z ]+ )group-projects? ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>OOC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
  chatCapture=true
  demonnic.chat:append("OOC", whoMatch, bodyMatch)
end

--display(matches)

--testtable=matches</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+/)?([A-Za-z]+ )OOC: ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>NHC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
  chatCapture=true
  demonnic.chat:append("NHC", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+)?/?([A-Za-z]+ )NHC:(?: \(H\))? ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ACC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
  chatCapture=true
  demonnic.chat:append("ACC", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+)?/?([A-Za-z]+ )ASSOC: ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>GCC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
  chatCapture=true
  demonnic.chat:append("GCC", whoMatch, bodyMatch)
end

--alert()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+/)?([A-Za-z]+ )GCC: ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>TELLS</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

alert()

if not chatCapture then
  chatCapture=true
  demonnic.chat:append("TELLS", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>39</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(.* )tells you ('.*')$</string>
							<string>^(?:&lt; .* &gt; )?(You tell )(.*)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Skill</name>
						<script>-- ([A-Za-z]+) has died!

local bodyMatch= getColourString( matches[2] )

if not chatCapture then
  chatCapture=true
  demonnic.chat:append("SKILL", bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(You have learned something new about .*)$</string>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ has died!)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Gruumsh responds to your petition with</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

-- Beshaba responds to your petition with
if not chatCapture then
  chatCapture=true
  demonnic.chat:append("TELLS", whoMatch, bodyMatch)

  sound("365641__furbyguy__8-bit-alarm.wav",nil,true) 
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )responds to your petition with (.*)</string>
							<string>^(?:&lt; .* &gt; )?(You )petition (.*)</string>
							<string>^(?:&lt; .* &gt; )?(.* )responds to your group with (.*)</string>
							<string>^(?:&lt; .* &gt; )?(\[[A-Z][a-z]+\]:? )(.*)</string>
							<string>^(?:&lt; .* &gt; )?(\[SYSTEM\] )(.*)</string>
							<string>^(?:&lt; .* &gt; )?(\&lt;Support\&gt; [A-Za-z]+)(: '.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>SAYS</name>
						<script>-- ^(?:&lt; .* &gt; )?([A-Za-z]+ )says ('.*')$
-- ^(?:&lt; .* &gt; )?([A-Za-z]+ )projects ('.*')$
-- ^(?:&lt; .* &gt; )?(You )say ('.*')$
-- ^(?:&lt; .* &gt; )?(You )project ('.*')$

-- Oghma says with a melodious voice 'I can see it either way'
-- Dugmaren mutters in a surly voice 'ok'

-- You sign 'can someone sign something?'
-- Nilan signs 'hi'


-- says is not compacted

local whoMatch= getColourString( matches[2] )
-- local bodyMatch= getColourString( matches[3] )

if not chatCapture then
  chatCapture=true
  demonnic.chat:append("SAYS", whoMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ says '.*')$</string>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ projects '.*')$</string>
							<string>^(?:&lt; .* &gt; )?(You say '.*')$</string>
							<string>^(?:&lt; .* &gt; )?(You project '.*')$</string>
							<string>^(?:&lt; .* &gt; )?(You sign '.*')$</string>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ signs '.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>AUCTION</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

-- Auction: a silvery war axe term ended with NO SALE
if not chatCapture then
  chatCapture=true
  
  -- Only capture body
  demonnic.chat:append("AUC", bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(Auction: )(.*)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>end chat capture</name>
						<script>chatCapture=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(.*)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>SpellTracker</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You have finished praying for</name>
					<script>local spellname = to_snake(matches[2])

charData:init("memcount", 1)

if charData:get("memcount") == 0 then
  charData:set("memcount", 1)
end

incSpellCount(spellname)

-- update spell button/ spells to memorize

if charData:get("memcount") &gt; 0 then
  charData:set("memcount", charData:get("memcount")-1 )
  MemButton("MemButton", buttons.UPDATE)
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have finished praying for ([A-Za-z ]+)[.]</string>
						<string>You have finished memorizing ([A-Za-z ]+)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Memorized Spells</name>
					<script>--               12 - Magic Missile

setSpellCount(to_snake(matches[3]), tonumber(matches[2]))</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\( [0-9][snrt][dth] circle\) +([0-9]+) - ([A-Za-z ]+)$</string>
						<string>^\(10th circle\)  ([0-9]) - ([A-Za-z ]+)$</string>
						<string>^               ?([0-9]+) - ([A-Za-z ]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>And you are currently praying for the following spells:</name>
					<script>-- enable counter

charData:set("memcount", 0)

spell:setMem(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>And you are currently praying for the following spells:</string>
						<string>You are currently memorizing the following spells:</string>
						<string>And you are currently memorizing the following spells:</string>
						<string>You are currently praying for the following spells:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>spells to memorize</name>
					<script>-- 146 seconds:  ( 3rd) Jar The Soul
--  89 seconds:  (10th) Ancestral Fury

if charData:get("memcount") == nil then
  charData:set("memcount", 0)
end

charData:set("memcount", charData:get("memcount")+1)
MemButton("MemButton", buttons.UPDATE)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^    [0-9] seconds:  \([1 ][0-9][snrt][tdh]\) ([A-Za-z ]+)$</string>
						<string>^   [0-9][0-9] seconds:  \([1 ][0-9][snrt][tdh]\) ([A-Za-z ]+)$</string>
						<string>^  [0-9][0-9 ][0-9] seconds:  \([1 ][0-9][snrt][tdh]\) ([A-Za-z ]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your prayers are complete.</name>
					<script>-- finish mem

spell:setMem(false)

charData:set("memcount", 0)
MemButton("MemButton", buttons.UPDATE)

-- reset groupsend
--group:set(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your prayers are complete.$</string>
						<string>^Your studies are complete.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You can pray for no more spells.</name>
					<script>if prompt:get("position") == "sit" and charData:get("memcount") == 0 then
  mud:send("ST")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You can pray for no more spells.</string>
						<string>You can memorize no more spells.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You have memorized the following spells:</name>
					<script>charData:set("spells", {})

-- Todo: This should also update the spellcount on gui buttons</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have memorized the following spells:</string>
						<string>^You forget all the memorized spells.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>A feeling of immense power flows through you.</name>
					<script>-- righteous might on</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A feeling of immense power flows through you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are praying for Dispel Magic, which will take about 4 seconds.</name>
					<script>if charData:get("memcount") == 0 then
  charData:set("memcount", 1)
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are praying for</string>
						<string>You are memorizing</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You start chanting...</name>
					<script>-- casting spell
local castspell=spell:getCurrent()

if castspell == nil then
  if command ~= "group" and command ~= "look" then
    spell:setCurrent(command)
    echoDebug("&lt;red&gt;[Setting spell.casting to " .. command .. "]")
    castspell=command
  else
    spell:setCurrent("unknown")
    echoDebug("&lt;red&gt;[Setting spell.casting to unknown command: " .. command .. "]")
    castspell="unknown"
  end
end

castspell=castspell:lower()

local displayname = to_english(powerAliases:toSpell(castspell))

cecho("&lt;red&gt; [Casting: &lt;yellow&gt;" .. castspell:upper() .. " &lt;green&gt;(" .. displayname .. ")&lt;red&gt;]")

-- Update local spellcount

local spellname= powerAliases:toSpell(castspell)

if spellname ~= nil then
  if matches[2] == "chanting" then
       -- Spell is being successfully cast
      decSpellCount(spellname)
  elseif matches[2] == "memorized" or matches[2] == "available" then
       -- Spell was not successfuly cast because because not memorized
      
      echoDebug("\n&lt;red&gt;[ Setting spell count for: " .. spellname .. " to 0 after 'Dont have that spell memorized message'.]" )
       setSpellCount(spellname, 0)

    -- if that spell is currently queued clear it
    -- clear would need to be power alone (not target)

    --spell:clear(spellname)
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .*)?You start (chanting)...</string>
						<string>^You don't have that spell (memorized).*</string>
						<string>^You don't have any more spells (available) at that circle!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>spell completed - updated hp</name>
					<script>-- You cast the spell 'Healing Aura'.

-- and hp to local database if heal spells cast

local spellname= spell:getCurrent()

charData:set("memcount", charData:get("memcount")+1)

if spellname ~= nil then
  spellname = spellname:lower()

  local displayname = to_english(powerAliases:toSpell(spellname))

  --cecho("&lt;red&gt; [&lt;cyan&gt; " .. spellname:upper() .. " (" .. displayname .. ") &lt;red&gt;]")

  -- [Completed spell: dopple Bombum (Doppleganger) ]

  -- if spellname dopple add buff

  local dopplechar = string.match(spellname, "^dpl (.*)")

  if groupList:ingroup(dopplechar) then
    buff:set(dopplechar, "doppleganger", 1000)
  end

  -- if spellname ff or faerie fire mark as cast

  if string.find(spellname, "^ff") or string.find(spellname, "faerie fire") then
    spell:setCast("ff")
  end

  -- if spell cast was groupheal clear all blind
  if spellname == "gh" then
    for k,char in pairs(groupList:pc()) do
      buff:del(char, "blind")
      buff:del(char, "blindness")
    end

    -- is this sending abort?
    spell:clear("gh", true)
  end

  local realmchar = string.match(spellname, "^realm (.*)")

  if realmchar ~= nil then
    realmchar = string.title(realmchar)
  end

  if groupList:ingroup(realmchar) then
    buff:set(realmchar, "greater_realm_of_protecti", 45*60)
  end

  local cbchar = string.match(spellname, "^cb$")

  if cbchar then
    -- remove blind
    buff:del(whoami(), "blind")
    buff:del(whoami(), "blindness")
  end

  local cbchar = string.match(spellname, "^cb (.*)")

  if groupList:ingroup(cbchar) then
    -- remove blind
    buff:del(cbchar, "blind")
    buff:del(cbchar, "blindness")
  end

  local dpuchar = string.match(spellname, "^dpu (.*)")

  if dpuchar ~= nil then
    dpuchar = string.title(dpuchar)
  end

  if groupList:ingroup(dpuchar) then
    -- remove blind, para, poison flag on divine purify
    buff:del(dpuchar, "blind")
    buff:del(dpuchar, "blindness")
    buff:del(dpuchar, "minor_paralysis")
    buff:del(dpuchar, "major_paralysis")
  end

  local fhchar = string.match(spellname, "^fh (.*)")

  if fhchar ~= nil then
    fhchar = string.title(fhchar)
  end

  if groupList:ingroup(fhchar) then
    -- remove blind flag on fullheal
    buff:del(fhchar, "blind")
    buff:del(fhchar, "blindness")

    local hp=tonumber(groupList:getHP(fhchar))
    local maxhp= tonumber(groupList:getMaxHP(fhchar))

    if hp == nil or maxhp == nil then
      return
    end

    if hp &lt; maxhp then
      hp=hp+300

      if hp &gt; maxhp then
        hp=maxhp
      end

      groupList:setHP(fhchar, hp, maxhp)
    end
  end
else
  -- cecho(" &lt;red&gt;[&lt;green&gt;Completed spell: &lt;red&gt;unknown]" )
end

spell:setCurrent(nil)

-- reset groupsend
if group:get() == "GROUPSENT" then
  group:set(false)
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You complete your spell.*</string>
						<string>^You cast the spell.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>failed spellcast</name>
					<script>-- You abort your prayer before it's done! if moving gsay
-- You are already affected by Greenfire!

local tmp=memsent

if matches[2] == "are already affected by" then
  if spell:getCurrent() == nil then
    echoDebug("&lt;red&gt;[Failed spellcast, but current is nil]")
  else
    local castString = spell:getCurrent()

    failedSpell = castString

    
    -- if healing aura set status to prevent further cast "HA Ynndchiarhlizz"
    -- healing aura not currently in status
    
    if string.split(failedSpell, " ")[1] == "HA" then
      buff:set( string.split(failedSpell, " ")[2], "healing_aura", 30)
    end

    echoDebug("\n&lt;red&gt;[ " .. castString .. " : Already affected by this spell ]" )

    -- send status on spell target: only works if grouped
    for k,v in pairs( string.split(castString, " ") ) do
      if k == 2 and (groupList:ingroup(v) or pet:getInRoom(v)) then
        sendStatus(v)
      end
    end
  end
end

spell:setMem(false)

if spell:getMoving() == false then
  spell:stop()
  spell:cast()
else
  spell:setCurrent(nil)
end

-- restore original value for memsent
memsent=tmp</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>They (are already affected by)</string>
						<string>You (are already affected by)</string>
						<string>You don't have that spell memorized.</string>
						<string>You don't see them here!</string>
						<string>You have to be standing up to do that!</string>
						<string>You abort your prayer before it's done!</string>
						<string>That power hasn't recharged yet!</string>
						<string>That spell cannot be cast for another</string>
						<string>You are stunned and unable to concentrate enough for that!</string>
						<string>You need their consent to do that.</string>
						<string>You abort your spell before it's done!</string>
						<string>Impossible! You can't concentrate enough!</string>
						<string>seems to be just a BIT out of reach.</string>
						<string>You don't see that item here.</string>
						<string>Standing would be a good first step.</string>
						<string>Nobody here by that name.</string>
						<string>You don't have any more spells available at that circle!</string>
						<string>Who should the spell be cast upon?</string>
						<string>You can't use this power on NPCs.</string>
						<string>You would pass right through them!</string>
						<string>That power would have no effect on them!</string>
						<string>You need to be able to speak to do that!</string>
						<string>You can't do that without solid ground underneath you!</string>
						<string>You are already maintaining that power!</string>
						<string>The magic gathers, then fades away.</string>
						<string>Nobody playing by that name.</string>
						<string>You can't see a thing, you're blinded!</string>
						<string>They have too much health to be affected by that.</string>
						<string>You can't teleport there.</string>
						<string>You must be in the same room as the group leader to do that.</string>
						<string>You can't do that underwater!</string>
						<string>You don't see that corpse here.</string>
						<string>No target for your power could be found!</string>
						<string>Pardon?</string>
						<string>You may not cast offensive spells on other players.</string>
						<string>You need to wield a bow to do that.</string>
						<string>You don't have any more spells available at that circle!</string>
						<string>You need to wield a melee weapon to do that.</string>
						<string>You flee (.*)ward!</string>
						<string>You can only cast this spell on yourself.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You're busy spellcasting!</name>
					<script>if spell:getCurrent() ~= nil then
  echoDebug("&lt;red&gt;[Busy casting: " .. spell:getCurrent() .. "]")
else
  echoDebug("&lt;red&gt;[Unknown spell being cast]")
  spell:setCurrent("bugfix")
end

cecho("&lt;red&gt; [Queing error: " .. command .. "]\n")

-- reset groupsend
group:set(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You're busy spellcasting!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You complete your spell...</name>
					<script>-- sets to nil

--charData:set("memcount", 0)

if matches[2] == "You clamber to your feet." or matches[2] == "Your prayers are complete." then
  if checkMask("casterPsi") then
    MemButton("MemButton", buttons.INIT)
  end
end

if checkMask("singer") == false and not checkMask("powerCaster") then
  MemButton("MemButton", buttons.UPDATE)
end

if matches[2] == "That spell cannot be cast for another" then
  mud:send("RECHARGE")
end

look:set(nil)

spell:stop() -- set spell.casting=nil

-- only have priests send group command after casting
if checkMask("pray") then
  group:send()
end

look:send()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You complete your spell...).*</string>
						<string>(You clamber to your feet.)</string>
						<string>(Your prayers are complete.)</string>
						<string>(You finish scribing spell)</string>
						<string>^You cast the spell.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>[A-Za-z]+ group-says 'moving.*</name>
					<script>-- reset variable
NyyLIB.escapedir = nil

spell:setMoving(true)

-- set to false to fix potential bug

group:send(false)

if checkMask("psi") then
  if getHide() then
    cecho("\n&lt;red&gt;[Not standing, currently hidden.]\n")
  else
    mud:send("ST")
  end
end

if checkMask("caster") or checkMask("nonPriestCaster") or checkMask("pray") then
  spell:clear()

  if getHide() then
    echo("\n[Not standing, currently hidden.]\n")
  else
    mud:send("ST")
  end
end

if mount:getMounted() then
  mud:send("dismount")
end

automem = 0

--expandAlias("@debug")

-- If function movingClassnameSubclass exists, call it
-- Example: movingSorDraconic()
local fnMoving="moving" .. whoclass() .. subClass

if _G[fnInit] ~= nil then
  _G[fnInit]()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[A-Za-z]+ group-says? '(mov|mv|omv|dmov|mvo).*</string>
						<string>([A-Za-z]+) group-says? '(Adud|adud|tanks|tank) ([nsewud]).*'</string>
						<string>.* group-says? '\[Moving to: .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>gsay memorize trigger</name>
					<script>if matches[2] == NyyLIB.leader or matches[2] == whoami() then
  sendFollowers()

  if checkMask("blk") then
    return
  end


  if checkMask("casterPsi") or checkMask("nonPriestCaster") and not checkMask("noMemCaster") then
  --if checkMask("casterPsi") then
    if not getHide() then
      if memsent == true then
        echo("\n")
      end

      mud:send("mem")
    end
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) group-says? 'mem.*</string>
						<string>([A-Za-z]+) group-says 'quick mem'</string>
						<string>([A-Za-z]+) group-says 'dmem.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You continue your study.</name>
					<script>setLabelImage("MemButton", "stand.png")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You continue your study.</string>
						<string>You continue your praying.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You abandon your studies.</name>
					<script>-- reset variable
NyyLIB.escapedir = nil

mud:send("st")

spell:setMem(false)

automem=0

MemButton("MemButton", buttons.INIT)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You abandon your studies.$</string>
						<string>^(?:&lt; .* &gt; )?You abandon your prayers.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The world starts spinning, and your ears are ringing!</name>
					<script>-- stunned

sound("274736__sforsman__distort-ring-2.wav")

buff:set(whoami(), "stun", 2)
spell:clear()
sendStatus()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?The world starts spinning, and your ears are ringing!</string>
						<string>^(?:&lt; .* &gt; )?You are stunned and unable to concentrate enough for that!$</string>
						<string>^(?:&lt; .* &gt; )?You are too stunned to do that!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You purge 'Healing Aura' spell from your thoughts.</name>
					<script>local spellname= to_snake(matches[2])

decSpellCount(spellname)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You purge '(.*)' spell from your thoughts.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You can't concentrate with all the racket!</name>
					<script>-- set as currently moving

-- You clamber to your feet. &lt;- Can't use, won't cast

spell:setMoving(true)
look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You can't concentrate with all the racket!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are already affected by that spell!</name>
					<script>sendStatus()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are already affected by</string>
						<string>Your form begins to</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are in a dead magic area and cannot cast spells!</name>
					<script>-- this room is !cast (either magically or beholder proc)

-- The magic gathers, then fades away.

nomagic = true

spell:clear()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are in a dead magic area and cannot cast spells!</string>
						<string>You need to be able to speak to do that!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You seem to have misplaced your spell book during memorization.</name>
					<script>-- disable autocast
buttons:change("autocast", false, "SpellsButton")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You seem to have misplaced your spell book during memorization.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You've created a devastating sandstorm!</name>
					<script>-- sandstorm - add 12 minute cooldown
timer:set("sandstorm", 12*60)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You've created a devastating sandstorm!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>recharge - sandstorm</name>
					<script>--  - Sandstorm in 5 minutes 45 seconds 1 pulse 
--  - Sandstorm in 2 minutes 2 seconds 2 pulses 

local timeleft

if matches[2] == "recharging" then
  timeleft=0
else
  if matches[3] == nil then
    timeleft = tonumber(matches[2])
  else
    timeleft = tonumber(matches[2])*60 + tonumber(matches[3])
  end
end

timer:set("sandstorm", timeleft)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Sandstorm in ([0-9]+) seconds .*</string>
						<string> - Sandstorm in ([0-9]) minutes ([0-9]+) seconds</string>
						<string>You do not have any powers (recharging).</string>
						<string> - Sandstorm in ([0-9]) minute ([0-9]+) seconds</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You abort your prayer before it's done!</name>
					<script>-- This doesn't work if you're casting on someone doing runs and they move midcast
-- spell:setMoving(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You abort your prayer before it's done!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You sit down and relax.</name>
					<script>prompt:set("position", "sit")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You sit down and relax.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>ClassTriggers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Bard</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are not composed enough to sing.</name>
						<script>tempTimer(3, playsong)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are not composed enough to sing.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You decide not to expend the mana required to keep your song.</name>
						<script>charData:set("_instrument", charData:get("currentInstrumentType") )

charData:set("_song", charData:get("song") )

echoDebug("\n&lt;red&gt;[Previous song set: " .. charData:get("_song") .. "]" )

tempTimer(3, tr_renew)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You decide not to expend the mana required to keep your song.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Resume singing</name>
						<script>if checkMask("singer") then
  playsong()
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world stops spinning.</string>
							<string>You are no longer attractive to pigeons.</string>
							<string>You feel able to speak again.</string>
							<string>your soul is gently deposited into your previous body, at the feet of ([A-Za-z]+)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Heal vs Dragons</name>
						<script>-- if you get attacked by a dragon and aren't singing heal, switch to heal
if checkMask("singer") then
  if charData:get("song") ~= "song of healing" then
     mud:send("ST")
     mud:send("REM ravenous")
     music( "lute", "song of healing", "")
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You reel backwards in pain as the massive tail smashes into you!</string>
							<string>breathes Fire!</string>
							<string>breathes a cone of frost!</string>
							<string>staggers in pain as the massive tail smashes into</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Songs</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of healing.</name>
							<script>if NyyLIB.active ~= "HealSong" then
  resetSongs()

  setLabelImage("HealSong", "barHeal-on.png")

  NyyLIB.active = "HealSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of healing.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of protection.</name>
							<script>if NyyLIB.active ~= "ProtectSong" then
  resetSongs()

  setLabelImage("ProtectSong", "protect-on.png")

  NyyLIB.active = "ProtectSong"
end

NyyLIB.songtimer=12
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of protection.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of renewal.</name>
							<script>if NyyLIB.active ~= "RenewSong" then
  resetSongs()

  setLabelImage("RenewSong", "renew-on.png")

  NyyLIB.active = "RenewSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of renewal.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of sorcery.</name>
							<script>NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of sorcery.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of travel.</name>
							<script>if NyyLIB.active ~= "TravelSong" then
  resetSongs()

  setLabelImage("TravelSong", "travel-on.png")

  NyyLIB.active = "TravelSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of travel.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish belting out a verse of the song of harming.</name>
							<script>if NyyLIB.active ~= "HarmSong" then
  resetSongs()

  setLabelImage("HarmSong", "barHarm-on.png")

  NyyLIB.active = "HarmSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish belting out a verse of the song of harming.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your bellowing blast deadens the reflexes of your foes.</name>
							<script>if NyyLIB.active ~= "SlowSong" then
  resetSongs()

  setLabelImage("SlowSong", "slow-on.png")

  NyyLIB.active = "SlowSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your bellowing blast deadens the reflexes of your foes.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your harmonious notes flood the room, inspiring your companions.</name>
							<script>NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your harmonious notes flood the room, inspiring your companions.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your quickening chant fills your cohort with awesome determination.</name>
							<script>if NyyLIB.active ~= "HasteSong" then
  resetSongs()

  setLabelImage("HasteSong", "barHaste-on.png")

  NyyLIB.active = "HasteSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your quickening chant fills your cohort with awesome determination.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your voice lifts the spirits of your companions.</name>
							<script>if NyyLIB.active ~= "RecoverySong" then
  resetSongs()

  --  setLabelImage("RecoverySong", "recover-on.png")

  -- label=findlabel("RecoverySong")
  -- label:setStyleSheet([[border-image: url(]] .. iconpath("recover-on.png") .. [[)]])

  NyyLIB.active = "RecoverySong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your voice lifts the spirits of your companions.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You complete another verse, of the song of regeneration.</name>
							<script>if NyyLIB.active ~= "RegenSong" then
  resetSongs()

  setLabelImage("RegenSong", "barRegen-on.png")

  NyyLIB.active = "RegenSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You complete another verse, of the song of regeneration.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your solemn chant steadies your cohort with stalwart determination.</name>
							<script>NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your solemn chant steadies your cohort with stalwart determination.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body becomes more in tune with your mind!</name>
						<script>setLabelImage("barBless", "barBless-on.png")
buff:set(whoami(), "harmonious_blessing", 780) -- 30 seconds extra</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body becomes more in tune with your mind!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel less in tune with your body!</name>
						<script>setLabelImage("barBless", "barBless-off.png")
buff:del(whoami(), "harmonious_blessing")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel less in tune with your body!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your song has no affect here!</name>
						<script>mud:send("stopmusic")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your song has no affect here!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You begin singing.</name>
						<script>setLabelImage("StopMusic", "barStopMusic-timer.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You begin singing.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You stop your song.</name>
						<script>setLabelImage("StopMusic", "stopmusic.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You stop your song.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your spells have replenished.</name>
						<script>setSpellCount("harmonious_blessing", 3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your spells have replenished.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Determine char class level</name>
					<script>charData:set("level", tonumber(matches[2]))

followersSent=nil

sqlinwho(whoami())

for k, v in pairs(NyyLIB.fullclasslist) do
  if v[1] == matches[4]:trim()   then
    if inwho(whoami()) == false then
      whoadd(whoami(), v[2], matches[3]:trim())
    else
      -- make sure katumi database is correct class
      if NyyLIB.WhoClass.wholist[whoami()] ~= nil then
        NyyLIB.WhoClass.wholist[whoami()][1] = v[2]
      end
    end

    if NyyLIB.initgui == false then
      initFullData()
    end

    --checkVoteButton()

    return
  end
end

-- no matching class has been found</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Level: ([0-9]+)[ ]+Race: ([A-Z a-z-]+)[ ]+Class: ([A-Za-z- ]*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Psi</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>wormhole: ASSOC</name>
						<script>-- ^([A-Za-z]+) ASSOC::? '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
  return
end

local sender = multimatches[2][2]
local target = multimatches[2][4]


display(sender)
display(target)


if sender == "You" then 
  sender = whoami()
end

if checkMask("psi") then
  if not getHide() then
    if charData:get("wormhole") then
      eraseLine()
      noSound = true

      if target == "me" or target == "please" then
        mud:send("worm " .. sender)
      else
        mud:send("worm " .. target)
      end

      NyyLIB.psilag="wormhole"

      tempTimer(1.5, [[mud:send("mem")]])
  
      look:send()
    end
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#aa00ff</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#800080</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG12BG2</string>
							<string>^(?:@[A-Z][a-z]+)?/?([A-Za-z]+) ASSOC::? '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>wormhole: TELL</name>
						<script>-- ^([A-Za-z]+) tells you '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'

-- ^([A-Za-z]+) ASSOC::? '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
  return
end


local sender = multimatches[2][2]
local target = multimatches[2][4]

--if target == nil or target == "" then
--  target = sender
--end

if sender == "You" then 
  sender = whoami()
end

if charData:get("disableworm") then
  if checkMask("psi") then
    -- mud:send("t " .. sender .. " " .. string.title(sender) .. ", lack of voting on TMC (http://www.mudconnect.com/cgi-bin/vote_rank.cgi?mud=TorilMud,+the+Sojourner%27s+Home) has disabled this trigger. 30+ people are online free daily, but not willing to vote.")
    mud:send("t " .. sender .. " " .. string.title(sender) .. ", enabling this trigger requires contributing new or re-written helpfiles.")
    return
  end
end

if checkMask("psi") then
  if not getHide() then
    if charData:get("wormhole") then
      eraseLine()
      noSound = true

      if target == "me" or target == "please" then
        mud:send("worm " .. sender)
      else
        mud:send("worm " .. target)
      end

      NyyLIB.psilag="wormhole"

      tempTimer(1.5, [[mud:send("mem")]])
  
      look:send()
    end
  
    cecho("&lt;red&gt;\n\n[&lt;cyan&gt;WORM: &lt;red&gt;" .. sender .. "] " .. "&lt;yellow&gt;" .. target )
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#ffffff</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG15BG0</string>
							<string>^(?:@[A-Z][a-z]+)?/?([A-Za-z]+) tells you '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>rift: ASSOC</name>
						<script>-- ^([A-Za-z]+) tells you '(rift|gate) ([A-Za-z]+)( .*)?'

-- ^([A-Za-z]+) ASSOC::? '(rift|gate) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
  return
end


local sender = multimatches[2][2]
local target = multimatches[2][4]

if not getHide() then
  if charData:get("wormhole") then
    eraseLine()
    noSound = true

    mud:send("rift " .. target)
    NyyLIB.psilag="rift"

    tempTimer(1.5, [[mud:send("mem")]])

    look:send()
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#800080</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG12BG0</string>
							<string>^(?:@[A-Z][a-z]+)?/?([A-Za-z]+) ASSOC::? '(rift|gate) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>rift: TELL</name>
						<script>-- ^([A-Za-z]+) tells you '(rift|gate) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
  return
end


local sender = multimatches[2][2]
local target = multimatches[2][4]

if charData:get("disableworm") then
  if checkMask("psi") then
    --mud:send("t " .. sender .. " " .. string.title(sender) .. ", lack of voting on TMC (http://www.mudconnect.com/cgi-bin/vote_rank.cgi?mud=TorilMud,+the+Sojourner%27s+Home) has disabled this trigger. 30+ people are online free daily, but not willing to vote.")
    mud:send("t " .. sender .. " " .. string.title(sender) .. ", enabling this trigger requires contributing new or re-written helpfiles.")
    return
  end
end

if not getHide() then
  if charData:get("wormhole") then
    eraseLine()
    noSound = true

    mud:send("rift " .. target)
    NyyLIB.psilag="rift"

    tempTimer(1.5, [[mud:send("mem")]])

    look:send()
  end

  cecho("&lt;red&gt;\n\n[&lt;cyan&gt;RIFT: &lt;red&gt;" .. sender .. "] " .. "&lt;yellow&gt;" .. target )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#ffffff</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG15BG0</string>
							<string>^(?:@[A-Z][a-z]+)?/?([A-Za-z]+) tells you '(rift|gate) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your ultrablast hits [A-Za-z0-9]+ target[s.]+</name>
						<script>charData:set("ultraquested", true)
NyyLIB.psilag="ultra"
look:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your ultrablast hits [A-Za-z0-9]+ target[s.]+</string>
							<string>You feel a field of lethal energy start expanding outward.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Exits: .*</name>
						<script>if NyyLIB.psilag == "ultra" then
  if setLabelImage("ultrablast", "ultrablast-off.png") == nil then
    addbutton("ultrablast", 0, 2, 47)
  end
end

if NyyLIB.psilag == "death" then
  if setLabelImage("deathfield", "deathfield-off.png")  == nil then
    addbutton("deathfield", 0, 2, 20)
  end
end 

NyyLIB.psilag = "none"</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Exits: .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You envelop your mind in a protective tower.</name>
						<script>if charData:get("autotower") then
  setBackgroundColor("tower", 0,0,150,255)
end

NyyLIB.tower = 1
look:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You envelop your mind in a protective tower.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel more vulnerable to psionic attack.</name>
						<script>NyyLIB.tower=0

if charData:get("autotower") then
  mud:send("tower me", false)
  setBackgroundColor("tower",32,32,32,255)
  NyyLIB.psilag="tower"
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel more vulnerable to psionic attack.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>becomes more alert, evaluating possible targets.</name>
						<script>local xchar = matches[2]
local nx

if groupList:ingroup(xchar) then
  buff:set(xchar, "combatmind", 600)
  look:send()
end

for k,char in pairs(groupList:pc("hitterSinger")) do
  if not buff:get("combatmind", char) then
    return
  end
end

setBackgroundColor("combatmind", 0,0,150,255)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Z][a-z]+) becomes more alert, evaluating possible targets.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Drawing darkness itself around you,</name>
						<script>setHide(true)
look:send()
sendStatus()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Drawing darkness itself around you,</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>projection improves your fighting ability.</name>
						<script>-- batletrance on
setBackgroundColor("battletrance", 0,0,150,255)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>projection improves your fighting ability.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel a little confused as your augmented knowledge of battle tactics fades.</name>
						<script>-- battletrance off
setBackgroundColor("battletrance",32,32,32,255)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel a little confused as your augmented knowledge of battle tactics fades.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>[A-Za-z]+ group-says 'tower'</name>
						<script>if not getHide() then
  mud:send("tower me")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>[A-Za-z]+ group-says 'tower'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>group-says 'hole|worm ([A-Za-z])''</name>
						<script>--Pidibeple group-says 'hole wd so i can get back to group plz'--
--[  LUA  ] - object:&lt; group-says 'hole|worm ([A-Za-z])''&gt; function:&lt;Trigger95&gt;
--            &lt;[string "Trigger:  group-says 'hole|worm ([A-Za-z])'..."]:6: attempt to concatenate field '?' (a nil value)&gt;

local target=matches[4]

if checkMask("psi") then
  if getHide() then
    echo("[Not worming, currently hidden.]\n")
  else
    if target == "me" or target == "please" then
      target = matches[2]
    end
    
    mud:send("worm " .. target)
  
    NyyLIB.psilag="wormhole"

    tempTimer(1.5, [[mud:send("mem")]])
  
    look:send()
  end
end

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '(hole|worm) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The air in the immediate area darkens abruptly as a result of your projection!</name>
						<script>NyyLIB.psilag="death"
look:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The air in the immediate area darkens abruptly as a result of your projection!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You start meditating...</name>
						<script>spell:setMem(true)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You start meditating...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You stop meditating.</name>
						<script>spell:setMem(false)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You stop meditating.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body grows taller as you complete your projection.</name>
						<script>if whosize() == "L" then
  charData:set("bodysize", "H")
elseif whosize() == "M" then
  charData:set("bodysize", "L")
elseif whosize() == "S" then
  charData:set("bodysize", "M")
end

setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body grows taller as you complete your projection.</string>
							<string>Your body grows to gigantic heights!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You focus your mind and force your body to return to its natural size.</name>
						<script>charData:set("bodysize", whosize())

setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")

if table.contains( {"psi", "Enc" }, whoclass() ) then
  -- size change, no echo needed
else
  mud:send("gsay [[ SPELLOUT - NOW SIZE=" .. charData:get("bodysize") .. "]]")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You focus your mind and force your body to return to its natural size.$</string>
							<string>^(?:&lt; .* &gt; )?Your body size returns to normal.$</string>
							<string>^(?:&lt; .* &gt; )?Your body returns to its normal size.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body shrinks substantially as you complete your projection.</name>
						<script>if whosize() == "L" then
  charData:set("bodysize", "M")
elseif whosize() == "M" then
  charData:set("bodysize", "S")
elseif whosize() == "S" then
  charData:set("bodysize", "T")
end

setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body shrinks substantially as you complete your projection.</string>
							<string>Your body shrinks substantially.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>nopsp</name>
						<script>-- out of psp</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You do not have enough psp's to project that.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>War</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>EC: ([A-Za-z ]+) EP: (std|sit|rcl) P: (std)</name>
						<script>-- Being the ferocious sort, you charge at the enemy!

-- trip (rogue)

-- EC: ([A-Za-z ]+) EP: (std|sit|rcl) P: (std|sit|rcl)

if checkMask("rog") then
  if charData:get("autotrip") then
    if matches[3] == "std" then
      sendTrip()      
    end
  end
end

-- bash (fighter)

if checkMask("fighter") == false then
  return
end

if NyyLIB.escapedir ~= nil then
  return
end

if matches[3] == "std" then
  if canBash() then
    sendBash()
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>EC: ([A-Za-z ]+) EP: (std|sit|rcl) P: (std|sit|rcl)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Bash</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Elaith Waterstill clambers to his feet.</name>
							<script>if not inCombat() then
  return
end

if checkMask("rog") then
  if groupList:ingroup(matches[2]) == false and whoclass(matches[2]) == nil then
    if charData:get("autotrip") then
      sendTrip()      
    end
  end
end

if checkMask("fighter") == false then
  return
end

-- castOK intercepts if casting (example, paladin), escape attempt set, etc

if not spell:castOK() then
  return
end

if groupList:ingroup(matches[2]) == false and whoclass(matches[2]) == nil then
  if canBash() then
    sendBash()
  end
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(.*) clambers to .*</string>
								<string>^(.*) rises to (his|her|its) feet.$</string>
								<string>(.*) staggers about, but manages to get to (his|her) feet.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>failed rescues or bashes</name>
							<script>meleePowerUsed=false

setBashing(false)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?Sorry, you can't do that while lying around.</string>
								<string>you topple over and fall to the ground.</string>
								<string>^(?:&lt; .* &gt; )?You haven't reoriented yourself yet enough for another bash!</string>
								<string>^(?:&lt; .* &gt; )?Maybe you should get on your feet first?</string>
								<string>nimbly avoids your powerful shield bash!</string>
								<string>You are too stunned to do that!</string>
								<string>Your mount misses</string>
								<string>You have to be mounted to do that!</string>
								<string>Your mount refuses to trample!</string>
								<string>nimbly avoids your powerful shield bash!</string>
								<string>^(?:&lt; .* &gt; )?They are already affected by that power!</string>
								<string>^(?:&lt; .* &gt; )?That power hasn't recharged yet!</string>
								<string>^(?:&lt; .* &gt; )?You need to wield a</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>0</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You assist a dapper noble heroically.</name>
							<script>-- assisting someone
setBashing(false)
setTripping(false)

spell:setMem(false)

meleePowerUsed=false

-- rogue: circle
if charData:get("autocircle") then
  expandAlias("cr", false)
end
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You assist (.*) heroically.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>KegorRescue</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>visible fighting</name>
							<script>-- Bafog dodges an ice troll's attack.

-- A burly bouncer deflects Aliha's blow, and strikes back at Aliha!
-- A burly bouncer severely wounds Aliha with his massive bludgeon.

-- TODO if prior line = deflect, return

--A disgusting slithering vine badly wounds the ghost of a shambling mound with its powerful bite.
--A disgusting slithering vine shivers from the cold, as it hits the ghost of a shambling mound.
--A disgusting slithering vine badly wounds the ghost of a shambling mound with its powerful bite.
--A disgusting slithering vine shivers from the cold, as it hits the ghost of a shambling mound.


-- Text that should be skipped: 

-- A massive fireball erupts from an enormous golden chest and hits Lilabipple!
-- A skeletal archer's carefully aimed shot from the north hits Lalira.
-- Rekpezul touches Jibbi. Interesting.
-- An alert kobold archer's carefully aimed shot  hits Turilenil.

-- lua display( string.find( "Rekpezul touches Jibbi. Interesting.", "Interesting") )
-- Vomicopol bites Pid on the leg.

if string.find(matches[1], "Interesting") then
--  display("X")
  return
end

if string.find(matches[1], "on the leg") then
--  display("X")
  return
end

if string.find(matches[1], "A massive fireball erupts from") then
  return
end

if string.find(matches[1], "carefully aimed shot") then
  return
end


local torescue=matches[3]

if NyyLIB == nil then
  return
end

-- If last command entered was "l " or scan, return

if string.find(command, "L ") == 1 or command == "SCAN" then
  return
end


if charData:get(whoami(), true) == nil then
  return
end

-- this is warrior rescue triggers only
if checkMask("fighter") == false then
  return
end

if NyyLIB.escapedir ~= nil then
  return
end

if torescue == whoami() then
  return
end

-- Don't rescue if less then 25% max hp
if prompt:get("hp") &lt; (.25 * prompt:get("maxhp")) then
  return
end

if string.find(previousLine(), "deflects") then
  echoDebug("deflect detected\n")
  return
end


-- rescue wuss

if torescue == charData:get("wuss") then
  sendRescue(torescue)
  return
end


-- autorescue code


if charData:get("rescuetype") ~= "off" then
  if groupList:ingroup(torescue) then
    if checkMask("warrior", torescue) and charData:get("rescuetype") == "basic" then
      return
    end

    -- if ranger don't rescue rangers
    
    if checkMask("ran") and checkMask("ran", torescue) then
      return
    end
    
    -- 25% chance of rescuing rangers, hex
    
    if checkMask("ran", torescue) or checkMask("hex", torescue) and ((math.random() * 100) &gt; 25) then
      return
    end
    
    sendRescue(torescue)
  end
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>.+(,\sfighting|wounds|knocks|misses|a\smirror\simage\sof|tried\sto\sbackstab|tries\sto\srescue|attacks|beat|beats|choke|chokes|touch|touches|hit|hits|slash|slashes|crush|crushes|whip|whips|pierce|pierces|smash|smashes|sting|stings|drain|drains|strike|strikes|pummel|pummels|pound|pounds|claw|claws|nip|nips|burn|burns|bite|bites) ([A-Za-z]+)</string>
								<string>in (the back) of ([A-Za-z]+), resulting in some strange noises</string>
								<string>(.*) sends ([A-Za-z]+) sprawling with a powerful bash.</string>
								<string>(&lt; ).* T: ([A-Za-z]+) TC: .* E: .* EC: .* EP: .* P: .* &gt; </string>
								<string>^([A-Za-z]+) futilely tries to rescue (.*)[.]</string>
								<string>(.+), fighting ([A-Z][a-z]+)[.]$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>rescue messages</name>
							<script>-- if this line arrives same line as prompt, it double fires a rescue

rescueSent=false
look:send()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>But nobody is fighting him?</string>
								<string>You fail the rescue.</string>
								<string>Banzai! To the rescue...</string>
								<string>You don't see them here!</string>
								<string>But nobody is fighting her?</string>
								<string>Who do you want to rescue?</string>
								<string>Sorry, you can't do that while lying around.</string>
								<string>But nobody is fighting it?</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Rescue tank</name>
						<script>local tank=prompt:get("tank")
local tankcondition= prompt:get("tankcondition")
local hp=prompt:get("hp")
local maxhp=prompt:get("maxhp")

if tank == whoami() then
  return
end

if hp == nil then
  return
end

if hp &lt; (.40 * maxhp ) then
  return
end

if checkMask("fighter") == false then
  return
end

if NyyLIB.escapedir ~= nil then
  return
end

if charData:get("rescuetype") == "all" then
  -- display(tank)
  sendRescue(tank)
  return
end

if (charData:get("rescuetype") == "basic" or charData:get("rescuetype") == "all") then
  if tank == "ghost" then
    sendRescue(tank)
    return
  end

  if table.contains( {"awful", "pretty hurt"}, tankcondition ) then
    sendRescue(tank)  
    return
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>&lt; .* T: ([A-Za-z]+) TC: ([A-Za-z ]+) .*&gt; </string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You make a great effort, and send a training dummy's weapon crashing to the floor.</name>
						<script>mud:send("get all")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You make a great effort, and send .* weapon crashing to the floor.</string>
							<string>You have managed to get FAR TOO CLOSE to .*</string>
							<string>.* steps directly in front of your path.  No way to get it now.</string>
							<string>.* hurtles itself into close vicinity of the .*  Impossible to get to now!</string>
							<string>You fail miserably in your attempt to disarm .*</string>
							<string>Impossible to get to now!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Autotank</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Lilithelle group-says 'tanks ([nsewud])'</name>
							<script>-- tnaks

-- this trigger can only be used by group leader
if matches[2] ~= NyyLIB.leader then
  return
end

if checkMask("necros") and matches[3] == "spectre" then
  mud:send("ORDER spectre " .. matches[4])
end

if checkMask("fighter") == false then
  return
end

if ( matches[3] == "Adud" or matches[3] == "adud" ) and whoami() ~= "Adud" then
  return
end

if charData:get("autotank") then
  -- If less then 75% hp and less then 900hp, grep and don't move
  if prompt:get("hp") &lt; .75 * prompt:get("maxhp") and prompt:get("hp") &lt; 900 then
    mud:send("tackle " .. matches[2])
    mud:send("grep")
    return
  end

  if matches[4] == "en" then
    mud:send("enter " .. matches[5])
  else
    mud:send(matches[4])
  end
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([A-Za-z]+) group-says '(Adud|adud|tank|tanks|tnkas|dtnaks|tnaks|atnks) ([nsewud])( .*)?'</string>
								<string>^([A-Za-z]+) group-says '(Adud|adud|tank|tanks) (north|south|east|west|up|down)'</string>
								<string>^([A-Za-z]+) group-says '(Adud|adud|tank|tanks) (en) (.*)'</string>
								<string>^([A-Za-z]+) group-says '(spectre) ([nsewud])( .*)?'</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wall of rotting flesh and carrion plows through the corridor.</name>
						<script>if whoami() == "Adud" then
  sendBash("wall")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wall of rotting flesh and carrion plows through the corridor.</string>
							<string>A living wall stands here</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You get a rune graven adamantine longsword.</name>
						<script>mud:send("wield graven")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You get a rune graven adamantine longsword.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>powers</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>warriors ultimatum</name>
							<script>-- You face Corland Deepforge and beckon him towards you with a terrifying roar.

timer:set("warriors_ultimatum", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You face .* and beckon .* towards you with a terrifying roar.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>shield bash</name>
							<script>-- You slam your shield into a lithe commoner with tremendous force, knocking her to the ground!
-- You savagely bash a graceful commoner over the head with your shield, and his lifeless form crumples.
-- You strike Seipora Rein a glancing blow with your shield, and she maintains her balance.

meleePowerUsed=false

setBashing(false)

timer:set("shield_bash", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You slam your shield into .*</string>
								<string>^(?:&lt; .* &gt; )?You savagely bash .* over the head with your shield, and .* lifeless form crumples.$</string>
								<string>^(?:&lt; .* &gt; )?You strike .* a glancing blow with your shield, and .* maintains .* balance[.]$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>defensive strike</name>
							<script>-- You drop into a defensive posture and raise your shield as you land a strike on a lithe commoner.
-- You pivot into a defensive posture after mercilessly finishing off Elaith Waterstill.

meleePowerUsed=false

-- timer is one more then duration because there is an expiry message
timer:set("defensive_strike", 13)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You drop into a defensive posture and raise your shield as you land a strike on .*</string>
								<string>^(?:&lt; .* &gt; )?Your defensive posture is thrown off balance as your blow merely glances off of .*</string>
								<string>^(?:&lt; .* &gt; )?You pivot into a defensive posture after mercilessly finishing off .*</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>brutal strike</name>
							<script>-- You lunge forward and crack a graceful commoner a brutal blow upside the head with your weapon.
-- Aratha Sul sidesteps your lunge, and your blow glances off of her.
-- You lunge and deliver a devastating final blow to a robin's head with a sickening crack.

meleePowerUsed=false

timer:set("brutal_strike", 36)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You lunge forward and crack .* a brutal blow upside the head with your weapon.</string>
								<string>sidesteps your lunge, and your blow glances off of</string>
								<string>^(?:&lt; .* &gt; )?You lunge and deliver a devastating final blow to .* head with a sickening crack.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>0</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>comeback strike</name>
							<script>-- You feel invigorated as you land a powerful strike upon a lithe commoner.
-- You are flooded with a wave of strength as you cut Ersenas down ruthlessly.

meleePowerUsed=false

timer:set("comeback_strike", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You feel invigorated as you land a powerful strike upon .*</string>
								<string>^(?:&lt; .* &gt; )?Your powerful strike merely glances off of .*</string>
								<string>^(?:&lt; .* &gt; )?You are flooded with a wave of strength as you cut .*</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>relentless assault</name>
							<script>-- You set your shield with grim determination and strike out at nearby foes.

meleePowerUsed=false

timer:set("relentless_assault", 36)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You set your shield with grim determination and strike out at nearby foes.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>spinning sweep</name>
							<script>-- You spin beneath a graceful commoner's guard and strike out with a precise attack.

meleePowerUsed=false

setBashing(false)

timer:set("spinning_sweep", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You spin beneath .* guard and strike out with a precise attack.</string>
								<string>^(?:&lt; .* &gt; )?You spin beneath .* guard and deliver a punishing, mortal blow.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>cleave</name>
							<script>-- You bring your weapon to bear and strike out in a deadly arc.

meleePowerUsed=false

timer:set("cleave", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You bring your weapon to bear and strike out in a deadly arc.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>unyielding avalanche</name>
							<script>-- You crash forward into your foes and strike out with a barrage of attacks.

meleePowerUsed=false

timer:set("unyielding_avalanche", 28)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You crash forward into your foes and strike out with a barrage of attacks.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>skullcrusher</name>
							<script>-- A dapper noble's skull is pulverized as you deliver a tremendous overhead blow to his head.
-- You raise your weapon high and bring it crashing down on Willa O'Greensleeves's head with a sickening crack.
-- You deliver a powerful overhead blow that merely glances off of Lavis Ryl.
-- You raise your weapon high and bring it crashing down on a spectral hound's head with a sickening crack.

meleePowerUsed=false

timer:set("skullcrusher", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>.* skull is pulverized as you deliver a tremendous overhead blow to.* head.$</string>
								<string>^(?:&lt; .* &gt; )?You raise your weapon high and bring it crashing down on .* head with a sickening crack.</string>
								<string>You deliver a powerful overhead blow that merely glances off of</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>rain of steel</name>
							<script>-- You weave through your foes, your weapon flashing as you strike through their ranks.

meleePowerUsed=false

timer:set("rain_of_steel", 28)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You weave through your foes, your weapon flashing as you strike through their ranks.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>iron warrior</name>
							<script>-- You feel a wave of vigor flooding through you as you stand fast against your foes.

buff:set(whoami(), "iron_warrior", 30)
timer:set("iron_warrior", 3*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You feel a wave of vigor flooding through you as you stand fast against your foes.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>diamond shield defense</name>
							<script>-- You channel your indomitable will into an impenetrable active defense.

buff:set(whoami(), "diamond_shield_defense", 12)
timer:set("diamond_shield_defense", 60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You channel your indomitable will into an impenetrable active defense.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>unbreakable</name>
							<script>-- You adjust your defensive stance and steel yourself for incoming attacks.

buff:set(whoami(), "unbreakable", 12)
timer:set("unbreakable", 1*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You adjust your defensive stance and steel yourself for incoming attacks.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>no opening</name>
							<script>-- You take a step back and move to block an opening in your defenses.

buff:set(whoami(), "no_opening", 30)
timer:set("no_opening", 30)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You take a step back and move to block an opening in your defenses.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>storm of destruction</name>
							<script>-- You become a whirling cyclone of terror as you spin your weapon about and charge your enemies.

meleePowerUsed=false

timer:set("storm_of_destruction", 56)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You become a whirling cyclone of terror as you spin your weapon about and charge your enemies.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>unstoppable</name>
							<script>-- You grit your teeth and ignore some of your wounds as your adrenaline surges.

timer:set("unstoppable", 1*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You grit your teeth and ignore some of your wounds as your adrenaline surges.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>combat challenge</name>
							<script>-- You hoist your weapon in the air and flash it menacingly at Willa O'Greensleeves.
-- You hoist your weapon in the air and flash it menacingly at a flaming chasme.

meleePowerUsed=false

buff:set(whoami(), "combat_challenge", 20)
timer:set("combat_challenge", 60)

setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You hoist your weapon in the air and flash it menacingly at .*[.]</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>heroic defiance</name>
							<script>-- You shake off your adverse conditions in a burst of willpower.

timer:set("heroic_defiance", 1*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You shake off your adverse conditions in a burst of willpower.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>defensive strike (drop)</name>
							<script>-- With aching muscles, you relax your defensive posture.

timer:set("defensive_strike", 0)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?With aching muscles, you relax your defensive posture.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>vigilant protector</name>
							<script>-- You move close to Padi and stand ready to defend her.

buff:set(whoami(), "vigilant_protector", 60*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You move close to .* and stand ready to defend.*[.]$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>vigilant protector (off)</name>
							<script>-- You relax your vigilant defense.

buff:set(whoami(), "vigilant_protector", 0)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You relax your vigilant defense.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Enc</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Lic</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stephan recoils in fear from the sudden assault of baleful sound.</name>
						<script>-- banshee wail took effect</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>recoils in fear from the sudden assault of baleful sound.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A black aura surrounds A burly bouncer briefly, then dissipates.</name>
						<script>-- blackmantle</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A black aura surrounds .* briefly, then dissipates.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your contagion wave washes over A naked woman, causing her to sag feebly.</name>
						<script>-- contagion</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your contagion wave washes over</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>banshee wail</name>
						<script>-- banshee wail has been cast in room
spell:setCast("bw")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The area reverberates with the shrieks and wails of lost souls!</string>
							<string>Shrieking and wailing erupts all around you!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel powers of darkness strengthen you!</name>
						<script>group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel powers of darkness strengthen you!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Cle</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>HA countdown timer</name>
						<script>-- cast healing aura if cleric and @mtank set (countdown timer)

-- mark as ha when heal proc happens

spell:setMoving(false)

NyyLIB.mtank=matches[2]

if checkMask("Cle") then
  if charData:get("autoheal") then
    if spell:getMem() then
      mud:send("ST")
    end

    spell:cast("HA " .. NyyLIB.mtank)
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '&lt;4&gt;'</string>
							<string>([A-Za-z]+) group-says ''-=4=-'</string>
							<string>([A-Za-z]+) group-says 'Killing dragon in:'</string>
							<string>([A-Za-z]+) group-says '-5'</string>
							<string>([A-Za-z]+) group-says '5!'</string>
							<string>([A-Za-z]+) group-says '5'</string>
							<string>([A-Za-z]+) group-says 'Going in: 5'</string>
							<string>([A-Za-z]+) group-says 'going in 5'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Autoquake triggers</name>
						<script>-- Flag earthquake to be cast

-- The ghost of Talrinim stands in mid-air here, fighting Brammithizzar."set quake"
-- true

-- A Cult of the Dragon sorcerer is lying here, fighting Afu.


if not checkMask("priest") or not charData:get("autoquake") then
  return
end

-- last command entered was look direction or scan - return
if string.find(command, "l ") == 1 or string.find(command, "look ") == 1 or command == "SCAN" then
  return
end

setQuake(true)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^A frost giant jarl stands.*, fighting</string>
							<string>^A member of the Smoking Beard battalion stands.*, fighting</string>
							<string>^A fire giant captain stands.*, fighting</string>
							<string>^A sandman stands.*, fighting</string>
							<string>^A frost giant spirit-seeker stands.*, fighting</string>
							<string>^A vine of thorns stands.*, fighting</string>
							<string>^A hideous choker stands.*, fighting</string>
							<string>^Talrinim stands.*, fighting</string>
							<string>^A living wall stands.*, fighting</string>
							<string>^A minion of Moander stands.*, fighting</string>
							<string>^Goortok stands.*, fighting</string>
							<string>^A carnivorous vine stands.*, fighting</string>
							<string>^Thrym stands.*, fighting</string>
							<string>A tower apprentice stands.*, fighting</string>
							<string>A busy clerk stands.*, fighting</string>
							<string>Yamel Rerraser stands.*, fighting</string>
							<string>^Granak .* here, fighting .*</string>
							<string>The Tarrasque stands here, fighting</string>
							<string>Blintim Trilamir stands here, fighting</string>
							<string>A Spellguard apprentice stands in mid-air here, fighting</string>
							<string>An ancient guardian stands in mid-air here, fighting</string>
							<string>A toad demon stands in mid-air here, fighting</string>
							<string>^A .*(witch|mage|warlock|druid|shaman|cleric|priest|priestess|invoker|oracle|seer|hierophant|wizard|sorcerer|necromancer) .*, fighting .*</string>
							<string>A member of the Smoking Beard battalion flies in from</string>
							<string>A galeb duhr stands, inches above the surface here, fighting</string>
							<string>The djinn vizier stands in mid-air here, fighting</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Healing aura on lich</name>
						<script>-- healing aura after lich proc

-- mark char as liched for when heal proc happens

if getSpellCount("healing_aura") &gt; 0 then
  if not buff:get("healing_aura", matches[2]) then
    spell:setNext("ha " .. matches[2])
  end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* literally sucks the life force from ([A-Za-z]+), who crumples into a ball of lifeless </string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Remove poison on venom</name>
						<script>-- venom

-- mark char as venomed for heal proc

local charname = matches[2]

if not checkMask("priest") then
  return
end

if getSpellCount("remove_poison") &gt; 0 then
  sendStatus(charname)
  spell:setNext("rp " .. charname)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) writhes in agony.</string>
							<string>([A-Za-z]+) shudders in pain, and looks very pale.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>^([A-Za-z]+) tells you 'para'</name>
						<script>sendStatus(matches[2])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^([A-Za-z]+) tells you 'para'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Sha</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>And you are currently praying for the following spells:</name>
						<script>if checkMask("sha") then
  mud:send("PRIO gh")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^And you are currently praying for the following spells:$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Rog</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You use the last of the poison.</name>
						<script>mud:send( "GET blind " .. charData:get("poisonbag"))</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You use the last of the poison.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You can't seem to find that!</name>
						<script>mud:send("get slow hole")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can't seem to find that!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your assassination attempt goes wide of the mark.</name>
						<script>-- You may only attempt to assassinate someone once a day!

timer:set("assassinatetimer", 24*60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your assassination attempt goes wide of the mark.</string>
							<string>With practiced ease and lightning reflexes,</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You attempt to hide yourself.</name>
						<script>sendStatus()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You attempt to hide yourself.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You clamber to your feet.</name>
						<script>setTripping(false)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You clamber to your feet.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>assassinate in cooldown</name>
						<script>-- You may only attempt to assassinate someone once a day!

-- unknown cooldown, setting to 5 minutes

timer:set("assassinatetimer", 5*60)

-- train portion: backstab if unable to assassinate

if NyyLIB.traintarget then
    mud:send("bs " .. getEnemy() )
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You may only attempt to assassinate someone once a day!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>wraithform mobs</name>
						<script>timer:set("wraithform", 30)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You would pass right through them!</string>
							<string>You try to trip .*, only to sprawl completely THROUGH it.</string>
							<string>You can't backstab something which is immaterial!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>set notrip</name>
						<script>-- Such a maneuver appears to be useless against the fire drake!
-- Such a maneuver appears to be useless against Quturac, the skeletal death dragon!

timer:set("notrip", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Such a maneuver appears to be useless against</string>
							<string>You have no footing here!</string>
							<string>is too huge for you to trip! You go crashing to the ground.</string>
							<string>Tripping creatures of this minute size is hopeless at best.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ill</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The illusion covering your group is shattered!</name>
						<script>-- The illusion over Lilabipple's group is shattered!
-- The illusion covering your group is shattered!

mud:send("gsay Massmorph DOWN!")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?The illusion over .* group is shattered!</string>
							<string>^(?:&lt; .* &gt; )?The illusion covering your group is shattered!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>An Ashstone noble's outline is illuminated by brilliant scarlet flames!</name>
						<script>-- sct scarlet outline</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>An Ashstone noble's outline is illuminated by brilliant scarlet flames!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You create a swirling rainbow pattern in front of an Ashstone noble, who seems distracted...</name>
						<script>-- rainbow pattern</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You create a swirling rainbow pattern in front of an Ashstone noble, who seems distracted...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ele</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ran</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>eviscerate</name>
						<script>-- Eviscerate
-- You swing your weapons in lethal arcs, dousing the area with a lithe commoner's blood.

meleePowerUsed=false

timer:set("eviscerate", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You swing your weapons in lethal arcs, dousing the area .*</string>
							<string>^(?:&lt; .* &gt; )?You swing your weapons in a killing arc, eviscerating .*</string>
							<string>^(?:&lt; .* &gt; )?Your arcing weapons glance off of .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>twin strike</name>
						<script>-- Twin Strike
-- You attack a lithe commoner with both weapons and land twin precision strikes.
-- You strike at Seipora Rein with both weapons, landing glancing blows.
-- You attack a giant fire elemental with both weapons, landing twin precision strikes.
-- You strike a robin down with a barrage of blows from both weapons.

meleePowerUsed=false

timer:set("twin_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You attack .* with both weapons, landing glancing blows.</string>
							<string>^(?:&lt; .* &gt; )?You attack .* with both weapons, landing twin precision strikes.</string>
							<string>^(?:&lt; .* &gt; )?You strike at .* with both weapons, landing glancing blows.</string>
							<string>^(?:&lt; .* &gt; )?You attack .*l with both weapons, landing twin precision strikes.</string>
							<string>^(?:&lt; .* &gt; )?You strike .* down with a barrage of blows from both weapons.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>armor splinter</name>
						<script>-- Armor Splinter
-- You strike the weak spots in A naked woman's armor, leaving her vulnerable.
-- You strike the weak spots in a freshly animated wight's armor, leaving it vulnerable.

meleePowerUsed=false

timer:set("armor_splinter", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You strike the weak spots in .*</string>
							<string>collapses in agony as you penetrate the weakest spot</string>
							<string>armor resists the impact of your carefully aimed strikes.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>bladestorm</name>
						<script>-- Bladestorm
-- You spin and leap through the fray, unleashing a torrent of steel on your enemies!

meleePowerUsed=false


timer:set("bladestorm", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You spin and leap through the fray, unleashing a torrent of steel on your enemies!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>failed power</name>
						<script>meleePowerUsed=false

if checkMask("ran") then
  procPromptRan()
end

if checkMask("pal") then
  procPromptPal()
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?They have to be standing up for you to do that!</string>
							<string>^(?:&lt; .* &gt; )?No target for your power could be found!</string>
							<string>^(?:&lt; .* &gt; )?That can only be done in combat!</string>
							<string>^(?:&lt; .* &gt; )?They don't have have any legs for that!</string>
							<string>^(?:&lt; .* &gt; )?You have to be dual wielding to do that.</string>
							<string>^(?:&lt; .* &gt; )?You have to be standing up to do that!</string>
							<string>^(?:&lt; .* &gt; )?They are too large for you to do that!$</string>
							<string>^(?:&lt; .* &gt; )?You would pass right through them!</string>
							<string>^(?:&lt; .* &gt; )?Your mighty blow causes .* to slow down dramatically!</string>
							<string>^(?:&lt; .* &gt; )?You need to wear a shield to do that.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You're not ready to perform another action!</name>
						<script>meleePowerUsed=nil
spell:setCurrent(nil)

setBashing(false)

timer:set("cooldown", .5)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You're not ready to perform another action!$</string>
							<string>^(?:&lt; .* &gt; )?You're not ready to use a weapon power!$</string>
							<string>^You're not ready to cast that spell!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>sweeping strike</name>
						<script>-- Sweeping Strike

-- You sweep attack a devout priest with unbound fury, knocking him off balance!
-- You sweep attack Ersenas with a fury of blows, but he retains his balance.
-- You sweep a half-elven boy to the ground and finish him with a pair of killing blows.

-- sweeping strike
meleePowerUsed=false

timer:set("sweeping_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You sweep attack</string>
							<string>You sweep .* to the ground and finish .* with a pair of killing blows.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>knockdown shot</name>
						<script>-- Knockdown Shot
-- You loose a precision shot at a lithe commoner that knocks her off her feet!
-- Your precisely aimed arrow streaks into a human noble, who staggers but retains his balance.
-- Your arrow tears through a chipmunk's leg, knocking its lifeless body to the ground.

meleePowerUsed=false

timer:set("knockdown_shot", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You loose a precision shot at</string>
							<string>Your precisely aimed arrow streaks into</string>
							<string>Your arrow tears through .* leg, knocking its lifeless body to the ground.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hail of arrows</name>
						<script>--Hail of Arrows

--You launch a barrage of arrows into the air to rain down upon your enemies!
-- A lithe commoner is pincushioned by the swarm of falling arrows!

meleePowerUsed=false

timer:set("hail_of_arrows", 28)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You launch a barrage of arrows into the air to rain down upon your enemies!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>splintering shot</name>
						<script>--Splintering Shot
--Your arrow burrows deep into a lithe commoner's flesh and shatters, leaving her howling in pain.
--Your arrow shatters in a spray of splinters as it grazes Aratha Sul.
-- A ruby-throated humming bird's flesh erupts in a shower of blood as your arrow shatters beneath its skin!

meleePowerUsed=false

timer:set("splintering_shot", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your arrow burrows deep into</string>
							<string>Your arrow shatters in a spray of splinters as it grazes</string>
							<string>.* flesh erupts in a shower of blood as your arrow shatters beneath .* skin!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>concussive shot</name>
						<script>-- Concussive Shot
-- You pull an arrow back as far as it will go and unleash its concussive force on a graceful commoner!
-- Your powerfully drawn shot just grazes Aratha Sul!
-- Your mighty shot decapitates a black-capped chickadee with its concussive impact!

meleePowerUsed=false

timer:set("concussive_shot", 28)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You pull an arrow back as far as it will go and unleash its concussive force on</string>
							<string>Your powerfully drawn shot just grazes .*</string>
							<string>Your mighty shot decapitates .* with its concussive impact!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>triple shot</name>
						<script>--Triple Shot
--You launch of volley of three arrows at a human noble, who staggers under the impact.
--A human noble is slain instantly as your deadly volley of arrows find their target.

meleePowerUsed=false

timer:set("triple_shot", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You launch of volley of three arrows at</string>
							<string>is slain instantly as your deadly volley of arrows find their target.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of the winds</name>
						<script>-- Cloak of the winds
-- You feel your movements speed up as a swirling cloak of winds envelops you.

buff:set(whoami(), "cloak_of_the_winds", 40)
timer:set("cloak_of_the_winds", 40)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel your movements speed up as a swirling cloak of winds envelops you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of the winds (drop)</name>
						<script>-- Your cloak of winds vanishes.

buff:set(whoami(), "cloak_of_the_winds", nil)
timer:set("cloak_of_the_winds", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your cloak of winds vanishes.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of protection</name>
						<script>-- Cloak of Protection
-- Softly glowing mists wrap around you in an cloak of protection.

buff:set(whoami(), "cloak_of_protection", 50)
timer:set("cloak_of_protection", 50)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Softly glowing mists wrap around you in an cloak of protection.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of protection (drop)</name>
						<script>-- Your misty cloak of protection dissipates.

buff:set(whoami(), "cloak_of_protection", nil)
timer:set("cloak_of_protection", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your misty cloak of protection dissipates.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of resilience</name>
						<script>-- Cloak of Resilience
-- Wispy bands of shadow clasp about you in a cloak of resilience.

buff:set(whoami(), "cloak_of_resilience", 60)
timer:set("cloak_of_resilience", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Wispy bands of shadow clasp about you in a cloak of resilience.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of resilience (drop)</name>
						<script>-- Your shadowy cloak of resilience dissolves.

buff:set(whoami(), "cloak_of_resilience", nil)
timer:set("cloak_of_resilience", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shadowy cloak of resilience dissolves.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>misty path</name>
						<script>-- Misty Path
-- Swirling, vaporous mists creep up from the ground and encircle your legs.

buff:set(whoami(), "misty_path", 360)
timer:set("misty_path", 360)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Swirling, vaporous mists creep up from the ground and encircle your legs.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>blades of fire</name>
						<script>-- Blades of Fire
-- Your weapons burst into searing white-hot flames.

buff:set(whoami(), "blades_of_fire", 20)
timer:set("blades_of_fire", 20)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapons burst into searing white-hot flames.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>greenfire</name>
						<script>-- Greenfire
-- Your weapons erupt in tendrils of virulent green flames!

buff:set(whoami(), "greenfire", 30)
timer:set("greenfire", 30)

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapons erupt in tendrils of virulent green flames!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>greenfire (drop)</name>
						<script>-- The virulent green flames coating your weapons are extinguished.

buff:set(whoami(), "greenfire", nil)
timer:set("greenfire", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The virulent green flames coating your weapons are extinguished.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>arctic barrage</name>
						<script>-- Arctic Barrage
-- Your bow is encased in a thin layer of sparkling ice.

buff:set(whoami(), "arctic_barrage", 30)
timer:set("arctic_barrage", 30)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your bow is encased in a thin layer of sparkling ice.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>arctic barrage (drop)</name>
						<script>-- The sparkling ice around your bow melts away.

buff:set(whoami(), "arctic_barrage", nil)
timer:set("arctic_barrage", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The sparkling ice around your bow melts away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>lightning arrow</name>
						<script>-- Lightning Arrow
-- Your bow crackles with electricity as a charge collects around it.

buff:set(whoami(), "lightning_arrow", 60)
timer:set("lightning_arrow", 60)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your bow crackles with electricity as a charge collects around it.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>lightning arrow (drop)</name>
						<script>-- Your arrow detonates in a burst of crackling lightning!

buff:set(whoami(), "lightning_arrow", nil)
timer:set("lightning_arrow", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your arrow detonates in a burst of crackling lightning!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hail of thorns</name>
						<script>-- Hail of Thorns
-- A cluster of tiny thorns sprouts all along your bow.

buff:set(whoami(), "hail_of_thorns", 60)
timer:set("hail_of_thorns", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A cluster of tiny thorns sprouts all along your bow.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hail of thorns (drop)</name>
						<script>-- Your arrow explodes in a shower of vicious thorns!

buff:set(whoami(), "hail_of_thorns", nil)
timer:set("hail_of_thorns", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your arrow explodes in a shower of vicious thorns!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>electric discharge</name>
						<script>-- Electric Discharge
-- Static fills the air as your weapons are wreathed in crackling electricity.

buff:set(whoami(), "electric_discharge", 60)
timer:set("electric_discharge", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Static fills the air as your weapons are wreathed in crackling electricity.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>electric discharge (drop)</name>
						<script>-- Your weapon disharges a massive blast of crackling electricity!

buff:set(whoami(), "electric_discharge", nil)
timer:set("electric_discharge", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon disharges a massive blast of crackling electricity!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>beast sense</name>
						<script>-- Beast Sense

-- You can't see who is fighting Kaizu.

if checkMask("ran") then
  if spell:getSlot(2) &gt; 0 then
    spell:cast("BSE")
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can't see who is fighting</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Pal</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shielding smite</name>
						<script>-- A translucent golden shield forms in front of you as strike out at a lithe commoner.
-- As you strike out at a gold finch a golden shield appears and slams into it, leaving only a battered wreck.

-- Shielding smite

meleePowerUsed=false

timer:set("shielding_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A translucent golden shield forms in front of you as</string>
							<string>, and your golden shield fails to appear.</string>
							<string>As you strike out at .* a golden shield appears and slams into .*, leaving only a battered wreck.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>bolstering strike</name>
						<script>-- Bolstering Strike

meleePowerUsed=false

timer:set("bolstering_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>and your accuracy is rewarded with a divine gift of health.</string>
							<string>You strike out at .*, landing a glancing blow!</string>
							<string>You strike .* without reprieve, and .* falls before your overwhelming assault.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>radiant charge</name>
						<script>-- Brilliant rays of light stream from your shield as you charge into Aratha Sul and knock her to the ground!
-- You knock a half-elven girl to the ground with your radiant charge and stand triumphantly over her shattered form.

-- Radiant Charge

meleePowerUsed=false

setBashing(false)

timer:set("radiant_charge", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Brilliant rays of light stream from your shield as you charge into</string>
							<string>sidesteps your charge!</string>
							<string>You knock .* to the ground with your radiant charge and stand triumphantly over .* shattered form.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>enervating strike</name>
						<script>-- Enervating Strike

-- You land a mighty blow upon Willa O'Greensleeves and follow it up with a lethal shield bash!

meleePowerUsed=false

timer:set("enervating_strike", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You land a mighty blow upon .* that leaves .* staggering in pain.</string>
							<string>Using your shield as cover, you land a glancing blow upon</string>
							<string>You land a mighty blow upon .* and follow it up with a lethal shield bash!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>wrathful smite</name>
						<script>-- Wrathful Smite

meleePowerUsed=false

timer:set("wrathful_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A halo of divine light emanates from you, filling you with holy wrath.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>lay on hands</name>
						<script>-- lay on hands

meleePowerUsed=false

timer:set("lay_on_hands", 6*60)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You lay your blessed hands upon</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>divine smite</name>
						<script>-- Divine Smite

-- Your weapon flares with a burst of divine radiance as you strike Willa O'Greensleeves!
-- You land a glancing blow upon NN with your radiant weapon.
-- Your righteous blow shatters an opulent merchant in a blast of divine power!

meleePowerUsed=false

timer:set("divine_smite", 60)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon flares with a burst of divine radiance as you strike</string>
							<string>You land a glancing blow upon .* with your radiant weapon.</string>
							<string>Your righteous blow shatters</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>thunderous smite</name>
						<script>-- Thunderous smite

-- Your weapon explodes in a peal of roaring thunder as you strike Lavis Ryl!
-- Lavis Ryl is thrown to the ground by the shockwave!

-- Aratha Sul staggers but maintains her balance as your weapon explodes in a peal of roaring thunder!

-- A vault sentinel collapses in a battered heap as the wave of thunder slams into him.

meleePowerUsed=false

setBashing(false)

timer:set("thunderous_smite", 12)
setMeleeCooldown()

if matches[2] ~= nil then
  -- Success
  addStat(whoami(), "palTSsuccess")
else
  -- Fail
  addStat(whoami(), "palTSfail")
end

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon explodes in a peal of roaring thunder as you (strike) .*</string>
							<string>balance as your weapon explodes in a peal of roaring thunder!</string>
							<string>collapses in a battered heap as the wave of thunder slams into</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>valiant strike</name>
						<script>-- valiant strike

--Your weapon ignites with a blazing holy light!
--Your powerful strike glances off of Willa O'Greensleeves's armor!

-- Your powerful strike engulfs an Ashstone noble in searing ribbons of divine radiance.


meleePowerUsed=false

timer:set("valiant_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your powerful strike engulfs .* in searing ribbons of divine radiance.</string>
							<string>Your weapon ignites with a blazing holy light!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>brilliant smite</name>
						<script>-- Brilliant smite

-- Your weapon detonates in a flash of pure light as you strike Willa O'Greensleeves!
-- You cut down a small lizard in a flash of brilliant light.

meleePowerUsed=false

timer:set("brilliant_smite", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon detonates in a flash of pure light as you strike</string>
							<string>Your weapon's brilliant flash is dampened as it glances off of</string>
							<string>You cut down .* in a flash of brilliant light.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>terrifying smite</name>
						<script>-- Terrifying Smite

meleePowerUsed=false

timer:set("terrifying_smite", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your eyes glow with a terrifying radiance as waves of divine dread wash over your enemies.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>whirlwind smite</name>
						<script>-- Whirlwind Smite

meleePowerUsed=false

timer:set("whirlwind_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Brilliant holy light explodes around you as you swing your weapon in a full circle!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>divine challenge</name>
						<script>-- A searing, divine light radiates from you as you confront an elite fortress guard.

buff:set(whoami(), "divine_challenge", 20)
timer:set("divine_challenge", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A searing, divine light radiates from you as you confront</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>true nemesis</name>
						<script>-- You extend your holy symbol towards an elemental lord, singling it out for your divine retribution.

timer:set("true_nemesis", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string> ?You extend your holy symbol towards .*, singling it out for your divine retribution.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cleansing spirit</name>
						<script>-- cleansing spirit

-- A translucent outline briefly appears above you as your afflictions are cleansed.
-- A translucent outline briefly appears above Kelwyn.

buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")
buff:del(whoami(), "poison")
buff:del(whoami(), "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A translucent outline briefly appears above you as your afflictions are cleansed.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of warding</name>
						<script>-- shield of warding

-- An opaque globe of light blossoms around you, shielding you from harm.

buff:set(whoami(), "shield_of_warding", 12)

timer:set("shield_of_warding", 12)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>An opaque globe of light blossoms around you, shielding you from harm.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of warding (drop)</name>
						<script>-- shield of warding

buff:set(whoami(), "shield_of_warding", nil)

timer:set("shield_of_warding", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shield of warding evaporates, leaving you vulnerable to attack.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>brand of judgement</name>
						<script>-- You summon a divine light to sear the symbol of your deity into Corland Deepforge's flesh!

timer:set("brand_of_judgement", 50)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You summon a divine light to sear the symbol of your deity into</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of faith</name>
						<script>-- shield of faith

buff:set(whoami(), "shield_of_faith", 30)

timer:set("shield_of_faith", 30)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A shimmering field of light surrounds you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of faith (drop)</name>
						<script>-- shield of faith

buff:set(whoami(), "shield_of_faith", nil)

timer:set("shield_of_faith", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shimmering shield of faith fades away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of life</name>
						<script>-- Aura of Life
-- You begin to pulsate with a soft light as you are infused with divine health.

buff:set(whoami(), "aura_of_life", 90)

timer:set("aura_of_life", 90)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You begin to pulsate with a soft light as you are infused with divine health.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of life (drop)</name>
						<script>-- aura of life

-- The soft light surrounding you dims as your aura of life fades away.

buff:set(whoami(), "aura_of_life", nil)

timer:set("aura_of_life", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The soft light surrounding you dims as your aura of life fades away.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>holy sword</name>
						<script>-- holy sword
-- Divine light coalesces in a soft radiance around your weapon.

buff:set(whoami(), "holy_sword", 20)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Divine light coalesces in a soft radiance around your weapon.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>divine inspiration</name>
						<script>-- The blinding radiance of your charge sets Seipora Rein alight with holy flames.

timer:set("divine_smite", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The blinding radiance of your charge sets .* alight with holy flames.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Blk</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>plundering smite</name>
						<script>-- Your strike leaves a vile blight on a lithe commoner, and some of her life flows into you.
-- You attack Dragor Keenblade with a vile strike, landing a glancing blow.
-- Your strike leaves a vile blight on Corland Deepforge, and some of his life flows into you.

meleePowerUsed=false

timer:set("plundering_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your strike leaves a vile blight on .*</string>
							<string>^(?:&lt; .* &gt; )?You land a hideous blow on .* is overwhelmed with necrotic blight.</string>
							<string>^(?:&lt; .* &gt; )?You attack .* with a vile strike, landing a glancing blow.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dominating smite</name>
						<script>-- You advance upon a lithe commoner with a series of devastating blows.

-- You advance upon a graceful commoner with a series of devastating blows that send him crashing to the ground.
-- Willa O'Greensleeves retains her balance in the face of your punishing advance!

-- You crushed Sir Frithyl's skull, I'm afraid he's dead.

--You advance upon Willa O'Greensleeves with a series of devastating strikes that send forth waves of dark energy.
--The waves of dark energy course through Willa O'Greensleeves, wracking her body with pain.




meleePowerUsed=false

setBashing(false)

timer:set("dominating_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You advance upon .* with a series of devastating blows that send .* crashing to the ground.</string>
							<string>.* balance in the face of your punishing advance!$</string>
							<string>^(?:&lt; .* &gt; )?You advance mercilessly upon .*, raining down blow after blow until .*</string>
							<string>^(?:&lt; .* &gt; )?You crushed .* skull, I'm afraid .* dead.</string>
							<string>^(?:&lt; .* &gt; )?You advance upon .* with a series of devastating blows.</string>
							<string>^(?:&lt; .* &gt; )?You advance upon .* with a series of devastating strikes that send forth waves of dark energy.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dark majesty</name>
						<script>-- Dark tendrils crawl forth from your shield and wrap around you as you strike out at a lithe commoner.
-- Dark tendrils crawl forth from your shield and wrap around you as you strike out at Willa O'Greensleeves.
-- As you slam your shield into a squire a cloud of shadowy tendrils bursts forth and smothers the life from him.

meleePowerUsed=false

timer:set("dark_majesty", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Dark tendrils crawl forth from your shield and wrap around you as you strike out at .*</string>
							<string>^(?:&lt; .* &gt; )?Your shield emits an acrid puff of black smoke as you strike a glancing blow upon .*</string>
							<string>^(?:&lt; .* &gt; )?As you slam your shield into .* a cloud of shadowy tendrils bursts forth and smothers the life from .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ruinous smite</name>
						<script>-- With a murderous howl, you land a gruesome blow on Aratha Sul that leaves her faltering.
-- With a murderous howl, you land a gruesome blow on Willa O'Greensleeves that leaves her faltering.
-- A black-capped chickadee wails in mortal terror as you strike it down with a horrifying blow!

-- ruinous smite

meleePowerUsed=false

timer:set("ruinous_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?With a murderous howl, you land a gruesome blow on .*</string>
							<string>^(?:&lt; .* &gt; )?You shriek in anger as your gruesome blow glances off .*</string>
							<string>.* wails in mortal terror as you strike .* down with a horrifying blow!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>frenzying smite</name>
						<script>-- Your eyes glow with a crimson light as you are overcome with bloodlust.


meleePowerUsed=false

timer:set("frenzying_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your eyes glow with a crimson light as you are overcome with bloodlust.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>sigil of pain</name>
						<script>-- You summon a blood-red ray to sear a sigil of pain into Ersenas's flesh!
-- A ruby-throated humming bird collapses in agony as you sear the flesh from its bones with a blood-red ray!

timer:set("sigil_of_pain", 50)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You summon a blood-red ray to sear a sigil of pain into .*</string>
							<string>collapses in agony as you sear the flesh from .* bones with a blood-red ray!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dread smite</name>
						<script>-- Dread smite
-- Shadows coalesce around your weapon as you strike Seipora Rein in a burst of dark power.
-- You land a glancing blow upon Shalyssa Lurialar with your dread weapon.
-- Your dread strike pulverizes a squire in a blast of frigid shadows!
-- Shadows coalesce around your weapon as you strike a narzugon dragon-knight in a burst of dark power.

meleePowerUsed=false

timer:set("dread_smite", 60)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Shadows coalesce around your weapon as you strike .*</string>
							<string>^(?:&lt; .* &gt; )?You land a glancing blow upon .* with your dread weapon.</string>
							<string>^(?:&lt; .* &gt; )?Your dread strike pulverizes .* in a blast of frigid shadows!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shattering smite</name>
						<script>-- shattering smite

-- Your weapon unleashes a torrent of dark power as you strike A burly bouncer, knocking him to the ground.
-- Your weapon explodes in a blast of dark power, sending Forell Luckaun's shattered form sprawling.

-- Your weapon unleashes a torrent of dark power as you strike Elaith Waterstill.

meleePowerUsed=false

setBashing(false)

timer:set("shattering_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your weapon unleashes a torrent of dark power as you strike</string>
							<string>^(?:&lt; .* &gt; )?Your dark power washes over.* as you strike a glancing blow.</string>
							<string>^(?:&lt; .* &gt; )?Your weapon explodes in a blast of dark power, sending .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>vengeance strike</name>
						<script>-- vengeance strike

-- Your weapon begins to pulse with a sinister glow as your soul fills with vengeance.
-- Your weapon begins to pulse with a sinister glow as your soul fills with vengeance.

meleePowerUsed=false

timer:set("vengeance_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your weapon begins to pulse with a sinister glow as your soul fills with vengeance.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>spirit harrow</name>
						<script>-- spirit harrow

-- Your raise your weapon menacingly as it fades out, becoming smoky and grey.

meleePowerUsed=false

timer:set("spirit_harrow", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your raise your weapon menacingly as it fades out, becoming smoky and grey.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>mortal dread</name>
						<script>-- mortal dread
-- Strands of darkness shroud your form as you land a wicked strike upon A burly bouncer.
-- You lash out at a devout priest with a wicked strike, landing a glancing blow.
-- You loose a dread roar as you pulverize a ruby-throated humming bird with a wicked strike!

meleePowerUsed=false

timer:set("mortal_dread", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Strands of darkness shroud your form as you land a wicked strike upon .*</string>
							<string>^(?:&lt; .* &gt; )?You lash out at .* with a wicked strike, landing a glancing blow.</string>
							<string>^(?:&lt; .* &gt; )?You loose a dread roar as you pulverize .* with a wicked strike!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>uncontrolled fury</name>
						<script>-- uncontrolled fury
-- Your skin turns stark white and your eyes blacken as you let loose a terrifying death shriek.

meleePowerUsed=false

timer:set("uncontrolled_fury", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your skin turns stark white and your eyes blacken as you let loose a terrifying death shriek.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>baleful challenge</name>
						<script>-- baleful challenge
-- You radiate a powerful sense of crushing dread as you confront Willa O'Greensleeves.

buff:set(whoami(), "baleful_challenge", 20)
timer:set("baleful_challenge", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You radiate a powerful sense of crushing dread as you confront .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>corrupt weapon</name>
						<script>-- Corrupt Weapon
-- Crimson tendrils seep from your hands and coil menacingly around your weapon.

buff:set(whoami(), "corrupt_weapon", 20)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Crimson tendrils seep from your hands and coil menacingly around your weapon.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aspect of domination</name>
						<script>-- Aspect of domination
-- Shadowy black wings sprout from your back as you start emanating a wave of seething hatred.

buff:set("aspect_of_domination", 40)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Shadowy black wings sprout from your back as you start emanating a wave of seething hatred.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>soul touch</name>
						<script>-- Soul Touch
-- You reach out and grasp Corland Deepforge savagely, drawing his life force into you.
-- You reach out and grasp A naked woman savagely, drawing her life force into you.
-- You are overcome with a dark euphoria as the last of an opulent merchant's life force flows into you.

meleePowerUsed=false

timer:set("soul_touch", 6*60)

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You reach out and grasp .* savagely, drawing .* life force into you.</string>
							<string>^(?:&lt; .* &gt; )?You are overcome with a dark euphoria as the last of .* life force flows into you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shroud of shadow</name>
						<script>-- shroud of shadow

-- A misty cloud of gloom swirls about you, shielding you from harm.

buff:set(whoami(), "shroud_of_shadow", 12)
timer:set("shroud_of_shadow", 12)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?A misty cloud of gloom swirls about you, shielding you from harm.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shroud of shadow (drop)</name>
						<script>-- Your shroud of shadow dissipates, leaving you vulnerable.

buff:set(whoami(), "shroud_of_shadow", nil)
timer:set("shroud_of_shadow", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shroud of shadow dissipates, leaving you vulnerable.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of death</name>
						<script>-- aura of death
-- A dark mist surrounds you, wrapping you in the chill embrace of death.

buff:set(whoami(), "aura_of_death", 90)
timer:set("aura_of_death", 90)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?A dark mist surrounds you, wrapping you in the chill embrace of death.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of death (drop)</name>
						<script>-- The dark mists swirling around you melt back into the shadows.

buff:set(whoami(), "aura_of_death", nil)
timer:set("aura_of_death", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The dark mists swirling around you melt back into the shadows.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>consumption</name>
						<script>-- Your form flares with a brief crimson glow as you purge yourself of afflictions.

buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")
buff:del(whoami(), "poison")
buff:del(whoami(), "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your form flares with a brief crimson glow as you purge yourself of afflictions.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>scourge of agony</name>
						<script>-- A ruby-throated humming bird shrieks in agony as your flaming whip strips the flesh from its bones!

-- Scourge of Agony

-- no unique button</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>. * shrieks in agony as your flaming whip strips the flesh from .* bones!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ravenous shadows</name>
						<script>-- You channel the twisted spirits of your past victims into a swirling, life-draining mass!
-- The swirling spirits screech an ear-rending shriek as they devour a ruby-throated humming bird's flesh!</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You channel the twisted spirits of your past victims into a swirling, life-draining mass!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>impulsive dread</name>
						<script>timer:set("dread_smite", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The waves of dark energy course through .*, wracking .* body with pain.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Hex</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hexblast</name>
						<script>-- Your weapons fire a blast of spectral flames at Lavis Ryl.
-- Your weapons fire a blast of spectral flames at a lithe commoner.
-- Your weapon fires a blast of spectral flames at an opulent merchant.
-- You land a glancing blow on Shalyssa Lurialar with your blast of spectral flames.

meleePowerUsed=false

timer:set("hexblast", 8)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your weapons? fires? a blast of spectral flames at .*</string>
							<string>^(?:&lt; .* &gt; )?You land a glancing blow on .* with your blast of spectral flames.</string>
							<string>^Your weapons fire a blast of spectral flames at .*$</string>
							<string>^You miss .* with your Hexblast.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>smothering darkness</name>
						<script>-- You hurl a sphere of swirling shadows at an opulent merchant, engulfing him in darkness.
-- You land a glancing blow with your sphere of shadows.
-- The swirling shadows pull an opulent merchant down into their dark embrace, smothering the life out of him.

meleePowerUsed=false

timer:set("smothering_darkness", 8)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You hurl a sphere of swirling shadows at .*, engulfing .* in darkness.</string>
							<string>^(?:&lt; .* &gt; )?You land a glancing blow with your sphere of shadows.</string>
							<string>^(?:&lt; .* &gt; )?The swirling shadows pull .* down into their dark embrace, smothering the life out of .*</string>
							<string>^You miss .* with your Smothering Darkness.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>darkworm feast</name>
						<script>-- an opulent merchant collapses as a legion of wriggling shadow worms slough off his flesh!
-- You speak a forbidden word, summoning shadow worms to burrow into a lithe commoner's flesh.
-- You speak a forbidden word, but Ultrumm shakes off the wriggling shadow worms.

meleePowerUsed=false

timer:set("darkworm_feast", 32)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* collapses as a legion of wriggling shadow worms slough off .* flesh!</string>
							<string>^(?:&lt; .* &gt; )?You speak a forbidden word, summoning shadow worms to burrow into</string>
							<string>^(?:&lt; .* &gt; )?You speak a forbidden word, but .* shakes off the wriggling shadow worms.</string>
							<string>^You miss .* with your Darkworm Feast.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>memory of blades</name>
						<script>-- Your ghostly blades rip an opulent merchant apart in a blast of eldritch energy.
-- At your command, dozens of ghostly sword blades appear and streak towards a stout commoner.
-- ^(?:&lt; .* &gt; )?Your ghostly sword blades land a series of glancing blows upon

meleePowerUsed=false

timer:set("memory_of_blades", 32)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your ghostly blades rip .* apart in a blast of eldritch energy.</string>
							<string>^(?:&lt; .* &gt; )?At your command, dozens of ghostly sword blades appear and streak towards .*</string>
							<string>^(?:&lt; .* &gt; )?Your ghostly sword blades land a series of glancing blows upon</string>
							<string>^You miss .* with your Memory of Blades.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>soul eater</name>
						<script>-- You cut an opulent merchant down with your fell blade and revel in the stolen life energy.
-- Your blade glows with a fell energy as it devours a bearded commoner's soul and transfers his life to you.
-- Your blade glows with a fell energy as it glances off of a devout priest.

meleePowerUsed=false

timer:set("soul_eater", 32)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You cut .* down with your fell blade and revel in the stolen life energy.</string>
							<string>^(?:&lt; .* &gt; )?Your blade glows with a fell energy as it devours .* soul and transfers .*</string>
							<string>^(?:&lt; .* &gt; )?Your blade glows with a fell energy as it glances off of .*</string>
							<string>^You miss .* with your Soul Eater.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>baleful hex</name>
						<script>-- You focus your destructive energy on a bearded commoner, cursing him with a baleful hex!

meleePowerUsed=false

timer:set("baleful_hex", 30)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You focus your destructive energy on .*, cursing .* with a baleful hex!</string>
							<string>^You miss .* with your Baleful Hex.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hellstrike</name>
						<script>-- Dark crimson flames leap off of your weapon as you strike an opulent merchant, searing his flesh.
-- You land a glancing blow on Corland Deepforge with your hellborne attack.
-- Hellborne flames erupt from your weapon and blast a stout commoner into a fiery oblivion.

meleePowerUsed=false

timer:set("hellstrike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Dark crimson flames leap off of your weapon as you strike .*, searing .* flesh.</string>
							<string>^(?:&lt; .* &gt; )?You land a glancing blow on .* with your hellborne attack.</string>
							<string>^(?:&lt; .* &gt; )?Hellborne flames erupt from your weapon and blast .* into a fiery oblivion.</string>
							<string>^You miss .* with your Hellstrike.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>void star</name>
						<script>-- an opulent merchant succumbs to the void as his flesh sloughs away.
-- The dying light of a dark star enshrouds your weapon as you strike a bearded commoner.
-- Your weapon pulsates with a dark light as your weapon glances off of Shalyssa Lurialar.

meleePowerUsed=false

timer:set("void_star", 28)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* succumbs to the void as .* flesh sloughs away.</string>
							<string>^(?:&lt; .* &gt; )?The dying light of a dark star enshrouds your weapon as you strike .*</string>
							<string>^(?:&lt; .* &gt; )?Your weapon pulsates with a dark light as your weapon glances off of .*</string>
							<string>^The dark light contracts and then suddenly expands into a nebulous sunburst!$</string>
							<string>^You miss .* with your Void Star.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>black frost</name>
						<script>-- an opulent merchant howls as the dark ice needles on your weapon rend his flesh away in a spray of frost.
-- Your weapon sprouts a dark forest of frost needles that rip through a graceful commoner's flesh.
-- The dark frost needles that sprout from your weapon glance off of Elaith Waterstill.

meleePowerUsed=false

timer:set("black_frost", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* howls as the dark ice needles on your weapon rend .* flesh away in a spray of frost.</string>
							<string>^(?:&lt; .* &gt; )?Your weapon sprouts a dark forest of frost needles that rip through .* flesh.</string>
							<string>^(?:&lt; .* &gt; )?The dark frost needles that sprout from your weapon glance off of</string>
							<string>^You miss .* with your Black Frost.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>vortex of fire</name>
						<script>-- an opulent merchant collapses within the fiery embrace of your all-consuming vortex of flames.
-- Your weapon erupts in a raging column of flame as it strikes Seipora Rein.

--The dancing column of flame sweeps through the area, burning all those within its fiery core.
--Your weapon smolders menacingly as your attack glances off of Shalyssa Lurialar.

-- Seipora Rein collapses within the fiery embrace of your all-consuming vortex of flames.
-- Willa O'Greensleeves collapses within the fiery embrace of your all-consuming vortex of flames.

meleePowerUsed=false

timer:set("vortex_of_fire", 28)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* collapses within the fiery embrace of your all-consuming vortex of flames.</string>
							<string>^(?:&lt; .* &gt; )?Your weapon erupts in a raging column of flame as it strikes</string>
							<string>^(?:&lt; .* &gt; )?Your weapon smolders menacingly as your attack glances off of</string>
							<string>^You miss .* with your Vortex of Fire.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>soulcutter</name>
						<script>-- Your weapon unleashes a cascade of eldritch energy as it strikes a lithe commoner.
-- a stout commoner glows brightly with eldritch energy as you strike her down with your weapon.
-- Your powerful eldritch strike glances off of a devout priest.

meleePowerUsed=false

timer:set("soulcutter", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your weapon unleashes a cascade of eldritch energy as it strikes .*</string>
							<string>.* glows brightly with eldritch energy as you strike .* down with your weapon.</string>
							<string>^(?:&lt; .* &gt; )?Your powerful eldritch strike glances off of </string>
							<string>^You miss .* with your Soulcutter.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of flies</name>
						<script>-- You call forth a cloud of acidic black flies to swirl around you.

buff:set(whoami(), "cloak_of_flies", 60)
timer:set("cloak_of_flies", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You call forth a cloud of acidic black flies to swirl around you.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>frostblade</name>
						<script>-- A thick layer of eldritch frost encases your weapon.

buff:set(whoami(), "frostblade", 20)
timer:set("frostblade", 20)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?A thick layer of eldritch frost encases your weapon.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>blade of annihilation</name>
						<script>-- Your weapon blackens as it awakens with a terrible bloodlust.

buff:set(whoami(), "blade_of_annihilation", 45)
timer:set("blade_of_annihilation", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your weapon blackens as it awakens with a terrible bloodlust.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>blazing doom</name>
						<script>-- Wopur utters an infernal phrase that infuses his weapon with hellish fire and pain.

if matches[2] == whoami() then
  buff:set(whoami(), "blazing_doom", 90)
  timer:set("blazing_doom", 30)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Z][a-z]+) utters an infernal phrase that infuses his weapon with hellish fire and pain.</string>
							<string>^(?:&lt; .* &gt; )?([A-Z][a-z]+) utters an infernal phrase that infuses her weapon with hellish fire and pain.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>armor of winters grasp</name>
						<script>-- You summon chunks of Abyssal ice to form a chilling suit of icy plate armor.

buff:set(whoami(), "armor_of_winters_grasp", 50)
timer:set("armor_of_winters_grasp", 50)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You summon chunks of Abyssal ice to form a chilling suit of icy plate armor.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>armor of the void</name>
						<script>-- You draw forth the dead space from between planes and forge it into a suit of dull black armor.
-- You draw forth the dead space from between planes and forge it into a suit of dull black armor.

buff:set(whoami(), "armor_of_the_void", 30)
timer:set("armor_of_the_void", 30)

meleePowerUsed=false
setMeleeCooldown()

spell:stop() -- set spell.casting=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You draw forth the dead space from between planes and forge it into a suit of dull black armor.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>death shroud</name>
						<script>-- You summon an ancient eldritch power to drain the life-force of your enemies.</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You summon an ancient eldritch power to drain the life-force of your enemies.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>armor of hexes</name>
						<script>-- Spectral tendrils weave around you, forming an eldritch armor.

buff:set(whoami(), "armor_of_hexes", 60)
timer:set("armor_of_hexes", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Spectral tendrils weave around you, forming an eldritch armor.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>eldritch chains</name>
						<script>--A lithe commoner is weakened!
--A lithe commoner looks strong again.

timer:set("eldritch_chains", 40)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Spectral chains lash out from you and wrap tightly around .*</string>
							<string>^You miss .* with your Eldritch Chains.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ruin blade</name>
						<script>-- Your weapon glows with infernal energy as you strike a stout commoner, unleashing a torrent of dark power.

meleePowerUsed=false

timer:set("ruin_blade", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon glows with infernal energy as you strike .*, unleashing a torrent of dark power.</string>
							<string>^You miss .* with your Ruinblade.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>fiendish frenzy</name>
						<script>-- Infernal might floods your body and engulfs your weapon in ancient hexes.
-- Your Fiendish Frenzy has expired.

meleePowerUsed=false

buff:set("fiendish_frenzy", 14)

timer:set("fiendish_frenzy", 30)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Infernal might floods your body and engulfs your weapon in ancient hexes.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>eldritch renewal</name>
						<script>timer:set("eldritch_renewal", 2.5*60)

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You cast the spell 'Eldritch Renewal'.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>gift of the everliving</name>
						<script>meleePowerUsed=false
setMeleeCooldown()

spell:stop() -- set spell.casting=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You access a well of ancient power to soothe your wounds.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>starless shield</name>
						<script>meleePowerUsed=false

timer:set("starless_shield", 8)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Darkness coalesces around you, forming a swirling void shield that you slam into .*</string>
							<string>^You miss .* with your Starless Shield.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>horrific howl</name>
						<script>-- You release a terrifying howl that echoes with the despair of absolute nothingness.

meleePowerUsed=false

--timer:set("horrific_howl", 45)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You release a terrifying howl that echoes with the despair of absolute nothingness.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hex of void embrace</name>
						<script>buff:set(whoami(), "hex_of_void_embrace", 60)
timer:set("hex_of_void_embrace", 60*3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your weapon glows with eldritch power as you weave a hex of void embrace around it.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hex of arcane disruption</name>
						<script>buff:set(whoami(), "hex_of_arcane_disruption", 60)
timer:set("hex_of_arcane_disruption", 60*3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon glows with eldritch power as you weave a hex of arcane disruption around it.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hellforged avatar</name>
						<script>-- In an explosion of hellfire, you transform into a diabolical harbinger of destruction!
buff:set(whoami(), "hellforged_avatar", 20)
timer:set("hellforged_avatar", 60*3+30)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^In an explosion of hellfire, you transform into a diabolical harbinger of destruction!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hex of lingering doom</name>
						<script>-- Your weapon glows with eldritch power as you weave a hex of lingering doom around it.
buff:set(whoami(), "hex_of_lingering_doom", 60)
timer:set("hex_of_lingering_doom", 60*3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon glows with eldritch power as you weave a hex of lingering doom around it.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hex of shattered defenses</name>
						<script>buff:set(whoami(), "hex_of_shattered_defenses", 60)
timer:set("hex_of_shattered_defenses", 60*3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your weapon glows with eldritch power as you weave a hex of shattered defenses around it.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hex of null resilience</name>
						<script>timer:set("hex_of_null_resilience", 30)
buff:set("hex_of_null_resilience", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your weapon glows with eldritch power as you weave a hex of null resilience around it.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>infernal brand</name>
						<script>-- The flames of the Nine Hells roar to life as your weapon becomes a conduit for infernal power!

meleePowerUsed=false
buff:set("infernal_brand", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^The flames of the Nine Hells roar to life as your weapon becomes a conduit for infernal power!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Sor</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>crackling whip</name>
						<script>-- Your hand crackles with electricity as you lash a purple martin with a whip of lightning.
spell:setCurrent(nil)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your hand crackles with electricity as you lash .+ with a whip of lightning.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>acidic orb</name>
						<script>timer:set("acidic_orb", 50)

spell:setCurrent(nil)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The air hisses with toxic vapor as you hurl an orb of bubbling acid into .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>prismatic sphere</name>
						<script>--You summon a brilliant sphere of ever-changing colors and send it streaking towards an opulent merchant.
timer:set("prismatic_sphere", 12)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You summon a brilliant sphere of ever-changing colors and send it streaking towards .*$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>entropic blast</name>
						<script>-- The air shimmers as you channel a blast of entropic energy at an opulent merchant.
timer:set("entropic_blast", 12)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^The air shimmers as you channel a blast of entropic energy at .*$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>RaceTriggers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Yuan-Ti</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You concentrate and harden your body into thick scales.</name>
						<script>-- scaleskin enabled (yuanti)
-- innate scaleskin - You concentrate and harden your body into thick scales.

charData:set("scaleskin", true)
scale_skin("scale_skin", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You concentrate and harden your body into thick scales.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your scales become soft once more.</name>
						<script>-- Your scales become soft once more.

charData:set("scaleskin", false)
scale_skin("scale_skin", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your scales become soft once more.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Half-Orc</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>furious assault</name>
						<script>-- You attack Stephan with monstrous fury!

meleePowerUsed=false

timer:set("furious_assault", 90)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You attack .* with monstrous fury!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>WhoClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture from wholist</name>
					<script>--[50 Cle] Isila  (Moon Elf) [@Inames]
--[50 Ill] Imay  (Drow Elf) [@Tanji]
--[50 Rog] Gaidiel - Pirate King of the Valkurian Blades (Moon Elf) [@Diel]
--[50 Cle] Osheara Arluune -*- Azurite -*- Shadows of Imphras (Moon Elf)
--[50 A-P] Razem  (Half-Orc) [@Enth]

--[50 Psi] Nyyrazzilyss - Head Jailer of the Valkurian Blades (Illithid) (AFK) (@Nyyrazzilyss)
--{ "[50 Psi] Nyyrazzilyss - Head Jailer of the Valkurian Blades (Illithid) (@Nyyrazzilyss)", "Psi", "Nyyrazzilyss", "Illithid", "Nyyrazzilyss" }


sqlinwho(matches[3])

-- [3] - name
-- [2] - class
-- [4] - race
-- [5] - profilename

if matches[5] then
  whoadd(matches[3], matches[2], matches[4], matches[5])
end

local profile=getProfile(matches[3])

--display(profile)

if profile == "unknown" or profile == 1  or not profile then
    -- TODO needs to be corrected to not send when in paging mode
    mud:send("who " .. matches[3])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[[0-9 ]+([a-zA-Z-]+)\] ([a-zA-Z]+) .*\(([a-zA-Z- ]+)\)$</string>
						<string>^\[[0-9 ]+([a-zA-Z-]+)\] ([a-zA-Z]+) .*\(([a-zA-Z- ]+)\).*(?:\(@(.*)\))+$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Save wholist</name>
					<script>savewholist()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Record number of players on this boot</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture charname</name>
					<script>setwhoami(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Character attributes for ([a-zA-Z]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Katumi tells you</name>
					<script>if inwho(matches[3]) == false then
  whoadd(matches[3], matches[2], matches[4], matches[5])

  echoDebug("\n[Adding " .. matches[3] .. " to wholist]")

  setProfile(matches[3], matches[5])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Katumi tells you '\[[0-9]+ (.*)\] ([A-Za-z]+) \((.*)\) \(@([A-Za-z]+)\) seen .*'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture from individual who</name>
					<script>if inwho(matches[3]) == false then
  for k, v in pairs(NyyLIB.fullclasslist) do
    if v[1] == matches[2]:trim()   then
      whoadd(matches[3], v[2], matches[4], matches[5])
      return
    end
  end
end

if inwho(matches[3]) == "unknown" then
  setProfile(matches[3], matches[5])
  echoDebug(" [Setting " .. matches[3] .. " profile name to " .. matches[5] .. "]\n")
end

-- getProfile(matches[3]) this command errors if not in database

if getProfile(matches[3]) ~= matches[5] then
  echoDebug(" [Profile Error: " .. getProfile(matches[3]) .. " : " .. matches[5] .. "]\n")
  setProfile(matches[3], matches[5])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\[ ?[0-9]+ (.*) *\] ([A-Za-z]+) +.*\((.*)\) \(@([A-Za-z]+)\)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Total players online: 20.</name>
					<script>-- end of who list</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Total players online: [0-9]+[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>anon char</name>
					<script>-- [ Anon ] Anlar  (Half-Orc) 

local profile=getProfile(matches[2])

if profile then
  cecho( "&lt;slate_grey&gt; [@" .. profile .. "]" )
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[ Anon \] ([A-Z][a-z]+) +\(.+\)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GroupClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Add from group display</name>
					<script>local temp = whoclass(matches[8]) or "UNK"

if gagGroup == nil then
  groupList:display(matches[8], matches[6], matches[7], matches[4], matches[5], matches[2], matches[3] )
else
  eraseLine()
end

groupList:add( idMob(matches[8]),temp,matches[6],matches[7])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([0-9]+)/([0-9]+) +man +([0-9]+)/([0-9]+) +move +([0-9]+)/([0-9]+) +hit - ([A-Za-z ]+)</string>
						<string>([0-9]+)/([0-9]+) +psp +([0-9]+)/([0-9]+) +move +([0-9]+)/([0-9]+) +hit - ([A-Za-z ]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Reset grouplist</name>
					<script>groupRedraw = false

groupList:reset()

NyyLIB.groupname = matches[2]

if gagGroup == nil then
  if charData:get("group", true) then
    cecho("                                 &lt;yellow&gt;[Stats: " .. charData:get("statname") .. "]\n")
  end
else
  eraseLine()
end

group:set("GROUPSTART")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Group information for (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>But you are a member of no group?!</name>
					<script>groupRedraw = nil

groupList:reset()

if gagGroup then
  group:send(false)
  eraseLine()
  echoDebug(" &lt;red&gt;[empty group received]")
end

groupList:add(whoami(), whoclass(), prompt:get("hp"), prompt:get("maxhp") )

rescuelist:generate()

RedrawGroupStatus()

resizeGroupWindow(true)

group:set("GROUPSTART")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>But you are a member of no group?!</string>
						<string>You are no longer a member of the group.</string>
						<string>You are now a member of</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Joined group</name>
					<script>group:send()
tempTimer(2, [[resizeGroupWindow(true)]])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>now a member of</string>
						<string>([A-Za-z]+) has left the group.</string>
						<string>has disbanded the group.</string>
						<string>You disband the group.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Add when not in same room</name>
					<script>local temp = whoclass(matches[2]) or "UNK"

if   gagGroup == nil then
  groupList:display(matches[2])
else
  eraseLine()
end

groupList:add( idMob(matches[2]),temp, 0, 0)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>                                                        [-] ([A-Za-z ]+)</string>
						<string>[(]Head[)]   [ ]+[-] ([A-Za-z]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>add from group no mana</name>
					<script>local temp = whoclass(matches[6]) or "UNK"

if   gagGroup == nil then
  groupList:display(matches[6], matches[4], matches[5], matches[2], matches[3] )
else
  eraseLine()
end

groupList:add( idMob(matches[6]),temp,matches[4],matches[5])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>        +([0-9]+)/([0-9]+) +move +([0-9]+)/([0-9]+) +hit - ([A-Za-z ]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Autogroup</name>
					<script>-- Dlabble has just given you his consent.
-- Vooku has just given you his consent.

local consentchar= matches[2]


consent:set( consentchar, true )

if matches[2] ~= "slaad" then
  if inwho(matches[2]) == false then
    mud:send("who " .. consentchar)
  end
end

-- Send group command if char isn't currently grouped
if groupList:ingroup(consentchar) then
  --
else
  mud:send("GROUP " .. consentchar)
  group:send()
end

look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) has just given you (his|her|its) consent[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>remove dead people</name>
					<script>-- open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving
-- hand reaching down to touch ([A-Za-z]+) and .*
-- When it at last clears ([A-Za-z]+) stands before you, looking extremely tired!
-- ([A-Za-z]+) takes a first shuddering breath and rises from the dead. 

local matchchar=matches[2]

-- Misi has returned to the land of the living.



-- return if in fugue

if map:getRoom() == 93848 then
  return
end

-- if grouplist doesn't have hp send group
if groupList:ingroup(matchchar) then
  if groupList:getHP(matchchar) == 0 then
    group:send()
  end
end

if table.contains(NyyLIB.deadpeople, matches[2]) then
  echoDebug("\n" .. matchchar .. " is alive!\n")

  table.remove(NyyLIB.deadpeople, table.index_of(NyyLIB.deadpeople, matchchar))

  group:send()
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) .* stands here.</string>
						<string>([A-Za-z]+) .* sits resting.</string>
						<string>([A-Za-z]+) .* stands in mid-air here.</string>
						<string>([A-Za-z]+) .* stands, inches above the surface here.</string>
						<string>([A-Za-z]+) steps out of a wormhole.</string>
						<string>([A-Za-z]+) flies in from the (north|south|east|west).</string>
						<string>([A-Za-z]+) .* hulks here.</string>
						<string>open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving</string>
						<string>hand reaching down to touch ([A-Za-z]+) and .*</string>
						<string>When it at last clears ([A-Za-z]+) stands before you, looking extremely tired!</string>
						<string>([A-Za-z]+) has returned to the land of the living.</string>
						<string>([A-Za-z]+) .* is stretched out, sound asleep.</string>
						<string>([A-Za-z]+) takes a first shuddering breath and rises from the dead. </string>
						<string>([A-Za-z]+) flies in from above.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Dogmasa has died!</name>
					<script>if groupList:ingroup(matches[2]) then
  if table.contains(NyyLIB.deadpeople, matches[2]) == false then
    table.insert(NyyLIB.deadpeople, 1, matches[2])
  end

  buff:del(matches[2])

  if inwho(matches[2]) == "Lilithelle" then
    sound("209740__yummie__minion-yahoo-2.wav")
  else
    sound("195954_minian89_death-blood-splatter.wav")
  end

  group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?([A-Za-z]+) has died!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>([A-Za-z]+) group-says '.*</name>
					<script>inwho(matches[2])

if not groupList:ingroup( idMob(matches[2]) ) then
  if whoclass(matches[2]) ~= nil then
    groupList:add( idMob(matches[2]), whoclass(matches[2]), 0, 0)
    resizeGroupWindow(true)
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) group-says '.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>add group leader</name>
					<script>-- setting group leader

if matches[2] ~= "Someone" then
  NyyLIB.leader = matches[2]
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\(Head\) .* - ([A-Za-z]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Size:</name>
					<script>currentsize = currentsize or 0

-- if groupsize has changed or blind, gui will need forced resize
if currentsize ~= matches[2] or buff:get("blind") or buff:get("blindness") then 
  currentsize = matches[2]

  --display("enable forceresize")

  tempTimer(1, [[resizeGroupWindow(true)]])
end

enableTrigger("endprompt")

if   gagGroup == nil then
  if charData:get("group", true) then
    eraseLine()

    cecho(string.format("\n&lt;yellow&gt;  HP/Max           [Group Size:%2d]              MV/Max  PSP/Max    " .. 
      "Hit (Total) Rescue (Total)",
      matches[2]))
  end
else
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Size: +([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endprompt</name>
					<script>-- group has been recieved. can check for vit (send status) now
gagGroup=nil

groupList:checkMaxHP()

disableTrigger("endprompt")
rescuelist:generate()
--echoDebug("&lt;red&gt; [Group received]\n")
group:send(false)
groupRedraw = nil
--display("X")
group:set(false) -- might interfere with circle
raiseEvent("promptEvent")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&gt;\t\n$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>is already a member of another group!</name>
					<script>if NyyLIB.leader == whoami() then
  mud:send("t " .. matches[2] .. " " .. matches[2] .. " is already a member of another group!")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) is already a member of another group!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Update grouped players fighting</name>
					<script>-- Add any grouped players tanking a mob to the list

--The ghoul of an opulent merchant stands here, fighting an opulent merchant.
--An opulent merchant stands here, fighting the ghoul of an opulent merchant.

-- If last command entered was "l " or scan, return

if string.find(command, "L ") == 1 or command == "SCAN" then
  return
end

if matches[2] == "YOU" then
  groupList:incTanking(whoami())
end

if groupList:ingroup( idMob(matches[2]) ) then
  groupList:incTanking( idMob(matches[2]) )
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*[,] fighting ([A-Za-z ]+)[.]</string>
						<string>.*[,] fighting (YOU)!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Reset tanking list</name>
					<script>-- Since a room is being looked at, the table of players tanking mobs is reset

-- If last command entered was "l " or scan, return

if string.find(command, "L ") == 1 or command == "SCAN" then
  return
end

groupList:resetTanking()

-- if pet tanking
if prompt:get("tank") ~= "" then
  if not inwho( prompt:get("tank") ) then
    groupList:incTanking( prompt:get("tank") )
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>disable looting and autoassist when grouped</name>
					<script>-- You form a new group.

-- don't disable if leading smtrain
if isActive("SMTrain", "trigger") == 0 then
  if previousLine() ~= "You form a new group." then
    echo("\n")
    buttons:change("autoloot", "off", "autoloot")
    buttons:change("autoassist", false, "autoassist")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are now a member of</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>gsay not in grouplist</name>
					<script>local whoMatch= matches[2]:trim()

--display(whoMatch)

if whoMatch ~= "You" then
  if not groupList:ingroup(whoMatch) then
	 group:send()
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+)?/?([A-Za-z ]+ )group-says? ('.*')$</string>
						<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+)?/?([A-Za-z ]+ )group-projects? ('.*')$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>MiscTriggers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>PANIC!  You couldn't escape!</name>
					<script>-- Send flee again on failed attempt to flee

fleeAttempt = fleeAttempt or 0

if charData:get("flee") ~= "off" and charData:get("flee") ~= "dragon"  or NyyLIB.escapedir ~= nil then

  if matches[2] ~= "busy" then
    --display("X")
    fleeAttempt = fleeAttempt + 1
  end

  if fleeAttempt &lt; 15 then
    -- abort spell if casting

    spell:clear()

    mud:send("FLEE")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?PANIC!  You couldn't escape!</string>
						<string>^(?:&lt; .* &gt; )?You scramble madly to your feet!</string>
						<string>^(?:&lt; .* &gt; )?You're too (busy) trying to gain the initiative to flee!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Stand Triggers</name>
					<script>-- Various reasons to send a stand command

-- sends you sprawling


-- removed ^(?:&lt; .* &gt; )?Your head slams into the ground, stunning you!$ since this appears to double send stand
-- removed 'You are slammed' because 'You are slammed by the powerful blast of air!' doesn't always bash
-- actual trigger from blacks looks to be 'You are slammed down on the ground!'

sound("123753__vicces1212__collapse.wav")

meleePowerUsed=false

spell:setMem(false)

if spell:getCurrent() then
  spell:setCurrent(nil)
end

-- TODO: Because the prompt is going to show recline/stand hasn't been sent, a stand command should be generated/ this one removed
mud:send("ST")

-- set prompt to reclined

prompt:set("position", "rcl")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>fall to your knees</string>
						<string>^(?:&lt; .* &gt; )?The shockwave sends you crashing to the ground!$</string>
						<string>tripping you.</string>
						<string>You are knocked</string>
						<string>You are swept off your feed by the size of the wave!$</string>
						<string>^(?:&lt; .* &gt; )?You fall and injure yourself!$</string>
						<string>^(?:&lt; .* &gt; )?You get hit by a giant boulder and fall to the ground!$</string>
						<string>You lose your balance</string>
						<string>^(?:&lt; .* &gt; )?You stagger about, then fall sprawling!$</string>
						<string>^(?:&lt; .* &gt; )?Your hasty hamstring causes you to slip and fall to the ground!$</string>
						<string>^(?:&lt; .* &gt; )?You flail about wildly and crash to the ground!$</string>
						<string>^(?:&lt; .* &gt; )?Boldly taking the impact, you are still knocked aside!$</string>
						<string>You simply bounce off</string>
						<string>^(?:&lt; .* &gt; )?You have to be standing up to do that!$</string>
						<string>you topple over and fall to the ground.</string>
						<string>only to sprawl completely THROUGH</string>
						<string>^(?:&lt; .* &gt; )?You are swept off your feet by the size of the wave!$</string>
						<string>^(?:&lt; .* &gt; )?Who can concentrate with all that clanging and screaming[?]$</string>
						<string>^(?:&lt; .* &gt; )?You can't concentrate with all the racket!$</string>
						<string>^(?:&lt; .* &gt; )?You crash to the ground beneath the powerful strike!$</string>
						<string>around your limbs. It yanks your feet out from under you, sending you crashing</string>
						<string>^(?:&lt; .* &gt; )?You manage to, with complete incompetence, throw yourself head first directly into the ground!$</string>
						<string>^(?:&lt; .* &gt; )?Get off your knees!$</string>
						<string>^(?:&lt; .* &gt; )?In your haste to slam people around, you slip and fall!$</string>
						<string>only to fall onto your face THROUGH</string>
						<string>^(?:&lt; .* &gt; )?The violent winds pick you up and toss you aside!$</string>
						<string>^(?:&lt; .* &gt; )?Intense pain runs through your body as your ribs fracture from the impact.$</string>
						<string>^(?:&lt; .* &gt; )?You collapse in a heap on the ground.$</string>
						<string>is too huge for you to trip! You go crashing to the ground.</string>
						<string>^(?:&lt; .* &gt; )?And just for the attempt, you fall down.$</string>
						<string>and you go down as well.</string>
						<string>^(?:&lt; .* &gt; )?Standing would be a good first step.$</string>
						<string>^(?:&lt; .* &gt; )?You fall to the ground.  You stop riding.$</string>
						<string>^(?:&lt; .* &gt; )?Damn!  Lost your train of thought!$</string>
						<string>With a powerful heave on the whip, an elite cornugon sends you crashing to the ground in a spray of blood!$</string>
						<string>^(?:&lt; .* &gt; )?You can't do this sitting!$</string>
						<string>^(?:&lt; .* &gt; )?You stagger, and fall to your knees!$</string>
						<string>^.* sends you sprawling.$</string>
						<string>^(?:&lt; .* &gt; )?You are unable to dodge the blow, and its force sends you crashing to the ground!$</string>
						<string>^(?:&lt; .* &gt; )?You are slammed down on the ground!$</string>
						<string>^(?:&lt; .* &gt; )?You drop to the ground and retch.$</string>
						<string>^(?:&lt; .* &gt; )?The solar's words, imbued with a magical command, force you to your knees!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Flee Lich'd</name>
					<script>-- Flee if hit by lich proc

if charData:get("flee") == "lich" then
  mud:send("flee")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you fall, you see a stream of your own life force flowing away from you..</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Return after fleeing</name>
					<script>-- If a room is fleed (for example, by dragon roar) return to the previous room
-- If autohide is turned on, you won't return - You'll attempt to hide
-- If your current hp is less then your wimpy, you also won't return.

local temp = matches[2]:lower()

if checkMask("psi") then
  if charData:get("autohide") then
    return
  end
end

if charData:get("wimpy") ~= nil then
  if prompt:get("hp") &lt;= charData:get("wimpy") then
    return
  end
end

if NyyLIB.escapedir ~= nil then
  return
end


if charData:get("flee") == "dragon" then
  if temp == "north" then
    mud:send("s")
  elseif temp == "south" then
    mud:send("n")
  elseif temp == "east" then
    mud:send("w")
  elseif temp == "west" then
    mud:send("e")
  elseif temp == "up" then
    mud:send("d")
  elseif temp == "down" then
    mud:send("u")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You flee (.*)ward!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Looting</name>
					<script>-- Loot if autoloot enabled, update xp display and dismount if mounted
-- Reset various variables, and send a look command to the mud

prompt:set("tank", nil)

if not getHide() then
  if charData:get("autoloot") == "coins" then
    mud:send("get coins corpse")
  elseif charData:get("autoloot") == "all" then
    mud:send("get all corpse")
  end
end

if charData:get("level") &lt; 50 then
  mud:send("exp", false)
  NyyLIB.delxpline = true
end

--if mount:get() ~= nil then
--  mud:send("dismount")
--end

setBashing(false)
setTripping(false)
rescueSent=false

assistSent=nil

look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You receive .* XP .* experience.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Any prompt</name>
					<script>-- raise status event
if NyyLIB.statuschar ~= "" then
  raiseEvent("statusEvent", NyyLIB.statuschar)
end

NyyLIB.statuschar=""

-- room capture: disable if present

disableTrigger("RoomCapture")

roomWindow:update()

disableTrigger("lootlist")

enableTrigger("StartRoomCapture")

if look:get() ~= "LOOKSENT" then
  gaglook=nil
end

if Geyser.Label:getWindow("gIconBarWindow") == nil then
  return
end

roomWindow:resize()

-- don't enable gagging look until a prompt has been receieved subsequent to sending the command
if toGagLook == true then
  gaglook=true
  toGagLook=nil
end  

-- first prompt after a look recieved
if look:get() == "LOOKSTART" then
  look:set(nil)

  -- re-raise prompt event
  raiseEvent("promptEvent")
end

-- first prompt after a group recieved
if group:get() == "GROUPSTART" then
  group:set(false)
  
  -- rogue: circle
  if charData:get("autocircle") then
    if prompt:get("tank") ~= whoami() and inCombat() then
      --if prompt:get("enemycondition") ~= "awful" then
        expandAlias("cr", false)
      --end
    end
  end
end

RedrawGroupStatus()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&gt;\t\n$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are getting hungry.</name>
					<script>-- If not hidden, eat food

if inCombat() then
  return
end

if not getHide() then
  if checkMask("psi") then
    if charData:get("autosustain") then
      mud:send("sustain")
    end
  else
    mud:send("eat " .. charData:get("food") .. " " .. charData:get("container") )
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are getting hungry[.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are getting thirsty.</name>
					<script>-- If not hidden, drink water

if not getHide() then
  if checkMask("psi") then
    --
  else
    if not inCombat() then
      mud:send("drink " .. charData:get("canteen") )
    end
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are getting thirsty[.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The ([A-Za-z]+) seems to be closed.</name>
					<script>-- disabled since this should have already occured by the map

-- If an attempt is made to walk through a closed door, and autoopen is enabled - Open it

if charData:get("autoopen") then
  mud:send("open " .. matches[2])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The ([A-Za-z]+) seems to be closed.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You stop trying to hide.</name>
					<script>setHide(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You stop trying to hide.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>misc look:send() triggers</name>
					<script>look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A dark shape springs out of the darkness at you!</string>
						<string>causes an EARTHQUAKE!</string>
						<string>utters a single word and disappears.</string>
						<string>.* turns .* attention to .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>bash messages</name>
					<script>meleePowerUsed=false

setBashing(false)
setTripping(false)

sound("241280__sonictechtonic__gooeybashes.wav")

timer:set("cooldown", 1.5)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your bash at .* sends (him|her|it) sprawling.</string>
						<string>They have to be standing up for you to do that!</string>
						<string>You can't do that without solid ground underneath you!</string>
						<string>Your icy bash at .* sends (him|her|it) sprawling.</string>
						<string>But they're already on the ground!</string>
						<string>You manage to, with complete incompetence, throw yourself head first directly into the ground!</string>
						<string>You do a fancy maneuver, tripping</string>
						<string> is too huge for you to trip! You go crashing to the ground.</string>
						<string>You're not ready to perform another action!</string>
						<string>You sweep attack</string>
						<string>That power hasn't recharged yet!</string>
						<string>You would pass right through them!</string>
						<string>No target for your power could be found!</string>
						<string>You advance .* with a series of devastating blows that send .* crashing to the ground.</string>
						<string>You need to be able to see your target to do that!</string>
						<string>They are too large for you to do that!</string>
						<string>They are too small for you to do that!</string>
						<string>You are slammed down on the ground!</string>
						<string>Sorry, you can't do that while lying around.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You raise a level!</name>
					<script>charData:set( "level", charData:get("level")+1 )

mud:send("score")
mud:send("gsay &lt;&lt;&lt; Level " .. charData:get("level") .. "! &gt;&gt;&gt;")

initClass()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You raise a level!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are 6,256,116 XP (83.75%) away from your next level.</name>
					<script>-- Your guildmaster says 'You have just begun the trek to your next level!' - l1/0%

if NyyLIB.xpwindow == nil then
  return
end

local xppercent = 100 - tonumber(matches[3])

NyyLIB.xpwindow:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;L:]] .. charData:get("level") .. " " .. xppercent .. [[%&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])  

if NyyLIB.delxpline then
  eraseLine()
  NyyLIB.delxpline = false
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are ([0-9,]+) XP \(([0-9.]+)%\) away from your next level.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>anti-spellguard</name>
					<script>-- Spellguard (aggro evil race) entering room in Silverymoon

if whoami() == "Nyyrazzilyss" then
  mud:send("slaad")
  mud:send("ORDER slaad bash spellguard")
  mud:send("project schism")
  mud:send("protect")
end

if whoclass() == "Psi" then
  mud:send("ultra spellguard")
  mud:send("ultra spellguard")
  mud:send("ultra spellguard")
end

if whoami() == "Adud" or whoami() == "Cadisasor" then
  mud:send("say aid of mage")
  mud:send("say strength of stone")
  mud:send("vitme")
  sendBash("spellguard")
end

if whoami() == "Rrissun" then
  mud:send("slaad")
  mud:send("ORDER slaad bash spellguard")
  spell:cast("ha slaad")
  spell:cast("ha me")
  spell:cast("cr spellguard")
  spell:cast("sp spellguard")
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A mage in the Spellguard flies in from</string>
						<string>A mage in the Spellguard snaps into visibility.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>.* switches targets[.][.]$</name>
					<script>look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* switches targets[.][.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You give your consent to Lilithelle.</name>
					<script>if groupList:size() &gt; 1 then
  mud:send("t " .. matches[2] .. " " .. matches[2] .. " now has consent.")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You give your consent to ([A-Za-z]+).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You now flee at 200 hit points or less!</name>
					<script>if matches[2] == nil then
  charData:set("wimpy", 0)
else
  charData:set("wimpy", tonumber(matches[2]) )
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You now flee at ([0-9]+) hit points or less!</string>
						<string>You now feel like a true hero, no auto-fleeing here! :-)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Resurrection triggers</name>
					<script>if matches[2] == nil then
  cecho("&lt;red&gt;[Error: nil consent match]\n")
end

if groupList:ingroup(matches[2]) then
  mud:send("consent " .. matches[2])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Thamos) tells you 'I will now RESURRECT you, make sure I have your CONSENT'</string>
						<string>^(Osheara) tells you 'Get ready for the BLUEST resurrection ever!'</string>
						<string>^([A-Za-z]+) tells you 'consent.*$</string>
						<string>^([A-Za-z]+) tells you 'ressing, consent .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You think Coburaxximus has spotted you!</name>
					<script>setHide(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You think .* has spotted you!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You escape ([nsewud]).*</name>
					<script>NyyLIB.escapedir = nil

if NyyLIB.roguereturn ~= nil then
  mud:send(NyyLIB.reversedirs[matches[2]], false)

  local attacktarget

  if NyyLIB.target == nil then
    attacktarget = getEnemy()
  else
    attacktarget = NyyLIB.target
  end

  if attacktarget ~= "" then
    if NyyLIB.roguereturn == "c" then
      NyyLIB.tosend = "circle " .. attacktarget
    elseif NyyLIB.roguereturn == "b" then
      NyyLIB.tosend = "backstab " .. attacktarget
    elseif NyyLIB.roguereturn == "p" then
      NyyLIB.tosend = "bs " .. attacktarget
    end
  else
    cecho("&lt;red&gt;[No target is currently set. Use @target name to set targets.]\n")
  end

  NyyLIB.roguereturn = nil
else
  if charData:get("autohide") then
    if checkMask("rog") then
      mud:send("hide")
      mud:send("save")
    end
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You escape ([nsewud]).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You get the dust of a shadow from corpse of a shadow.</name>
					<script>mud:send("put dust " .. charData:get("container") )</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You get the dust of a shadow from corpse of a shadow.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>poke - haste</name>
					<script>-- haste on poke

if charData:get("pokehaste") then
  if groupList:ingroup(matches[2]) then
    local level = charData:get("level")

    if whoclass() == "Enc" and level &gt;= 16 then
      spell:cast("HS " .. matches[2])
      spell:cast("MB " .. matches[2])
    elseif whoclass() == "Ele" and level &gt;= 31 then
      spell:cast("HS " .. matches[2])
    elseif whoclass() == "Nec" and level &gt;= 31 then
      spell:cast("HS " .. matches[2])
    elseif whoclass() == "Lic" and level &gt;= 31 then
      spell:cast("HS " .. matches[2])
    end

  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) pokes you in the ribs. What!?</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>That power hasn't recharged yet!</name>
					<script>if matches[2] ~= "stunned" then
  mud:send("RECHARGE")
end

local val=timer:get("cooldown")


if val ~= nil then
  if timer:get("cooldown") &lt; 1 then
    timer:set("cooldown", .5)
  end
else
  timer:set("cooldown", .5)
end

meleePowerUsed=false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>That power hasn't recharged yet!</string>
						<string>You are too (stunned) to do that!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Why?  You are not fighting anyone.</name>
					<script>if NyyLIB.escapedir ~= nil then
  mud:send(NyyLIB.escapedir, false)

  NyyLIB.escapedir = nil
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Why?  You are not fighting anyone.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>player enter room</name>
					<script>local matchchar = matches[2]

enteredPortal = enteredPortal or {}

-- clear mtank if not in group

if NyyLIB.mtank ~= nil then
  if not groupList:ingroup(NyyLIB.mtank) then
    NyyLIB.mtank=nil
  end
end

-- visible in room so has not entered portal

if groupList:ingroup(matchchar) then
  enteredPortal[matchchar] = nil

  if groupList:getHP(matchchar) == 0 then
    group:send()
    return
  end
end

-- use @mtank to check hp (send group) when a particular char enters the room

if NyyLIB.mtank ~= nil then
  if NyyLIB.mtank == matchchar then
    group:send()
    return
  end
end

-- don't proceed if npc (= following)

if not inwho(matchchar) then
  return
end

-- update group info if autoheal enabled

if charData:get("autoheal") then
  if groupList:ingroup(matchchar) then
    -- don't send group if moving
    
    if not spell:getMoving() then
      group:send()
    end
    return
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) lumbers in .*</string>
						<string>([A-Za-z]+) enters from .*</string>
						<string>([A-Za-z]+) flies in .*</string>
						<string>([A-Za-z]+) prowls in from .*</string>
						<string>([A-Za-z]+) skulks in from .*</string>
						<string>([A-Za-z]+) sneaks in from .*</string>
						<string>([A-Za-z]+) slowly fades into existence.</string>
						<string>([A-Za-z]+) steps out of .*</string>
						<string>([A-Za-z]+) flies in.</string>
						<string>([A-Za-z]+) swims in .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Katumi NHC: (H) 'Welcome,</name>
					<script>-- Katumi NHC: (H) 'Welcome, Aminmag. If
-- ^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+/)?([A-Za-z]+ )GCC: ('.*')$

local charname = matches[2]

--if getProfile ( whoami() ) == "Nyyrazzilyss" then
--  mud:send("advert")
--end

mud:send("who " .. charname)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?(?:@[A-Z][a-z]+/)?Katumi NHC: .* 'Welcome, ([A-Za-z]+).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^([A-Za-z]+) tells you 'version'</name>
					<script>-- send version
display(matches[2])
mud:send("TELL " .. matches[2] .. " Script version: 013dev 6/27/2023")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:@[A-Za-z]+/)?([A-Za-z]+) tells you '@?version'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>is dead! R.I.P.</name>
					<script>setEnemy("")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>is dead! R.I.P.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>auction claim</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> +[0-9]+\) +([0-9]+) +.*[A-Za-z]+ +SELLER (.*)</string>
						<string> +[0-9]+\) +([0-9]+) +.*You.*(ENDED|BUYER).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>follow trigger</name>
					<script>-- Whiffle Whark (leaves|swims) ([A-Za-z]+).
-- Thelmor Thoren (leaves|swims) ([A-Za-z]+).

-- reaches vipertongue (7019) at 23 minutes
-- reaches stream (6840) at 40 minutes 
-- reaches south side docks (3782) at 70-80 minutes

-- Keep Whark invis the entire time on north side of docks+

-- north side dock (3773) 81 minutes
-- leaves north side dock at 90 minutes
-- arrives calimshan spice emporium (3561) at 98 minutes
-- leaves spice at 121 minutes

-- invis all the guards at the Black Dragon Gate (3305)
-- invis the werewolf at the Circle of Contest (71711)

-- arrives kopha 137 minutes

-- if werewolf fights druid, invis werewolf again

-- departs kopha at 154 minutes

if matches[2] == toFollow then
  mud:send(matches[4])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) (flies|crawls|leaves|swims) ([A-Za-z]+)[.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You flee (.*)ward!</name>
					<script>--abort cast

if NyyLIB.escapedir ~= nil then
  -- send reverse

  if NyyLIB.escapedir ~= matches[2] then
    expandAlias(NyyLIB.reversedirs[matches[2]], false)
    expandAlias(NyyLIB.escapedir, false)
  end

  NyyLIB.escapedir = nil

end

if charData:get("autohide") then
  if checkMask("psi") then
    mud:send("darkness")
  end

  if checkMask("rog") or checkMask("ran") then
    mud:send("hide")
    mud:send("save")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You flee ([nsewud]).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The fighting in the area rages on.</name>
					<script>look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The fighting in the area rages on.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>A small pile of coins.</name>
					<script>if charData:get("autoloot") == "coins" then
  mud:send("GET coins")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A small pile of coins.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>EquipProcs</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaSleeves</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your utterance brings about an instantanious mending of</name>
						<script>-- sleeves went off (not charged)
setLabelImage("TiaSleeves", "TiaSleeves-off.png")

timer:set("TiaSleeves", 24*60)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your utterance brings about an instantaneous mending of</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Baatorian</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Smoke begins to pour out of your bracer, swirling around you in a dizzying</name>
						<script>rescuelist:generate()
mud:send("ORDER slaad consent " .. whoami(), false)
sendFollowers()
timer:set("baatorian", 24*60)
baatorian("baatorian", buttons.INIT)
pet_rescue("pet_rescue", buttons.INIT)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Smoke begins to pour out of your bracer, swirling around you in a dizzying</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A gray slaad stops following you.</name>
						<script>if matches[2] == "A gray slaad" then
  if not getHide() then
    mud:send("get all gray")
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(.*) stops following you.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are using:</name>
					<script>local nx
local label


for nx=1, #equipment, 1 do
  -- disable folder in equipprocs representing specific item triggers
  disableTrigger(equipment[nx][1])
end

-- hide all equipment icons associated with the item

for nx=0, 20, 1 do
  label=findlabel("1button" .. nx)

  if label ~= nil then
    label:show()
    label:hide()
  end
end

enableTrigger("CaptureWorn")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are using:$</string>
						<string>You aren't wearing anything!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CaptureWorn</name>
					<script>-- {"TiaScale", "a silvered scale of deepest blue hue", 5, "say deeply defend"},


local capture=matches[2]

for nx=1, #equipment, 1 do
  if string.findPattern(matches[2], equipment[nx][2]) then
       local shortname=equipment[nx][1]
    local buttonnumber = equipment[nx][3]

    enableTrigger(shortname)
    
    -- addbutton(xname, xbar, xid, xlevel, xwidth, xheight)
    addbutton( shortname, 1, buttonnumber, 0)
  end
end

if string.ends(capture, "&gt; ") or string.ends(capture, "&gt;\t\n") then
  disableTrigger("CaptureWorn")
  return
end

-- TODO weapon should be set here

local autoWeapon = charData:get("autoweapon")

if autoWeapon ~= "auto" then
  equip:setWeapon(autoWeapon)
  return
end

-- Remove all (word) patterns: (magic), (illuminating), (glowing), (damaged), (invis)
capture = string.gsub(capture, " %(.+%)", "")

local teststring = string.match(capture, "&lt;primary weapon&gt;     (.*)")

if teststring then
  equip:setWeapon(teststring)
end

local teststring = string.match(capture, "&lt;wielding twohanded&gt; (.*)")

if teststring then
  local checkBow = sqlIsBow(teststring)
    if #checkBow &gt; 0 then
      equip:setWeapon("Bow")
    else
      equip:setWeapon("TwoHand")
    end
end

local teststring = string.match(capture, "&lt;secondary weapon&gt;   (.*)")
if teststring then
  equip:setWeapon("Dual")
end

local teststring = string.match(capture, "&lt;held as shield&gt;     (.*)")

if teststring then
  equip:setWeapon("Shield")
end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(&lt;.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaStaff</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>nimbus flares about your body.  The magic buffers against the glowing sphere,</name>
						<script>-- spell captured
setLabelImage("TiaStaff", "TiaStaff-loaded.png")

charData:set("TiaStaff", "charged")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>nimbus flares about your body.  The magic buffers against the glowing sphere,</string>
							<string>You have no target for your released spell, very dangerous...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You lift an ancient staff of the arch-magi high above your head, calling</name>
						<script>-- spell release
setLabelImage("TiaStaff", "TiaStaff-off.png")

charData:set("TiaStaff", "")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You lift an ancient staff of the arch-magi high above your head, calling</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You whisper quietly to an ancient staff of the arch-magi, hefting it in</name>
						<script>-- spell capture enabled
setLabelImage("TiaStaff", "TiaStaff-waiting.png")

charData:set("TiaStaff", "")
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You whisper quietly to an ancient staff of the arch-magi, hefting it in</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaMask</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A set of gem studded tentacle rings glows with a soft light as its charge is fully replenished.</name>
						<script>-- tiamask charged
setLabelImage("TiaMask", "TiaMask-charged.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A set of gem studded tentacle rings glows with a soft light as its charge is fully replenished.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The three ioun stones of a set of gem studded tentacle rings glow</name>
						<script>-- mask  invoked
setLabelImage("TiaMask", "TiaMask-on.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The three ioun stones of a set of gem studded tentacle rings glow</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaBane</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A ([A-Za-z]+) notch appears along the handle of your blade.</name>
						<script>if matches[2] == "single" then
  charData:set("banecharges", 1)
elseif matches[2] == "second" then
  charData:set("banecharges", 2)
elseif matches[2] == "third" then
  charData:set("banecharges", 3)
elseif matches[2] == "fourth" then
  charData:set("banecharges", 4)
end

TiaBane("TiaBane", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A ([A-Za-z]+) notch appears along the handle of your blade.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>As you shout to the infernal stiletto of Bane, the weapon begins to glow</name>
						<script>-- bane - dragonstrike

local label=findlabel("TiaBane")

charData:set("banecharges", 0)

if label ~= nil then
  TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>As you shout to the infernal stiletto of Bane, the weapon begins to glow</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The handle of your blade glows brightly.</name>
						<script>local label=findlabel("TiaBane")
charData:set("banecharges", 5)

if label ~= nil then
  TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The handle of your blade glows brightly.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>see the hand of Bane himself emerge from the blade of your stiletto and point at</name>
						<script>-- bane - blind

local label=findlabel("TiaBane")
charData:set("banecharges", charData:get("banecharges")-3)

if label ~= nil then
  TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>see the hand of Bane himself emerge from the blade of your stiletto and point at</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>around the blade before the stiletto flies back to your hand.</name>
						<script>-- bane - slow

local label=findlabel("TiaBane")
charData:set("banecharges", charData:get("banecharges")-2)

if label ~= nil then
  TiaBane("TiaBane", buttons.UPDATE)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>around the blade before the stiletto flies back to your hand.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>As you whisper under your breath your blade makes a faint noise, and shudders</name>
						<script>-- failed

local label=findlabel("TiaBane")
charData:set("banecharges", 0)

if label ~= nil then
  TiaBane("TiaBane", buttons.UPDATE)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>As you whisper under your breath your blade makes a faint noise, and shudders</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>the infernal stiletto of bane glows for a brief second before poison begins to drip down one of it's edges.</name>
						<script>local label=findlabel("TiaBane")
charData:set("banecharges", charData:get("banecharges")-1)

if label ~= nil then
  TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>the infernal stiletto of bane glows for a brief second before poison begins to drip down one of it's edges.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The frenzy begins to stir in your heart anew!</name>
					<script>-- grin recharged
setLabelImage("FrenziedGrin", "FrenziedGrin-on.png")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The frenzy begins to stir in your heart anew!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you whisper a prayer to the heavens, you are quickly</name>
					<script>setLabelImage("TiaSandals", "TiaSandals-off.png")
timer:set("TiaSandals", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you whisper a prayer to the heavens, you are quickly</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The corner of your mouth spasms with bloodthirsty frenzy!</name>
					<script>setLabelImage("FrenziedGrin", "FrenziedGrin-off.png")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The corner of your mouth spasms with bloodthirsty frenzy!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you whisper to yourself the words of power, you are caught up</name>
					<script>setLabelImage("TiaLoop", "TiaLoop-off.png")
timer:set("TiaLoop", 24*60)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you whisper to yourself the words of power, you are caught up</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You raise your hands above your head, whispering words of power to your sleeves.</name>
					<script>-- haste proc vermillion sleeves

--setLabelImage("VermSleeves", "equipVerm-active.png")

timer:set("VermSleeves", 24*60)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You raise your hands above your head, whispering words of power to your sleeves.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You call upon the magics contained within your volant band</name>
					<script>-- volance on

setLabelImage("TiaVolance", "TiaVolance-on.png")
timer:set("TiaVolance", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You call upon the magics contained within your volant band</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your entire body begins to slow down.  All your movements become sluggish as total physical</name>
					<script>-- vermillion sleeves - drop</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your entire body begins to slow down.  All your movements become sluggish as total physical</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>All of your mirror images have been destroyed!</name>
					<script>-- mirrors dropped
if findlabel("TiaMask") ~= nil then
  setLabelImage("TiaMask", "TiaMask-off.png")
end

-- volance

if findlabel("TiaVolance") ~= nil then
  setLabelImage("TiaVolance", "TiaVolance-off.png")
end

buff:del(whoami(), "mirror_image" )

sound("86324__timbre__smashing-1b.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?All of your mirror images have been destroyed!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaWarmaul</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your %w bludgeon</name>
						<script>-- Your powerful bludgeon barely wounds Corland Deepforge.
-- the warmaul of celestial glory seems to hum with energy as it connects with
-- You critically wound Shalyssa Lurialar with a mighty bludgeon!


-- #TRIGGER {{You crushed|Your mighty bludgeon|Your strong bludgeon|Your average bludgeon|Your powerful bludgeon|Your massive bludgeon}} {#add wmhits 1;#STATUS Hit Count: @wmhits}

NyyLIB.warmaul = NyyLIB.warmaul or 0

if matches[2] then
  if matches[2] == "zero" then
    return
  end
  
  if matches[2] == "one" then
    NyyLIB.warmaul = NyyLIB.warmaul + 1
  end
  
  if matches[2] == "two" then
    NyyLIB.warmaul = NyyLIB.warmaul + 2
  end
else
  NyyLIB.warmaul = NyyLIB.warmaul + 1
end

TiaWarmaul("TiaWarmaul", buttons.UPDATE)

echoDebug("&lt;red&gt; (" .. NyyLIB.warmaul .. ")")

if NyyLIB.warmaul &gt; 12 then
  local tmpvar=charData:get("warmaul")

  if tmpvar == "aid" then
    mud:send("aid")
  elseif tmpvar == "restore" then
    mud:send("restore")
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your .* bludgeon .*</string>
							<string>You critically wound .* with a mighty bludgeon!</string>
							<string>.* staggers from your .* bludgeon!</string>
							<string>You crushed</string>
							<string>You attack .+, landing (.+) hit.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You swing the warmaul of celestial glory in a mighty arc, crushing into</name>
						<script>-- You swing the warmaul of celestial glory in a mighty arc, colliding solidly (dead)
-- You swing the warmaul of celestial glory in a mighty arc, crushing into (damaged)
cecho("&lt;red&gt; [Warmaul proc: " .. NyyLIB.warmaul .. "]\n")

NyyLIB.warmaul=-1

TiaWarmaul("TiaWarmaul", buttons.UPDATE)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You swing the warmaul of celestial glory in a mighty arc, colliding solidly</string>
							<string>^under the impact.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You mutter under your breath to your the warmaul of celestial glory and watch</name>
						<script>echoDebug("[Warmaul called proc at " .. NyyLIB.warmaul .. "]\n")

NyyLIB.warmaul=0

TiaWarmaul("TiaWarmaul", buttons.UPDATE)

group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You mutter under your breath to your the warmaul of celestial glory and watch</string>
							<string>You call upon your deity to restore your health!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>the warmaul of celestial glory from the glowing corpse.</name>
						<script>NyyLIB.warmaul=0

TiaWarmaul("TiaWarmaul", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>the warmaul of celestial glory from the glowing corpse.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your manacle shoots out visible strands of magic which interlace</name>
					<script>--
setLabelImage("TiaManacle", "TiaManacle-off.png")

timer:set("TiaManacle", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your manacle shoots out visible strands of magic which interlace</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You scream in pain as your wrists are sliced open within your own gauntlets!</name>
					<script>-- You scream in pain as your wrists are sliced open within your own gauntlets!
-- As the nasty spikes on your gauntlets tear into the flesh of your opponent     &lt;hitall&gt;

mud:send("att", false)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You scream in pain as your wrists are sliced open within your own gauntlets!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You feel yourself growing, in strength and size as magic fills you.  Your body gains a</name>
					<script>-- supple girdle
timer:set("SuppleGirdle", 24*60*3)
sound("105308__kovrov__rumble.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel yourself growing, in strength and size as magic fills you.  Your body gains a</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You swirl your cloak around and blend into the background.</name>
					<script>-- warder cloak
timer:set("TiaWarder", 24*60)
setHide(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You swirl your cloak around and blend into the background.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you say 'blend' to a dark gray cloak with a rune embroidered hem,</name>
					<script>-- warder cloak still isn't charged
if not timer:get("TiaWarder") then
  timer:set("TiaWarder", 2*60)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you say 'blend' to a dark gray cloak with a rune embroidered hem,</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hitting shield</name>
					<script>-- You shiver from unnatural cold.
-- You are burned as you hit a half-dragon kobold!

-- proc globe if not globed or warded and &lt; 80% hp

if not buff:get("globe_of_invulnerability") and not buff:get("elemental_ward") then
  if prompt:get("hp") &lt; (.80 * prompt:get("maxhp") ) then
    -- fighters loop (warrior)
    if isIconActive("TiaLoop") and timer:get("TiaLoop") == nil then
      TiaLoop("TiaLoop", buttons.CLICK)
    end
  end
  
  if checkMask("rog") then
    -- silvered scale (rogue)
    if isIconActive("TiaScale") and timer:get("TiaScale") == nil then
      TiaScale("TiaScale", buttons.CLICK)
    end
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You shiver from unnatural cold</string>
						<string>^You are burned as you hit</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As Ozay takes a viscious wound, the mighty scepter of valhalla begins to hum</name>
					<script>-- As Ofug takes a viscious wound, the mighty scepter of valhalla begins to hum

-- valhalla blur
if groupList:ingroup(matches[2]) then
  buff:set(matches[2], "blur", 570)
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As ([A-Za-z]+) takes a viscious wound, the mighty scepter of valhalla begins to hum</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Upon being struck, a mirror image of Adud shatters into a million particles of light!</name>
					<script>if matches[2] == whoami() then
  sound("86324__timbre__smashing-1a.wav")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?Upon being struck, a mirror image of ([A-za-z]+) shatters into a million particles of light!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As the magic of your bracers saturates your body, they begin</name>
					<script>-- As the magic of your bracers saturates your body, they begin

mud:send("GSAY [TIMESTOP UP]")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As the magic of your bracers saturates your body, they begin</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you invoke your deep blue silvered scale, a transluscent field</name>
					<script>-- silvered scale

setLabelImage("TiaScale", "TiaScale-off.png")
timer:set("TiaScale", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you invoke your deep blue silvered scale, a transluscent field</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your cincture glows brightly for a moment while the magics tied to</name>
					<script>-- cincture

setLabelImage("TiaCincture", "TiaCincture-off.png")
timer:set("TiaCincture", 24*60)

buff:set(whoami(), "displacement", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your cincture glows brightly for a moment while the magics tied to</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You begin to speak in a devilish tongue, grinding out</name>
					<script>-- gelugon claws
setLabelImage("TiaClaws", "TiaClaws-off.png")

timer:set("TiaClaws", 12*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You begin to speak in a devilish tongue, grinding out</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You kneel to the ground, wrapping your cloak about your body, chanting softly.</name>
					<script>-- dcult robes

setLabelImage("DragonCult", "DragonCult-off.png")

timer:set("DragonCult", 3*24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You kneel to the ground, wrapping your cloak about your body, chanting softly.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You wear</name>
					<script>-- You wear a dark gray cloak with a rune embroidered hem about your body.
-- You clasp a luminous cincture of nightfallen stars about your waist.
-- You wear a silvered scale of deepest blue hue over your eyes.
-- You place a smoking bracer forged from Baatorian steel around your left wrist.
-- You cover your arms with the quickly pulsing bracers of time.
-- You place the mystical boots of stability on your feet.
-- You duck your head and place a thick titanium band of volance around your neck.
-- You place a fighter's loop of sorcerous ability on your left ring finger.
-- You cover your face with a set of gem studded tentacle rings.
-- You wear the wickedly sharp claws of a gelugon devil on your hands.

local equipinfo = equipment:getByLongName( matches[2])

-- create button if equipment worn is proc'ing

if equipinfo ~= nil then
    enableTrigger(equipinfo[1])
    addbutton( equipinfo[1], 1, equipinfo[3], 0)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You wear (.*) about your body[.]</string>
						<string>You clasp (.*) about your waist[.]</string>
						<string>You wear (.*) over your eyes[.]</string>
						<string>You place (.*) around your .*</string>
						<string>You cover your arms with (.*)[.]</string>
						<string>You place (.*) on your feet[.]</string>
						<string>You duck your head and place (.*) around your neck[.]</string>
						<string>You place (.*) on your .*</string>
						<string>You cover your face with (.*)[.]</string>
						<string>You wear (.*) on your hands[.]</string>
						<string>You wield (.*)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You stop using</name>
					<script>-- You stop using a supple leather girdle with golden studs.

-- TODO - regex conflict with magi staff

local equipinfo = equipment:getByLongName( matches[2])
local checkBow = sqlIsBow(matches[2])
local check2H = sqlIs2H(matches[2])
local checkWeapon = sqlIsWeapon(matches[2])

-- remove button if present

if equipinfo ~= nil then
  disableTrigger(equipinfo[1])

  local label=findlabel("1button" .. equipinfo[3])

  if label ~= nil then
    label:show()
    label:hide()
  end
end

-- was the item removed a longbow?

if checkMask("ran") then
  if #checkBow &gt; 0 then
    -- bow was just removed. switch to melee buttons
    equip:setWeapon(matches[2])
    return
  end
end

-- TODO paladin: was the item removed a 2h sword

if checkMask("pal") then
  if #check2H &gt; 0 then
    equip:setWeapon(matches[2])
    return
  end
end

-- was the item rmeoved a wapon?

if not checkMask("ran") then
  if #checkWeapon &gt; 0 then
    equip:setWeapon("none")
  end
end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You stop using (.*)[.]$</string>
						<string>You are zapped by (.*) and instantly release it.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You hold your ancient staff high in the air, and with a deathly</name>
					<script>-- ashen staff

setLabelImage("AshenStaff", "AshenStaff-off.png")
timer:set("AshenStaff", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You hold your ancient staff high in the air, and with a deathly </string>
						<string>As you say 'rot' to an ancient staff of the ashen soul,</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You wield (.*)[.]</name>
					<script>-- Set wielded weapon, change skill buttons if needed

local autoWeapon = charData:get("autoweapon")

if autoWeapon ~= "auto" then
  equip:setWeapon(autoWeapon)
else
  equip:setWeapon(matches[2])
end

-- Switch buttons if ranger, paladin, blackguard, warrior, hexblade

if checkMask("war") then
  initWar()
end


if checkMask("ran") then
  initRan()
end

if checkMask("pal") then
  initPal()
end

if checkMask("blk") then
  initBlk()
end

if checkMask("hex") then
  _G["initHex" .. subClass]()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You wield (.*)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>BuffClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>BuffTriggers</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>(.*)'s skin seems to turn to stone.</name>
						<script>if matches[2] == "You" then
  buff:set(whoami(), "stoneskin")
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "stoneskin")
  end
end  
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*)'s skin seems to turn to stone.</string>
							<string>(You) feel your skin harden to stone.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>^Your flesh loses its stony texture.$</name>
						<script>if groupList:size() &lt; 9 or checkMask("warrior") then
  mud:send("gsay " .. charData:get("stoneout", true) )
end

buff:del(whoami(), "stoneskin")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your flesh loses its stony texture.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your form begins to blur!</name>
						<script>if matches[2] == "Your" then
  buff:set(whoami(), "blur")
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "blur")
  end
end  
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(Your) form begins to blur!$</string>
							<string>([A-Za-z]+)'s form becomes blurred and difficult to make out!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel your heart start to race REALLY FAST!</name>
						<script>-- The spectre of a human noble starts to move with uncanny speed!

if matches[2] == "You" then
  buff:set(whoami(), "haste")
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "haste")
  else
    -- pet
    local name=pet:member(matches[2])

    if name then
      buff:set(name, "haste")
    end
  end
end  </script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) feel your heart start to race REALLY FAST!$</string>
							<string>(.*) starts to move with uncanny speed!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You begin to shimmer.</name>
						<script>-- The spectre of a human noble begins to shimmer.

if matches[2] == "You" then
  buff:set(whoami(), "globe_of_invulnerability")
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "globe_of_invulnerability")
  else
    -- pet
    local name=pet:member(matches[2])

    if name then
      buff:set(name, "globe_of_invulnerability")
    end
  end
end  </script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) begin to shimmer.$</string>
							<string>(.*) begins to shimmer.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel your skin transform into dragon scales.</name>
						<script>if matches[2] == "You" then
  buff:set(whoami(), "dragonscales")
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "dragonscales")
  end
end  </script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) feel your skin transform into dragon scales.</string>
							<string>([A-za-z]+)'s skin transforms into hard-plated dragon scales.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The world slows down around you!</name>
						<script>-- timestop

if checkMask("priest") then
  setLabelImage("TiaBracers", "TiaBracers-on.png")
else
  setLabelImage("time_stop", "time_stop-active.png")
end

buff:set(whoami(), "time_stop")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world slows down around you!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Time speeds up suddenly!</name>
						<script>buff:del(whoami(), "time_stop")

if checkMask("priest") then
  setLabelImage("TiaBracers", "TiaBracers-off.png")
else
  if charData:get("autots") then
    setLabelImage("time_stop", "time_stop-on.png")
  else
    setLabelImage("time_stop", "time_stop-off.png")
  end

  PopulateTimestop()
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Time speeds up suddenly!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your form stops blurring.</name>
						<script>if matches[2] == "Your" then
  if groupList:size() &gt; 1 and groupList:size() &lt; 9 or checkMask("warrior") then
    mud:send("gsay " .. charData:get("blurout", true) )
  end
  buff:del(whoami(), "blur")
else
  if groupList:ingroup(matches[2]) then
    buff:del(matches[2], "blur")  
  end
end  </script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(Your) form stops blurring.</string>
							<string>([A-Za-z]+) group-says '.*(blur|Blur|BLUR) .+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your dragon scales melt back into your regular flesh.</name>
						<script>if groupList:size() &gt; 1 and groupList:size() &lt; 9 or checkMask("warrior") then
  mud:send("gsay " .. charData:get("scaleout", true) )
end

buff:del(whoami(), "dragonscales")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your dragon scales melt back into your regular flesh.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*globe.*'</name>
						<script>if groupList:ingroup(matches[2]) then
  buff:del(matches[2], "globe_of_invulnerability", "x")  
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(globe|Globe|GLOBE).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*haste.*'</name>
						<script>if groupList:ingroup(matches[2]) then
  buff:del(matches[2], "haste", "x")  
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(haste|HASTE|Haste).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*scale.*'</name>
						<script>if groupList:ingroup(matches[2]) then
  buff:del(matches[2], "dragonscales", "x")  
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(scale|Scale|SCALE).*'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*stone.*'</name>
						<script>local var=buff:get("stoneskin", matches[2])

if not var then
  return
end

if var &gt; 220 then
  return
end

if groupList:ingroup(matches[2]) then
  buff:del(matches[2], "stoneskin", "x")  
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(stone|Stone|STONE).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*vitality.*'</name>
						<script>if groupList:ingroup(matches[2]) then
  -- display("removing vitality from " .. matches[2])


  buff:del(matches[2], "vitality", "x")  
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(vit|Vit|VIT).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The world speeds up around you.</name>
						<script>if groupList:size() &gt; 1 and groupList:size() &lt; 9 or checkMask("warrior") or checkMask("hitter") then
  mud:send("gsay " .. charData:get("hasteout", true) )
end

buff:del(whoami(), "haste")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world speeds up around you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your globe shimmers, and fades into the air.</name>
						<script>if groupList:size() &gt; 1 and groupList:size() &gt; 1 and groupList:size() &lt; 9 or checkMask("warrior") or checkMask("hitter") then
  mud:send("gsay " .. charData:get("globeout", true) )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your globe shimmers, and fades into the air.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your vitality drains away.</name>
						<script>buff:del(whoami(), "vitality")  

if groupList:size() &gt; 1 and groupList:size() &lt; 9 or checkMask("warrior") then
  mud:send("gsay " .. charData:get("vitout", true) )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your vitality drains away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are suddenly filled with knowledge of battle tactics!</name>
						<script>buff:set(whoami(), "combatmind", 600)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are suddenly filled with knowledge of battle tactics!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel less wooden.</name>
						<script>if groupList:size() &gt; 1 and groupList:size() &lt; 9 or checkMask("warrior") then
  mud:send("gsay " .. charData:get("barkout", true) ) 
end

buff:del(whoami(), "barkskin")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel less wooden.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your magic armor fades away.</name>
						<script>if charData:get("level") &lt; 30 then
  mud:send("gsay [[ ARMOR OUT ]]" )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your magic armor fades away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The elemental ward protecting you shudders and disappears.</name>
						<script>-- elemental ward      

mud:send("gsay [[ WARD OUT ]]" )
buff:del(whoami(), "elemental_ward")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The elemental ward protecting you shudders and disappears.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>image of a Valkyrie appears to partially conceal and protect you.</name>
						<script>-- valhalla blur
buff:set(whoami(), "blur", 600 )
--mud:send("gsay [[ VALHALLA UP ]]" )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>image of a Valkyrie appears to partially conceal and protect you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Invisible things vanish again.</name>
						<script>-- mud:send("gsay &lt;&lt; DET INVIS OUT &gt;&gt;")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Invisible things vanish again.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A crackling purple nimbus of light pops into being around your arms and weapons.</name>
						<script>-- ward

-- Peri begins to glow with an eerie purple light.


if matches[2] == "your" then
  buff:set(whoami(), "elemental_ward")
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "elemental_ward", 240)
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A crackling purple nimbus of light pops into being around (your) arms and weapons.</string>
							<string>([A-Za-z]+) begins to glow with an eerie purple light.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body shimmers and sheds its elemental form, returning to normal.</name>
						<script>mud:send("gsay [[ ELEMENTAL EMBODIMENT OUT ]]" )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body shimmers and sheds its elemental form, returning to normal.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body becomes infused with the divine power of your god!</name>
						<script>-- divine power on</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body becomes infused with the divine power of your god!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wave of exhaustion washes over you as your divine power fades.</name>
						<script>-- divine power off</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wave of exhaustion washes over you as your divine power fades.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The feeling of power fades as your deity departs.</name>
						<script>-- righteous might off</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The feeling of power fades as your deity departs.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Tatris is infused with vitality.</name>
						<script>if matches[2] == "You" then
  buff:set(whoami(), "vitality")
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "vitality")
  end
end

group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) is infused with vitality.</string>
							<string>(You) feel vitalized.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Onut's form is displaced.</name>
						<script>if matches[2] == "Your" then
  buff:set(whoami(), "displacement", 1440)
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "displacement", 1440)
  end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+)'s form is displaced.</string>
							<string>(Your) form is displaced!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>displacement spellout</name>
						<script>-- ([A-Za-z]+) group-says '.*(Displace|displace|DISPLACE).+'

if matches[2] == "Your" then
  mud:send("gsay " .. charData:get("displaceout", true) )
  buff:del(whoami(), "displacement", "x")
else
  if groupList:ingroup(matches[2]) then
    buff:del(matches[2], "displacement", "x")  
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(Displace|displace|DISPLACE).+'</string>
							<string>(Your) displaced form snaps back to your physical location!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Several mirror images of you pop into existence at your side!</name>
						<script>buff:set(whoami(), "mirror_image", 31*60 )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Several mirror images of you pop into existence at your side!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>earth embo</name>
						<script>-- Hetat's form begins to harden and solidify as he is transformed into an earth elemental.
-- Hirple's form begins to harden and solidify as he is transformed into an earth elemental.
-- "elemental_earth_embodiment"

if groupList:ingroup(matches[2]) then
  buff:set(matches[2], "elemental_earth_embodiment", 600)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+)'s form begins to harden and solidify as .* is transformed into an earth elemental.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The ancestral spirits depart, dissipating your shield.</name>
						<script>-- remove ancestral shield
buff:del(whoami(), "ancestral_shield", "x")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The ancestral spirits depart, dissipating your shield.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A shimmering spiritual shield hovers over you.</name>
						<script>-- add ancestral shield
buff:set(whoami(), "ancestral_shield", 30)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A shimmering spiritual shield hovers over you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel somewhat safer from things that go bump in the night.</name>
						<script>-- pfu
buff:set(whoami(), "protection_from_undead", 360)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel somewhat safer from things that go bump in the night.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Undead love you once more.</name>
						<script>-- pfu
buff:del(whoami(), "protection_from_undead", "x")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Undead love you once more.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A doppelganger of Bombum snaps into being at his side!</name>
						<script>-- add buff
if groupList:ingroup(matches[2]) then
  buff:set(matches[2], "doppleganger", 1000)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A doppelganger of (.*) snaps into being at .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Caceshen is now protected from undead!</name>
						<script>--
-- Protection From Undead 6min
-- buff:set(whoami(), "protection_from_undead", 360)

if matches[2] == "You" then
  --
else
  if groupList:ingroup(matches[2]) then
    buff:set(matches[2], "protection_from_undead", 360)
  end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is now protected from undead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your blood burns with the fiery power of death!</name>
						<script>-- death pact
buff:set(whoami(), "death_pact", 3*60+52)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your blood burns with the fiery power of death!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The wraith of a human noble's hand starts to glow RED as blood.</name>
						<script>-- vampiric touch
if groupList:ingroup(matches[2]) then
  buff:set(matches[2], "vampiric_touch", 13*60)
else
  -- pet
  local name=pet:member(matches[2])

  if name then
    buff:set(name, "vampiric_touch", 13*60)
  end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*)'s hand starts to glow RED as blood.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The wight of a human noble appears to gain power from a sudden deadly chill around it.</name>
						<script>-- heal undead
sendFollowers()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) appears to gain power from a sudden deadly chill around it.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The wraith of a human noble is surrounded by an aura of deadly cold!</name>
						<script>-- coldshield
if groupList:ingroup(matches[2]) then
  buff:set(matches[2], "coldshield", 2*60)
else
  -- pet
  local name=pet:member(matches[2])

  if name then
    buff:set(name, "coldshield", 2*60)
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is surrounded by an aura of deadly cold!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The spectre of a human noble is now protected from undead!</name>
						<script>-- protection from undead
if groupList:ingroup(matches[2]) then
  buff:set(matches[2], "protection_from_undead", 6*60+2)
else
  -- pet
  local name=pet:member(matches[2])

  if name then
    buff:set(name, "protection_from_undead", 6*60+2)
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is now protected from undead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel natures blessing wrap around you like a safe, warm blanket.</name>
						<script>-- natures blessing

buff:set(whoami(), "natures_blessing", 13*60) -- 30 seconds extra</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel natures blessing wrap around you like a safe, warm blanket.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>PenaltyTriggers</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>penalty status</name>
						<script>-- should set status, not just send status

-- Azora is blinded by the burning sands!
-- Vomicopol tries to cleanse your body of impurities...
-- A carnivorous vine's pollen makes your eyes burn and water!  You can't see!
-- An elite gelugon's spear launches a bolt of frost at Gormal, encasing him in the freezing cold!

-- Vitality                  (  7:18)   sleep                     ( 54:00)   

if matches[2] == "your" or matches[2] == "Your" then
  sendStatus()
else
  if groupList:ingroup(matches[2]) then
    sendStatus(matches[2])
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) body turns to stone as a petralisk gazer stares .*</string>
							<string>([A-Za-z]+) ceases to move.. still and lifeless.</string>
							<string>([A-Za-z]+) suddenly looks speechless!</string>
							<string>([A-Za-z]+) seems to be blinded!</string>
							<string>.* cleanse ([A-Za-z]+)'s body of impurities...</string>
							<string>.* tries to dispel ([A-Za-z]+)'s magic!</string>
							<string>Some of (your) magic has been dispelled!</string>
							<string>([A-Za-z]+) body turns to stone as the dracolisk stares at .*</string>
							<string>([A-Za-z]+) staggers about blindly!</string>
							<string>([A-Za-z]+) goes to sleep.</string>
							<string>([A-Za-z]+) is blinded by .*</string>
							<string>([A-Za-z]+)  group-says '&lt;&lt; BLIND! &gt;&gt;'</string>
							<string>(Your) body turns to stone as a petralisk gazer stares at you!</string>
							<string>An elite gelugon's spear erupts in a spray of frost as he plunges it through ([A-Za-z]+)!</string>
							<string>([A-Za-z]+) is blinded by the deep black shadows!</string>
							<string>.* tries to cleanse (your) body of impurities...</string>
							<string>.* pollen makes (your) eyes burn and water!  You can't see!</string>
							<string>([A-Za-z]+) inhales the toxic gas and immediately ceases to move.</string>
							<string>([A-Za-z]+) stops moving as webs of ice crystalize about (?:his|her) body. </string>
							<string>([A-Za-z]+) tells you 'para.*'</string>
							<string>An elite gelugon's spear launches a bolt of frost at ([A-Za-z]+), encasing him in the freezing cold!</string>
							<string>An elite gelugon's spear launches a bolt of frost at ([A-Za-z]+), encasing her in the freezing cold!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are suddenly silenced!</name>
						<script>sendStatus()
spell:clear()

-- only dispel magic if caster or bard
if checkMask("caster") or checkMask("singer") then
  mud:send("quaff disp hole")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are suddenly silenced!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel your blood freezing in your veins!</name>
						<script>mud:send("gsay " .. whoami() .. "  &lt;&lt; FREEZING &gt;&gt; " .. prompt:get("hp") .. "/" .. prompt:get("maxhp") )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel your blood freezing in your veins!</string>
							<string>The poison burns in your veins, and you feel weaker.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You have been blinded!</name>
						<script>mud:send("gsay &lt;&lt; BLIND! &gt;&gt;" )

buff:set(whoami(), "blind", 600)

sendStatus()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^.*You have been blinded!$</string>
							<string>^You are blinded!$</string>
							<string>You are blinded.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Lobbole's vision is restored!</name>
						<script>buff:del(matches[2], "blind")
buff:del(matches[2], "blindness")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+)'s vision is restored!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your vision returns!</name>
						<script>-- chkstat


-- clear blind
buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")

group:send()

mud:send("@chkstat")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your vision returns!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You can see normally again!</name>
						<script>buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")

group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can see normally again!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel able to speak again!</name>
						<script>buff:del(whoami(), "silence")
buff:del(whoami(), "silence_person")
nomagic=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel able to speak again!</string>
							<string>You feel able to speak again.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The world stops spinning.</name>
						<script>-- no longer stunned
buff:del(whoami(), "stun")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world stops spinning.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Lilpekal looks MUCH healthier.</name>
						<script>-- Lilpekal looks MUCH healthier.
-- Misi looks MUCH healthier.

-- cure poison/venom
buff:del(matches[2], "poison")
buff:del(matches[2], "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) looks MUCH healthier.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A warm flush runs throughout your body as the toxins are neutralized.</name>
						<script>buff:del(whoami(), "poison")
buff:del(whoami(), "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A warm flush runs throughout your body as the toxins are neutralized.</string>
							<string>You feel much healthier as the toxins within are neutralized.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body becomes like stone as the paralyzation takes effect.</name>
						<script>-- You can't!  You're paralyzed to the bone.

buff:set(whoami(), "major_paralysis", 600)
spell:clear()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body becomes like stone as the paralyzation takes effect.</string>
							<string>A carnivorous vine reaches up and wraps itself about you, making it difficult to move, or even breathe!</string>
							<string>You wait mindlessly for direction from your master.</string>
							<string>Your body becomes rigid as the paralyzation takes effect.</string>
							<string>You remain paralyzed and can't do a thing to defend yourself...</string>
							<string>tail radiates freezing cold, causing your bones to lock up.</string>
							<string>leaving you near to death, numb, and barely concious.</string>
							<string>You are partially frozen by a dragonborn knight's icy breath!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are no longer attractive to pigeons.</name>
						<script>-- remove para
buff:set(whoami(), "major_paralysis", nil)
buff:set(whoami(), "minor_paralysis", nil)

sendStatus()

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are no longer attractive to pigeons.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>add venom</name>
						<script>-- Lilabipple writhes in agony.
--pupilless eyes glow bright red as its tail spur sinks into Kerishai's
--Kerishai shudders in pain, and looks very pale.


if groupList:ingroup(matches[2]) then
  buff:set(matches[2], "venom", 600)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) writhes in agony.</string>
							<string>(.*) shudders in pain, and looks very pale.</string>
							<string>pupilless eyes glow bright red as its tail spur sinks into (.*)i's</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You can't see a thing, you're blinded!</name>
						<script>buff:set(whoami(), "blind", 600)
look:set(nil)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can't see a thing, you're blinded!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your soul is transported to The Fugue Plane as your crumbling body succumbs</name>
					<script>--Your soul is transported to The Fugue Plane as your crumbling body succumbs

sound("165331__ani-music__tubular-bell-of-death.wav")

NyyLIB.active=nil

-- echo last known room information here

local lastRoom = map:getRoom()

--display( lastRoom )


-- set room to fugue
map:setRoom(93848)
centerview( map:getRoom() )

-- Remove all buffs on death
buff:del(whoami())

NyyLIB.escapedir = nil
NyyLIB.roguereturn = nil

-- Reset size
charData:set("bodysize", whosize() )
setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")

-- Clear train mem variable

NyyLIB.castertrain=nil

-- Clear memorized spells

-- store hbl

local hbl=getSpellCount("harmonious_blessing")

resetSpellCount()

setSpellCount("harmonious_blessing", hbl)

-- assign an arbitrary memcount

charData:set("memcount", 25)

-- Not casting

spell:clear()

group:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your soul is transported to The Fugue Plane as your crumbling body succumbs.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture powername</name>
					<script>NyyLIB.powersname= matches[2]:trim()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Name             : ([A-Za-z ]+) \[.*\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Change powers durations</name>
					<script>--   armor=1200, 
--   haste=324, 
--   dragonscales=360,
--   blur=202,  
--   globe_of_invulnerability=324,
--   displace=1200,
--   time_stop=175,
--   stoneskin=240,
--   elemental_ward=180


-- Target Effect    : Add globe of invulnerability for 4 minutes 


-- Target Effect    : Modify hitpoints by 254 for 8 minutes 40 seconds 2 pulses  
-- vit - will also show on other powers
--local num

--num = tonumber(matches[2])*60 + tonumber(matches[3])

local num=0

if tonumber(matches[2]) then
  num=tonumber(matches[2])*60
end

if tonumber(matches[3]) then
  num=num+ tonumber(matches[3])
end

if NyyLIB.powersname ~= nil then
  power:set( to_snake(NyyLIB.powersname), num )
else
  echo("Powersname is nil\n")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Target Effect    : Modify hitpoints by [0-9]+ for ([0-9]+) minutes ([0-9]+) seconds ([0-9]+) pulses</string>
						<string>Target Effect    : Modify hitpoints by [0-9]+ for ([0-9]+) minutes ([0-9]+) seconds </string>
						<string>Target Effect    : Add globe of invulnerability for ([0-9]+) minutes ?([0-9]+)? ?(seconds)?</string>
						<string>Target Effect    : Add haste for ([0-9]+) minutes ([0-9]+) seconds</string>
						<string>Self Effect      : Add time stop for ([0-9]+) minutes ([0-9]+) seconds</string>
						<string>Target Effect    : Modify target hitroll by -33 for ([0-9]+) minutes ([0-9]+) seconds</string>
						<string>Target Effect    : Add stoneskin for ([0-9]+) minutes ?([0-9]+)? ?(seconds)?</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>StatusGroup</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Status of Bonble</name>
					<script>sendingStatus = false

local charname = matches[2]

-- pet:isNamed(xnamelist)

if pet:isNamed(charname) then
  charname = pet:isNamed(charname)
end

if groupList:ingroup(charname) or pet:isNamed(charname) then
  NyyLIB.statuschar = charname

  local duration=buff:get("healing_aura", charname)

  -- include healing aura
  if duration then
    buff:del(charname)
    buff:set(charname, "healing_aura", duration)
  else
    buff:del(charname)
  end
end

if not showstatus then
  enableTrigger("gagstatus")
end

enableTrigger("endstatusgag")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Status of (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capturestatus</name>
					<script>local min, sec, dur

--display(NyyLIB.statuschar)

if NyyLIB.statuschar ~= "" then
  min=tonumber(matches[3])
  sec=tonumber(matches[4])

  if sec == 0 then
    dur=min*60+NyyLIB.ticktimer
  else
    dur=min*60+sec
  end

  -- TODO
  -- Nyth Flare                (  0:24)
  --if to_snake(matches[2]) == "nyth_flare" then
    -- blind
  --end

  buff:set(NyyLIB.statuschar, to_snake(matches[2]), dur)

  if matches[5] ~= nil then
    min=tonumber(matches[7])
    sec=tonumber(matches[8])

    if sec == 0 then
      dur=min*60+NyyLIB.ticktimer
    else
      dur=min*60+sec
    end

    buff:set(NyyLIB.statuschar, to_snake(matches[6]), dur)

  end

  if not showstatus then
    eraseLine()
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z ]+) +\([ ]*([0-9]+):([0-9]+)\)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endstatusgag</name>
					<script>-- this trigger must be located above the gagstatus trigger

disableTrigger("gagstatus")
disableTrigger("endstatusgag")
showstatus=false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt; .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>gagstatus</name>
					<script>--
eraseLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>effects</name>
					<script>--Status of Innanin
---------------------------------------------------------------------------

--Effects
---------------------------------------------------------------------------
--haste                     hide                      infravision               
--no summon                 protection from evil      sense life                
--slow poison               sneak          </script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Effects$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>effect: hide</name>
					<script>setHide(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>   hide                      </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>There are no active status effects.</name>
					<script>if command == "STATUS " then
  buff:del(whoami())
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>There are no active status effects.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>SplitClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>lootlist</name>
					<script>-- add to list

table.insert(NyyLIB.groupitems, 1, matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[ ]+(.+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The following items exist in the group cache for</name>
					<script>NyyLIB.groupitems = {}
enableTrigger("lootlist")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The following items exist in the group cache for</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>acceptbid</name>
					<script>-- need to improve itename capture (bid on, please, no bid, etc)

local biditem=string.lower(string.trim(matches[3]))

-- confirm valid bidder
for nx=1, #NyyLIB.validbidders, 1 do
  if NyyLIB.validbidders[nx]:lower() ==
     string.lower(matches[2]) then
    expandAlias("@bid add " .. matches[2] .. " " .. biditem, false)
    return
  end
end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) tells you 'bid (.*)'</string>
						<string>([A-Za-z]+) tells you '(abstain)'</string>
						<string>([A-Za-z]+) tells you '([A-Za-z]+)'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>acceptdice</name>
					<script>local dice, name

name = multimatches[1][2]
dice = multimatches[5][4]:trim()

if name == "You" then
  name = whoami()
end

if NyyLIB.trackbid ~= nil then
  if NyyLIB.trackbid[name] == 0 then
    expandAlias("@adddice " .. name .. " " .. dice, false)
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile>C:/Users/Chris/.config/mudlet/profiles/toril 006/NyyLIB.006/beep.wav</mSoundFile>
					<colorTriggerFgColor>#0000ff</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) group.* '</string>
						<string>FG13BG2</string>
						<string>I've rolled a 100 sided dice 1 times, the total result is:</string>
						<string>FG9BG0</string>
						<string>([ 0-9]+)'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>6</integer>
						<integer>0</integer>
						<integer>6</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Mounted</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your mount rises up on its hind legs at lets forth a baleful howl!</name>
					<script>timer:set("howlcd", 7)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your mount rises up on its hind legs at lets forth a baleful howl!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>A massive snarling dire wolf answers your summons!</name>
					<script>mount:set( "mount" )</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A massive snarling dire (wolf) answers your summons!</string>
						<string>A hell (hound) answers your summons!</string>
						<string>A heavy (warhorse) answers your summons!</string>
						<string>A zealous (griffon) answers your summons!</string>
						<string>answers your summons!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your mount misses Elaith Waterstill with its charge!</name>
					<script>setBashing(false)

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your mount misses .* with its charge!</string>
						<string>Your mount charges .* and .*</string>
						<string>Your mount refuses to trample!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Remount in combat</name>
					<script>--display("set dismounted")

dismounted = true

if mount:get() then
  mud:send("mount")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You lose your balance and are dismounted.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>summon return</name>
					<script>mount:set(nil)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your mount gently nuzzles your hand before trotting away and disappearing.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mount</name>
					<script>-- You climb on and ride A heavy warhorse.
-- You climb on and ride a hell hound.
-- You skillfully climb on and ride A heavy warhorse in the midst of battle.
-- You climb on and ride a pack pony.

if not checkMask("mountedCombat") then
  return
end

local fname="MountDismount"
local label=findlabel(fname)

if label ~= nil then
  setLabelImage(fname, "dismount.png")
end

if mount:get() == nil then
  mount:set("unknown")
end

mount:setMounted(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You skillfully climb on and ride (.*) in the midst of battle.</string>
						<string>You climb on and ride (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dismount</name>
					<script>-- You dismount A heavy warhorse.
-- You dismount a hell hound.
-- You stop riding a hell hound.

--Your mount heads south, and you head for the ground!
--You fall to the ground.  You stop riding.


if not checkMask("mountedCombat") then
  return
end

local fname="MountDismount"
local label=findlabel(fname)

if label ~= nil then
  setLabelImage(fname, "mount.png")
end

-- was dismounted
if dismounted==true then
  return
end

mount:setMounted(false)
setBashing(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You dismount</string>
						<string>You stop riding</string>
						<string>You fall to the ground.  You stop riding.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You would bash your brains out on the roof, better dismount.</name>
					<script>-- failed movement

--Nurpy flies south.
--You follow Nurpy south.
--
--You would bash your brains out on the roof, better dismount.

mud:send("dismount")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You would bash your brains out on the roof, better dismount.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You maneuver your wolf to outflank Shalyssa Lurialar!</name>
					<script>timer:set("outflankcd", 6)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You maneuver your wolf to outflank</string>
						<string>You fail to outflank</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>BOT</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>WaterXP</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A sea elf adventurer swims here.</name>
						<script>echo("adventurer found\n")
NyyLIB.bots.advfound=1

display("Adventurer:" )

NyyLIB.bots.advposition = map:getRoom()

display( map:getRoom() )

-- mud:send("give pearl adventurer")
-- expandAlias("@fwalk 86308")

--#COLOR red</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A sea elf adventurer swims here.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Exits: -N -E -S -W -U -D</name>
						<script>-- room movement
NyyLIB.bots.position = NyyLIB.bots.position or 0


NyyLIB.bots.position = NyyLIB.bots.position+1</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Exits: -N -E -S -W -U -D</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You snap your fingers.</name>
						<script>NyyLIB.bots.position=0

if NyyLIB.bots.advposition == 0 then
  NyyLIB.bots.xval=NyyLIB.bots.xval+1

  if NyyLIB.bots.xval ~= 6 then
    expandAlias(".e5n")
    mud:send("snap")
  else
    NyyLIB.bots.xval=0
    NyyLIB.bots.yval=NyyLIB.bots.yval+1

    if NyyLIB.bots.yval ~= 3 then
      expandAlias(".d5n")
      mud:send("snap")
    end
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You snap your fingers.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You get a near-perfect pearl from corpse of a marid farmer.</name>
						<script>expandAlias("@fwalk 86308")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You get a near-perfect pearl from corpse of a marid farmer.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TM_Mochanokul</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Banzai! 
To the rescue...</name>
						<script>if prompt:get("enemycondition") ~= "awful" then
  mud:send("tug suit")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Banzai! To the rescue...</string>
							<string>Mochanokul fails miserably in his attempt to rescue you.</string>
							<string>Mochanokul rises to his feet.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A fiery spark blazes about, forming a large pillar for flame.</name>
						<script>-- restart, 3min wait

setBashing(false)
rescueSent=false
NyyLIB.damaged = false

function startspark()
  mud:send("kill spark")
  mud:send("tug suit")
  --mud:send("shieldpunch")
end

tempTimer(180, startspark)

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A fiery spark blazes about, forming a large pillar for flame.</string>
							<string>a fiery spark is dead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CMShadows</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You switch opponents!</name>
						<script>mud:send("kill 2.shadow")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You switch opponents!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are already fighting them!</name>
						<script>mud:send("kill 1.shadow")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are already fighting them!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You try to switch opponents, but you become confused!</name>
						<script>mud:send("kill 3.shadow")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You try to switch opponents, but you become confused!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You strike out wildly about the area in a mighty burst of power!
You critically wound a shadow with a powerful bludgeon!</name>
						<script>function starthit()
  mud:send("hitall")
end

mud:send("kill 4.shadow")

tempTimer(20, starthit)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You strike out wildly about the area in a mighty burst of power!</string>
							<string>You are too disoriented to hitall again!</string>
							<string>You failed to strike any targets!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Zurg</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wooden bucket rests here, filled with water.</name>
						<script>for k,v in pairs(NyyLIB.buckets) do
  if v == map:getRoom() then
    return
  end
end

table.insert(NyyLIB.buckets, 1, map:getRoom() )

echo("\n[Found bucket in room: " .. map:getRoom() .. "]\n")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wooden bucket rests here, filled with water.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SMTrain</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>trainstation</name>
						<script>testnum = testnum or 0

local currentroom = map:getRoom()

if currentroom == NyyLIB.nextstop then
  disableTrigger("trainstation")

  if NyyLIB.smtrainposition == nil then
    if getPath(currentroom, 48603) then
      
      if not silent then
        mud:send("gsay Stopping train and returning to inn (48603)" .. " &lt;." .. compressSpeedwalk() .. "&gt;" )
      end
      
      expandAlias("@fwalk 48603", false)
    else
      if not silent then
        mud:send("gsay Ending train" )
      end
    end

    disableTrigger("SMTrain")
  else
    local stopname=NyyLIB.smtrainstops[NyyLIB.smtrainposition][2]

    cecho("\n\n&lt;cyan&gt;[Reached train station: &lt;green&gt;(" .. currentroom .. ")&lt;cyan&gt; " .. stopname .. "]\n\n")

    if _G[stopname] ~= nil then
      cecho("&lt;cyan&gt;[Calling function: " .. stopname .. "]\n")
      _G[stopname]()
      tempTimer(2, [[NextTrainStop()]])
    else
      if not pcharsInRoom then
        mud:send("glance " .. string.split(stopname, " ")[1] )
        tempTimer(2, [[StartFight()]])
      else
        cecho("&lt;red&gt;[Players in room - Moving to next station]\n")
        NextTrainStop()
      end
    end
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>&gt;\t\n</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>checkhealth</name>
						<script>if matches[2] == "You don't see that here." then
--  cecho("\n&lt;red&gt;[Target is already dead.]\n")
else
  NyyLIB.traintarget=true
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) is in an excellent condition.</string>
							<string>(You don't see that here.)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>(.*) is dead! R.I.P. ^Your blood freezes as you hear the rattling death cry of (.*)[.]</name>
						<script>-- An Ashstone holyman utters a single word and disappears.

if matches[2] == "an onyx dagger with a pulsing ruby hilt" then
  return
end

if matches[2] == "an emerald and ruby encrusted dagger" then
  return
end

if _G["NextTrainStop"] == nil then
  expandAlias("@resettrain", false)
  return
end

--display(fwalkQue)
--display(NyyLIB.smtrainposition)

if NyyLIB.smtrainposition == nil then
  -- end train / return to bank
  NyyLIB.trainecho=0
  tempTimer(5, [[NextTrainStop()]])
else
  if map:getRoom() ~= NyyLIB.smtrainstops[NyyLIB.smtrainposition][1] then
    -- current room isn't expected room - this happens if a kill occurs right when you path through a room
    NyyLIB.traintarget=false

    --cecho("\n&lt;red&gt;[Error: Current room isn't expected room]\n")
    --cecho("&lt;red&gt;[map:getRoom() " .. map:getRoom() .. "]\n")
    --cecho("&lt;red&gt;[NyyLIB.nextstop " .. NyyLIB.nextstop .. "]\n")
    --cecho("&lt;red&gt;[NyyLIB.smtrainposition " .. NyyLIB.smtrainposition .. "]\n")

    -- If an fwalk was already sent, don't send another
    if not fwalkQue and map:countMovement() == 0 then
        fwalkQue=true
        echoDebug("&lt;red&gt;[Queuing fwalk to " .. NyyLIB.nextstop .. "]\n")
        tempTimer(5, [[expandAlias("@fwalk " .. NyyLIB.nextstop)]])
    end
  else
    NyyLIB.trainecho=0

    if callNextTrain == nil then
      callNextTrain=true
      look:send()
      cecho("&lt;red&gt;\n\n[Calling function: NextTrainStop()]\n")

      -- Suggested by Vooku - only 3 second delay if no followers
      if groupList:size() &gt; 1 then
        tempTimer(6, [[NextTrainStop()]])
      else
        tempTimer(3, [[NextTrainStop()]])
      end
    end
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your blood freezes as you hear the rattling death cry of (.*)[.]</string>
							<string>No target for your power could be found!</string>
							<string>They're not here!</string>
							<string>I don't see that person here.</string>
							<string>You don't see them here!</string>
							<string>.* utters a single word and disappears.</string>
							<string>^(?:&lt; .* &gt; )?(.*) is dead! R.I.P.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>EC: nasty wounds</name>
						<script>local xname=string.lower(matches[2])

if NyyLIB.smtrainposition == nil then
  return
end

local xtarget=string.lower(NyyLIB.smtrainstops[NyyLIB.smtrainposition][2])

-- TODO need to capitalize all words in name, not just first

if NyyLIB.trainecho ~= 1 then
  if string.findPattern(xtarget, xname) then
--  if string.split(NyyLIB.smtrainstops[NyyLIB.smtrainposition][2], " ")[1] == string.title(matches[2]) then
    NyyLIB.trainecho=1
--    send("gcmd [" .. string.title(xtarget) .. " has nasty wounds!]")


    local str = NyyLIB.smtrainstops[NyyLIB.smtrainposition][2]
    local nextmob = string.gsub(" "..str, "%W%l", string.upper):sub(2)

    if not silent then
      mud:send("gcmd [" .. nextmob .. " has nasty wounds!]")
    end
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>E: (.*) EC: nasty wounds</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Purniel group-says 'stats reset'</name>
						<script>NyyLIB.stats={}
mud:send("gcmd [Resetting Stats]")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* group-(say|project)[s]? 'stats reset'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Purniel group-says 'stats display''</name>
						<script>printStats(3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* group-(say|project)[s]? 'stats display'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ssassav gets a small pile of coins from corpse of Ersenas.</name>
						<script>local charname=matches[2]

if groupList:ingroup(charname) then
  mud:send("gsay looting from " .. whoami() .. " bad! bad " .. charname .. "!" )
  mud:send("FOLLOWERS pause " .. charname)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) gets a small pile of coins from corpse of .*</string>
							<string>([A-Za-z]+) gets something from corpse.</string>
							<string>([A-Za-z]+) gets a few coins from corpse.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>a human paladin is dead! R.I.P.</name>
						<script>if getPath(map:getRoom(), NyyLIB.nextstop) then
  mud:send("gcmd Moving to: " .. NyyLIB.smtrainstops[NyyLIB.smtrainposition][2] ..
              " (" .. NyyLIB.smtrainstops[NyyLIB.smtrainposition][1] .. ") " ..
               " &lt;." .. compressSpeedwalk() .. "&gt;")
  
  NyyLIB.traintarget=false

  expandAlias("@fwalk " .. NyyLIB.nextstop)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^a human paladin is dead! R.I.P.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A mage in the Spellguard clambers to her feet.</name>
						<script>sendBash("spellguard")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A mage in the Spellguard clambers to her feet.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Aratha Sul is dead! R.I.P.</name>
						<script>mud:send("get lucky corpse")
mud:send( p("lucky") )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Aratha Sul is dead! R.I.P.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dismount on xp</name>
						<script>if mount:getMounted() then
  mud:send("dismount")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You receive .* XP .* experience.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your mount refuses to trample</name>
						<script>mount:charge( getEnemy() )
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your mount refuses to trample!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>newroom</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>botRoomCapture</name>
							<script>-- location matters on this trigger to prevent double firing

-- terminate capture on blank line
if matches[1] == "" then
  disableTrigger("botRoomCapture")
  return
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^.*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>^Exits: .*</name>
							<script>-- new room entered

enableTrigger("botRoomCapture")

pcharsInRoom = false</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^Exits: .*</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>player in room</name>
							<script>-- Waf  (RP) (Barbarian) stands in mid-air here, fighting A burly bouncer.
-- Rahar  (Shield Dwarf) hovers in mid-air here, fighting Elaith Waterstill.

-- Cyre Tahl'Veras the Huntsman of Ashen Lorenthal (Moon Elf) stands here.
-- Newple -=Manx=- - Pride of the Sabertooth (Halfling) stands here.

-- Tutenef  (Human) hulks here.
-- Trenik  (RP) (Human) oozes here.
-- Trenik  (RP) (Human) blazes in mid-air here.
-- Trenik  (RP) (Human) oozes in mid-air here.

if inwho(matches[2]) then
  pcharsInRoom=true
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([A-Z][a-z]+) .* (sits|stands|hovers|oozes|blazes|hulks) .*[.]</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>petition disable</name>
						<script>-- Suggestion from @Afu

mud:send("@stoptrain")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )responds to your petition with (.*)</string>
							<string>^(?:&lt; .* &gt; )?(.* )responds to your group with (.*)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>PsiBomb</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wispy smoke colored portal hovers just above the center of the room.</name>
						<script>if NyyLIB.psibomb ~= true then
  NyyLIB.psibomb = true
  mud:send("enter portal")
  mud:send("enter hole")
  mud:send("enter rift")
  mud:send(".uw")
  mud:send("ultra 2.drake")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wispy smoke colored portal hovers just above the center of the room.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are dead!</name>
						<script>NyyLIB.psibomb=false</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are dead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You do not have enough psp's to project that.</name>
						<script>-- disable trigger set
disableTrigger("PsiBomb")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You do not have enough psp's to project that.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Bel</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>It seems to be locked.</name>
						<script>belcount = belcount or 0

belcount = belcount + 1

mud:send("open door")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>It seems to be locked.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The door SLAMS shut and locks with a heavy thud.</name>
						<script>belcount=0

mud:send("GSAY door is closed!")
mud:send("ST")
mud:send("OPEN door")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The door SLAMS shut and locks with a heavy thud.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ok.</name>
						<script>belcount = belcount or 0

mud:send("gsay &lt;&lt;&lt; The door is open! After " .. belcount .. " attempts! &gt;&gt;&gt;")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Ok.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SMTrainCaster</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Tuw group-says 'Attacking: Forell'</name>
						<script>-- only do this if not already in combat
if not inCombat() and assistSent == nil then
  local nextroom = NyyLIB.nextroomstop or map:getRoom()

  -- move to correct room if lost

  if nextroom ~= map:getRoom() then
    expandAlias("@fwalk " .. nextroom)  
  else
    fleeMem()
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says 'Attacking: .*</string>
							<string>([A-Za-z]+) group-says 'Killing .*</string>
							<string>([A-Za-z]+) group-says '\[Attacking: .*</string>
							<string>([A-Za-z]+) group-says 'Going on .*</string>
							<string>(Entetee) is ENRAGED!</string>
							<string>([A-Za-z]+) group-says 'Target .*</string>
							<string>([A-Za-z]+) .* resulting in some strange noises and some blood.</string>
							<string>([A-Za-z]+) group-says 'bash .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You flee downward!</name>
						<script>if NyyLIB.castertrain then
  NyyLIB.castertrain = matches[2]

  mud:send("pray", false)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You flee ([nsewud]).*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>finish mem/pray return to fight</name>
						<script>fightreturn=true

if NyyLIB.castertrain ~= nil then
  mud:send("ST")

  if NyyLIB.reversedirs[NyyLIB.castertrain] == nil then
    cecho("\n&lt;red&gt;[Error: unknown direction to return to fight]\n")
    display(NyyLIB.castertrain)
    mud:send("ST")
    NyyLIB.casterttrain=nil
    return
  end

  expandAlias(NyyLIB.reversedirs[NyyLIB.castertrain], false)
  NyyLIB.castertrain=nil
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your prayers are complete.$</string>
							<string>.* group-says '.* has nasty wounds.*</string>
							<string>.* group-says '.* is -=Nasty Wounds=-'</string>
							<string>.* group-says '.* is -=P-Hurt=-'</string>
							<string>.* group-says 'ph'</string>
							<string>.* group-says '.* is pretty hurt and will die soon.'</string>
							<string>.* group-says '.* is not lookin good, Nasty!'</string>
							<string>Who can concentrate with all that clanging and screaming?</string>
							<string>.* group-says '.*  - pretty hurt -'</string>
							<string>But you don't have any spells in your thoughts!</string>
							<string>You can't concentrate with all the racket!</string>
							<string>Your studies are complete.</string>
							<string>.* group-says '.* has some nasty wounds!'</string>
							<string>.* group-says '.* is doomed!! \(Nasty Wounds\)'</string>
							<string>Our enemy will join Kelemvor soon.(pretty hurt)</string>
							<string>Hoppil group-says '.. Pretty Hurt'</string>
							<string>Your skin crawls as you hear a death cry nearby!</string>
							<string>.* in the afterlife!! \(Pretty Hurt\)'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>(.*) is dead! R.I.P.</name>
						<script>spell:clear()

fightreturn=false
NyyLIB.castertrain=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is dead! R.I.P.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Harlindrel group-says 'Moving to: Lavis Ryl (48524)  &lt;.sen&gt;'</name>
						<script>-- Harlindrel group-says 'Moving to: Ultrumm (49135)  &lt;.2e5s5w3nu&gt;'

NyyLIB.castertrain=nil

NyyLIB.nextroomstop = tonumber(matches[2])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* group-says .*Moving to: .* \(([0-9]+)\).*&lt;.*&gt;.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>^Your blood freezes as you hear the rattling death cry of (.*)[.]</name>
						<script>if mount:get() then
  mud:send("dismount")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your blood freezes as you hear the rattling death cry of (.*)[.]</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CPNoble</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You get a signet ring from corpse of a Calimport noble.</name>
						<script>mud:send("put signet hole")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You get a signet ring from corpse of a Calimport noble.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A Calimport noble stands here arrogantly.</name>
						<script>sendBash("noble")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A Calimport noble stands here arrogantly.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>AutoPortal</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Sarrshis enters a blood-red portal and disappears among the mist.</name>
						<script>-- Bubbinople enters a planar vortex and disappears among the mist.

-- a humming portal of violet mist suddenly glows brightly!
-- Pidibeple slowly fades out of existence.

-- Ezarak enters a rainbow colored portal and disappears among the mist.

-- todo
-- Atraz utters the words, 'uizuguburuhl'.
-- The ghost of a huge air elemental utters the words, 'invisibility'.
-- if previous line = invis

-- if more people have entered portal then warriors in group, enter portal

local charname = matches[2]
local portalname = matches[3]

enteredPortal = enteredPortal or {}


if groupList:ingroup(charname) and charData:get("autoportal") then
  enteredPortal[charname] = "entered"

  -- return if &lt; 6 people in group, or no warriors
  if groupList:size() &lt; 6 or #(groupList:pc("warrior")) == 0 or alreadyEnteredPortal then
    return
  end

  if table.size(enteredPortal) &gt; #(groupList:pc("warrior")) then
    enteredPortal={}

    alreadyEnteredPortal=true

    spell:clear()

    mud:send("ST")

    if portalname == "fades" then
    -- special exit or invis

      if map:getRoom() ~= nil then
        local specialexit = getSpecialExitsSwap( map:getRoom() )

        -- TODO: why only use if 1 exit?

        if table.size(specialexit) == 1 then
          for k,v in pairs(specialexit) do
            if mount:getMounted() then
              mud:send("dismount")
            end

            local exitcmd=string.split(k, "|")[1]

            if pet:status() or mount:get() ~= nil then
              mud:send("ORDER followers " .. exitcmd)
            end

            cecho("\n&lt;green&gt;[Using special exit '&lt;cyan&gt;" .. exitcmd .. "&lt;green&gt;' to room &lt;cyan&gt;" .. v .. " : " .. getRoomName(v) .. "&lt;green&gt;]\n")

            map:processMovement(exitcmd)
            --mud:send (exitcmd)
          end
        end
      end
    else
      if mount:getMounted() then
        mud:send("dismount")
      end

      if pet:status() or mount:get() ~= nil then
        mud:send("ORDER followers enter " .. portalname)
      end
      
      mud:send("enter " .. portalname)
    end

    look:send()
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) enters a blood-red (portal) and disappears among the mist.</string>
							<string>([A-Za-z]+) enters a planar (rift) and disappears among the mist.</string>
							<string>([A-Za-z]+) enters a (wormhole) and disappears among the darkness.</string>
							<string>([A-Za-z]+) enters a rainbow colored (portal) and disappears among the mist.</string>
							<string>([A-Za-z]+) slowly (fades) out of existence.</string>
							<string>([A-Za-z]+) enters a (moonwell) and disappears among the mist.</string>
							<string>([A-Za-z]+) enters the dimensional (fold) and reappears elsewhere...</string>
							<string>([A-Za-z]+) enters a planar (vortex) and disappears among the mist.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>AutoMem</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ozzec opens an ancient tome and begins studying it intently.</name>
						<script>-- mem started ingroup
automem = automem or 0

if groupList:ingroup(matches[2]) then
  automem = automem + 1

  if automem &gt;= 2 then
    spell:setMoving(false)
  end

  echoDebug("\n&lt;red&gt;[+1 automem " .. automem .. " memcount " .. charData:get("memcount") .. "\n")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) opens an ancient tome and begins studying it intently.</string>
							<string>([A-Za-z]+) takes out (his|her) holy symbol and begins praying intently.</string>
							<string>([A-Za-z]+) takes out (his|her) holy symbol and begins praying intently</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Sorry, you aren't allowed to do that in combat.</name>
						<script>automem=0</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Sorry, you aren't allowed to do that in combat.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>AutoAssist</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Autoassist - barely wounds</name>
					<script>-- ^(.+) attacks .*
-- .* attacks (.+), landing .*

-- The spectre of a human noble barely wounds a human noble with its average drain.
-- The spectre of a human noble misses a human noble with its drain.
-- The spectre of a human noble barely wounds a human noble with its average drain.

-- triggered by combat occuring in same room

-- A hamatula sentinel stands here, fighting Nimasho. .+, fighting ([A-Z][a-z]+)[.]$
--Smirn  (RP) (Halfling) stands here, fighting an elite gelugon.
--Gurkz  (Barbarian) stands in mid-air here, fighting an elite gelugon.
-- Valeznik  (Duergar) stands here, fighting a dusty unseelie sprite.

local testname= matches[2]

if testname == whoami() then
  return
end

--display(testname)

if charData:get("autoassist") then
  if groupList:ingroup(testname) then
    if not inCombat() and groupList:getTanking(whoami()) == 0 then
      --display(testname)
      if testname ~= whoami() then
        sendAssist(testname)
      end

      -- Send assist if ungrouped pet following self

      testname = pet:member(testname)

      if testname then
        sendAssist(testname)
      end
    end
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.+) barely wounds .* with .*</string>
						<string>^(.+) attack only grazes .*</string>
						<string>^(.+) slams .* shield into .*</string>
						<string>.* attacks (.+), landing .*</string>
						<string>^(.+) sends .* sprawling with a powerful bash.</string>
						<string>^([A-Za-z]+) tried to backstab.*</string>
						<string>^([A-Za-z]+) places .* in the back of.*</string>
						<string>.* assists (.+) heroically.$</string>
						<string>^(.+) sends a powerful force missile slamming into .*</string>
						<string>^(.+) heroically rescues.*</string>
						<string>^(.+) does an acrobatic maneuver in battle, and trips up .*</string>
						<string>^(.+) dodges .*</string>
						<string>^(.+) misses .* with .*</string>
						<string>^(.+) attacks .*</string>
						<string>^([A-Z][a-z]+) .+, fighting .+$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>assist sent</name>
					<script>-- failed assist attempts

assistSent=nil
look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are already fighting them!</string>
						<string>Assist whom?</string>
						<string>That person is not fighting anyone.</string>
						<string>You can't see who is fighting</string>
						<string>You stumble and miss your attack!</string>
						<string>Maybe you should get on your feet first?</string>
						<string>You can't get to</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Counters</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>successful rescues</name>
					<script>-- You are rescued by Atorax, you are confused, but grateful!

if matches[2] == "Banzai" then
  addStat(whoami(), "successrescue")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "successrescue")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(Banzai)! To the rescue...</string>
						<string>([A-Za-z]+) heroically rescues .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>failed rescues</name>
					<script>-- Atorax fails miserably in his attempt to rescue you.

if matches[2] == "You" then
  addStat(whoami(), "failedrescue")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "failedrescue")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) fail the rescue.</string>
						<string>([A-Za-z]+) futilely tries to rescue .*</string>
						<string>([A-Za-z]+) fails miserably in .* attempt to rescue you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defShieldGlance (all)</name>
					<script>-- Ersenas's attack glances off your shield, but finds its mark!
-- Wobb partially blocks a githyanki patrol leader's attack with her shield!


-- there will still be a hit

if matches[2] == "your" then
  addStat(whoami(), "defShieldGlance")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "defShieldGlance")
  end
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* glances off (your) shield, but finds its mark!</string>
						<string>([A-Za-z]+)  partially blocks .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>STR: 100  AGI: 116  DEX:  83  CON: 106</name>
					<script>NyyLIB.str=matches[2]
NyyLIB.agi=matches[3]
NyyLIB.dex=matches[4]
NyyLIB.con=matches[4]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>STR: +([0-9]+) +AGI: +([0-9]+) +DEX: +([0-9]+) +CON: +([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Armor Class: -100  (100 to -100)  Agility Bonus: -10</name>
					<script>NyyLIB.agibonus=matches[2]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*\(100 to -100\)  Agility Bonus: -([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Hitroll: 44   Damroll: 29</name>
					<script>NyyLIB.hitroll=matches[2]
NyyLIB.damroll=matches[3]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Hitroll: ([0-9]+) *Damroll: ([0-9]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offParryPartial (all)</name>
					<script>-- A draconian warrior partially deflects Misi's lunge at it.

if matches[2] == "your" then
  addStat(whoami(), "offParryPartial")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offParryPartial")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* partially deflects ([A-Za-z]+)'s lunge.*</string>
						<string>.* partially deflects (your) lunge at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offDeflect (all)</name>
					<script>-- Tarthilmor Aerasume deflects your blow, and strikes back at YOU!
-- A githyanki captain deflects Lorle's blow, and strikes back at Lorle!

if matches[2] == "your" then
  addStat(whoami(), "offDeflect")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offDeflect")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* deflects (your) blow, and strikes back at YOU!</string>
						<string>.* deflects ([A-Za-z]+)'s blow, and strikes back at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defWeaponDeflect (all)</name>
					<script>-- You deflect Willa O'Greensleeves's blow, and strike back at Willa O'Greensleeves! (riposte)
-- Oggsk deflects an elite snow elf warrior's blow, and strikes back at an elite snow elf warrior!

if matches[2] == "You" then
  addStat(whoami(), "defWeaponDeflect")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "defWeaponDeflect")
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) deflect.* </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defGraze (all)</name>
					<script>if matches[2] == "you" then
  addStat(whoami(), "defGraze")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "defGraze")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* attack only grazes ([A-Za-z]+) as .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defDodge (all)</name>
					<script>-- Uggub dodges a dapper noble's attack.

if matches[2] == "You" then
  addStat(whoami(), "defDodge")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "defDodge")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) dodge .*</string>
						<string>([A-Za-z]+) dodges .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defHit - through my defenses</name>
					<script>-- hit through my defense
if matches[2] == "you" then
  addStat(whoami(), "defHit")
else
  if groupList:ingroup(matches[2]) then
    addStat(whoami(), "defHit")
    
    -- TODO: this group probably be removed (for barely, at least)
    group:send()
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>barely wounds ([A-Za-z]+)</string>
						<string>slightly wounds ([A-Za-z]+)</string>
						<string>badly wounds ([A-Za-z]+)</string>
						<string>You stagger from</string>
						<string>wounds ([A-Za-z]+) harshly </string>
						<string>severely wounds ([A-Za-z]+)</string>
						<string>critically wounds ([A-Za-z]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offMissed - missed attack (all)</name>
					<script>if matches[2] == "You" then
  addStat(whoami(), "offMiss")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offMiss")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) miss .* with .*</string>
						<string>^([A-Za-z]+) misses .* with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offHit - me</name>
					<script>-- Your weak hit barely wounds a massive turnip.


-- Elaith Waterstill staggers from your massive slash!
-- You enshroud Lavis Ryl in a mist of blood with your massive slash!
-- Lavis Ryl is nearly slain by the force of your massive slash!
-- Your final slash sends Lavis Ryl's head bouncing along the ground.

-- Seipora Rein is nearly slain by the force of your massive bludgeon!
-- You cave in Seipora Rein's chest, she dies rather quickly.
-- You crushed Forell Luckaun's skull, I'm afraid he's dead.

-- hit
addStat(whoami(), "offHit")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your awesome .*</string>
						<string>^Your strong .*.</string>
						<string>^Your mighty .*.</string>
						<string>^Your powerful .*.</string>
						<string>^Your massive .*.</string>
						<string>^Your average .*.</string>
						<string>^You enshroud .*</string>
						<string> .* is nearly slain by the force of your .*</string>
						<string>^You critically wound .*</string>
						<string>^Your weak hit .*</string>
						<string>.* staggers from your massive .*[!]</string>
						<string>^Your final .* sends .* head bouncing along the ground.</string>
						<string>^You cave in .* chest, .* dies rather quickly.</string>
						<string>^You crushed .*[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offHit - other</name>
					<script>-- Yugguk barely wounds Forell Luckaun with his powerful slash.

if groupList:ingroup(matches[2]) then
  addStat(matches[2], "offHit")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) barely wounds .*</string>
						<string>^([A-Za-z]+) critically wounds .*</string>
						<string>^([A-Za-z]+) wounds .*</string>
						<string>^([A-Za-z]+) enshrouds .*</string>
						<string>^([A-Za-z]+) slightly wounds .*</string>
						<string>^([A-Za-z]+) brutally wounds .*</string>
						<string>^([A-Za-z]+) severely wounds .*</string>
						<string>^.* staggers from ([A-Za-z]+)'s awesome .*</string>
						<string>^.* is nearly slain by the force of ([A-Za-z]+)'s .*</string>
						<string>^.* is slashed into two by a masterly stroke performed by ([A-Za-z]+).</string>
						<string>^([A-Za-z]+) badly wounds .*</string>
						<string>^.* staggers from ([A-Za-z]+)'s massive .*</string>
						<string>^([A-Za-z]+) pierces.*, whose body falls lifeless to the ground.</string>
						<string>^([A-Za-z]+) pierces the heart of .* who falls to the ground clutching at the wound.</string>
						<string>^.* staggers from ([A-Za-z]+)'s strong .*</string>
						<string>^([A-Za-z]+) neatly beheads .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offDodge (all)</name>
					<script>-- miss - dodge

if matches[2] == "you" or matches[2] == "You" then
  addStat(whoami(), "offDodge")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offDodge")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>dodges (you)r futile attack.</string>
						<string>.* dodges ([A-Za-z]+)'s attack.</string>
						<string>(You)r attack glances harmlessly off of .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defMiss - missed attack (all)</name>
					<script>-- A challenge warrior's attack only grazes Graxod as he dodges aside!
-- Tarthilmor Aerasume deflects your blow, and strikes back at YOU!


-- attack doesn't get through my defense

if matches[2] == "you" then
  addStat(whoami(), "defMiss")
end

if groupList:ingroup(matches[2]) then
  addStat(matches[2], "defMiss")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> misses (you) </string>
						<string>.* missed ([A-Za-z]+) with .*</string>
						<string>.* misses ([A-Za-z]+) with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>shield vamp</name>
					<script>addStat(whoami(), "shieldvamp")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your shield glows brightly as it steals some lifeforce</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defParry (all)</name>
					<script>-- Grxx parries a mage in the Spellguard's lunge at him.

if matches[2] == "You" then
  addStat(whoami(), "defParry")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "defParry")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) parry .*</string>
						<string>([A-Za-z]+) parries .* lunge at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offParry (all)</name>
					<script>-- An elite caravan guard parries your futile lunge at him.
-- A magical skeleton parries Nisaya's lunge at it.
-- Grxx parries a mage in the Spellguard's lunge at him.

if matches[2] == "your" then
  addStat(whoami(), "offParry")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offParry")
  end
end
  </script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* parries ([A-Za-z]+)'s lunge at .*</string>
						<string>.* parries (your) futile lunge at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defShieldBlock (all)</name>
					<script>-- Graxod blocks a member of the High Guard's attack with his shield!
-- A large ogre blocks Sashishe's attack with his shield!
--Wobb blocks a githyanki Defender's attack with her shield!
-- .* blocks ([A-Za-z]+)'s attack with his shield!


if matches[2] == "You" then
  addStat(whoami(), "defShieldBlock")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "defShieldBlock")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) block .*</string>
						<string>([A-Za-z]+) blocks .* attack with .* shield!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offGraze - other</name>
					<script>--Hoppel's attack only grazes a githyanki warrior as he dodges aside!
--Your attack only grazes a tl'a'ikith as he dodges aside!

if matches[2] == "Your" then
  addStat(whoami(), "offGraze")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offGraze")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+)'s attack only grazes .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defParryPartial (all)</name>
					<script>-- Lashimer partially deflects a shadowy spectre's lunge at him.

if matches[2] == "You" then
  addStat(whoami(), "defParryPartial")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "defParryPartial")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) partially deflect</string>
						<string>([A-Za-z]+) partially deflects .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offShieldBlock (other)</name>
					<script>-- A large ogre blocks Sashishe's attack with his shield!

if groupList:ingroup(matches[2]) then
  addStat(matches[2], "offShieldBlock")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* blocks ([A-Za-z]+)'s attack with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ganar summons a healing light that surround the entire group.</name>
					<script>-- Bafog summons a healing light that surround the entire group.
-- Vare summons a holy light that surrounds the entire group.
-- Rokpat summons a holy light that surrounds the entire group.


if matches[2] == "You" then
  addStat(whoami(), "GroupHeal")
  return
end

addStat(matches[2], "GroupHeal")

if groupList:size() &gt; 1 then
  group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a healing light that surround the entire group.</string>
						<string>(You) summon a healing light that surrounds the entire group.</string>
						<string>([A-Za-z]+) summons a holy light that surrounds the entire group.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Nilebbeple starts casting a spell called 'Vitality'</name>
					<script>
addStat(matches[2], "Vitality")


if groupList:ingroup(matches[2]) then
  tempTimer(4, [[group:send()]])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) starts casting a spell called 'Vitality'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>invoker spells</name>
					<script>--</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a fearsome meteor swarm!</string>
						<string>Billowing clouds of incendiary gases pour from ([A-Za-z]+)'s fingertips!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Hosol summons a holy light to surround Hosol and close his wounds.</name>
					<script>-- full heal
-- Rynshana summons a holy light to surround Ravad and close his wounds.
-- Your feel a rush of warmth as your wounds are healed.
-- You summon a holy light to surround Lilabipple and close her wounds.
-- You summon a holy light to surround a gray slaad and close its wounds.[heal trigger]
-- Lilebeple summons a holy light to surround Tatris and close his wounds.


if matches[2] == "Your" then
  addStat(whoami(), "gotFullHeal")
  return
end

if matches[2] == "You" then
  addStat(whoami(), "castFullHeal")

  if not groupList:ingroup(matches[3]) then
    return
  end

  addStat(matches[3], "gotFullHeal")

  return
end

if groupList:ingroup(matches[2]) then
  addStat(matches[2], "castFullHeal")
end

if groupList:ingroup(matches[3]) then
  addStat(matches[3], "gotFullHeal")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a holy light to surround ([A-Za-z]+) and close .*</string>
						<string>(Your) feel a rush of warmth as your wounds are healed.</string>
						<string>(You) summon a holy light to surround ([A-Za-z ]+) and close .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Hosol surrounds Ashashas in a brilliant aura of 
holy power.</name>
					<script>-- healingaura - add buff (20 sec timer)
-- Repeats 5 times every 4 seconds = 20 sec
-- triggers after 4, 4, 4, 4, 4 (heal at 4, 8, 12, 16, 20

--Mizes completes his spell...
--You are surrounded in a brilliant aura of holy power.

spell:whocast()

if groupList:ingroup(matches[2]) then
  -- ([A-Za-z]+) surrounds ([A-Za-z]+) in a brilliant aura of holy power.
  addStat(matches[2], "castHealingAura")

  if groupList:ingroup(matches[3]) then
    buff:set(matches[3], "healing_aura", 20)

    addStat(matches[3], "gotHealingAura")
  end
end

if matches[2] == "You" then
  if matches[3] == nil then
    -- You are surrounded in a brilliant aura of holy power.
    buff:set(whoami(), "healing_aura", 20)

    addStat(whoami(), "gotHealingAura")

    if spell:whocast() == whoami() then
      addStat(whoami(), "castHealingAura")
    end
  else
    -- You surround Harlindrel in a brilliant aura of holy power.
    addStat(whoami(), "castHealingAura")

    if groupList:ingroup(matches[3]) then
      buff:set(matches[3], "healing_aura", 20)

      addStat(matches[3], "gotHealingAura")
    end
  end
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) surrounds ([A-Za-z]+) in a brilliant aura of holy power.</string>
						<string>(You) are surrounded in a brilliant aura of holy power.</string>
						<string>(You) surround ([A-Za-z]+) in a brilliant aura of holy power.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Lilithelle has died!</name>
					<script>-- death counter

if groupList:ingroup(matches[2]) then
  addStat(matches[2], "death")
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) has died!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your body warms as some of your wounds are healed.</name>
					<script>-- heal cast on self
-- Your body warms as some of your wounds are healed. 

-- Your body warms as your wounds are healed. groupheal?

-- You summon a healing light that surrounds the entire group.

addStat(whoami(), "castHeal")
addStat(whoami(), "gotHeal")

for k,char in pairs(groupList:pc()) do
  buff:del(char, "blind")
  buff:del(char, "blindness")
end

group:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your body warms as some of your wounds are healed.</string>
						<string>Your body warms as your wounds are healed.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Daggararoa is infused with vitality.</name>
					<script>-- Daggararoa is infused with vitality. (cast by me)
--([A-Za-z]+) is infused with vitality. (someone else)
-- You feel vitalized. (by me or someone else)


local caster=spell:whocast()


if caster ~= nil then
  addStat(caster, "Vitality")
end

if matches[2] == "You" then
  sendStatus()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) is infused with vitality.</string>
						<string>(You) feel vitalized.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are rescued by Harlindrel!</name>
					<script>-- You are rescued by the spectre of a human noble!

if groupList:ingroup(matches[2]) then
  addStat(matches[2], "successrescue")
end

look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are rescued by (.*)!</string>
						<string>You are rescued by (.*), you are confused, but grateful!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Kazah starts casting an offensive spell called 'Spectral Hand'</name>
					<script>-- track total spellcast
if matches[2] == "You" then
  addStat(whoami(), "spellCast")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "spellCast")
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) starts casting .*</string>
						<string>(You) start chanting...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You maneuver your mount to avoid A naked woman's attack!</name>
					<script>-- mount block

addStat(whoami(), "defMountBlock")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You maneuver your mount to avoid</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>planetar heal</name>
					<script>-- planetar heal proc
addStat(whoami(), "planetar")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Warm, radiating sunlight exudes from your blade, healing your wounds with its powerful energy.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ranger</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>armor splinter</name>
						<script>-- Lulaz strikes the weak spots in a black dragon scout's armor, leaving him vulnerable.
-- You strike the weak spots in a black dragon scout's armor, leaving him vulnerable.

-- The green dragon consort's armor resists the impact of Melenes's carefully aimed strikes. (failed)

if matches[2] == "You" then
  addStat(whoami(), "offHitAP")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offHitAP")
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) strikes the weak spots in .*</string>
							<string>(You) strike the weak spots in .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>evis</name>
						<script>-- You swing your weapons in lethal arcs, dousing the area with an elite barbazu soldier's blood.
-- Lulaz swings his weapons in lethal arcs, dousing the area with an elite narzugon's blood.

if matches[2] == "You" then
  addStat(whoami(), "offHitEV")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offHitEV")
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) swing your weapons in lethal arcs, dousing the area with .*</string>
							<string>(Lulaz) swings his weapons in lethal arcs, dousing the area with .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>blade storm</name>
						<script>-- Lulaz spins and leaps through the fray, unleashing a torrent of steel on his enemies!

if matches[2] == "You" then
  addStat(whoami(), "offHitBS")
else
  if groupList:ingroup(matches[2]) then
    addStat(matches[2], "offHitBS")
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) spins and leaps through the fray, unleashing a torrent of steel on his enemies!</string>
							<string>(You) spin and leap through the fray, unleashing a torrent of steel on your enemies!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Critical hits</name>
					<script>addStat(whoami(), "crithit")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You score a CRITICAL HIT!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>AutoRoller</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>roller dice</name>
					<script>local value= tonumber(matches[3])

if NyyLIB.roller == nil then
  return
end

if value &gt;= 90 and value &lt; 95 then
  NyyLIB.roller = NyyLIB.roller + 1
elseif value &gt;= 95 and value &lt; 100 then
  NyyLIB.roller = NyyLIB.roller + 2
elseif value == 100 then
  NyyLIB.roller = NyyLIB.roller + 3
end

value= tonumber(matches[6])

if value &gt;= 90 and value &lt; 95 then
  NyyLIB.roller = NyyLIB.roller + 1
elseif value &gt;= 95 and value &lt; 100 then
  NyyLIB.roller = NyyLIB.roller + 2
elseif value == 100 then
  NyyLIB.roller = NyyLIB.roller + 3
end


--if matches[3] == "mighty" then
--  NyyLIB.roller = NyyLIB.roller +   1
--end

--if matches[6] == "mighty" then
--  NyyLIB.roller = NyyLIB.roller +   1
--end

--if matches[3] == "heroic" then
--  NyyLIB.roller = NyyLIB.roller +   2
--end

--if matches[6] == "heroic" then
--  NyyLIB.roller = NyyLIB.roller +   2
--end


--if matches[3] == "perfect" then
--  NyyLIB.roller = NyyLIB.roller +   3
--end

--if matches[6] == "perfect" then
--  NyyLIB.roller = NyyLIB.roller +   3
--end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(Strength|Dexterity|Agility|Constitution|Power|Intelligence|Wisdom|Charisma): +(bad|fair|average|mundane|good|mighty|heroic|perfect)</string>
						<string>(Strength|Dexterity|Agility|Constitution|Power|Intelligence|Wisdom|Charisma): +([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your basic stats:</name>
					<script>NyyLIB.roller=0</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your basic stats:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>RollerTrigger</name>
					<script>-- ^Constitution: .* Charisma: .*
-- (Strength|Dexterity|Agility|Constitution|Power|Intelligence|Wisdom|Charisma): +(bad|fair|average|mundane|good|mighty|heroic|perfect)

-- You may choose to reroll your character at this time. If you elect

rollerstats = rollerstats or {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

-- NyyLIB.roller - the value of current roll

local rollTarget = charData:get("autoroll", true)

if NyyLIB.roller ~= 0 then
  rollerstats[NyyLIB.roller] = rollerstats[NyyLIB.roller] + 1

  local nx
  
  for nx=1,(rollTarget-1),1 do
        
    local val=rollerstats[nx]
  end
end

if NyyLIB.roller &lt; rollTarget then
  send("y", false)
else
  -- sound
  sound("365641__furbyguy__8-bit-alarm.wav",nil,true)

  -- anti-timeout
  timer:set("autoroll", 120)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Constitution: .*Charisma: .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^Your character has been created and is ready for you to play.</name>
					<script>--Thanks, Gyrx!

-- erase current value of autoroll timer
timer:set("autoroll", nil)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your character has been created and is ready for you to play.</string>
						<string>^Explanation of stats:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>DisplayPotions</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>When you look inside, you see:</name>
					<script>-- A hole of spatial distortion (carried) : 

-- enable potion detect trigger
enableTrigger("InventoryPotions")
enableTrigger("EndTrigger")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>When you look inside, you see:</string>
						<string>([A-Za-z ]+) \(carried\) : </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>InventoryPotions</name>
					<script>local itemname=matches[2]

-- Remove all (word) patterns: (magic), (illuminating), (glowing), (damaged), (invis)
itemname = string.gsub(itemname, " %(.+%)", "")

-- [#] itemname (i.e. multiple items)

if string.find(itemname, "] ") ~= nil then
  itemname = string.sub(itemname, string.find(itemname, "] ")+2)
end

itemname = NyyLIB.itemdb[itemname]

if itemname ~= nil then
  if itemname[1] == "potion" then
    itemname=itemname[2]
    cecho(" " .. charData:get("potionc", true) .. "[" .. itemname .. "]")
  elseif itemname[1] == "scroll" then
    itemname=itemname[2]
    cecho(" &lt;:medium_blue&gt;&lt;red&gt;" .. "[" .. itemname .. "]")
  else
    itemname=itemname[2]
    cecho(" &lt;:medium_blue&gt;&lt;green&gt;" .. "[" .. itemname .. "]")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>EndTrigger</name>
					<script>-- need to fix for badge

disableTrigger("EndTrigger")
disableTrigger("InventoryPotions")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt;.*&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>DisplayContainer</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>DisableDisplayContainer</name>
					<script>disableTrigger("DisplayContainer")
disableTrigger("container contents")

enableTrigger("DisplayPotions")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt;.*&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>container start</name>
					<script>enableTrigger("container contents")

noIdItems = {}
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>When you look inside, you see:</string>
						<string>([A-Za-z ]+) \(carried\) : </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>container contents</name>
					<script>local itemname=matches[2]

if string.find(itemname, "%(carried%)") then
  return
end

-- Remove all (word) patterns: (magic), (illuminating), (glowing), (damaged), (invis)
itemname = string.gsub(itemname, " %(.+%)", "")

-- [#] itemname (i.e. multiple items)

if string.find(itemname, "] ") ~= nil then
  itemname = string.sub(itemname, string.find(itemname, "] ")+2)
end

local itemid= sqliditem(itemname)

if itemid[1] then
  itemid = string.gsub(itemid[1], itemname, "")

  echo(itemid)
else
  -- unknown item
  noIdItems[table.size(noIdItems)+1]= itemname
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>TorilMapper</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^Exits: (.*)</name>
					<script>local xexits=matches[2]
local roomPortal = false

-- last command entered was look direction - return
if string.find(command, "L ") == 1 and not string.find(command, "L in") then

  local lineindex=1

  while prompt:isStringPrompt( getLines(getLineNumber()-lineindex, getLineNumber())[1] ) == false do
    if getLines( getLineNumber()-lineindex, getLineNumber() )[1] == "               " then
      break
    end
        
    lineindex=lineindex+1

    if lineindex &gt; 1500 then
      echoDebug("&lt;red&gt;[Searched more then 1500 lines unable to locate last prompt for roomname]\n")
      return
    end
  end

  local teststring = getLines(getLineNumber()-lineindex, getLineNumber())[1]

  while map:isRoomName(teststring) == false do
    lineindex=lineindex-1
    teststring = getLines(getLineNumber()-lineindex, getLineNumber())[1]
  end

  map.farseeRoomname = teststring
  map.farseeExits = matches[2]

  return
end

-- TODO: correct room number in looking n/e/s/w/etc
-- You extend your sights northwards.
-- You extend your sights upwards.

-- clair - 'cast your sights far out' in the last 6 lines

for nx=1,6,1 do
  if string.find( getLines(getLineNumber()-nx, getLineNumber())[1], "cast your sights far out") then
    roomPortal="Clair"
  end
end

-- looking in wormhole - 'You peer into'
-- You peer into a blood-red portal
-- You peer into a rainbow colored portal and see...
-- You peer into a moonwell and see...

-- TODO/tofix: this segment can't be reached (it returns from 'L') 

for nx=1,6,1 do
  local portal=string.match( getLines(getLineNumber()-nx, getLineNumber())[1], "You peer into a (.*) and see" )

  if portal ~= nil then
    roomPortal=portal
  end
end

-- last command entered was scan
-- This block will also attempt to solve location from scan results

if command == "SCAN" then
  local lineindex=1

  while ( string.find( getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([A-Za-z]+)[.][.][.]") == nil) do
    lineindex=lineindex+1

    if lineindex &gt; 150 then
      cecho("&lt;red&gt;[Scan error after 150 lines]\n")
      command = ""
      return
    end
  end

  local scandir= string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*")

  scanned[scandir]={}
  scanned[scandir]["roomname"]= getLines(getLineNumber()-lineindex+1, getLineNumber())[1]
  scanned[scandir]["exits"] = getExitTable(xexits)

  scanned[scandir]["roomids"] = map:findRoomIDTable( scanned[scandir]["roomname"], getExitTable(xexits), true)

  scanned["currentroomname"] = map:getRoomname()
  scanned["currentroomexits"] = map:getExits()

  filterScan(scandir) -- reverse checks all rooms

  if map:getRoom() == nil then
    local solveroom = solveScan(true)

    if solveroom ~= nil then
      map:setRoom(solveroom)
      centerview( map:getRoom() )
    end
  end

  return
end

-- was last command entry to special exit?
-- This is the block that echos the special exit usage message

if map:getRoom() ~= nil then
  local specialexit = getSpecialExitsSwap( map:getRoom() )

  local exitlist={}

  -- build list of special exits
  for k,v in pairs(specialexit) do
    -- key will be each special exit from this room example: "enter wave|dancer"
    local specialExit = string.split(k, " ")
    
    for k2,v2 in pairs(string.split(specialExit[2], "|")) do
      local testCommand = string.split(string.lower(command), " ")
      local testExit = string.lower(specialExit[1])
      
      -- Check for special command/partial command, exit
      if string.find(testExit, testCommand[1]) == 1 and testCommand[2] == string.lower(v2) then
        -- TODO - command2 causes problems with fwalk paths
        cecho("\n&lt;green&gt;[Using special exit '&lt;cyan&gt;" .. k .. "&lt;green&gt;' to room &lt;cyan&gt;" .. v .. " : " .. getRoomName(v) .. "&lt;green&gt;]\n")
        map:setRoom(v)
        centerview( map:getRoom() )

        -- remove first movement from queue
        map:removeMovement()

        return
      end
    end
  end
end

-- find last blank line received, room name is first following line of format title the doesn't end in period or start with [
-- OR minimap marker "     " \t\t\t\n
local lineindex=1

while prompt:isStringPrompt( getLines(getLineNumber()-lineindex, getLineNumber())[1] ) == false do
  if getLines( getLineNumber()-lineindex, getLineNumber() )[1] == "               " then
    break
  end
        
  lineindex=lineindex+1

  if lineindex &gt; 1500 then
    echoDebug("&lt;red&gt;[Searched more then 1500 lines unable to locate last prompt for roomname]\n")
    return
  end
end

local teststring = getLines(getLineNumber()-lineindex, getLineNumber())[1]

while map:isRoomName(teststring) == false do
  lineindex=lineindex-1
  teststring = getLines(getLineNumber()-lineindex, getLineNumber())[1]
end

-- if claired decrease index by 1
local checkline= getLines(getLineNumber()-lineindex, getLineNumber())[1]

if checkline ~= nil then
  if string.find( checkline, "cast your sights far out") then
    lineindex=lineindex-1
  end

  if string.find( checkline, "You peer into") then
    lineindex=lineindex-1
  end
end

-- TODO: clair/portal shouldn't be setting roomname

local roomName = getLines(getLineNumber()-lineindex, getLineNumber())[1]

map:setRoomname( roomName )

if roomName == nil then
  return
end

-- Remove all (word) patterns: (Shadowed), (Airy), except: (Water), (Fogged) (No Ground), (burning)
local buildName = string.gsub(roomName, " %(.+%)", "")

if string.find( roomName, "%(burning%)" ) then
  buildName = buildName .. " (burning)"
end

if string.find( roomName, "%(Water%)" ) then
  buildName = buildName .. " (Water)"
end

if string.find( roomName, "%(Fogged%)" ) then
  buildName = buildName .. " (Fogged)"
end

if string.find( roomName, "%(No Ground%)" ) then
  buildName = buildName .. " (No Ground)"
end

roomName = buildName

-- in case roomname was on same line as prompt (it happens!)
if string.find( roomName, "&gt; ") ~= nil then
  roomName = string.sub(roomName, string.find(roomName, "&gt; ")+2) 
end

-- if not a portal, can set name/exits
if not roomPortal then
  map:setExits( getExitTable(xexits) )
  
  -- clear trailing whitespace
  roomName = roomName:trim()
  
  map:setRoomname(roomName)
end

-- pop last movement (if there was one)

local lastMovement = map:popMovement()

local testMovement = string.match( tostring(lastMovement), "^DRAG .* ([nsewud]).*")

if testMovement then
  echoDebug("&lt;green&gt;[testMovement: " .. tostring(testMovement) .. "]\n")
  lastMovement=testMovement
end

-- if lastMovement was to unlock a door, pop again
if string.find(tostring(lastMovement), "^unlock ") then
  lastMovement = map:popMovement()
end

-- if lastMovement was to open a door, pop again

if string.find(tostring(lastMovement), "^open ") then
  lastMovement = map:popMovement()
end


-- this function is called twice (because of potential inserts)
sendBufferedMovements()
sendBufferedMovements()


if lastMovement then
  if lastMovement == "enter" then
    expandAlias("@find", false)
  else
    map:update(lastMovement)
  end
end

if not roomPortal then
  if map:getRoom() == nil then
    map:setRoom( map:findRoomID( map:getRoomname(), map:getExits(), true) )
  
    --map:update( map:getRoom() )
    map:update(nil)
  end
end

if xexits == nil then
  cecho("&lt;red&gt;[Error: nil match on exits]\n")
end

-- Does the mapper think I am where the mud thinks I am?

local id= map:getRoom()
    
if not roomPortal and id ~= nil and not forceFind then
  local mapRoomName = string.gsub(tostring( getRoomName( id )) , " %(.+%)", "")
  
  -- remove (airy), (water), etc before comparing
  
  if mapRoomName ~= string.gsub(tostring( map:getRoomname() ) , " %(.+%)", "")   then
    if not charData:get("maperror", true) then
      cecho(string.format(" &lt;red&gt;[Error: mud '&lt;cyan&gt;%s&lt;red&gt;' doesn't match mapper '&lt;cyan&gt;%s&lt;red&gt;' at '&lt;cyan&gt;%d&lt;red&gt;'] ", map:getRoomname(), mapRoomName, id ) )
    end
  end
end

-- forceFind=nil

-- display vnum at the end of exits line
if charData:get("vnum", true) then
  if not roomPortal then
    if map:getRoom() ~= nil then
      cecho("&lt;forest_green&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s] ", " ", map:getRoom() ))
    else
      cecho("&lt;red&gt;" .. string.format("%" .. (20-string.len(xexits)) .. "s [%s] ", " ", "Map not in sync, type &lt;green&gt;@find &lt;red&gt;or &lt;green&gt;scan&lt;red&gt; to attempt resync"))
    end
  else
    local clairedroomid = map:findRoomID( roomName, getExitTable(xexits), true)
    local clairzone = map:findRoomArea( roomName, getExitTable(xexits) )

    if clairzone == nil then
      cecho("&lt;red&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s] ", " ", roomPortal))
    else
      if clairedroomid == nil then
        cecho("&lt;red&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s: &lt;green&gt;%s&lt;red&gt;] ", " ", roomPortal, clairzone))
      else
        cecho("&lt;red&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s: %d &lt;green&gt;%s&lt;red&gt;] ", " ", roomPortal, clairedroomid, clairzone))
      end
    end
  end
end

if getHide() then
  cecho("&lt;blue&gt; [Hidden]")
end

echo("\n")

if map:countMovement() == 0 then
  if NyyLIB.tosend ~= nil then
    send(NyyLIB.tosend)
  end

   NyyLIB.tosend=nil 
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>forcefind</name>
					<script>-- As you step into the ruby, there is a blinding flash of light!

--Your vision descends into darkness as your feel your soul pulled back into
--your mortal form. As the transference completes. you feel your body wracked
--with terrible pain. You open your eyes and take a first, shuddering breath.

scanned={}

--if timer:get("forcefind") then
--  return
--end

forceFind = true

tempTimer(1.5, [[expandAlias("@find", false)]])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Suddenly the darkness falls revealing different surroundings.$</string>
						<string>You are instantaneously teleported nearby!$</string>
						<string>You enter something and reappear elsewhere...$</string>
						<string>You start to become less and less solid, until you reappear elsewhere!$</string>
						<string>You recite a scroll of cave escape which turns to dust in your hands.$</string>
						<string>You recite an ensorcelled scroll of the Mistwalker which turns to dust in your hands.$</string>
						<string>^Your soul is instantly whisked away from the dreary Fugue Plane when you</string>
						<string>Someone demands your presence NOW!$</string>
						<string>has summoned you!$</string>
						<string>^You feel a Presence touch you, its divine hand cupping itself</string>
						<string>^Your vision descends into darkness as your feel your soul pulled back into</string>
						<string>The world goes dark.  When you can see again, you are in your guild.$</string>
						<string>You disembark this ship.$</string>
						<string>OH NO!  Something has gone wrong!  You feel lost!$</string>
						<string>forceful crunch of the landing.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You flee ([nsewud]).*</name>
					<script>-- currently moving
spell:setMoving(true)

-- erase spellqueue if any spells present
spell:eraseQueue()

scanned={}

map:update(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You flee ([nsewud]).*</string>
						<string>You follow .* ([nsewud]).*</string>
						<string>You escape ([nsewud]).*</string>
						<string>You stop fighting and attempt to retreat to the ([nwes]).*!</string>
						<string>You find traces of tracks leading ([nsewud]).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Failed movement</name>
					<script>-- failed room movement

-- Animated plants secure your feet and prevent your exit!

-- Alas, you cannot go that way. . . .


-- You're busy spellcasting! - follow has already processed
-- need to record last room/direction

--&lt; 104h/104H 118v/126V P: std &gt; 
--Bloogak lumbers down.
--You follow Bloogak down.

--A magic force blocks movement downwards.
--Irohple leaves down.

--&lt; 104h/104H 118v/126V P: std &gt; 

-- Changed to erase entire queue

--map:clearQueue() -- &lt;-- already sent movements still need to be processeed



-- need to pop last sent movement from queue

map:removeMovement()

-- Erase unsent movements from queue

map:trimMovement()

-- error above: What about movements already sent/not yet processed?</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>That isn't the direction to your guild, type look room to view</string>
						<string>Alas, you cannot go that way</string>
						<string>Nah... You feel too relaxed to do that...</string>
						<string>Perhaps you should get on your feet first?</string>
						<string>Oof!  It seems that .* is in your way.</string>
						<string>The .* seems to be closed.</string>
						<string>Sorry, you aren't allowed to do that in combat.</string>
						<string>There is no .* here.</string>
						<string>You are too exhausted</string>
						<string>You need a boat to go there.</string>
						<string>.* is blocking your path!$</string>
						<string>You would bash your brains out on the roof, better dismount.</string>
						<string>Stepping off .* at this height might not be such a good idea.</string>
						<string>humiliates you, and blocks your way.</string>
						<string>The passage is too tight to fly.</string>
						<string>You'd surely drown!</string>
						<string>An impenetrable wall of ice blocks passage</string>
						<string>preventing you from going</string>
						<string>You need to board a ship to travel the oceans.</string>
						<string>The entrance is locked and barred tight.</string>
						<string>There is no .* here.</string>
						<string>Try flapping your arms!  (Couldn't hurt)</string>
						<string>You can't drag something when you're flying.</string>
						<string>What do you want to drag?</string>
						<string>You are much too big to fit through the holes in the floor.</string>
						<string>You collapse under your carried load!</string>
						<string>A magic force blocks movement downwards.</string>
						<string>You are stuck in a huge spider web!</string>
						<string>Animated plants secure your feet and prevent your exit!</string>
						<string>Your mount is too exhausted for you to follow.</string>
						<string>You crawl past</string>
						<string>The flesh golem roughly grabs you and tosses you backwards!</string>
						<string>Something strikes out at you from the shadows!</string>
						<string>You're busy spellcasting!</string>
						<string>Sorry, you aren't allowed to do that in combat.</string>
						<string>a gate guard whispers 'We don't want your type here, get lost.'</string>
						<string>The unstable tunnel to the west has collapsed on itself. There is absolutely</string>
						<string>A shady old man whispers 'This area is far below you, unless you wish to fight me.'</string>
						<string>The deadly cold coming down the mountain's peak makes it impossible to progress any further.</string>
						<string>Alas, you can't go that way.</string>
						<string>But you are busy sucking on a brain already!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You sit down.</name>
					<script>-- can't be moving TODO: trying to spam recline?

disableTrigger("minimap display")  

map:clearQueue()

spell:stop() -- set spell.casting=nil
spell:clear()

spell:setMoving(false)

setHide(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You sit down.</string>
						<string>You drop to your belly.</string>
						<string>You sit down and relax.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Doorbash movement</name>
					<script>-- You feel stupid, about to bash open doorway down?

if matches[2] == "did" then
  map:update(NyyLIB.doorbash)
end

NyyLIB.doorbash=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You (did) it! The door budges under your weight, and you charge into a new place!</string>
						<string>You feel stupid, about to bash open doorway</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>scanlandmarks</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A portal of swirling clouds hovers here.</name>
						<script>-- set room on ethereal

--if map:getRoom() ~= nil then
--  return
--end

map:setRoom(88233)
centerview( map:getRoom() )

if command == "SCAN" then
  -- You scan north...
  local lineindex=1

  while string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") == nil do
    lineindex=lineindex+1

    if lineindex &gt; 150 then
      echoDebug("&lt;red&gt;[Unable to locate scan message]\n")
      return
    end
  end

  local scandir = string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") 

  local setroom = getRoomExits(88233)[NyyLIB.reversedirs[scandir]]

  --display(setroom)

  map:setRoom(setroom)
  centerview( map:getRoom() )

  --display("Found on scan in dir " .. scandir)
end

if string.match(command, "^[nsewud]$") then
  map:setRoom(88233)
  centerview( map:getRoom() )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^A portal of swirling clouds hovers here.( \(magic\))?$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A violent maelstrom swirls here, drawing in the unwary.</name>
						<script>-- plane of air 93607: A violent maelstrom swirls here, drawing in the unwary.

map:setRoom(93607)
centerview( map:getRoom() )

if command == "SCAN" then
  -- You scan north...
  local lineindex=1

  while string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") == nil do
    lineindex=lineindex+1

    if lineindex &gt; 150 then
      echoDebug("&lt;red&gt;[Unable to locate scan message]\n")
      return
    end
  end

  local scandir = string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") 

  local setroom = getRoomExits(93607)[NyyLIB.reversedirs[scandir]]

  --display(setroom)

  map:setRoom(setroom)
  centerview( map:getRoom() )

  --display("Found on scan in dir " .. scandir)
end

if string.match(command, "^[nsewud]$") then
  map:setRoom(93607)
  centerview( map:getRoom() )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^A violent maelstrom swirls here, drawing in the unwary.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>kenjin teleport</name>
						<script>-- kenjin proc teleport

map:setRoom(93537)
centerview( map:getRoom() )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Suddenly he points it at YOU! You feel your stomach churn as you$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>It is pitch black...</name>
					<script>-- room entry into a pitch black room

-- last command entered was look or scan - return
if string.find(command, "l ") == 1 or string.find(command, "look ") == 1 or command == "SCAN" then
  return
end

-- pop last movement (if there was one)

local lastMovement = map:popMovement()

if lastMovement then
  if lastMovement == "enter" then
    expandAlias("@find", false)
  else
    map:update(lastMovement)
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>It is pitch black...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tells you @room</name>
					<script>local roomid = map:getRoom()

if roomid ~= nil then
  local zoneid=tonumber(getRoomUserData(roomid, "zoneid") )

  mud:send("T " .. matches[2] .. " " .. roomid .. ", " .. getRoomName(roomid) .. " : " .. NyyLIB.areaTable[zoneid] .. "\n")
else
  mud:send("T " .. matches[2] .. " Map not currently in sync")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you '@room'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ice teleport</name>
					<script>-- 86574

map:setRoom(86574)
centerview( map:getRoom() )
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You awake to find yourself in a dark and unfamiliar site, the stench</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capture mud area list</name>
					<script>mudAreaTable={}
enableTrigger("areaname capture")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Zone    Name$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>areaname capture</name>
					<script>local ZoneId
local ZoneName

ZoneId=tonumber(matches[2])
ZoneName=matches[3]:trim()

mudAreaTable[ZoneName] = ZoneId

--display(ZoneId)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^ ? ?([0-9]?[0-9]?[0-9]?) +(.*) +$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>RoomClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>RoomCapture</name>
					<script>-- location matters on this trigger to prevent double firing

-- terminate capture on blank line
if matches[1] == "" then
  disableTrigger("RoomCapture")

  if gaglook then
    eraseLine()
  end

  return
end

selectCurrentLine()
copy()
appendBuffer("roomBuffer")

if gaglook then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>StartRoomCapture</name>
					<script>--gaglook=nil

if not roomWindow:exists() then
  return
end

-- last command entered was look direction - return
if string.find(command, "L ") == 1 then
  return
end

-- room is from clair, looking in portal

for nx=1,6,1 do
  local testLine = getLines(getLineNumber()-nx, getLineNumber())[1]
  
  if string.find( testLine, "cast your sights far out") then
    return
  end

  if string.match( testLine, "You peer into a (.*) and see" ) then
    return
  end
end

-- last command entered was scan
if command == "SCAN" then
  return
end

clearWindow("roomBuffer")

enableTrigger("RoomCapture")

local exitLine = getLineNumber()
local lineOffset = 1


-- capture line prior to exits (room name in brief)
local roomline = getLines(exitLine-lineOffset, exitLine)[1]
local linecheck = string.find(roomline, "%[")

while linecheck ~= nil do
  lineOffset=lineOffset+1

  roomline = getLines(getLineNumber()-lineOffset, getLineNumber())[1]
  linecheck = string.find(roomline, "%[")

  if lineOffset &gt; 100 then
    cecho("&lt;red&gt;[StartRoomCapture: error]\n")
    return
  end
end

-- move to line prior to exits that doesn't start with a [:
moveCursor(0, exitLine-lineOffset)

local roomline = getLines(exitLine-lineOffset, exitLine)[1]

-- changed was "&gt; "
local linecheck = string.find(roomline, "&gt;")

-- previous line started with a prompt
if linecheck ~= nil then
  selectSection(linecheck+1, string.len(roomline)-linecheck-1)
else
  -- include full line in capture window
  selectCurrentLine()
end

-- this is the room title
copy()
appendBuffer("roomBuffer")

--display( getLines(getLineNumber()-lineOffset-5, getLineNumber()+2) )

if gaglook then
  eraseLine()
end

-- return to exits line
moveCursorEnd( "main" )

-- include full line in capture window
selectCurrentLine()

copy()
appendBuffer("roomBuffer")

if gaglook then
  eraseLine()
end

look:set("LOOKSTART")

--display(linecheck)
--display(roomline)

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#aa007f</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^Exits: .*</name>
					<script>NyyLIB.torescue=""

roomCombat=false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You cast your sights far out, into the realms!</name>
					<script>gaglook=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You cast your sights far out, into the realms!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GroupHP</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Group heal</name>
					<script>-- group heal
-- Rokpat summons a holy light that surrounds the entire group.
-- Vooku summons a healing light that surround the entire group.

-- should increase hp accordingly

spell:clear("cb", true) -- noAbort set

for k,char in pairs(groupList:pc()) do
  buff:del(char, "blind")
  buff:del(char, "blindness")
end

-- only send group command if in a group
if groupList:size() &gt; 1 then
  group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a healing light that surround the entire group.</string>
						<string>(You) summon a healing light that surrounds the entire group.</string>
						<string>([A-Za-z]+) summons a holy light that surrounds the entire group.</string>
						<string>(Your) vision returns!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>call group:send</name>
					<script>-- You summon a holy light to surround Hosol and close his wounds.
-- Lilebeple summons a holy light to surround Tatris and close his wounds.
-- Diac summons a holy light to surround Kitra and close her wounds.

if matches[2] ~= nil and matches[2] ~= "You" then
  sendStatus(matches[2])
end

--if groupList:size() &gt; 1 and matches[2] ~= nil then
if groupList:size() &gt; 1 then
  --display("X")
  group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>in a brilliant aura of holy power.</string>
						<string>a holy light to surround</string>
						<string>to heal a death kiss.</string>
						<string>([A-Za-z]+) group-says 'I have</string>
						<string>(You) don't see them here!</string>
						<string>flips head over heels.</string>
						<string>OUCH!  That really did HURT!</string>
						<string>has created a devastating blast of sand!</string>
						<string>says 'I have</string>
						<string>A harmonious combination of notes from</string>
						<string>You finish a verse of the song of healing.</string>
						<string>(hates) your guts!</string>
						<string>You lay your blessed hands upon</string>
						<string>has been appointed the leader of the group by</string>
						<string>breathes</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Condensed</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Duplicate line filter</name>
					<script>-- this trigger will go off on every line recieved

if matches[2] == nil then
  return
end

-- don't echo gagged text

if isGagged(matches[2]) then
  eraseLine()
  return
end

-- the prompt line might have been rewritten because of powers gag

matches[2] = getCurrentLine()

if charData:get("condensed", true)["duplicate"] then
  condenseLine(matches[2])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Assorted Gags</name>
					<script>--As Peri's mount opens its mouth, flames lick out to sear a banedead's body!
--Peri's mount's baleful howl freezes a banedead is its tracks!

if charData:get("condensed", true)["misc"] then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>shaft of light streaking towards</string>
						<string>is bathed in scorching flames!</string>
						<string>is stunned by the horrific visions!</string>
						<string>A fire elemental revels in</string>
						<string>A huge beam of white light shines down from the</string>
						<string>moves about the room gathering</string>
						<string>The flames engulfing</string>
						<string>Your strike passes through</string>
						<string>is partially absorbed!</string>
						<string>The globe around your body flares as it bears the brunt</string>
						<string>only grazes .* dodges aside!</string>
						<string>is outside of the area of the blast!</string>
						<string>mount opens its mouth, flames lick out to sear</string>
						<string>baleful howl freezes</string>
						<string>says 'I must assist my friend!'</string>
						<string>.* recognizes .*, and charges to attack .*</string>
						<string>.* sent you a tell, and your AFK is toggled on!^</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Combat gags</name>
					<script>-- (You) miss .* with .*

if charData:get("condensed", true)["combat"] then
  if groupList:ingroup(matches[2]) or matches[2] == "you" or matches[2] == "You" or matches[2] == "" or matches[2] == nil then
    eraseLine()
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) barely wounds .*</string>
						<string>^([A-Za-z]+) misses .* with .*</string>
						<string>.* misses (you) with .*</string>
						<string>.* misses ([A-Za-z]+) with .*</string>
						<string>(You) parry .* lunge at you.</string>
						<string>^([A-Za-z]+) assists .* heroically.</string>
						<string>(You).* barely wounds .*</string>
						<string>backwards several feet with a powerful kick.</string>
						<string>^([A-Za-z]+) attempts to circle around .*</string>
						<string>^([A-Za-z]+) circles around .*</string>
						<string>^([A-Za-z]+) makes a nice ballet step .*</string>
						<string>.* dodges ([A-Za-z]+)'s attack.</string>
						<string>.* gasps in agony as ([A-Za-z]+) strikes at .*</string>
						<string>^([A-Za-z]+) grits his teeth and viciously headbutts.*</string>
						<string>.* partially deflects ([A-Za-z]+)'s lunge at .*</string>
						<string>partially blocks .* attack with .*</string>
						<string>attack with your shield!</string>
						<string>attack glances off your shield, but finds its mark!</string>
						<string>You dodge</string>
						<string>dodges your futile attack.</string>
						<string>You partially deflect</string>
						<string>attack only grazes you as you dodge aside!</string>
						<string>You score a CRITICAL HIT!</string>
						<string>^You deflect .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ItemProcGags</name>
					<script>--Suddenly the room is filled with dark clouds, the very ground before Rahas 
--apparantly not quite as it had seemed just a moment ago. You picture Rahas
--dashing through some mystical land, on his way to a demon infested dungeon.
--Just before he arrives at it's entrance, a whisper is about the air. The 
--trickery of Brandobaris is suddenly apparent! You blink and it is all gone.
--Only Rahas seems to be grining.

--Dharn swings the warmaul of celestial glory in a mighty arc, crushing
--into Forell Luckaun's body with a mighty blow.  The weapon glows
--fiercely at the impact, and that glow seems to intensify the
--strike.  The celestial strike hammers into Forell Luckaun,
--who sways under the impact.

-- and torso, granting you a reptilian quickstrike ability! Your eyes gleam

if charData:get("condensed", true)["items"] then
  eraseLine()

  if matches[2] == "slithering" then
    if matches[3] == "your" then
      cecho("\n&lt;blue&gt;[" .. whoami() .. " : the mystical circlet of the coiled serpent]\n")
    else
      local xname=string.sub(matches[3], 1, string.find(matches[3], "'")-1)

      cecho("\n&lt;blue&gt;[" .. xname .. " : the mystical circlet of the coiled serpent]\n")
    end
  end

  if matches[2] == "khanjari" then
    cecho("\n&lt;blue&gt;[proc: an enchanted khanjari dagger]\n")
  end

  if matches[2] == "screaming" then
    cecho("\n&lt;blue&gt;[proc: a glittering dagger of the Nurturing Matriarch]\n")
  end

  if matches[2] == "fanged" then
    cecho("\n&lt;blue&gt;[proc: red dragon fanged]\n")
  end

  if matches[3] == "warmaul" then
    cecho("\n&lt;blue&gt;[" .. matches[2] .. " : warmaul of celestial glory]\n")
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A momentary brilliant glow originating from</string>
						<string>.* appearance. Countless serpents begin to uncoil,</string>
						<string>(slithering) and sliding their way down and around (.*) arms, neck,</string>
						<string>and torso, granting .* a reptilian quickstrike ability! .*</string>
						<string>a vivid yellow the brief enchantment begins to fade. Quickly as</string>
						<string>they descended, the serpents twist and twine their way back to the magic</string>
						<string>within their circlet.</string>
						<string>features twist in a grimace of absolute fury, as</string>
						<string>a warped broadsword tightly.  With a howl of rage,</string>
						<string>powerfully.  In a frenzy of howling fury</string>
						<string> squeezes the ironwood haft</string>
						<string>dwarven waraxe and wades fearlessly into battle.  Magic surges</string>
						<string>through the glowing golden runes as</string>
						<string>A sudden intense rush of physical fury spiderwebs its way up and down</string>
						<string>Physical power emanating from the tip of .* enchanted (khanjari) dagger</string>
						<string>races towards its wielder within a narrow strip of bright white light. A significant sounding</string>
						<string>BOOM reverberates between your ears as the light settles</string>
						<string>An eerie feeling creeps into your mind as a dark mystical power consumes</string>
						<string>wisps of feathery darkened light ooze forth from the blade</string>
						<string>enchanted (khanjari) dagger, surrounding</string>
						<string>is taken by its ferocity and is plunged into a trance.</string>
						<string>reappears, grinning as</string>
						<string>A (screaming) can be heard for miles as</string>
						<string>glittering dagger glows brightly, and then</string>
						<string>is bathed in scorching flames!</string>
						<string>jumps back and holds a red dragon fanged dagger out towards</string>
						<string>The blade becomes a blur as it rapidly changes into the head of Ilxarzzinazzium</string>
						<string>himself.  With a load roar the head lashes out towards</string>
						<string>it's giant maw.  As suddenly as the head appeared it dissappears back into</string>
						<string>a red dragon (fanged) dagger leaving no trace of itself.</string>
						<string>A red dragon (fanged) dagger suddenly begins glowing brightly and vibrating.</string>
						<string>The blade of the dagger slowly opens and begins to emerse the whole room in</string>
						<string>bright yellow, red, and white flames that scorch everything in sight.</string>
						<string>swings the warmaul of celestial glory in a mighty arc, colliding</string>
						<string>The weapon glows fiercely at the</string>
						<string>impact, and the radiance seems to reach out and</string>
						<string>in a brilliant luminescence. the warmaul of celestial glory continues</string>
						<string>body, crushing through unimpeded</string>
						<string>from the might of its wielder's swing.  The aura around</string>
						<string>intensifies, building to a painful glare as</string>
						<string>the holy power unleashed by the celestial strike.</string>
						<string>body sems to dissolve, slumping down into a lifeless corpse as</string>
						<string>withdraws the (warmaul) of celestial glory</string>
						<string>([A-Za-z]+) swings the (warmaul) of celestial glory in a mighty arc, crushing</string>
						<string>body with a mighty blow.  The weapon glows</string>
						<string>fiercely at the impact, and that glow seems to intensify the</string>
						<string>strike.  The celestial strike hammers into</string>
						<string>who sways under the impact.</string>
						<string>a vivid yellow as the brief enchantment begins to fade. Quickly as</string>
						<string>is drained.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SpellGags</name>
					<script>-- A doppelganger of 

-- falters as its undead force is seized and drained!


-- screams in exquisite pain as a lightning bolt unleashed by

if charData:get("condensed", true)["spells"] then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>sends out an almost endless carpet of arachnoids and insects to kill</string>
						<string>burst of lava coats</string>
						<string>directs waves of freezing ice towards</string>
						<string>storm of hail.</string>
						<string>swarm of fiery meteors.</string>
						<string>incendiary cloud torches</string>
						<string>bursts into red hot flames from</string>
						<string>reels from the sonic assault!</string>
						<string>blasting winds and snow chill</string>
						<string>sends a rainbow of prismatic spray from</string>
						<string>shivers slightly.</string>
						<string>staggers slightly, but manages to keep</string>
						<string>staggers and almost falls!</string>
						<string>looks a little less chilled.</string>
						<string>calls forth a massive wave of ice!</string>
						<string>electrical blast causes</string>
						<string>The tendrils of electricity wrapped around</string>
						<string>explodes in a shower of frost!</string>
						<string>shaft of light streaking towards</string>
						<string>sunray strikes</string>
						<string>The lightning bolt slams into</string>
						<string>looks really sick, and shivers uncomfortably.</string>
						<string>whose swings contact only air!</string>
						<string>body begins to rot and putrify under the assault of</string>
						<string>ancestors rend</string>
						<string>The flames engulfing .* subside.</string>
						<string>spell is partially absorbed by</string>
						<string>movements slow from the freezing cold!</string>
						<string>A torrent of howling souls rips at</string>
						<string>magic has been dispelled!</string>
						<string>The area erupts in a massive INFERNO of heat and flames!</string>
						<string>sends eight shimmering multicolored beams of light spraying</string>
						<string>with a storm of ice.</string>
						<string>.* shudders violently as .* is shattered!</string>
						<string>A massive stone rises from below</string>
						<string>Your ancestral spirits rend</string>
						<string>A splash of water sprays</string>
						<string>is coated in crimson ooze.</string>
						<string>shudders in agony as .* thunderblast jolts .*</string>
						<string>swarm of phantasmal blades slashes</string>
						<string>shudders in pain from the searing winds of</string>
						<string>waves of freezing ice towards</string>
						<string>burst of negative energy!</string>
						<string>You wave the gasses towards</string>
						<string>directs waves of fire toward</string>
						<string>The pummeling violence of hail echoes through the region!</string>
						<string>Waves of heat seem to drink the water right out of your bones!</string>
						<string>Then leaps and blasts into</string>
						<string>You fill .* with the fiery power of death!</string>
						<string>covered in the crimson fluid.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Dragon gags</name>
					<script>if charData:get("condensed", true)["dragon"] then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>is shocked by the electrical charge!</string>
						<string>chokes and gasps on the poison fumes!</string>
						<string>is splattered by the sizzling acid!</string>
						<string>is slammed by the powerful blast of air!</string>
						<string>staggers in pain as the massive tail smashes into</string>
						<string>is knocked down on</string>
						<string>is chilled by the glacial frost!</string>
						<string>is scorched by the intense flames!</string>
						<string>screams in terror as</string>
						<string>is gassed by</string>
						<string>breathes cold.</string>
						<string>is partly turned to ashes, as</string>
						<string>is drained by the negative energy!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>archery gags</name>
					<script>if charData:get("condensed", true)["arrows"] then
  if groupList:ingroup(matches[2]) or matches[2] == "" or matches[2] == nil then
    eraseLine()
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) fires .*</string>
						<string>([A-Za-z]+)'s arrows are turning into large shards of ice as they are fired!</string>
						<string>ammunition, but doesn't seem to find any.</string>
						<string>Crack! It impacts on</string>
						<string>is struck by the hail of thorns!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ItemProcGags (2)</name>
					<script>--Jazarr slightly wounds a baby green dragon with his strong bludgeon.
--[proc: a four-headed battleaxe of abyssal doom]
--shudder pitifully as he fights to cling to conciousness, when
--at the very last moments of effectiveness, the wave changes form.
--It shoots out tens of tiny thin wisps of energy, each alike and
--writhing in unison as they wend their way up a baby green dragon's body,
--forming into a compact mass. Growing double upon itself, the mass
--soon consumes a baby green dragon, turning him into a quivering mound of
--... nothing.
--a baby green dragon is dead! R.I.P.

--shudder pitifully as he fights to cling to conciousness. As the
--assault begins to fade, Lavis Ryl is unable to recover and falls
--to the ground. As you watch, the space all around their body
--shrinks and expands nearly constantly. Unable to withstand the
--massive forces directed at him, Lavis Ryl ceases the struggle
--at last and the magics release their hold.

--You scream in pain as your wrists are sliced open within your own gauntlets!
--Blood starts dripping down your arms as your vision blurs, causing you
--to fly into a maddening rage. Your entire world turns crimson as the intense
--fury of battle overwhelms you!

--As the nasty spikes on your gauntlets tear into the flesh of your opponent
--something inside your head triggers a seemingly infinite loop of carnage,
--repeating itself over and over. Your movement speed increases with every loop
--as you focus in on the bloodshed.

--Suddenly the room is filled with dark clouds, the very ground before Rahas 
--apparantly not quite as it had seemed just a moment ago. You picture Rahas
--dashing through some mystical land, on his way to a demon infested dungeon.
--Just before he arrives at it's entrance, a whisper is about the air. The 
--trickery of Brandobaris is suddenly apparent! You blink and it is all gone.
--Only Rahas seems to be grining.

--Enona's an enchanted khanjari dagger. As the finger-like tendrils writhe and wriggle
--their way up her arms, Enona is infused with a surprising finesse of movement.

--Nukakukac's eyes flash green, and he grins evilly.  Venomous toxins
--ooze from the dread gythka, and cause the blade to acquire an
--oily sheen.  The toxins are forced into Seipora Rein's bleeding wounds
--as Nukakukac slashes wildly.
--Nukakukac sends a small amount of caustic goo flying from his dread gythka,
--hitting Corland Deepforge squarely in the chest.

--An arched and jagged wave of negative energy lashes out in a great
--cone from the massive quadribladed axe wielded by Lilpekal. The
--space between Lilpekal and Corland Deepforge seems to spin wildly as the
--cone of energy penetrates its stunned victim. Corland Deepforge begins to
--shudder pitifully as he fights to cling to consciousness.

if charData:get("condensed", true)["items"] then
  eraseLine()

  if matches[2] == "bloodstone" then
    cecho("\n&lt;blue&gt;[proc: a bloodstone studded shortsword]\n")
  end

  if matches[2] == "crimson" then
    cecho("\n&lt;blue&gt;[proc: a glowing crimson dagger]\n")
  end

  if matches[2] == "gythka" then
    cecho("\n&lt;blue&gt;[proc: the enchanted dread gythka of the thri-kreen]\n")
  end

  if matches[2] == "quadribladed" then
    cecho("\n&lt;blue&gt;[proc: a four-headed battleaxe of abyssal doom]\n")
  end

  if matches[2] == "shards" then
    cecho("\n&lt;blue&gt;[proc: a set of frozen ice shard greaves]\n")
  end

  if matches[2] == "gauntlets" then
    cecho("\n&lt;blue&gt;[" .. whoami() .. " : a pair of berserker battle gauntlets &lt;green&gt;(stat increase)&lt;blue&gt;]\n")
  end

  if matches[2] == "spikes" then
    cecho("\n&lt;blue&gt;[" .. whoami() .. " : a pair of berserker battle gauntlets (hitall)]\n")
  end

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>rush suddenly, pivoting around on the ball</string>
						<string>foot to reverse</string>
						<string>With a sudden feint,</string>
						<string>attack routine with a dizzying flourish.</string>
						<string>slashes a (bloodstone) studded shortsword towards</string>
						<string>flinches back reflexively.  Paired sets of runes along</string>
						<string>spins about agilely, driving a powerful slash into</string>
						<string>body with a bloodstone studded longsword.  As the blade is wrenched clear of</string>
						<string>^the wound, .*</string>
						<string>glowing (crimson) dagger bathes the room in eerie crimson light as a scathing beam</string>
						<string>of pulsing pale energy fires from the blade at</string>
						<string>of pulsing green energy fires from the blade at</string>
						<string>nearly trips and falls.</string>
						<string>glowing crimson dagger draws green energy into itself.</string>
						<string>The dagger bursts into brilliant crimson fire which engulfs</string>
						<string>of pulsing dark energy fires from the blade at</string>
						<string>eyes flash green, and</string>
						<string>ooze from the dread (gythka), and cause the blade to acquire an</string>
						<string>oily sheen.  The toxins are forced into</string>
						<string>slashes wildly.</string>
						<string>sends a small amount of caustic goo flying from .* (gythka)</string>
						<string>hitting .* squarely in the chest.</string>
						<string>An arched and jagged wave of negative energy lashes out in a great</string>
						<string>cone from the massive (quadribladed) axe wielded by</string>
						<string>seems to spin wildly as the</string>
						<string>cone of energy penetrates its stunned victim.</string>
						<string>fights to cling to consciousness.</string>
						<string>You scream in pain as your wrists are sliced open within your own (gauntlets)!</string>
						<string>Blood starts dripping down your arms as your vision blurs, causing you</string>
						<string>to fly into a maddening rage. Your entire world turns crimson as the intense</string>
						<string>fury of battle overwhelms you!</string>
						<string>As the nasty (spikes) on your gauntlets tear into the flesh of your opponent</string>
						<string>something inside your head triggers a seemingly infinite loop of carnage,</string>
						<string>repeating itself over and over. Your movement speed increases with every loop</string>
						<string>as you focus in on the bloodshed.</string>
						<string>shudder pitifully as he fights to cling to conciousness. As the</string>
						<string>assault begins to fade, </string>
						<string>to the ground. As you watch, the space all around their body</string>
						<string>shrinks and expands nearly constantly. Unable to withstand the</string>
						<string>massive forces directed at </string>
						<string>at last and the magics release their hold.</string>
						<string>All of a sudden, your a set of frozen ice shard greaves explode</string>
						<string>in a shower of frost. The cloud of frost reforms into jagged,</string>
						<string>razor-sharp (shards) of eternal ice which form a protective shield</string>
						<string>of frozen razors around you. Revolving around you at an impossible</string>
						<string>speed, the frozen blades seem to be ready to rend the flesh from </string>
						<string>any foolish being who makes the costly mistake of getting too</string>
						<string>close to the gyrating blades of eternal ice.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ItemProcGags (3)</name>
					<script>--cone from your massive quadribladed axe. The space between you and
--penetrate her body. Still, she shudders pitifully, trying to cling to
--consciousness as the incredible power finally begins to subside.


--A moonblade with a golden hilt blurs into motion, striking
--flurry of attacks slices open cross-cuts across
--slides a moonblade with a golden hilt across the wound
--to inflict even greater damage.
--The runes along a moonblade with a golden hilt abruptly glow fiercely, emitting a
--warm glow that drifts across
--its body, and a loud sizzling sound can be heard as its body dissolves
--under the positive energy.
--seems to wilt under the positive energy discharge, cringing back away from the glare.



--Tafi kneels to the ground, wrapping her cloak around her body, chanting
--softly.  Smoke begins to issue from her cloak and begins to swirl around her 
--entire body, obscuring her in a swirling maelstrom of colors.  You see
--small disturbances in the column of smoke, tails flying out, wings breaking

--dragons are spinning around Tafi in the smoke, each representing a 
--different color.  The dragons suddenly break out of the column, and take spots 
--a few feet away from Tafi, their heads pointing down at her, their wings softly 
--beating. In unison, they all breathe their magic onto her, white, red, black
--blue and green breath slams into her resting body, disappating the smoke column
--and creating an aura around her, coating her with their basic elemental essence.
--The five dragons then begin to swirl around her, picking up speed, until they are 
--just a blur.  Then each swirling color breaks off from the group, flying into
--her cloak, reverting to the depiction of the dragon they represented.

--Xerena jumps back and holds both of her red dragon fanged daggers out
--in front of her. The blades of the daggers begin to glow and ignite in
--flames. A billowing vortex opens up and unleashes images of Ilxarzzinazzium,
--Fierrosa, Infernos, and Scorxariam into the room.  The dragons savagely tear at
--everything in sight with their giant talons. Fire blankets the battlefield
--searing everything.  Giant spiked tails flail about haphazardly crushing
--anything they hit!



--You take a few steps back as you notice Razz's greaves explode in a 
--shower of frost, only to reform about him as rotating blades of
--eternal ice. Even from a distance you can feel the deadly cold's touch
--sting your face as the jagged ice shards gyrate furiously. It would be
--foolish to move any closer to him.

if charData:get("condensed", true)["items"] then
  eraseLine()

  if matches[2] == "khanjari" then
    cecho("\n&lt;blue&gt;[proc: an enchanted khanjari dagger]\n")
  end

  if matches[2] == "greaves" then
    cecho("\n&lt;blue&gt;[proc: a set of frozen ice shard greaves]\n")
  end

  if matches[2] == "Vaprak" then
    cecho("\n&lt;blue&gt;[proc: stupid legging proc]\n")
  end


end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>softly.  Smoke begins to issue from</string>
						<string>in a swirling maelstrom of colors.  You see</string>
						<string>small disturbances in the column of smoke, tails flying out, wings breaking</string>
						<string>dragons are spinning around </string>
						<string>different color.  The dragons suddenly break out of the column, and take spots</string>
						<string>, their heads pointing down at</string>
						<string>beating. In unison, they all breathe their magic onto</string>
						<string>blue and green breath slams into </string>
						<string>and creating an aura around</string>
						<string>The five dragons then begin to swirl around</string>
						<string>just a blur.  Then each swirling color breaks off from the group, flying into</string>
						<string>cloak, reverting to the depiction of the dragon they represented.</string>
						<string>(greaves) explode in a</string>
						<string>shower of frost, only to reform about </string>
						<string>eternal ice. Even from a distance you can feel the deadly cold's touch</string>
						<string>sting your face as the jagged ice shards gyrate furiously. It would be</string>
						<string>foolish to move any closer to</string>
						<string>A ghostly portal suddenly opens, and a tall spectral troll steps out. He nods</string>
						<string>and whistles. The ancient ghost of a venerable silver dragon appears</string>
						<string>high above. It cries out, and a woosh of infernal energy radiates about the area</string>
						<string>augmenting those whomm are acknowledged by (Vaprak).</string>
						<string>Icis the Frigid snaps into visibility...and pats</string>
						<string>A wild elf of Darktree appears from behind a tree.</string>
						<string>An infernal giant strides in...and kicks</string>
						<string>A goblin tinker sneaks up and stabs</string>
						<string>who temporarily ducks out of sight.</string>
						<string>gasps and turns pale as an iron golem passes by.</string>
						<string>A group of elite soldiers march up and salute</string>
						<string>A lightning elemental flies in...and embraces</string>
						<string>kneels to the ground, wrapping</string>
						<string>the edges of the column, quiet grumblings breaking the silence.  Five tiny</string>
						<string>an enchanted (khanjari) dagger. As the finger-like tendrils writhe and wriggle</string>
						<string>is infused with a surprising finesse of movement.</string>
						<string>blinks as if</string>
						<string>A moonblade with a golden hilt blurs into motion, striking</string>
						<string>flurry of attacks slices open cross-cuts across</string>
						<string>slides a moonblade with a golden hilt across the wound</string>
						<string>to inflict even greater damage.</string>
						<string>The runes along a moonblade with a golden hilt abruptly glow fiercely, emitting a</string>
						<string>warm glow that drifts across</string>
						<string>its body, and a loud sizzling sound can be heard as its body dissolves</string>
						<string>under the positive energy.</string>
						<string>seems to wilt under the positive energy discharge, cringing back away from the glare.</string>
						<string>it's giant max.  The head of Ilxarzzinazzium chews through</string>
						<string>spits the lifeless, partially eatten body on the ground.  As suddenly as the head appeared,</string>
						<string>is scorched by the storm of fire.</string>
						<string>cone from your massive quadribladed axe. The space between you and</string>
						<string>shudders pitifully, trying to cling to</string>
						<string>consciousness as the incredible power finally begins to subside.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SpellGags (2)</name>
					<script>-- screams in exquisite pain as a lightning bolt unleashed by

if charData:get("condensed", true)["spells"] then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>screams in exquisite pain as a lightning bolt unleashed by</string>
						<string>Bits of flesh fall to the floor as</string>
						<string>exposed skin shrivels and cracks in the extreme heat.</string>
						<string>his body, and a loud sizzling sound can be heard as his body dissolves</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Consent</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Bitel has revoked her consent.</name>
					<script>consent:set( matches[2], nil)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) has revoked (his|her|its) consent.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>consent triggers</name>
					<script>-- Thaemos is consenting you.

consent:set(matches[2], true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) is consenting you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Corpse of Ilinal is lying here.</name>
					<script>-- ressurect corpses if not fighting, autores enabled, and spellcast enabled
-- 2/28/23 - added shaman (rd)

local charname = matches[3]

if groupList:ingroup( charname ) then
  --if consent:get(charname) then

    -- should only echo if not gagged
    --if not gaglook then
    -- cecho(" &lt;green&gt;(consented)")
    --end

    if (not checkMask("cle") and not checkMask("sha")) or not charData:get("autocast") then
      return
    end
    
    -- last command entered was look direction or scan - return  TODO: clair also
    if string.find(command, "L ") == 1 or string.find(command, "l ") == 1 or string.find(command, "look ") == 1 or command == "SCAN" then
      return
    end

    if checkMask("cle") and charData:get("autores") and not inCombat() then
      -- mark as to res

      if getSpellCount("resurrect") &gt; 0 then
        spell:setNext("resu " .. matches[3])
      end

      return
    end
  
    if checkMask("sha") and charData:get("autord") and not inCombat() then
      -- mark as to res

      if getSpellCount("raise_dead") &gt; 0 then
        spell:setNext("RD " .. matches[3])
      end

      return
    end

  --end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(Corpse) of ([A-Za-z]+) is lying here.</string>
						<string>(drags) corpse of ([A-Za-z]+) along behind .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Sounds</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tells you</name>
					<script>sound("320181__dland__hint.wav",nil,true)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>tells you</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ressurect sound</name>
					<script>-- open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving
-- hand reaching down to touch ([A-Za-z]+) and .*
-- When it at last clears ([A-Za-z]+) stands before you, looking extremely tired!
-- ([A-Za-z]+) takes a first shuddering breath and rises from the dead. 

sound("139025__rj10328__131659-bertrof-game-sound-intro-to-game-80921-justinbw-buttonchime02up-4.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving</string>
						<string>hand reaching down to touch ([A-Za-z]+) and .*</string>
						<string>^([A-Za-z]+) takes a first shuddering breath and rises from the dead. </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Lilithelle drags corpse of Venumma along behind her.</name>
					<script>-- Yinelinol drags corpse of Kitra along behind him.
-- Misi drags corpse of Kitra along behind her.

-- Send consent request to corpse if person dragging was not cleric,
-- and corpse owner is grouped

-- Lilabipple drags corpse of General Edmund Blitz along behind her.

-- display( groupList:ingroup(matches[2]) )

-- consent requirement to res was removed
--if charData:get("echodrag") then
--  if whoclass(matches[2]) ~= "Cle" and groupList:ingroup(matches[3]) then
--    mud:send("t " .. matches[3] .. " consent")
--  end
--end

-- corpse drag sound
sound("327909__ruonvniekerk__dragging-on-floor.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?^(.*) drags corpse of (.*) along behind (him|her|it).$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>looting coins</name>
					<script>-- looting coins
sound("343462__rocotilos__real-coin-drop.wav")

-- look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* gets a small pile of coins from corpse of .*</string>
						<string>.* gets a few coins from corpse.*</string>
						<string>^(?:&lt; .* &gt; )?You get a few coins from corpse.*</string>
						<string>^(?:&lt; .* &gt; )?You get a small pile of coins from corpse.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>inferno sound</name>
					<script>sound("45809__themfish__gas-fire-catch.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?The area erupts in a massive INFERNO of heat and flames!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dragon roar</name>
					<script>-- A black dragon scout spreads his wings and ROARS, filling your heart with terror!
-- A young red dragon spreads his wings and ROARS, filling your heart with terror!

-- TODO - tiamat - https://www.freesound.org/people/tambascot/sounds/203105/


--display("dragon sound")

sound("85568__joelaudio__dragon-roar.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* wings and ROARS, filling your heart with terror!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are burned as you hit</name>
					<script>sound("368014__trngle__burning-match-into-water.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You are burned as you hit</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>MobAlerts</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>An ogre shaman from Faang watches you closely.</name>
						<script>-- ^(?:&lt; .* &gt; )?A servant of the Keep's lady is here tending official business.

sound("72127__kizilsungur__sweetalertsound3.wav")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?An ogre shaman from Faang watches you closely.</string>
							<string>^(?:&lt; .* &gt; )?A servant of the Keep's lady is here tending official business.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Rares</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A shimmering portal of emerald mist floats in the air here.</name>
						<script>-- zoar portal</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A shimmering portal of emerald mist floats in the air here.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You find</name>
					<script>-- You find a secret exit south!</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You find .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>An ice weird utters the words, 'iuophwabraz'.</name>
				<script>-- should be cleric only

if checkMask("cle") then
  spell:setNext("sp weird")
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>weird utters the words, 'iuophwabraz'.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>MobCapture</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Dragor Keenblade is a medium-sized level 56 shield dwarf. Are you mad!?</name>
					<script>mobs = mobs or {}

conSent=nil

-- room number : map:getRoom()
-- mobname
-- keywords (list)

local roomid = map:getRoom()

local mobname = matches[2]:trim()
local mobsize = matches[3]
local moblvl = matches[4]
local mobrace = matches[5]


if roomid ~= nil then
  mobs[roomid] = {[mobname]={moblvl,mobsize,mobrace} }
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z '-]+) is a ([A-Za-z]+)-sized level ([0-9]+) (.*)[.].*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>They're not here!</name>
					<script>conSent=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>They're not here!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>PracticeSkills</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capture skills</name>
					<script>-- meditate                  (bad)           (21) 4 g, 1 s, and 1 c coins

-- mounted combat            (neophyte)      (8) 1 s coin

-- ^(.+) +\((bad|unlearned|neophyte|poor|very\sgood|below\saverage|average|above\saverage|good)\) +\([0-9]+\) .*coin.*

toPractice = toPractice or {}

local skillname = matches[2]

if skillname ~= nil then
  skillname = skillname:trim()
else
  display("error")
  display(matches)
  return
end

toPractice[skillname] = true
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.+) +\((bad|unlearned|neophyte|poor|very\sgood|below\saverage|average|above\saverage|good)\) +\([0-9]+\)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capture scribable spells - trainer</name>
					<script>toScribe = toScribe or {}

local spellname = matches[2]:trim()

toScribe[spellname] = true</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) +([0-9]+)(nd|rd|th) circle [0-9].*coin.*</string>
						<string>^(.*) +1st circle $</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>resend practice</name>
					<script>mud:send("prac " .. matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You practice '(.*)' for a while...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You don't feel comfortable enough to start to scribe.</name>
					<script>mud:send("rest")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You don't feel comfortable enough to start to scribe.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>scribenext</name>
					<script>-- scribe next
for k,v in pairs(toScribe) do
  mud:send("prac " .. k)
--  mud:send("scribe " .. k)
  toScribe[k]=nil
  return
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You finish scribing spell</string>
						<string>You already have that power in your spellbook.</string>
						<string>You already have that spell in your spellbook.</string>
						<string>You can't learn that power.</string>
						<string>You don't have that spell in any of your books or scrolls in learnable form!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>copyspells</name>
					<script>-- Detect Invisibility        1st circle [in spellbook]

toScribe = toScribe or {}

local spellname = matches[2]:trim()

toScribe[spellname] = true</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) +([0-9]+)(nd|rd|th) circle \[in spellbook\]</string>
						<string>^(.*) +1st circle $</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>reset skill table</name>
					<script>-- You can practice any of the following skills/spells:

toPractice = {}</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You can practice any of the following skills/spells:$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Resting now will most likely lead to your final rest!</name>
				<script>-- in combat, though prompt might have yet to update</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Resting now will most likely lead to your final rest!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>force switch</name>
				<script>--An (ice) golem .*, fighting
-- removed in ice^ gf only

if matches[2] == "ice" and map:getCurrentZone() ~= "The Golem Forge" then
  return
end

if prompt:get("enemy") ~= matches[2] then
  mud:send("kill " .. matches[2] )
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The (nightwing) .* fighting .*</string>
					<string>An (ice) golem .*, fighting</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Followers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Follower summary for</name>
					<script>-- start of followers on screen

--Follower summary for Nyyrazzilyss:
--Number of Followers: 1

--NPC:
--   274/274   HP  137/137  MV      + an opulent merchant (merchant opulent)


followers = matches[2]

pet:reset()

enableTrigger("endfollowers")
enableTrigger("capturefollower")
enableTrigger("gagpcfol")

if gagfollowers then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Follower) summary for .*:$</string>
						<string>You have no followers.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endfollowers</name>
					<script>-- disable trigger on first prompt

-- followers command has been sent/received
followersSent=nil

gagfollowers=true

disableTrigger("capturefollower")
disableTrigger("endfollowers")
disableTrigger("gagpcfol")

pet:cleanNames()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&gt;\t\n$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capturefollower</name>
					<script>--   2505/2505  HP  152/152  MV      + a gray slaad (gray slaad anvil)
--   2471/2569  HP  192/192  MV      + a hell hound (hell hound direraidermount wolf)
--     72/72    HP  167/167  MV      + a pack pony (pony pack)"a pack pony"
--  2317/2401  HP  197/197  MV      + a zealous griffon (griffon zealous mount paladinmount)
--  539/539   HP  152/152  MV      + the ghost of a human noble (ghost undead)
--   849/518   HP  153/153  MV      + the spectre of a human noble (spectre undead)

--    237/237   HP  119/119  MV      + a dapper noble (noble dapper)
--    47/255   HP  120/120  MV      - a dapper noble (noble dapper)


--PC:
--   303/303   HP  106/106  MV      + Vivizaza
--   538/538   HP  133/137  MV      + Kurrak
--   235/235   HP  135/135  MV      - Nonfanos


local keywordlist=matches[6]


local keywords= string.split(keywordlist, " ")

local keyword=keywords[1]

local fullname=matches[5]:trim()

local inroom = matches[4]   -- is the pet in the current room +=yes, -=no

if pet:isNamed( keywordlist ) then
  keyword= pet:isNamed(keywordlist)
  -- confirm name used

  pet:confirmName(keyword)
end

-- name un-named pets
if #keywords == 2 then
  mud:send("FOLLOWERS name " .. keyword .. " " .. pet:generateNumberName(keyword) )
end

pet:add(keyword, fullname, tonumber(matches[2]), tonumber(matches[3]), inroom, keywords )

-- set pet as being in this room
if inroom == "+" then
  pet:setRoom(keyword, map:getRoom() )
else
  -- use last known room for pet
  pet:setRoom(keyword, pet:getOldRoom(keyword) )
end



if gagfollowers then
  eraseLine()
end

if inroom == "-" then
  cecho("\n&lt;blue&gt;[&lt;green&gt;" .. string.title(fullname) .. " &lt;blue&gt;is not in the room]\n")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^ *([-0-9]+)/([0-9]+) +HP +[0-9]+/[0-9]+ +MV *([+-]) (.*)\((.*)\)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>starts/stops following you.</name>
					<script>--You breathe life into corpse of a frost giant warrior with the awesome power of your art.
--The wight of a frost giant warrior starts following you.
-- The spectre of a human noble starts following you.

if matches[2] == "otherworldly" then
  mud:send("O followers snap")
end

gagfollowers=true

sendFollowers()
group:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>starts following you.</string>
						<string>Smoke begins to pour out of your bracer, swirling around you in a dizzying</string>
						<string>stops following you.</string>
						<string>You feel the presense of an (otherworldly) being enter the room.</string>
						<string>That person isn't here.</string>
						<string>hates your guts!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>One, is the loneliest number...</name>
					<script>-- You have no followers.

pet.followers = {}
pet.used = {}

if checkMask("fighter") then
  mount:setMounted(false)
  mount:set(nil)
end

group:send()

if gagfollowers then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>One, is the loneliest number...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>*, fighting ({@NyyLIB/RescueListClass/rescuelist|YOU}){!|.}</name>
					<script>local who = matches[2]

local petrescue=rescuelist:get()

-- last command entered was too look in a direction - return
if string.find(command, "look ") == 1 or string.find(command, "l ") == 1 then
  return
end

-- combat is occuring in this room
roomCombat=true

if petrescue == nil then
  return
end

if who == "YOU" then
  who = whoami()
else
  if table.contains(petrescue, who) == false then
    return
  end
end

if charData:get("petrescue") ~= "NONE" then
  if who == whoami() then
    NyyLIB.torescue=whoami()
    return
  end
end

if charData:get("petrescue") == "ALL" then
  if NyyLIB.torescue ~= whoami() then
    local member  = table.index_of(petrescue, who)
    local already = table.index_of(petrescue, NyyLIB.torescue)

    if NyyLIB.torescue == "" then
      already=30
    end

    if member &lt; already then
      NyyLIB.torescue = who
    end
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*[,] fighting (.*)[.]</string>
						<string>.*[,] fighting (YOU)!.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ok.</name>
					<script>-- command has been sent to pet

petcommand=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Ok.$</string>
						<string>is busy, but will execute your order as soon as possible.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The ghost of a human noble completes its spell...</name>
					<script>-- spell completed</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The ghost of a human noble completes its spell...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Name (zzz) added to the ghost of a human noble successfully.</name>
					<script>-- This name is now assigned

pet:useName( matches[2] )
sendFollowers()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Name \((.*)\) added to (.*) successfully[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>followers gags</name>
					<script>if gagfollowers then
  eraseLine()
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Number of Followers:.*</string>
						<string>^NPC:$</string>
						<string>You have no followers.</string>
						<string>^PC:$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>pet spellcasting</name>
					<script>-- The wraith of a human noble completes its spell...</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) completes its spell...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The spectre of a human noble heroically rescues the wight of a human noble.</name>
					<script>-- The spectre of a human noble heroically rescues the wight of a human noble.

if pet:member(matches[2]) then
  sendFollowers()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* heroically rescues (.*)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The spectre of a human noble fails miserably in its attempt to rescue you.</name>
					<script>-- The spectre of a human noble fails miserably in its attempt to rescue you.

local name=pet:member(matches[2])

if name then
  mud:send("ORDER " .. name .. " rescue " .. whoami() )
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) fails miserably in its attempt to rescue you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ghost getting attacked</name>
					<script>--A disgusting slithering vine badly wounds the ghost of a shambling mound with its powerful bite.

-- ghost getting attacked

local ghostname=pet:member(matches[2])

if ghostname and not ghostRescue then
  if pet:status("spectre") then
    local petname= pet:getTable("spectre")[1]

    ghostRescue = true

    mud:send("ORDER " .. petname .. " rescue " .. ghostname)
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* wounds (the ghost .*) with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The spectre of a human noble heroically rescues the ghost of a human noble.</name>
					<script>ghostRescue=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^The spectre .* heroically rescues the ghost .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Aren't we funny today...</name>
					<script>sendFollowers()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Aren't we funny today...</string>
						<string>has quit the game, consent lost.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>follower movement</name>
					<script>-- The skeleton of a dapper noble shambles in from the south.
-- The skeleton of a dapper noble shambles in from below.
-- A gray slaad flies in from the south.
-- The spirit worg flies in from the east.

-- The shadow of a dockhand flies in from the west.

-- TODO: multiple pets with identical names

local shortname= idMob(matches[2])
--local petname= pet:member( matches[2] )

for k,name in pairs( pet:getTable(shortname) ) do
  if pet:getRoom(name) ~= map:getRoom() then
    pet:setRoom(name, map:getRoom() )
    pet:setInRoom(name, true)
    return
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) shambles in from .*[.]</string>
						<string>^(.*) flies in from .*[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>follower ordered movement</name>
					<script>-- The spectre of a human noble flies west.

local roomid = map:getRoom()
local petname = pet:member(matches[2])
local dirmoved = matches[3]

if roomid == nil or not petname then
  return
end

-- move pet to bordering room

pet:setRoom(petname, getRoomExits(roomid)[dirmoved])
pet:setInRoom(petname, false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) flies (north|south|east|west|up|down)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>gagpcfol</name>
					<script>-- ^ *([-0-9]+)/([0-9]+) +HP +[0-9]+/[0-9]+ +MV *([+-]) (.*)\((.*)\)$

-- gag pc followers

if gagfollowers then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^ *([-0-9]+)/([0-9]+) +HP +[0-9]+/[0-9]+ +MV *([+-]) (.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The shadow of a dockhand stands here.</name>
					<script>-- check current room

-- command ~= "look" then

if command ~= "L" and command ~= "LOOK" then
  return
end

local shortname= idMob(matches[2])
--local petname= pet:member( matches[2] )

for k,name in pairs( pet:getTable(shortname) ) do
  if pet:getRoom(name) ~= map:getRoom() then
    pet:setRoom(name, map:getRoom() )
    pet:setInRoom(name, true)
    return
  end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) stands here.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You have no followers.</name>
					<script>nofollowers = true</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You have no followers.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>have a follower</name>
					<script>nofollwers = false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Smoke begins to pour out of your bracer, swirling around you in a dizzying</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Utilities</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CapturePowers</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>powers list</name>
						<script>-- Sandblast                           Spell     Study      Level 46

powerslist = powerslist or {}

sortpowerslist={}

-- info needed: capture spellname, level



powerslist[#powerslist+1] = { matches[2]:trim(), matches[3]:trim()}

display(powerslist[#powerslist])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*)\[([a-z]+).*\] +(Study) .+circle</string>
							<string>(.*)\[([a-z]+).*\] +(At will) .+circle</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>capture name</name>
						<script>-- Name             : Sandblast

powername = matches[2]:trim()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Name             : (.*)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>capture alias</name>
						<script>-- Alias            : sb     

--

sortpowerslist = sortpowerslist or {}


-- info needed: powername, alias, chardata, function

local level=nil

if powerslist == nil then
  return
end


for nx=1, #powerslist, 1 do
  if powerslist[nx][1] == powername then
    level=powerslist[nx][2]
  end
end

if level == nil then
  display("Unable to find level")
  return
end

sortpowerslist[#sortpowerslist+1] = {to_snake(powername), matches[2]:trim(), level, "", ""}
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Alias            : (.*)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>end class</name>
						<script>disableTrigger("CapturePowers")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>&lt; .* &gt;</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>spell powers v2</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>spellname</name>
						<script>-- Elemental Fire Embodiment           [efe   ]   Study           10th circle

capSpellList = capSpellList or {}

capSpellList[#capSpellList+1] = matches[2]:trim()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z ]+)\[[a-z ]{6}\]   Study           [0-9]0?(st|nd|rd|th) circle</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Rugrag futilely tries to rescue Lilabipple!</name>
				<script>if groupList:ingroup(matches[2]) then
  pet:rescue(matches[3])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(.*) futilely tries to rescue (.*)!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Recharge</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endrecharge</name>
					<script>disableTrigger("capturerecharge")
disableTrigger("endrecharge")

nogagRecharge=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt;.*&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The following powers are currently recharging:</name>
					<script>--The following powers are currently recharging:

-- - Eviscerate in 21 seconds 1 pulse 
-- - Sweeping Strike in none

enableTrigger("capturerecharge")
enableTrigger("endrecharge")

if not nogagRecharge then
  eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The following powers are currently recharging:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capturerecharge</name>
					<script>-- Sandstorm in ([0-9]+) seconds .*

--The following powers are currently recharging:

-- - Eviscerate in 21 seconds 1 pulse 
-- - Sweeping Strike in none
-- - Armor Splinter in 1 second 3 pulses 

--  - Furious Assault in 1 minute 6 seconds 

--  - Sandstorm in 5 minutes 45 seconds 1 pulse 
--  - Sandstorm in 2 minutes 2 seconds 2 pulses 

--  - Dominating Smite in none

local powername = to_snake(matches[2])

local timeleft

if matches[2] == "recharging" or matches[3] == "none" or matches[3] == "pulse" then
  timeleft=0
else
  if matches[4] == nil then
    timeleft = tonumber(matches[3])
  else
    timeleft = tonumber(matches[3])*60
    
    if tonumber(matches[4]) then
      timeleft = timeleft + tonumber(matches[4])
    end
  end
end

timer:set(powername, timeleft)


if not nogagRecharge then
  eraseLine()
end


-- cecho("&lt;red&gt; [" .. powername .. ":" .. timeleft .. "]\n")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> - ([A-Z][A-Za-z ]+) in ([0-9]+) seconds .*</string>
						<string> - ([A-Z][A-Za-z ]+) in ([0-9]) minutes? ([0-9]+) seconds?</string>
						<string> - ([A-Z][A-Za-z ]+) in (1) second .*</string>
						<string> - ([A-Z][A-Za-z ]+) in (none)</string>
						<string> - ([A-Z][A-Za-z ]+) in [123] (pulse) </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>autoclose</name>
				<script>mud:send("close door")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The door is opened from the other side.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't see who is fighting</name>
				<script>-- need di

if checkMask("ran") then
  if spell:getSlot(2) &gt; 0 then
    spell:cast("BSE")
  end
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't see who is fighting</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>clickable url</name>
				<script>for i,v in ipairs(matches) do
  selectString(matches[i], 1)
  setLink([[openUrl("]]..matches[i]..[[")]], matches[i])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>\b(?:(?:(?:https?|ftp|telnet)://[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+|www|ftp)(?:\.[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+)+|[\w\d._%+\-]+@[\w\d.\-]+\.[\w]{2,4})\b</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>paging</name>
				<script>pagingmode = true</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[RETURN for more, q to quit\]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>PowersSpells</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You have the following spells available:</name>
					<script>-- enable trigger group

enableTrigger("powersSpellsCapture")
enableTrigger("promptendspells")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have the following spells available:$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>promptendspells</name>
					<script>-- disable trigger

disableTrigger("powersSpellsCapture")
disableTrigger("promptendspells")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&gt;\t\n$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>powersSpellsCapture</name>
					<script>--  - Heroism

cecho("  &lt;cyan&gt;[" .. string.upper(tostring( powerAliases:getAlias( to_snake(matches[2])) )) .. "]")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^ - ([A-Za-z ]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You aren't wearing anything!</name>
				<script>equip:setWeapon("None")

initClass()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You aren't wearing anything!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't do that without solid ground underneath you!</name>
				<script>timer:set("noground", 30)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't do that without solid ground underneath you!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Rerolling this character.</name>
				<script>-- Autoroll: This displays rolling stats summary

if isActive("RollerTrigger", "trigger") == 0 then
  return
end


clearWindow()

-- set start time as epoch
rollTime = rollTime or os.time()

local currentTime=os.time()

local rollTarget = charData:get("autoroll", true)

if NyyLIB.roller ~= 0 then
  --rollerstats[NyyLIB.roller] = rollerstats[NyyLIB.roller] + 1

  local nx
  local total=0
  
  local echostring = "\n&lt;cyan&gt;["
  
  for nx=1,(rollTarget-1),1 do
        
    local val=rollerstats[nx]
  
    total=total+val
    
    echostring = echostring .. " " .. nx .. ": " .. val
  end
    
  cecho( echostring .. "]\n" )  
  cecho( "&lt;cyan&gt;[Total Rolls: " .. total .. " Last Roll: " .. NyyLIB.roller .. " Target: " .. rollTarget .. "]\n")
  

  local rollDuration= currentTime-rollTime

  local speed= math.floor( total / (rollDuration / (60*60)) )
  
  local sec
  local min
  local hrs

  hrs=math.floor(rollDuration/(60*60))
  
  min=math.floor(rollDuration/60)-(hrs*60)

  sec=rollDuration-( ((hrs*60)+min)*60)

  cecho("&lt;cyan&gt;[Roll Time: " .. string.format("%d:%d:%02d", hrs, min, sec) ..
          " Rolls/hour: " .. speed .. "]\n")
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Rerolling this character.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>nobash</name>
				<script>-- set nobash

timer:set("nobash", 30)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>They are too small for you to do that!</string>
					<string>They are too large for you to do that!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Nah... You feel too relaxed to do that...</name>
				<script>mud:send("alert")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(?:&lt; .* &gt; )?Nah... You feel too relaxed to do that...$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>clunky bugfix</name>
				<script>tempTimer(.5, [[disableTrigger("minimap display")]] )</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>meld them to the fists.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>subClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>There are no sub-classes currently available to your class.</name>
					<script>subClass = ""</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^There are no sub-classes currently available to your class.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Available Sub-Classes:</name>
					<script>-- enable capture

enableTrigger("subclass capture")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Available Sub-Classes:$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>subclass capture</name>
					<script>
--* Draconic                 
--* Hellborne                 Damage         

subClass = to_snake( string.split(matches[2], "  ")[1] ):title()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\* ([A-Z][A-Za-z ]+).*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>disable subclass capture</name>
					<script>disableTrigger("subclass capture")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt; .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>class choose</name>
					<script>-- You have chosen the Voidcaller sub-class!

subClass= to_snake(matches[2]):title()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You have chosen the (.*) sub-class!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>null trigger</name>
				<script>display(matches[1])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>([\0])</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>NyyLIB</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>ClassAliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Bard</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>songs</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Offensive Harmony</name>
							<script>music( "drum", "song of offensive harmony", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^haste$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Healing</name>
							<script>if checkMask("singer") then
  music( "lute", "song of healing", "")
else
  mud:send("HEAL")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^heal$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Renewal</name>
							<script>music( "piccolo", "song of renewal", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^renew$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>The Elements</name>
							<script>music( "drum", "song of the elements", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^elements$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Harming</name>
							<script>music( "mandolin", "song of harming", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^harm$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Protection</name>
							<script>music("harp", "song of protection", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^prot$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Recovery</name>
							<script>music("piccolo", "song of recovery", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^recover$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Regeneration</name>
							<script>music("lute", "song of regeneration", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^regen$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Offensive Disruption</name>
							<script>music("trumpet", "song of offensive disruption", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^slow$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Sorcery</name>
							<script>music("piccolo", "song of sorcery", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^sorc$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Travel</name>
							<script>music("lute", "song of travel", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^travel$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Defensive Disruption</name>
							<script>music("trumpet", "song of defensive disruption", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^weak$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>stopmusic</name>
							<script>local label=findlabel("StopMusic")
label:echo([[&lt;p style="font-size:25px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;   &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])

mud:send("PLAY")

charData:set("song", "")
charData:set("_song", "")
charData:set("effect", "")
NyyLIB.songtimer = ""

resetSongs()
</script>
							<command></command>
							<packageName></packageName>
							<regex>^stopmusic$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Miscast</name>
							<script>music("mandolin", "song of miscast magic", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^miscast$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Defensive Harmony</name>
							<script>music("drum", "song of defensive harmony", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^defend$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Song of Revelation</name>
							<script>music("harp", "song of revelation", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^reveal$</regex>
						</Alias>
					</AliasGroup>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>spells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Harmonious Blessing</name>
							<script>mud:send("c 'harmonious blessing' me")</script>
							<command></command>
							<packageName></packageName>
							<regex>^bless$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Phantom Armor</name>
							<script>local cls = whoclass()

if cls == "Ctr" then
  spell:cast("c 'armor' " .. matches[2])
elseif cls == "Bar" then
  spell:cast("c 'phantom armor' " .. matches[2])
elseif cls == "Enc" then
  spell:cast("c 'energy shield' " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^armor (.*)</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Detect Invisibility</name>
							<script>if checkMask("sing") then
  spell:cast("c 'detect invis' " .. matches[2])
else
  spell:cast("DI " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^di (.*)</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Faerie Fire</name>
							<script>spell:setMoving(false)

spell:cast("FF " .. matches[2])</script>
							<command></command>
							<packageName></packageName>
							<regex>^ff (.+)$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Ray of Enfeeblement</name>
							<script>spell:setMoving(false)

if checkMask("singer") then
  spell:cast("c 'ray of enfeeblement'" .. (matches[2] or "") )
else
  spell:cast("RAY" .. (matches[2] or "") )
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^ray( .*)?</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Displacement</name>
							<script>-- displacement power is same as dragonscale

if checkMask("singer") then
  spell:cast("c 'displacement' " .. matches[2])
else
  spell:cast("DS " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^disp (.*)</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Feeblemind</name>
							<script>if checkMask("singer") then
  spell:cast("c 'feeblemind' " .. matches[2])
else
  spell:cast("FEEB " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^feeb (.*)</regex>
						</Alias>
					</AliasGroup>
					<Alias isActive="yes" isFolder="no">
						<name>accompany</name>
						<script>if NyyLIB.accompany == 0 then
  for k,char in pairs(groupList:pc("singer")) do
    if char ~= whoami() then
      mud:send("accompany " .. char)
      NyyLIB.accompany = 1
      return
    end
  end
else
  mud:send("accompany stop")
  NyyLIB.accompany = 0
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^accompany$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>escape dir return backstab</name>
						<script>mud:send("ESCAPE " .. matches[2])

NyyLIB.escapedir = matches[2]
NyyLIB.roguereturn = matches[3]</script>
						<command></command>
						<packageName></packageName>
						<regex>^es([nsewud])([cbp])?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Psi</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>^sneak([neswud])$</name>
						<script>expandAlias(matches[2], false)
mud:send("DARKNESS")</script>
						<command></command>
						<packageName></packageName>
						<regex>^sneak([neswud])$</regex>
					</Alias>
					<Alias isActive="no" isFolder="no">
						<name>shift</name>
						<script>mud:send("SHIFT " .. matches[2], false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^shift ([A-Za-z]+)$</regex>
					</Alias>
					<Alias isActive="no" isFolder="no">
						<name>rift</name>
						<script>--rift
mud:send("RIFT " .. matches[2], false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^rift (.*)$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Ctr</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>stone</name>
						<script>if whoclass() == "Ctr" then
  spell:cast("c 'stoneskin' " .. matches[2])
else
  spell:cast("ss " .. matches[2])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^stone ([A-Za-z]+)</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Lic</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>ssh</name>
						<script>local petname = pet:getCasterTable()[1]

spell:setMoving(false)

if petname ~= nil and not timer:get("petcast") then
  timer:set("petcast", 6)
  mud:send("ORDER " .. petname .. " cast 'soul shackles'")
  return
end

spell:setNext("SSH")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ssh$</regex>
					</Alias>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>LicSpells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>banshee wail</name>
							<script>spell:setMoving(false)
spell:setNext("BW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>death pact</name>
							<script>spell:setMoving(false)
spell:setNext("DP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ice tomb</name>
							<script>spell:setMoving(false)
spell:setNext("IT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:it)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>rain of blood</name>
							<script>spell:setMoving(false)
spell:setNext("RB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>rot</name>
							<script>spell:setMoving(false)
spell:setNext("ROT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rot)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>siphon undead</name>
							<script>spell:setMoving(false)
spell:setNext("SU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:su)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>siphon undead</name>
							<script>spell:setMoving(false)
spell:setNext("SU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:su)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>abi dalzims horrid wilting</name>
							<script>spell:setMoving(false)
spell:setNext("ABI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:abi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate ghost</name>
							<script>spell:setMoving(false)
spell:setNext("GHOST" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ghost)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>eradicate undead</name>
							<script>spell:setMoving(false)
spell:setNext("EU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>globe of invulnerability</name>
							<script>spell:setMoving(false)
spell:setNext("GI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>lich touch</name>
							<script>spell:setMoving(false)
spell:setNext("LT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate spectre</name>
							<script>spell:setMoving(false)
spell:setNext("SPECT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:spect)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blackmantle</name>
							<script>spell:setMoving(false)
spell:setNext("BM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>contagion</name>
							<script>spell:setMoving(false)
spell:setNext("CTG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ctg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>destroy undead</name>
							<script>spell:setMoving(false)
spell:setNext("DUN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dun)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>life drain</name>
							<script>spell:setMoving(false)
spell:setNext("LD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ld)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate wraith</name>
							<script>spell:setMoving(false)
spell:setNext("WRAITH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wraith)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>beltyns burning blood</name>
							<script>spell:setMoving(false)
spell:setNext("BBB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bbb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>corpse glamor</name>
							<script>spell:setMoving(false)
spell:setNext("CGLAM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cglam)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dimension door</name>
							<script>spell:setMoving(false)
spell:setNext("DIM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dim)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>haste</name>
							<script>spell:setMoving(false)
spell:setNext("HS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>locate remains</name>
							<script>spell:setMoving(false)
spell:setNext("LOCR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:locr)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protect undead</name>
							<script>spell:setMoving(false)
spell:setNext("PU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate ghast</name>
							<script>spell:setMoving(false)
spell:setNext("GHAST" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ghast)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor globe of invulnerability</name>
							<script>spell:setMoving(false)
spell:setNext("MGI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mgi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>nerve dance</name>
							<script>spell:setMoving(false)
spell:setNext("ND" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:nd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vampiric touch</name>
							<script>spell:setMoving(false)
spell:setNext("VT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ward undead</name>
							<script>spell:setMoving(false)
spell:setNext("WU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate wight</name>
							<script>spell:setMoving(false)
spell:setNext("WIGHT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wight)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>coldshield</name>
							<script>spell:setMoving(false)
spell:setNext("CSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:csh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cone of cold</name>
							<script>spell:setMoving(false)
spell:setNext("CONE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cone)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>energy drain</name>
							<script>spell:setMoving(false)
spell:setNext("ED" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ed)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>feeblemind</name>
							<script>spell:setMoving(false)
spell:setNext("FEEB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:feeb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>heal undead</name>
							<script>spell:setMoving(false)
spell:setNext("HU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ice storm</name>
							<script>spell:setMoving(false)
spell:setNext("IS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:is)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>infravision</name>
							<script>spell:setMoving(false)
spell:setNext("IV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:iv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>levitate</name>
							<script>spell:setMoving(false)
spell:setNext("LV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of enfeeblement</name>
							<script>spell:setMoving(false)
spell:setNext("RAY" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ray)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>snapping teeth</name>
							<script>spell:setMoving(false)
spell:setNext("SNP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:snp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>teleport</name>
							<script>spell:setMoving(false)
spell:setNext("TELE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tele)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate shadow</name>
							<script>spell:setMoving(false)
spell:setNext("SHADOW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:shadow)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>command horde</name>
							<script>spell:setMoving(false)
spell:setNext("COMH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:comh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel magic</name>
							<script>spell:setMoving(false)
spell:setNext("DISM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dism)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>embalm</name>
							<script>spell:setMoving(false)
spell:setNext("EMM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:emm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sleep</name>
							<script>spell:setMoving(false)
spell:setNext("SLP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:slp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>spectral hand</name>
							<script>spell:setMoving(false)
spell:setNext("SH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>strength</name>
							<script>spell:setMoving(false)
spell:setNext("STR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:str)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>wither</name>
							<script>spell:setMoving(false)
spell:setNext("WT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate ghoul</name>
							<script>spell:setMoving(false)
spell:setNext("GHOUL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ghoul)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>pain touch</name>
							<script>spell:setMoving(false)
spell:setNext("PT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>soul bind</name>
							<script>spell:setMoving(false)
spell:setNext("SB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate zombie</name>
							<script>spell:setMoving(false)
spell:setNext("ZOMB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:zomb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>chill touch</name>
							<script>spell:setMoving(false)
spell:setNext("CT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ct)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>command undead</name>
							<script>spell:setMoving(false)
spell:setNext("COMU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:comu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("INVIS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:invis)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor creation</name>
							<script>spell:setMoving(false)
spell:setNext("MINOR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:minor)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from cold</name>
							<script>spell:setMoving(false)
spell:setNext("PFC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from undead</name>
							<script>spell:setMoving(false)
spell:setNext("PFU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>animate skeleton</name>
							<script>spell:setMoving(false)
spell:setNext("SKEL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:skel)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("DI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:di)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect magic</name>
							<script>spell:setMoving(false)
spell:setNext("DM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>erase</name>
							<script>spell:setMoving(false)
spell:setNext("ERASE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:erase)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mage flame</name>
							<script>spell:setMoving(false)
spell:setNext("MF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>magic missile</name>
							<script>spell:setMoving(false)
spell:setNext("MG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>preserve</name>
							<script>spell:setMoving(false)
spell:setNext("PRS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:prs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>acid splash</name>
							<script>spell:setMoving(false)
spell:setNext("ASP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:asp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fire bolt</name>
							<script>spell:setMoving(false)
spell:setNext("FB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>light</name>
							<script>spell:setMoving(false)
spell:setNext("LIT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lit)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of frost</name>
							<script>spell:setMoving(false)
spell:setNext("RF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rf)( .+)?$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Enc</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>swapts</name>
						<script>charData:init("swapts", "ds")

if charData:get("swapts") == "ds" then
  mud:send("forget ds")
  mud:send("mem ts")
  mud:send("prio ts")
  charData:set("swapts", "ts")
else
  mud:send("forget ts")
  mud:send("mem ds")
  mud:send("prio ds")
  charData:set("swapts", "ds")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^swapts$</regex>
					</Alias>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>EncSpells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>aura of the griffon</name>
							<script>spell:setMoving(false)
spell:setNext("GRF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:grf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dragonscales</name>
							<script>spell:setMoving(false)
spell:setNext("DS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ds)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dragonscales</name>
							<script>spell:setMoving(false)
spell:setNext("DS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ds)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>time stop</name>
							<script>spell:setMoving(false)
spell:setNext("TS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ts)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>time stop</name>
							<script>spell:setMoving(false)
spell:setNext("TS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ts)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>breach</name>
							<script>spell:setMoving(false)
spell:setNext("BRC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:brc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>constriction</name>
							<script>spell:setMoving(false)
spell:setNext("CN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cn)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gate</name>
							<script>spell:setMoving(false)
spell:setNext("GATE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gate)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gate</name>
							<script>spell:setMoving(false)
spell:setNext("GATE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gate)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mind blank</name>
							<script>spell:setMoving(false)
spell:setNext("MB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mind blank</name>
							<script>spell:setMoving(false)
spell:setNext("MB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>relocate</name>
							<script>spell:setMoving(false)
spell:setNext("RELO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:relo)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>relocate</name>
							<script>spell:setMoving(false)
spell:setNext("RELO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:relo)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>airy water</name>
							<script>spell:setMoving(false)
spell:setNext("AIRY" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:airy)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blacklight burst</name>
							<script>spell:setMoving(false)
spell:setNext("BB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>globe of invulnerability</name>
							<script>spell:setMoving(false)
spell:setNext("GI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>major paralysis</name>
							<script>spell:setMoving(false)
spell:setNext("MP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>enlarge</name>
							<script>spell:setMoving(false)
spell:setNext("ENL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:enl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fly</name>
							<script>spell:setMoving(false)
spell:setNext("FLY" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fly)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>power word blind</name>
							<script>spell:setMoving(false)
spell:setNext("PWB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pwb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>prismatic spray</name>
							<script>spell:setMoving(false)
spell:setNext("PS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ps)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>reduce</name>
							<script>spell:setMoving(false)
spell:setNext("RED" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:red)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>repulsion</name>
							<script>spell:setMoving(false)
spell:setNext("RPS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rps)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>solid fog</name>
							<script>spell:setMoving(false)
spell:setNext("SFOG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sfog)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blur</name>
							<script>spell:setMoving(false)
spell:setNext("BL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>clairvoyance</name>
							<script>spell:setMoving(false)
spell:setNext("CLV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:clv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cone of cold</name>
							<script>spell:setMoving(false)
spell:setNext("CONE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cone)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>enchant weapon</name>
							<script>spell:setMoving(false)
spell:setNext("ENCHW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:enchw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>enervate</name>
							<script>spell:setMoving(false)
spell:setNext("ENV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:env)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>feeblemind</name>
							<script>spell:setMoving(false)
spell:setNext("FEEB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:feeb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fireball</name>
							<script>spell:setMoving(false)
spell:setNext("FBL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fbl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>identify</name>
							<script>spell:setMoving(false)
spell:setNext("ID" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:id)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>needle swarm</name>
							<script>spell:setMoving(false)
spell:setNext("NS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ns)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>charm person</name>
							<script>spell:setMoving(false)
spell:setNext("CHP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:chp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>coldshield</name>
							<script>spell:setMoving(false)
spell:setNext("CSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:csh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dimension door</name>
							<script>spell:setMoving(false)
spell:setNext("DIM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dim)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fireshield</name>
							<script>spell:setMoving(false)
spell:setNext("FSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fsh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>infravision</name>
							<script>spell:setMoving(false)
spell:setNext("IV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:iv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor globe of invulnerability</name>
							<script>spell:setMoving(false)
spell:setNext("MGI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mgi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>slowness</name>
							<script>spell:setMoving(false)
spell:setNext("SLOW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:slow)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>stoneskin</name>
							<script>spell:setMoving(false)
spell:setNext("SS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ss)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>stumble</name>
							<script>spell:setMoving(false)
spell:setNext("STM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:stm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel magic</name>
							<script>spell:setMoving(false)
spell:setNext("DISM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dism)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>farsee</name>
							<script>spell:setMoving(false)
spell:setNext("FS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fumble</name>
							<script>spell:setMoving(false)
spell:setNext("FMB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fmb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>haste</name>
							<script>spell:setMoving(false)
spell:setNext("HS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>levitate</name>
							<script>spell:setMoving(false)
spell:setNext("LV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>lightning bolt</name>
							<script>spell:setMoving(false)
spell:setNext("LB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mass invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("MASSI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:massi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor paralysis</name>
							<script>spell:setMoving(false)
spell:setNext("MINP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:minp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sleep</name>
							<script>spell:setMoving(false)
spell:setNext("SLP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:slp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>teleport</name>
							<script>spell:setMoving(false)
spell:setNext("TELE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tele)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>wizard eye</name>
							<script>spell:setMoving(false)
spell:setNext("WEYE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:weye)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blink</name>
							<script>spell:setMoving(false)
spell:setNext("BK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bk)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>chromatic orb</name>
							<script>spell:setMoving(false)
spell:setNext("CO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:co)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dexterity</name>
							<script>spell:setMoving(false)
spell:setNext("DEX" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dex)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel invisible</name>
							<script>spell:setMoving(false)
spell:setNext("DISI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:disi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>locate object</name>
							<script>spell:setMoving(false)
spell:setNext("LOCO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:loco)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of enfeeblement</name>
							<script>spell:setMoving(false)
spell:setNext("RAY" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ray)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>strength</name>
							<script>spell:setMoving(false)
spell:setNext("STR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:str)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>burning hands</name>
							<script>spell:setMoving(false)
spell:setNext("BH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>chill touch</name>
							<script>spell:setMoving(false)
spell:setNext("CT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ct)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>energy shield</name>
							<script>spell:setMoving(false)
spell:setNext("ES" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:es)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>faerie fire</name>
							<script>spell:setMoving(false)
spell:setNext("FF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ff)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("INVIS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:invis)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor creation</name>
							<script>spell:setMoving(false)
spell:setNext("MINOR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:minor)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("DI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:di)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect magic</name>
							<script>spell:setMoving(false)
spell:setNext("DM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>erase</name>
							<script>spell:setMoving(false)
spell:setNext("ERASE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:erase)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mage flame</name>
							<script>spell:setMoving(false)
spell:setNext("MF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>magic missile</name>
							<script>spell:setMoving(false)
spell:setNext("MG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>acid splash</name>
							<script>spell:setMoving(false)
spell:setNext("ASP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:asp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fire bolt</name>
							<script>spell:setMoving(false)
spell:setNext("FB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>light</name>
							<script>spell:setMoving(false)
spell:setNext("LIT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lit)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of frost</name>
							<script>spell:setMoving(false)
spell:setNext("RF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rf)( .+)?$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Cle</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>rpoison</name>
						<script>mud:send( g("removepoison") )
mud:send("rem warmaul")
mud:send("hold removepoison")
mud:send("use removepoison")
mud:send("rem removepoison")
mud:send("wield warmaul")
mud:send("drop removepoison")</script>
						<command></command>
						<packageName></packageName>
						<regex>^rpoison$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>castha</name>
						<script>spell:setMoving(false)

cecho("&lt;red&gt;[Queuing healing aura]\n")

--if NyyLIB.mtank ~= nil then
--  spell:setNext("ha " .. NyyLIB.mtank)
--end

for k,char in pairs(groupList:pc("warrior")) do
  spell:attempt(char, "healing_aura", "ha")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^castha$</regex>
					</Alias>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>CleSpells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>greater realm of protection</name>
							<script>spell:setMoving(false)
spell:setNext("REALM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:realm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>resurrect</name>
							<script>spell:setMoving(false)
spell:setNext("RESU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:resu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>eradicate undead</name>
							<script>spell:setMoving(false)
spell:setNext("EU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>full harm</name>
							<script>spell:setMoving(false)
spell:setNext("FHM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fhm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>full heal</name>
							<script>spell:setMoving(false)
spell:setNext("FH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>group vigorize</name>
							<script>spell:setMoving(false)
spell:setNext("GVIG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gvig)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>holy word</name>
							<script>spell:setMoving(false)
spell:setNext("HW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>unholy word</name>
							<script>spell:setMoving(false)
spell:setNext("UW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:uw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>water breathing</name>
							<script>spell:setMoving(false)
spell:setNext("WB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>continual light</name>
							<script>spell:setMoving(false)
spell:setNext("CNL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cnl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>curse</name>
							<script>spell:setMoving(false)
spell:setNext("CR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cr)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>curse item</name>
							<script>spell:setMoving(false)
spell:setNext("CURI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:curi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>darkness</name>
							<script>spell:setMoving(false)
spell:setNext("DKN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dkn)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>destroy undead</name>
							<script>spell:setMoving(false)
spell:setNext("DUN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dun)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fear</name>
							<script>spell:setMoving(false)
spell:setNext("FE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fe)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>harm</name>
							<script>spell:setMoving(false)
spell:setNext("HM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>silence person</name>
							<script>spell:setMoving(false)
spell:setNext("SP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>heal</name>
							<script>spell:setMoving(false)
spell:setNext("HL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>raise dead</name>
							<script>spell:setMoving(false)
spell:setNext("RD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize critic</name>
							<script>spell:setMoving(false)
spell:setNext("VC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vitality</name>
							<script>spell:setMoving(false)
spell:setNext("VT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vi?t)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blindness</name>
							<script>spell:setMoving(false)
spell:setNext("BL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>divine power</name>
							<script>spell:setMoving(false)
spell:setNext("DP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>flame strike</name>
							<script>spell:setMoving(false)
spell:setNext("FS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from acid</name>
							<script>spell:setMoving(false)
spell:setNext("PFA" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfa)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from cold</name>
							<script>spell:setMoving(false)
spell:setNext("PFC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from evil</name>
							<script>spell:setMoving(false)
spell:setNext("PFE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfe)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from fire</name>
							<script>spell:setMoving(false)
spell:setNext("PFF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pff)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from gas</name>
							<script>spell:setMoving(false)
spell:setNext("PFG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from good</name>
							<script>spell:setMoving(false)
spell:setNext("PFD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from lightning</name>
							<script>spell:setMoving(false)
spell:setNext("PFL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>remove curse</name>
							<script>spell:setMoving(false)
spell:setNext("REMC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:remc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>remove poison</name>
							<script>spell:setMoving(false)
spell:setNext("RP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>summon</name>
							<script>spell:setMoving(false)
spell:setNext("SUM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sum)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>transport via plants</name>
							<script>spell:setMoving(false)
spell:setNext("TVP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tvp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ward undead</name>
							<script>spell:setMoving(false)
spell:setNext("WU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause critical</name>
							<script>spell:setMoving(false)
spell:setNext("CAUC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cauc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>command undead</name>
							<script>spell:setMoving(false)
spell:setNext("COMU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:comu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure blind</name>
							<script>spell:setMoving(false)
spell:setNext("CB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure critic</name>
							<script>spell:setMoving(false)
spell:setNext("CCR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ccr)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel evil</name>
							<script>spell:setMoving(false)
spell:setNext("DEV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dev)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel good</name>
							<script>spell:setMoving(false)
spell:setNext("DISPG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dispg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>earthquake</name>
							<script>spell:setMoving(false)
spell:setNext("EAQ" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eaq)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sense life</name>
							<script>spell:setMoving(false)
spell:setNext("SEN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sen)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize serious</name>
							<script>spell:setMoving(false)
spell:setNext("VS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>bless</name>
							<script>spell:setMoving(false)
spell:setNext("BLS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bls)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause serious</name>
							<script>spell:setMoving(false)
spell:setNext("CAUSS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:causs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure serious</name>
							<script>spell:setMoving(false)
spell:setNext("CS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>preserve</name>
							<script>spell:setMoving(false)
spell:setNext("PRS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:prs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>slow poison</name>
							<script>spell:setMoving(false)
spell:setNext("SLP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:slp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize light</name>
							<script>spell:setMoving(false)
spell:setNext("VL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>word of recall</name>
							<script>spell:setMoving(false)
spell:setNext("WORD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:word)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause light</name>
							<script>spell:setMoving(false)
spell:setNext("CAUL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:caul)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>create food</name>
							<script>spell:setMoving(false)
spell:setNext("CFOOD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cfood)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>create water</name>
							<script>spell:setMoving(false)
spell:setNext("CRW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:crw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect evil</name>
							<script>spell:setMoving(false)
spell:setNext("DE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:de)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect good</name>
							<script>spell:setMoving(false)
spell:setNext("DG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>light</name>
							<script>spell:setMoving(false)
spell:setNext("LIT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lit)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>poison spray</name>
							<script>spell:setMoving(false)
spell:setNext("PS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ps)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sacred flame</name>
							<script>spell:setMoving(false)
spell:setNext("SF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>thorn whip</name>
							<script>spell:setMoving(false)
spell:setNext("TW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tw)( .+)?$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Sha</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>summon totem</name>
						<script>mud:send( g("totem") )
mud:send( "rem warmaul" )
mud:send( "hold totem" )
mud:send( "use totem" )
mud:send( "rem totem" )
mud:send( "wield warmaul" )
mud:send( p("totem") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^totem$</regex>
					</Alias>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>ShaSpells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>ancestral fury</name>
							<script>spell:setMoving(false)
spell:setNext("AFU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:afu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ancestral shield</name>
							<script>spell:setMoving(false)
spell:setNext("ASH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ash)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ancestral shield</name>
							<script>spell:setMoving(false)
spell:setNext("ASH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ash)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>control weather</name>
							<script>spell:setMoving(false)
spell:setNext("CNW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cnw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>group heal</name>
							<script>spell:setMoving(false)
spell:setNext("GH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>group heal</name>
							<script>spell:setMoving(false)
spell:setNext("GH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>plane shift</name>
							<script>spell:setMoving(false)
spell:setNext("PSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:psh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>plane shift</name>
							<script>spell:setMoving(false)
spell:setNext("PSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:psh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>spirit walk</name>
							<script>spell:setMoving(false)
spell:setNext("SWALK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:swalk)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>spirit walk</name>
							<script>spell:setMoving(false)
spell:setNext("SWALK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:swalk)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>scry remains</name>
							<script>spell:setMoving(false)
spell:setNext("SCREM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:screm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>scry remains</name>
							<script>spell:setMoving(false)
spell:setNext("SCREM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:screm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>spirit wrack</name>
							<script>spell:setMoving(false)
spell:setNext("SW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>water breathing</name>
							<script>spell:setMoving(false)
spell:setNext("WB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>darkness</name>
							<script>spell:setMoving(false)
spell:setNext("DKN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dkn)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>group vigorize</name>
							<script>spell:setMoving(false)
spell:setNext("GVIG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gvig)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor globe of invulnerability</name>
							<script>spell:setMoving(false)
spell:setNext("MGI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mgi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>silence person</name>
							<script>spell:setMoving(false)
spell:setNext("SP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>soul tempest</name>
							<script>spell:setMoving(false)
spell:setNext("STP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:stp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vitality</name>
							<script>spell:setMoving(false)
spell:setNext("VT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>continual light</name>
							<script>spell:setMoving(false)
spell:setNext("CNL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cnl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel magic</name>
							<script>spell:setMoving(false)
spell:setNext("DISM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dism)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>farsee</name>
							<script>spell:setMoving(false)
spell:setNext("FS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fear</name>
							<script>spell:setMoving(false)
spell:setNext("FE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fe)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>heal</name>
							<script>spell:setMoving(false)
spell:setNext("HL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>hex</name>
							<script>spell:setMoving(false)
spell:setNext("HX" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hx)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of enfeeblement</name>
							<script>spell:setMoving(false)
spell:setNext("RAY" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ray)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>stoneskin</name>
							<script>spell:setMoving(false)
spell:setNext("SS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ss)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>command undead</name>
							<script>spell:setMoving(false)
spell:setNext("COMU" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:comu)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>faerie fog</name>
							<script>spell:setMoving(false)
spell:setNext("FFOG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ffog)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from acid</name>
							<script>spell:setMoving(false)
spell:setNext("PFA" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfa)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from cold</name>
							<script>spell:setMoving(false)
spell:setNext("PFC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from evil</name>
							<script>spell:setMoving(false)
spell:setNext("PFE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfe)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from fire</name>
							<script>spell:setMoving(false)
spell:setNext("PFF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pff)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from gas</name>
							<script>spell:setMoving(false)
spell:setNext("PFG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from good</name>
							<script>spell:setMoving(false)
spell:setNext("PFD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from lightning</name>
							<script>spell:setMoving(false)
spell:setNext("PFL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>puppet</name>
							<script>spell:setMoving(false)
spell:setNext("PP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>raise dead</name>
							<script>spell:setMoving(false)
spell:setNext("RD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>remove curse</name>
							<script>spell:setMoving(false)
spell:setNext("REMC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:remc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>slowness</name>
							<script>spell:setMoving(false)
spell:setNext("SLOW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:slow)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>summon</name>
							<script>spell:setMoving(false)
spell:setNext("SUM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sum)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause critical</name>
							<script>spell:setMoving(false)
spell:setNext("CAUC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cauc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure blind</name>
							<script>spell:setMoving(false)
spell:setNext("CB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure critic</name>
							<script>spell:setMoving(false)
spell:setNext("CCR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ccr)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>earthquake</name>
							<script>spell:setMoving(false)
spell:setNext("EAQ" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eaq)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>faerie fire</name>
							<script>spell:setMoving(false)
spell:setNext("FF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ff)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor paralysis</name>
							<script>spell:setMoving(false)
spell:setNext("MINP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:minp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>unleash fetish</name>
							<script>spell:setMoving(false)
spell:setNext("UF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:uf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize critic</name>
							<script>spell:setMoving(false)
spell:setNext("VC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blindness</name>
							<script>spell:setMoving(false)
spell:setNext("BL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>jar the soul</name>
							<script>spell:setMoving(false)
spell:setNext("JS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:js)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>preserve</name>
							<script>spell:setMoving(false)
spell:setNext("PRS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:prs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>remove poison</name>
							<script>spell:setMoving(false)
spell:setNext("RP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sense life</name>
							<script>spell:setMoving(false)
spell:setNext("SEN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sen)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize serious</name>
							<script>spell:setMoving(false)
spell:setNext("VS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>word of recall</name>
							<script>spell:setMoving(false)
spell:setNext("WORD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:word)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>bless</name>
							<script>spell:setMoving(false)
spell:setNext("BLS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bls)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause serious</name>
							<script>spell:setMoving(false)
spell:setNext("CAUSS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:causs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure serious</name>
							<script>spell:setMoving(false)
spell:setNext("CS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect evil</name>
							<script>spell:setMoving(false)
spell:setNext("DE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:de)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect good</name>
							<script>spell:setMoving(false)
spell:setNext("DG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("DI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:di)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect magic</name>
							<script>spell:setMoving(false)
spell:setNext("DM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("INVIS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:invis)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>spiritknife</name>
							<script>spell:setMoving(false)
spell:setNext("SK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sk)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize light</name>
							<script>spell:setMoving(false)
spell:setNext("VL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>armor</name>
							<script>spell:setMoving(false)
spell:setNext("AM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:am)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause light</name>
							<script>spell:setMoving(false)
spell:setNext("CAUL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:caul)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>create food</name>
							<script>spell:setMoving(false)
spell:setNext("CFOOD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cfood)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>create water</name>
							<script>spell:setMoving(false)
spell:setNext("CRW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:crw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure light</name>
							<script>spell:setMoving(false)
spell:setNext("CUREL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:curel)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>totem darts</name>
							<script>spell:setMoving(false)
spell:setNext("TD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:td)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>light</name>
							<script>spell:setMoving(false)
spell:setNext("LIT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lit)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>poison spray</name>
							<script>spell:setMoving(false)
spell:setNext("PS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ps)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sacred flame</name>
							<script>spell:setMoving(false)
spell:setNext("SF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>thorn whip</name>
							<script>spell:setMoving(false)
spell:setNext("TW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tw)( .+)?$</regex>
						</Alias>
					</AliasGroup>
					<Alias isActive="yes" isFolder="no">
						<name>rpoison</name>
						<script>mud:send( g("removepoison") )
mud:send("rem warmaul")
mud:send("hold removepoison")
mud:send("use removepoison")
mud:send("rem removepoison")
mud:send("wield warmaul")
mud:send("drop removepoison")</script>
						<command></command>
						<packageName></packageName>
						<regex>^rpoison$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Rog</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>cr</name>
						<script>if checkMask("rogue") then
  if timer:get("wraithform") then
    return
  end

  if buff:get("blind") then
    return
  end


  mud:send("CR")
  group:send()

  --cecho("\n&lt;red&gt;[Attacking with circle]\n")
  --cecho("&lt;red&gt;\n\n[&lt;cyan&gt;MELEE: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() .. "\n")
  cecho("&lt;red&gt;\n\n[&lt;cyan&gt;MELEE: &lt;red&gt;CIRCLE]\n")
elseif whoclass() == "Blk" or whoclass() == "Cle" then
  spell:setNext("cr")
else
  mud:send("CR")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^cr$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>apb - apply poison blind</name>
						<script>mud:send("apply blind primaryweapon " .. charData:get("poisonbag") )
mud:send("apply blind secondaryweapon " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^apb$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gpb - get blind poison container</name>
						<script>mud:send( "GET blind " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gpb$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>appb - get blind container and apply</name>
						<script>expandAlias("gpb", false)
expandAlias("apb", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^appb$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aps - apply poison slow</name>
						<script>mud:send("apply slow primaryweapon " .. charData:get("poisonbag") )
mud:send("apply slow secondaryweapon " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^aps$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gps - get poison slow from container</name>
						<script>mud:send( "GET slow " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gps$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>apps - get, apply slow</name>
						<script>expandAlias("gps", false)
expandAlias("aps", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^apps$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>app - blind primary, slow secondary</name>
						<script>mud:send("apply blind primaryweapon " .. charData:get("poisonbag") )
mud:send("apply slow secondaryweapon " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^app$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gpp - get blind/slow container</name>
						<script>mud:send( "GET blind " .. charData:get("poisonbag") )
mud:send( "GET slow " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gpp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>appp - get/apply blind, slow</name>
						<script>expandAlias("gpp", false)
expandAlias("app", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^appp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>pick - hold pick</name>
						<script>mud:send("get string merchants")
mud:send("rem bane")
mud:send("hold string")</script>
						<command></command>
						<packageName></packageName>
						<regex>^pick$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>weapon</name>
						<script>mud:send("rem string")
mud:send("put string merchants")
mud:send("wield bane")</script>
						<command></command>
						<packageName></packageName>
						<regex>^weapon$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>assassinate</name>
						<script>if not checkMask("rog") then
  mud:send( string.upper(matches[2]) .. " " .. matches[3] )
  return
end

local timeleft=timer:get("assassinatetimer")

if not timeleft then
  timer:set("assassinatetimer", 24*60)
  mud:send("ASSASSINATE " .. matches[3])
else
  cecho("&lt;red&gt;[Assassinate in cooldown: &lt;green&gt;" .. timedisplay(timeleft) .. "&lt;red&gt;]\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^(assa?s?s?i?n?a?t?e?) (.+)</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>mpp - apply poison milky</name>
						<script>mud:send("apply milky primaryweapon " .. charData:get("poisonbag") )
mud:send("apply milky secondaryweapon " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^mpp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gpm - get milky poison</name>
						<script>mud:send( "GET milky " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gpm$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>mppp - get/apply milky</name>
						<script>expandAlias("gpm", false)
expandAlias("mpp", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^mppp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>backstab</name>
						<script>mud:send("BS " .. matches[2])
group:send()</script>
						<command></command>
						<packageName></packageName>
						<regex>^bs (.*)</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>apr - apply poison ray</name>
						<script>mud:send("apply ray primaryweapon " .. charData:get("poisonbag") )
mud:send("apply ray secondaryweapon " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^apr$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Nec</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>oc - order ghost cast</name>
						<script>mud:send("ORDER ghost cast '" .. matches[2] .. "'")</script>
						<command></command>
						<packageName></packageName>
						<regex>^oc (.*)</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Ele</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>EleSpells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>elemental fire embodiment</name>
							<script>spell:setMoving(false)
spell:setNext("EFE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:efe)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>elemental ward</name>
							<script>spell:setMoving(false)
spell:setNext("EW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ew)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>lava burst</name>
							<script>spell:setMoving(false)
spell:setNext("LB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>earthblood</name>
							<script>spell:setMoving(false)
spell:setNext("EB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>elemental earth embodiment</name>
							<script>spell:setMoving(false)
spell:setNext("EEE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eee)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gate</name>
							<script>spell:setMoving(false)
spell:setNext("GATE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gate)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gate</name>
							<script>spell:setMoving(false)
spell:setNext("GATE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gate)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>relocate</name>
							<script>spell:setMoving(false)
spell:setNext("RELO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:relo)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>earth fog</name>
							<script>spell:setMoving(false)
spell:setNext("EFOG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:efog)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>elemental air embodiment</name>
							<script>spell:setMoving(false)
spell:setNext("EAE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eae)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fire fog</name>
							<script>spell:setMoving(false)
spell:setNext("FIFOG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fifog)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>firewave</name>
							<script>spell:setMoving(false)
spell:setNext("FW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>icewave</name>
							<script>spell:setMoving(false)
spell:setNext("IW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:iw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>power word blind</name>
							<script>spell:setMoving(false)
spell:setNext("PWB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pwb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>power word stun</name>
							<script>spell:setMoving(false)
spell:setNext("PWS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pws)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>whirlwind</name>
							<script>spell:setMoving(false)
spell:setNext("WW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ww)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dimension door</name>
							<script>spell:setMoving(false)
spell:setNext("DIM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dim)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>elemental water embodiment</name>
							<script>spell:setMoving(false)
spell:setNext("EWE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ewe)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>haste</name>
							<script>spell:setMoving(false)
spell:setNext("HS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ice layer</name>
							<script>spell:setMoving(false)
spell:setNext("IL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:il)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ice tongue</name>
							<script>spell:setMoving(false)
spell:setNext("IT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:it)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blizzard sphere</name>
							<script>spell:setMoving(false)
spell:setNext("BS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>clairvoyance</name>
							<script>spell:setMoving(false)
spell:setNext("CLV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:clv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cone of cold</name>
							<script>spell:setMoving(false)
spell:setNext("CONE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cone)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>earth stones</name>
							<script>spell:setMoving(false)
spell:setNext("ES" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:es)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>feeblemind</name>
							<script>spell:setMoving(false)
spell:setNext("FEEB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:feeb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>stoneskin</name>
							<script>spell:setMoving(false)
spell:setNext("SS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ss)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>coldshield</name>
							<script>spell:setMoving(false)
spell:setNext("CSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:csh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>conjure elemental</name>
							<script>spell:setMoving(false)
spell:setNext("ELE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ele)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fireshield</name>
							<script>spell:setMoving(false)
spell:setNext("FSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fsh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>glitterdust</name>
							<script>spell:setMoving(false)
spell:setNext("GL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>infravision</name>
							<script>spell:setMoving(false)
spell:setNext("IV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:iv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>teleport</name>
							<script>spell:setMoving(false)
spell:setNext("TELE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tele)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>thunder lance</name>
							<script>spell:setMoving(false)
spell:setNext("TL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>faerie fog</name>
							<script>spell:setMoving(false)
spell:setNext("FFOG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ffog)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fireball</name>
							<script>spell:setMoving(false)
spell:setNext("FBL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fbl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>levitate</name>
							<script>spell:setMoving(false)
spell:setNext("LV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of enfeeblement</name>
							<script>spell:setMoving(false)
spell:setNext("RAY" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ray)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sleep</name>
							<script>spell:setMoving(false)
spell:setNext("SLP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:slp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>air blast</name>
							<script>spell:setMoving(false)
spell:setNext("AB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ab)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel magic</name>
							<script>spell:setMoving(false)
spell:setNext("DISM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dism)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>locate object</name>
							<script>spell:setMoving(false)
spell:setNext("LOCO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:loco)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>summon elemental kin</name>
							<script>spell:setMoving(false)
spell:setNext("EKIN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ekin)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect magic</name>
							<script>spell:setMoving(false)
spell:setNext("DM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ice spear</name>
							<script>spell:setMoving(false)
spell:setNext("IS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:is)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("INVIS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:invis)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("DI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:di)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>earth darts</name>
							<script>spell:setMoving(false)
spell:setNext("ED" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ed)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>erase</name>
							<script>spell:setMoving(false)
spell:setNext("ERASE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:erase)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mage flame</name>
							<script>spell:setMoving(false)
spell:setNext("MF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor creation</name>
							<script>spell:setMoving(false)
spell:setNext("MINOR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:minor)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>acid splash</name>
							<script>spell:setMoving(false)
spell:setNext("ASP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:asp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fire bolt</name>
							<script>spell:setMoving(false)
spell:setNext("FB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>light</name>
							<script>spell:setMoving(false)
spell:setNext("LIT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lit)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of frost</name>
							<script>spell:setMoving(false)
spell:setNext("RF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rf)( .+)?$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Pal</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>brand of judgement</name>
						<script>spell:setMoving(false)

spell:setNext("BOJ" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^(?:boj|brand)( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sunburst</name>
						<script>spell:setMoving(false)
spell:setNext("SB" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sb( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aura of life</name>
						<script>spell:setMoving(false)

spell:setNext("AL")</script>
						<command></command>
						<packageName></packageName>
						<regex>^al$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shield of warding (sonic wave)</name>
						<script>spell:setMoving(false)

spell:setNext("SW" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sw( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>divine bolt</name>
						<script>spell:setMoving(false)

spell:setNext("DB" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^db( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cleansing spirit</name>
						<script>spell:setMoving(false)

spell:setNext("CS")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cs$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>heroism</name>
						<script>spell:setMoving(false)

spell:setNext("HR")</script>
						<command></command>
						<packageName></packageName>
						<regex>^hr$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shield of faith</name>
						<script>spell:setMoving(false)

spell:setNext("SF")</script>
						<command></command>
						<packageName></packageName>
						<regex>^sf$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aura of glory</name>
						<script>spell:setMoving(false)

spell:setNext("AG")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ag$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>healing light</name>
						<script>spell:setMoving(false)

spell:setNext("HL")</script>
						<command></command>
						<packageName></packageName>
						<regex>^hl$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>noble shield</name>
						<script>spell:setMoving(false)

spell:setNext("NS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ns( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>lay hands</name>
						<script>mud:send("LH" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^lh( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ds (divine smite)</name>
						<script>useMeleePower("DS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ds( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ws (wrathful smite)</name>
						<script>useMeleePower("WS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ws( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>es (enervating smite)</name>
						<script>useMeleePower("ES" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^es( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ss (shielding smite)</name>
						<script>useMeleePower("SS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ss( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>rc (radiant charge)</name>
						<script>useMeleePower("RC" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^rc( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>bs (bolstering strike)</name>
						<script>useMeleePower("BS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^bs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>wws (whirlwind smite)</name>
						<script>useMeleePower("WWS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^wws( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>trs (terrifying smite)</name>
						<script>useMeleePower("TRS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^trs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>brs (brilliant smite)</name>
						<script>useMeleePower("BRS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^brs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ts (thunderous smite)</name>
						<script>useMeleePower("TS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ts( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>vs (valiant strike)</name>
						<script>useMeleePower("VS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^vs( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Blk</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>soul touch</name>
						<script>-- soul touch

mud:send("SOT" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sot( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sigil of pain</name>
						<script>spell:setMoving(false)

spell:setNext("SP" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sp( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aura of death</name>
						<script>spell:setMoving(false)

spell:setNext("AD")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ad$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ravenous shadows</name>
						<script>spell:setMoving(false)

spell:setNext("RAV" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^rav( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>umbral armor</name>
						<script>spell:setMoving(false)

spell:setNext("UA")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ua$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>dark blessing</name>
						<script> spell:setMoving(false)
 spell:setNext("DB")
</script>
						<command></command>
						<packageName></packageName>
						<regex>^db$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shadow healing</name>
						<script>spell:setMoving(false)

spell:setNext("SH")</script>
						<command></command>
						<packageName></packageName>
						<regex>^sh$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aspect of domination</name>
						<script>spell:setMoving(false)

spell:setNext("AOD")</script>
						<command></command>
						<packageName></packageName>
						<regex>^aod$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>corrupt weapon</name>
						<script>spell:setMoving(false)

spell:setNext("CW")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cw$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>consumption</name>
						<script>spell:setMoving(false)

spell:setNext("CS")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cs$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>scourge of agony</name>
						<script>spell:setMoving(false)

spell:setNext("SOA" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^soa( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>dark grace</name>
						<script>spell:setMoving(false)

spell:setNext("DG" .. matches[2] )</script>
						<command></command>
						<packageName></packageName>
						<regex>^dg( .+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shroud of shadows</name>
						<script>spell:setMoving(false)

spell:setNext("SOS")</script>
						<command></command>
						<packageName></packageName>
						<regex>^sos$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ds (dominating strike)</name>
						<script>useMeleePower("DS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ds( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>fs (frenzying smite)</name>
						<script>useMeleePower("FS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^fs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>rs (ruinous smite)</name>
						<script>useMeleePower("RS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^rs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>dm (dark majesty)</name>
						<script>useMeleePower("DM" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^dm( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ps (plungering smite)</name>
						<script>useMeleePower("PS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ps( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>uf (uncontrolled fury)</name>
						<script>useMeleePower("UF" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^uf( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sph (spirit harrow)</name>
						<script>useMeleePower("SPH" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sph( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>md (mortal dread)</name>
						<script>useMeleePower("MD" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^md( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ss (shattering smite)</name>
						<script>useMeleePower("SS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ss( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>vs (vengance strike)</name>
						<script>useMeleePower("VS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^vs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>drs (dread smite)</name>
						<script>useMeleePower("DRS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^drs( .+)?$</regex>
					</Alias>
					<AliasGroup isActive="no" isFolder="yes">
						<name>poison</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>apb - apply poison blind</name>
							<script>mud:send("apply blind primaryweapon " .. charData:get("poisonbag") )
mud:send("apply blind secondaryweapon " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^apb$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gpb - get blind poison container</name>
							<script>mud:send( "GET blind " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^gpb$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>appb - get blind container and apply</name>
							<script>expandAlias("gpb", false)
expandAlias("apb", false)</script>
							<command></command>
							<packageName></packageName>
							<regex>^appb$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>aps - apply poison slow</name>
							<script>mud:send("apply slow primaryweapon " .. charData:get("poisonbag") )
mud:send("apply slow secondaryweapon " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^aps$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gps - get poison slow from container</name>
							<script>mud:send( "GET slow " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^gps$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>apps - get, apply slow</name>
							<script>expandAlias("gps", false)
expandAlias("aps", false)</script>
							<command></command>
							<packageName></packageName>
							<regex>^apps$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>app - blind primary, slow secondary</name>
							<script>mud:send("apply blind primaryweapon " .. charData:get("poisonbag") )
mud:send("apply slow secondaryweapon " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^app$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gpp - get blind/slow container</name>
							<script>mud:send( "GET blind " .. charData:get("poisonbag") )
mud:send( "GET slow " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^gpp$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>appp - get/apply blind, slow</name>
							<script>expandAlias("gpp", false)
expandAlias("app", false)</script>
							<command></command>
							<packageName></packageName>
							<regex>^appp$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mpp - apply poison milky</name>
							<script>mud:send("apply milky primaryweapon " .. charData:get("poisonbag") )
mud:send("apply milky secondaryweapon " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^mpp$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gpm - get milky poison</name>
							<script>mud:send( "GET milky " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^gpm$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mppp - get/apply milky</name>
							<script>expandAlias("gpm", false)
expandAlias("mpp", false)</script>
							<command></command>
							<packageName></packageName>
							<regex>^mppp$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>apr - apply poison ray</name>
							<script>mud:send("apply ray primaryweapon " .. charData:get("poisonbag") )
mud:send("apply ray secondaryweapon " .. charData:get("poisonbag") )</script>
							<command></command>
							<packageName></packageName>
							<regex>^apr$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>War</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>sb (shield bash)</name>
						<script>if not timer:get("shield_bash") then
  useMeleePower("SB" .. (matches[2] or "") )
  setBashing(true)
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^sb( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ds (defensive strike)</name>
						<script>useMeleePower("DS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ds( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ra (relentless assault)</name>
						<script>useMeleePower("RA" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ra( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>bs (brutal strike)</name>
						<script>useMeleePower("BS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^bs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cs (comeback strike)</name>
						<script>useMeleePower("CS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^cs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ros (rain of steel)</name>
						<script>useMeleePower("ROS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ros( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ua (unyielding avalanche)</name>
						<script>useMeleePower("UA" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ua( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sk (skullcrusher)</name>
						<script>useMeleePower("SK" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sk( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ss (spinning sweep)</name>
						<script>useMeleePower("SS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ss( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cv (cleave)</name>
						<script>useMeleePower("CV" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^cv( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Ill</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>IllSpells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>nightmare</name>
							<script>spell:setMoving(false)
spell:setNext("NM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:nm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>phantasmal tendrils</name>
							<script>spell:setMoving(false)
spell:setNext("PT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>phantasmal tendrils</name>
							<script>spell:setMoving(false)
spell:setNext("PT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>gate</name>
							<script>spell:setMoving(false)
spell:setNext("GATE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gate)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>massmorph</name>
							<script>spell:setMoving(false)
spell:setNext("MASSM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:massm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>phantasmal killer</name>
							<script>spell:setMoving(false)
spell:setNext("PK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pk)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>shadow walk</name>
							<script>spell:setMoving(false)
spell:setNext("SWALK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:swalk)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dimensional fold</name>
							<script>spell:setMoving(false)
spell:setNext("FOLD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fold)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>feign death</name>
							<script>spell:setMoving(false)
spell:setNext("FND" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fnd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mirror image</name>
							<script>spell:setMoving(false)
spell:setNext("MI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mislead</name>
							<script>spell:setMoving(false)
spell:setNext("ML" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ml)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>phantom heal</name>
							<script>spell:setMoving(false)
spell:setNext("PHEAL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pheal)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>rainbow pattern</name>
							<script>spell:setMoving(false)
spell:setNext("RP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sun shadow</name>
							<script>spell:setMoving(false)
spell:setNext("SSHD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sshd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>camouflage</name>
							<script>spell:setMoving(false)
spell:setNext("CAMO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:camo)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>corpse glamor</name>
							<script>spell:setMoving(false)
spell:setNext("CGLAM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cglam)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>phantasmal blades</name>
							<script>spell:setMoving(false)
spell:setNext("PB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sequester</name>
							<script>spell:setMoving(false)
spell:setNext("SQ" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sq)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>shadechill</name>
							<script>spell:setMoving(false)
spell:setNext("SH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>shadow flux</name>
							<script>spell:setMoving(false)
spell:setNext("SF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>clairvoyance</name>
							<script>spell:setMoving(false)
spell:setNext("CLV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:clv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>displacement</name>
							<script>spell:setMoving(false)
spell:setNext("DS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ds)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>nondetection</name>
							<script>spell:setMoving(false)
spell:setNext("NON" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:non)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>summon shade</name>
							<script>spell:setMoving(false)
spell:setNext("SHADE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:shade)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>tranquility</name>
							<script>spell:setMoving(false)
spell:setNext("TQ" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tq)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dimension door</name>
							<script>spell:setMoving(false)
spell:setNext("DIM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dim)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>doppleganger</name>
							<script>spell:setMoving(false)
spell:setNext("DPL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dpl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>shadow burst</name>
							<script>spell:setMoving(false)
spell:setNext("SB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>shadow magic</name>
							<script>spell:setMoving(false)
spell:setNext("SHM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:shm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>true sight</name>
							<script>spell:setMoving(false)
spell:setNext("TS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ts)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>beautify</name>
							<script>spell:setMoving(false)
spell:setNext("BTF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:btf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel magic</name>
							<script>spell:setMoving(false)
spell:setNext("DISM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dism)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>farsee</name>
							<script>spell:setMoving(false)
spell:setNext("FS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>levitate</name>
							<script>spell:setMoving(false)
spell:setNext("LV" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lv)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>phantom steed</name>
							<script>spell:setMoving(false)
spell:setNext("PST" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pst)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>scarlet outline</name>
							<script>spell:setMoving(false)
spell:setNext("SCT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sct)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>spook</name>
							<script>spell:setMoving(false)
spell:setNext("SP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>teleport</name>
							<script>spell:setMoving(false)
spell:setNext("TELE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tele)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>change self</name>
							<script>spell:setMoving(false)
spell:setNext("CHS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:chs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>locate object</name>
							<script>spell:setMoving(false)
spell:setNext("LOCO" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:loco)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mass invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("MASSI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:massi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>phantom armor</name>
							<script>spell:setMoving(false)
spell:setNext("PA" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pa)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>blackthorns</name>
							<script>spell:setMoving(false)
spell:setNext("BT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel invisible</name>
							<script>spell:setMoving(false)
spell:setNext("DISI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:disi)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>faerie fire</name>
							<script>spell:setMoving(false)
spell:setNext("FF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ff)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("INVIS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:invis)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>minor creation</name>
							<script>spell:setMoving(false)
spell:setNext("MINOR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:minor)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect invisibility</name>
							<script>spell:setMoving(false)
spell:setNext("DI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:di)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect magic</name>
							<script>spell:setMoving(false)
spell:setNext("DM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>erase</name>
							<script>spell:setMoving(false)
spell:setNext("ERASE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:erase)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mage flame</name>
							<script>spell:setMoving(false)
spell:setNext("MF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>shadow bolt</name>
							<script>spell:setMoving(false)
spell:setNext("BOLT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bolt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>acid splash</name>
							<script>spell:setMoving(false)
spell:setNext("ASP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:asp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fire bolt</name>
							<script>spell:setMoving(false)
spell:setNext("FB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>light</name>
							<script>spell:setMoving(false)
spell:setNext("LIT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lit)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>ray of frost</name>
							<script>spell:setMoving(false)
spell:setNext("RF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rf)( .+)?$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Ran</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>hunters mark</name>
						<script>spell:setMoving(false)
spell:setNext("HM" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^hm( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cloak of vigor</name>
						<script>spell:setMoving(false)
spell:setNext("CLV")</script>
						<command></command>
						<packageName></packageName>
						<regex>^clv$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>longstrider</name>
						<script>spell:setMoving(false)
spell:setNext("LST")</script>
						<command></command>
						<packageName></packageName>
						<regex>^lst$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>beast sense</name>
						<script>spell:setMoving(false)
spell:setNext("BSE")</script>
						<command></command>
						<packageName></packageName>
						<regex>^bse$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cloak of the winds</name>
						<script>spell:setMoving(false)
spell:setNext("CLW")</script>
						<command></command>
						<packageName></packageName>
						<regex>^clw$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>dawns renewal</name>
						<script>spell:setMoving(false)
spell:setNext("DR")</script>
						<command></command>
						<packageName></packageName>
						<regex>^dr$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>lightning arrow</name>
						<script>spell:setMoving(false)
spell:setNext("LITA")</script>
						<command></command>
						<packageName></packageName>
						<regex>^lita$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>blades of fire</name>
						<script>spell:setMoving(false)
spell:setNext("BOF")</script>
						<command></command>
						<packageName></packageName>
						<regex>^bof$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cloak of protection</name>
						<script>spell:setMoving(false)
spell:setNext("CLP")</script>
						<command></command>
						<packageName></packageName>
						<regex>^clp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>electric discharge</name>
						<script>spell:setMoving(false)
spell:setNext("ELD")</script>
						<command></command>
						<packageName></packageName>
						<regex>^eld$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>hail of thorns</name>
						<script>spell:setMoving(false)
spell:setNext("HOT")</script>
						<command></command>
						<packageName></packageName>
						<regex>^hot$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cloak of resilience</name>
						<script>spell:setMoving(false)
spell:setNext("CLR")</script>
						<command></command>
						<packageName></packageName>
						<regex>^clr$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>greenfire</name>
						<script>spell:setMoving(false)
spell:setNext("GRF")</script>
						<command></command>
						<packageName></packageName>
						<regex>^grf$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>arctic barrage</name>
						<script>spell:setMoving(false)
spell:setNext("AB")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ab$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cloak of life</name>
						<script>spell:setMoving(false)
spell:setNext("CLL")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cll$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>misty path</name>
						<script>spell:setMoving(false)
spell:setNext("MSP")</script>
						<command></command>
						<packageName></packageName>
						<regex>^msp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>bs (bladestorm)</name>
						<script>useMeleePower("BS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^bs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ev (eviscerate)</name>
						<script>useMeleePower("EV" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ev( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ap (armor splinter)</name>
						<script>useMeleePower("AP" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ap( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ss (sweeping strike)</name>
						<script>useMeleePower("SS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ss( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ts (twin strike)</name>
						<script>useMeleePower("TS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ts( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ha (hail of arrows)</name>
						<script>useMeleePower("HA" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ha( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cn (concussive shot)</name>
						<script>useMeleePower("CN" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^cn( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sp (splintering shot)</name>
						<script>useMeleePower("SP" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sp( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ks (knockdown shot)</name>
						<script>useMeleePower("KS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ks( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>rs (ranged shot)</name>
						<script>useMeleePower("RS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^rs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>tr (triple shot)</name>
						<script>useMeleePower("TR" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^tr( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Hex</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>astral eyes</name>
						<script>spell:setMoving(false)
spell:setNext("AE")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ae$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>frostblade</name>
						<script>spell:setMoving(false)
spell:setNext("FB")</script>
						<command></command>
						<packageName></packageName>
						<regex>^fb$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>spider scuttle</name>
						<script>spell:setMoving(false)
spell:setNext("SS")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ss$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>eldritch chains</name>
						<script>spell:setMoving(false)

spell:setNext("EC" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ec( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>spectral fade</name>
						<script>spell:setMoving(false)

spell:setNext("SF")</script>
						<command></command>
						<packageName></packageName>
						<regex>^sf$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gift of the everliving ones</name>
						<script>spell:setMoving(false)

spell:setNext("GEO")</script>
						<command></command>
						<packageName></packageName>
						<regex>^geo$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>blade of annihilation</name>
						<script>spell:setMoving(false)

spell:setNext("BOA")</script>
						<command></command>
						<packageName></packageName>
						<regex>^boa$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>armor of winters grasp</name>
						<script>spell:setMoving(false)

spell:setNext("AWG")</script>
						<command></command>
						<packageName></packageName>
						<regex>^awg$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cloak of flies</name>
						<script>spell:setMoving(false)

spell:setNext("COF")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cof$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>death shroud</name>
						<script>spell:setMoving(false)

spell:setNext("DS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ds( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>armor of hexes</name>
						<script>spell:setMoving(false)

spell:setNext("AOH")</script>
						<command></command>
						<packageName></packageName>
						<regex>^aoh$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>blazing doom</name>
						<script>spell:setMoving(false)

spell:setNext("BZD")</script>
						<command></command>
						<packageName></packageName>
						<regex>^bzd$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shadowslip</name>
						<script>spell:setMoving(false)

spell:setNext("SHS" .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^shs( .+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>armor of the void</name>
						<script>spell:setMoving(false)

spell:setNext("AOV")</script>
						<command></command>
						<packageName></packageName>
						<regex>^aov$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>su (soulcutter)</name>
						<script>useMeleePower("SU" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^su( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>mb (memory of blades)</name>
						<script>useMeleePower("MB" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^mb( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>se (soul eater)</name>
						<script>useMeleePower("SE" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^se( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>df (darkworm feast)</name>
						<script>useMeleePower("DF" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^df( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sd (smothering darkness)</name>
						<script>useMeleePower("SD" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sd( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>hb (hexblast)</name>
						<script>useMeleePower("HB" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^hb( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>vs (void star)</name>
						<script>useMeleePower("VS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^vs( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>vf (vortex of fire)</name>
						<script>useMeleePower("VF" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^vf( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>bf (black frost)</name>
						<script>useMeleePower("BF" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^bf( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>hs (hellstrike)</name>
						<script>useMeleePower("HS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^hs( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<Alias isActive="yes" isFolder="no">
					<name>cast</name>
					<script>if not checkMask("casterSinger") and not checkMask("ran") and not checkMask("pal") and not checkMask("blk") then
  cecho("&lt;red&gt;[This class can't access casting scripts]\n")
  return
end

-- set to not moving, cast/mem ok

automem=3
memsent=false
spell:setMoving(false)
spell:setCurrent(nil)

mud:send("\n")

if checkMask("singer") then
  return
end

-- enable autocast
buttons:change("autocast", true, "SpellsButton")


</script>
					<command></command>
					<packageName></packageName>
					<regex>^cast$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>memd</name>
					<script>mud:send("MEM")</script>
					<command></command>
					<packageName></packageName>
					<regex>^memd$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>prayd</name>
					<script>mud:send("PRAY")</script>
					<command></command>
					<packageName></packageName>
					<regex>^prayd$</regex>
				</Alias>
				<AliasGroup isActive="no" isFolder="yes">
					<name>Dru</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>DruSpells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>creeping doom</name>
							<script>spell:setMoving(false)
spell:setNext("CD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>group barkskin</name>
							<script>spell:setMoving(false)
spell:setNext("GBARK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gbark)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>moonwell</name>
							<script>spell:setMoving(false)
spell:setNext("MW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dessicate</name>
							<script>spell:setMoving(false)
spell:setNext("DES" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:des)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>entangle</name>
							<script>spell:setMoving(false)
spell:setNext("ENG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eng)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>hailstorm</name>
							<script>spell:setMoving(false)
spell:setNext("HS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>plane shift</name>
							<script>spell:setMoving(false)
spell:setNext("PSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:psh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>plane shift</name>
							<script>spell:setMoving(false)
spell:setNext("PSH" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:psh)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fire seeds</name>
							<script>spell:setMoving(false)
spell:setNext("FS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>mud to rock</name>
							<script>spell:setMoving(false)
spell:setNext("MUDTR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:mudtr)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>rock to mud</name>
							<script>spell:setMoving(false)
spell:setNext("RKTM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rktm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>spiked stones</name>
							<script>spell:setMoving(false)
spell:setNext("SS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ss)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>water breathing</name>
							<script>spell:setMoving(false)
spell:setNext("WB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:wb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cyclone</name>
							<script>spell:setMoving(false)
spell:setNext("CY" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cy)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>flame blade</name>
							<script>spell:setMoving(false)
spell:setNext("FB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>group vigorize</name>
							<script>spell:setMoving(false)
spell:setNext("GVIG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gvig)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>pass without trace</name>
							<script>spell:setMoving(false)
spell:setNext("PWT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pwt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>changestaff</name>
							<script>spell:setMoving(false)
spell:setNext("CSTF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cstf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>continual light</name>
							<script>spell:setMoving(false)
spell:setNext("CNL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cnl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fear</name>
							<script>spell:setMoving(false)
spell:setNext("FE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fe)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>firestorm</name>
							<script>spell:setMoving(false)
spell:setNext("FST" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:fst)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>heal</name>
							<script>spell:setMoving(false)
spell:setNext("HL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>insect plague</name>
							<script>spell:setMoving(false)
spell:setNext("IP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ip)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>suffocate</name>
							<script>spell:setMoving(false)
spell:setNext("SUF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:suf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vitality</name>
							<script>spell:setMoving(false)
spell:setNext("VT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vt)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>call lightning</name>
							<script>spell:setMoving(false)
spell:setNext("CALL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:call)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>control weather</name>
							<script>spell:setMoving(false)
spell:setNext("CNW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cnw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dispel magic</name>
							<script>spell:setMoving(false)
spell:setNext("DISM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dism)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>harm</name>
							<script>spell:setMoving(false)
spell:setNext("HM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:hm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>raise dead</name>
							<script>spell:setMoving(false)
spell:setNext("RD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sunray</name>
							<script>spell:setMoving(false)
spell:setNext("SR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sr)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize critic</name>
							<script>spell:setMoving(false)
spell:setNext("VC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause critical</name>
							<script>spell:setMoving(false)
spell:setNext("CAUC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cauc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>create spring</name>
							<script>spell:setMoving(false)
spell:setNext("CSP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:csp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure critic</name>
							<script>spell:setMoving(false)
spell:setNext("CCR" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ccr)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dust devil</name>
							<script>spell:setMoving(false)
spell:setNext("DD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dd)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>earthquake</name>
							<script>spell:setMoving(false)
spell:setNext("EAQ" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:eaq)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sense life</name>
							<script>spell:setMoving(false)
spell:setNext("SEN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sen)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>summon</name>
							<script>spell:setMoving(false)
spell:setNext("SUM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sum)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>transport via plants</name>
							<script>spell:setMoving(false)
spell:setNext("TVP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tvp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>barkskin</name>
							<script>spell:setMoving(false)
spell:setNext("BARK" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bark)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>faerie fog</name>
							<script>spell:setMoving(false)
spell:setNext("FFOG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ffog)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from acid</name>
							<script>spell:setMoving(false)
spell:setNext("PFA" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfa)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from cold</name>
							<script>spell:setMoving(false)
spell:setNext("PFC" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfc)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from fire</name>
							<script>spell:setMoving(false)
spell:setNext("PFF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pff)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from gas</name>
							<script>spell:setMoving(false)
spell:setNext("PFG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from lightning</name>
							<script>spell:setMoving(false)
spell:setNext("PFL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>remove poison</name>
							<script>spell:setMoving(false)
spell:setNext("RP" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:rp)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>summon insects</name>
							<script>spell:setMoving(false)
spell:setNext("SI" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:si)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize serious</name>
							<script>spell:setMoving(false)
spell:setNext("VS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>bless</name>
							<script>spell:setMoving(false)
spell:setNext("BLS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:bls)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause serious</name>
							<script>spell:setMoving(false)
spell:setNext("CAUSS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:causs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure serious</name>
							<script>spell:setMoving(false)
spell:setNext("CS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:cs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect evil</name>
							<script>spell:setMoving(false)
spell:setNext("DE" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:de)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect good</name>
							<script>spell:setMoving(false)
spell:setNext("DG" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dg)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>faerie fire</name>
							<script>spell:setMoving(false)
spell:setNext("FF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ff)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>preserve</name>
							<script>spell:setMoving(false)
spell:setNext("PRS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:prs)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>protection from animals</name>
							<script>spell:setMoving(false)
spell:setNext("PFAN" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:pfan)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sticks to snakes</name>
							<script>spell:setMoving(false)
spell:setNext("STS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sts)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>vigorize light</name>
							<script>spell:setMoving(false)
spell:setNext("VL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:vl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>word of recall</name>
							<script>spell:setMoving(false)
spell:setNext("WORD" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:word)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cause light</name>
							<script>spell:setMoving(false)
spell:setNext("CAUL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:caul)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>create water</name>
							<script>spell:setMoving(false)
spell:setNext("CRW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:crw)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>cure light</name>
							<script>spell:setMoving(false)
spell:setNext("CUREL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:curel)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>detect magic</name>
							<script>spell:setMoving(false)
spell:setNext("DM" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:dm)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>goodberry</name>
							<script>spell:setMoving(false)
spell:setNext("GDB" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:gdb)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>shillelagh</name>
							<script>spell:setMoving(false)
spell:setNext("SHL" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:shl)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>light</name>
							<script>spell:setMoving(false)
spell:setNext("LIT" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:lit)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>poison spray</name>
							<script>spell:setMoving(false)
spell:setNext("PS" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ps)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>sacred flame</name>
							<script>spell:setMoving(false)
spell:setNext("SF" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:sf)( .+)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>thorn whip</name>
							<script>spell:setMoving(false)
spell:setNext("TW" .. (matches[2] or "") )
</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:tw)( .+)?$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
			</AliasGroup>
			<Alias isActive="no" isFolder="no">
				<name>restart</name>
				<script>--local ver=getMudletVersion()

--if ver["major"] == 3 then
--  if ver["build"] == "" or ver["build"] == "-dev" then
--    cecho("&lt;red&gt;[NyyLIB requires restart after installation.]\n")
--    return
--  end
--end

--cecho("&lt;red&gt;[NyyLIB requires minimum non-beta Mudlet version 3.x.x http://www.mudlet.org/download/ ]\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>^.+$</regex>
			</Alias>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>EquipProcs</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>clair</name>
					<script>if isIconActive("TiaManacle") then
  mud:send("SAY farsight " .. matches[2])
else
  mud:send( g("ball") )
  mud:send("gaze ball " .. matches[2])
  mud:send( p("ball") )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^clair (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>chpele</name>
					<script>mud:send("say strength of stone")</script>
					<command></command>
					<packageName></packageName>
					<regex>^chpele</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>shabay</name>
					<script>mud:send("EMOTE starts casting a spell called 'Shabay'.")
mud:send("SAY my heavenly home")</script>
					<command></command>
					<packageName></packageName>
					<regex>^shabay</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>blend</name>
					<script>if whoami() == "Adud" then
  mud:send("rem isha")
else
  mud:send("rem swirling")
end

mud:send("get 3.warder hole")
mud:send("wear warder")
mud:send("SAY blend")
mud:send("rem warder")

if whoami() == "Adud" then
  mud:send("wear isha")
else
  mud:send("wear swirling")
end

mud:send("put warder hole")</script>
					<command></command>
					<packageName></packageName>
					<regex>^blend$</regex>
				</Alias>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>TiaSleeves</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>healme</name>
						<script>mud:send("quaff glowing " .. charData:get("container") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^healme</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Baatorian</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>slaad</name>
						<script>mud:send("SAY demonic conjuration")</script>
						<command></command>
						<packageName></packageName>
						<regex>^slaad</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>bash</name>
						<script>if checkMask("fighter") then
  setBashing(false)
  sendBash(matches[2])
else
  mud:send("ORDER followers bash " .. matches[2])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^bash ([A-Za-z]+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>oflee</name>
						<script>mud:send("ORDER followers flee")</script>
						<command></command>
						<packageName></packageName>
						<regex>^oflee$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>resc</name>
						<script>-- attempt rescue if have that skill, otherwise direct command to followers
-- TODO: Should confirm you have followes before sending

if checkMask("fighter") then
  sendRescue(matches[3])
else
  mud:send("ORDER followers rescue " .. matches[3])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^resc(ue)? ([A-Za-z]+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>rme</name>
						<script>mud:send("ORDER followers rescue " .. whoami())</script>
						<command></command>
						<packageName></packageName>
						<regex>^rme$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>TiaStaff</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>protect</name>
						<script>mud:send("SAY Protect me")</script>
						<command></command>
						<packageName></packageName>
						<regex>^protect$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>release</name>
						<script>mud:send("SAY Release")</script>
						<command></command>
						<packageName></packageName>
						<regex>^release$</regex>
					</Alias>
				</AliasGroup>
				<Alias isActive="yes" isFolder="no">
					<name>pendant</name>
					<script>mud:send("SAY infernal protection")</script>
					<command></command>
					<packageName></packageName>
					<regex>^pendant$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>dcult</name>
					<script>mud:send("rem swirling")
mud:send( g("ceremonial") )
mud:send("wear ceremonial")
mud:send("SAY draconian protection")
mud:send("rem ceremonial")
mud:send("wear swirling")
mud:send( p("ceremonial") )
</script>
					<command></command>
					<packageName></packageName>
					<regex>^dcult</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>bane</name>
					<script>local bane=charData:get("bane")

if bane == "blind" then
  mud:send("SAY Dragonblind")
elseif bane == "poison" then
  mud:send("SAY Dragonpoison")
elseif bane == "slow" then
  mud:send("SAY Dragonslow")
elseif bane == "strike" then
  mud:send("SAY Dragonstrike")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^bane$</regex>
				</Alias>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>TiaWarmaul</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>aid</name>
						<script>mud:send("SAY aid my companions")
group:send()</script>
						<command></command>
						<packageName></packageName>
						<regex>^aid$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>restore</name>
						<script>mud:send("SAY restore me")</script>
						<command></command>
						<packageName></packageName>
						<regex>^restore$</regex>
					</Alias>
				</AliasGroup>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>NyyAliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@cgag</name>
					<script>local tmpvar = charData:get("cgags", true)

if matches[2] == "reset" then
  cecho("&lt;red&gt;[ Resetting all custom chat gags ]\n")
  charData:set("cgags", {}, true)
else
  if matches[2] == "" then
    cecho("&lt;red&gt;Usage:\n&lt;green&gt; @cgag text to gag\n&lt;green&gt; @cgag reset\n")
    cecho("&lt;red&gt;Existing chat gags:\n")
    display(tmpvar)
  else
    table.insert(tmpvar, matches[2]:lower())
    cecho("&lt;red&gt;[New chat gag created for: &lt;green&gt;" .. matches[2] .. "&lt;red&gt;]\n")
    charData:set("cgags", tmpvar, true)
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@cgag ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@debug information</name>
					<script>-- this alias displays numerous internal variable values

-- should add command @debug nhc to echo results to nhc


expandAlias("@version", false)

local WindowWidth, WindowHeight = getMainWindowSize()
cecho("&lt;red&gt;Mudlet window size: X: &lt;green&gt;" .. WindowWidth .. " &lt;red&gt;Y: &lt;green&gt;" .. WindowHeight .. "\n\n")

local hp=prompt:get("hp")
local maxhp=prompt:get("maxhp")
local psp=prompt:get("psp")
local maxpsp=prompt:get("maxpsp")
local mv=prompt:get("mv")
local maxmv=prompt:get("maxmv")
local tank=prompt:get("tank") or ""
local tankcon=prompt:get("tankcondition") or ""
local enemy=prompt:get("enemy") or ""
local enemycon=prompt:get("enemycondition") or ""
local enemypos=prompt:get("enemyposition") or ""
local pos=prompt:get("position") or ""

cecho(string.format("&lt;green&gt;hp: %d maxhp: %d\n", hp, maxhp) )
cecho(string.format("&lt;green&gt;mv: %d maxmv: %d\n", mv, maxmv) )

if psp ~= "" then
  cecho(string.format("&lt;green&gt;psp: %d maxpsp: %d\n", psp, maxpsp) )
end

echo (string.format("T: %s TC: %s E: %s EC: %s EP: %s P: %s\n", tank, tankcon, enemy, enemycon, enemypos, pos))

local current=spell:getCurrent() or "nil"

echo("\n")

cecho("&lt;red&gt;promt:get(tank) " .. tank .. "-\n")
echo("\n")

cecho("&lt;red&gt;spell:getCurrent(): " .. current .. "\n")
cecho("&lt;red&gt;spell:count(): " .. spell:count() .. "\n")

cecho("&lt;red&gt;To memorize (memcount): " .. charData:get("memcount") .. "\n")
cecho("&lt;red&gt;Seen mem'ing (automem): " .. automem .. "\n")

cecho("&lt;red&gt;spell:getMoving(): " .. tostring(spell:getMoving()) .. "\n")
cecho("&lt;red&gt;spell:getMem(): " .. tostring(spell:getMem()) .. "\n")


cecho("&lt;red&gt;look:get(): " .. tostring(look:get()) .. "\n")

cecho("&lt;red&gt;group:get() " .. tostring(group:get()) .. "\n")

echo("\n")

cecho("&lt;red&gt;meleePowerUsed " .. tostring(meleePowerUsed) .. "\n")

if memsent ~= nil then
  cecho("&lt;red&gt;memsent: " .. tostring(memsent) .. "\n")
end

cecho("&lt;red&gt;lastsent: " .. lastsent .. "\n")

if sendingStatus ~= nil then
  cecho("&lt;red&gt;sendingStatus: " .. tostring(sendingStatus) .. "\n")
end

cecho("&lt;red&gt;mud.sending: " .. tostring(mud.sending) .. "\n")

if NyyLIB.escapedir ~= nil then
  cecho("&lt;red&gt;NyyLIB.escapedir: " .. NyyLIB.escapedir .. "\n")
end

echo("\n")

if spell:count() &gt; 0 then
  cecho("&lt;red&gt;Queued spells (spell.spellcastqueue)\n")
  display( spell.spellcastqueue )
end

if ( #mud.varsendqueue &gt; 0 ) then
  cecho("&lt;red&gt;Queued commands (mud.varsendqueue):\n")
  display( mud.varsendqueue )
end

if groupList:whoTanking() then
  cecho("&lt;red&gt;Who's tanking (groupList:whoTanking()):\n")
  display ( groupList:whoTanking() )
end

display( enteredPortal )

cecho("&lt;red&gt;getEnemy(): " .. getEnemy() .. "\n")
cecho("&lt;red&gt;inCombat(): " .. tostring(inCombat()) .. "\n")
cecho("&lt;red&gt;assistSent: ")
display(assistSent)


display(  mud.varsendqueue )

cecho("&lt;red&gt;[End debug]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@debug$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@set</name>
					<script>local nx

-- set by itself, no arguments
if matches[2] == "@set" then
  cecho("&lt;red&gt;Usage: &lt;green&gt;@set key value &lt;red&gt;Example: &lt;green&gt;@set loot off &lt;red&gt;- turns off autoloot\n")
  echo("------------\n")

  for nx=1, #setvar, 1 do
    local key= setvar[nx][1]
    local value

    if key ~= "-" then
      if setvar[nx][2] == "" then
        value = charData:get(key, true)
      else 
        value = charData:get(key)
      end

      if type(value) == "boolean" then
        value=tostring(value)
      end

      if type(value) == "table" then
        value=""
      end

      -- if no value set, assign default value

      if value == nil then
        cecho("&lt;red&gt;[ nil value " .. key .. "]\n")
      end

      --if value == nil then
      --  value=setvar[nx][4]
      --  if setvar[nx][2] == "" then
      --    charData:set(key, value, true)
      --  else
      --    charData:set(key, value)
      --  end
      --end

      if setvar[nx][2] == "" or setvar[nx][2] == "*" then
        if key == "condensed" then
          local count=0

          cecho ( string.format("&lt;green&gt;%17s&lt;white&gt;\n",   "[" .. key .. "]") )

          for k,v in pairs(charData:get("condensed", true)) do
            count = count + 1

            if count == 1 then
              echo("            ")
            end

            cecho(string.format("&lt;green&gt; %-9s&lt;white&gt; %5s |", k, tostring(v) ))

            if count == 4 then
              count=0
              echo("\n")
            end
          end
          echo("\n")
        else
          cecho ( string.format("&lt;green&gt;%17s&lt;white&gt; %-15s %20s  %s\n", 
                "[" .. key .. "]",
                value,
                table.concat(setvar[nx][3], "|"),
                setvar[nx][5] )
             )
        end
      else
        if setvar[nx][2] ~= "equip" then
          if checkMask(setvar[nx][2]) then
            cecho ( string.format("&lt;green&gt;%17s&lt;white&gt; %-15s %20s  %s\n", 
                "[" .. key .. "]",
                value,
                table.concat(setvar[nx][3], "|"),
                setvar[nx][5] )
               )
          end
        end
      end
    else
      echo("--------------\n")
    end
  end

  return
end

-- at least one argument provided

for nx=1, #setvar, 1 do
  local key= setvar[nx][1]

  if matches[4] == key then
    local classes=setvar[nx][2]
    local pattern=setvar[nx][3]
    local value=matches[5]

    if matches[5] == "true" then
      value=true
    end

    if matches[5] == "false" then
      value=false
    end

    -- Is the key changeable by this class?

    if classes == "" or classes == "*" then
      -- ok to change
    else
      if classes ~= "equip" then
        if checkMask(classes) then
          -- ok to change
        else
          -- not ok to change
          cecho("&lt;red&gt;[Not a valid key for this character class]\n")
          return  
        end
      end
    end

    -- Does the new value match acceptable patterns?

    if matches[4] == "border" then
      if matches[5] == "file" then  
        local tmp = invokeFileDialog(true, "Select border image")

        if tmp ~= "" then
          charData:set("border", string.gsub(tmp, "\\", "/"), true  )
        end
    
        echo("[Border imagefile: " .. charData:get("border", true) .. "]\n")
      elseif matches[5] == "default" then
        charData:set("border", "default", true)
      else
      
        charData:set("border", matches[5], true)
      end

      cecho("&lt;red&gt;[Border set to " .. charData:get("border", true) .. "]\n")

      setBorder()
      return
    end


    if matches[4] == "condensed" then
      if table.index_of(pattern, matches[5]) then
        local condensed = charData:get("condensed", true)

        condensed[matches[5]] = togBoolean(condensed[matches[5]])
        charData:set("condensed", condensed, true)

        cecho("&lt;red&gt;[Setting condensed mode " .. matches[5] .. " to " .. tostring(condensed[matches[5]]) .. "]\n")
        return
      end
    end

    if matches[5] == "" and table.index_of(pattern, "true") ~= nil then
      local nval

      if classes == "" then
        nval = togBoolean( charData:get(key, true) )
        charData:set(key, nval, true)
      else
        nval = togBoolean( charData:get(key) ) 
        charData:set(key, nval)
      end

      cecho("&lt;red&gt;[Setting " .. key .. " to " .. tostring(nval) .. "]\n")


      -- check if key is hideequip

      if key == "hideequip" then
        leftIcons()
      end

      -- check if key is winIconbar

      if key == "winIconbar" then
        showIconbar()
      end

      if key == "style" then
        if nval == true then        
          setStyle()
        else
          setAppStyleSheet("")
        end
      end

      buttons:sync()

      return
    end

    if matches[5] == "" or matches[5] == "#" or matches[5] == "*" then
      cecho("&lt;red&gt;[No value provided]\n")
      return
    end

    if (pattern[1] == "*" or table.index_of(pattern, matches[5]) ~= nil) or
       ( (table.index_of(pattern, "#") or table.index_of(pattern, "%")) and tonumber(matches[5])) then
      
      if table.index_of(pattern, "%") then
        local val=tonumber(matches[5])
        
        if val &lt; 0 or val &gt; 100 then
          cecho("&lt;red&gt;[Percentages are between 0 and 100]\n")
          return
        end
      end
            
      cecho("&lt;red&gt;[Setting " .. key .. " to " .. matches[5] .. "]\n")

      if classes == "" then
        charData:set(key, value, true)
      else
        charData:set(key, value)
      end

      if key == "chatfontsize" then
        demonnic.chat:redo()
      end

      if key == "hideequip" then
        leftIcons()        
      end

      if key == "winIconbar" then
        showIconbar()
      end

      if key == "style" then
        if value == true then        
          setStyle()          
        else
          setAppStyleSheet("")          
        end
      end

      buttons:sync()

      return
    end

    cecho("&lt;red&gt;[Not a valid value for " .. key .. " : " .. table.concat(setvar[nx][3], "|") .. "]\n")

    return
  end
end

cecho("&lt;red&gt;[" .. matches[4] .. " is not a valid key]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>(^@set$)|(^@set ([A-Za-z_]+) ?(.*)?$)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@mtank</name>
					<script>if matches[2] == nil then
  NyyLIB.mtank = nil

  cecho("&lt;green&gt;[Main tank cleared]\n")
else
  NyyLIB.mtank = string.title(matches[2])
  cecho("&lt;green&gt;[Main tank is now set to: &lt;red&gt;" .. NyyLIB.mtank .. "&lt;green&gt;]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@mtank ?([0-9.a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@target</name>
					<script>NyyLIB.target = matches[2]

if matches[2] == nil then
  cecho("&lt;red&gt;[Target cleared]\n")
else
  cecho("&lt;red&gt;[Target is now set to: &lt;green&gt;" .. NyyLIB.target .. "&lt;red&gt;]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@target ?([0-9.a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@save</name>
					<script>-- save data files

saveNyyLIB()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@save$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@backup</name>
					<script>function backupDirectory(xname)
  lfs.mkdir(backupPath(xname))

  for file in lfs.dir(homepath(xname)) do
      -- file is the current file or directory name
    if file ~= "." and file ~= ".." then
        print( "Copying: " .. file )

      copyFile(homepath(xname) .. "/" .. file, backupPath(xname) .. "/" .. file)
    end
  end
end

function backupPath(xname)
  local path = charData:get("backupfolder", true) .. "\\" .. xname

  path=string.gsub(path, "\\", "/")  

  return(path)
end

if matches[2] == "logs" then
  cecho("&lt;red&gt;[Backing up profile logs files]\n")
  backupDirectory("log")
  return
end

if matches[2] == "set" then
  charData:set("backupfolder", invokeFileDialog(false, "Select destination folder for backups"), true )

  charData:set("backupfolder", string.gsub(charData:get("backupfolder", true), "/", "\\"), true )

  cecho("&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n")

  return
end

if matches[2] == "copy" then
  if charData:get("backupfolder", true) ~= nil then
    saveNyyLIB()

    cecho("\n&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n\n")

    backupFile("chardata.dat")
    backupFile("stats.dat")
    backupFile("wholist_v3")
    backupFile("notes.txt")

    backupFile("toril.map")
  else
    cecho("&lt;red&gt;[No backup folder selected]\n")
  end

  return
end

if matches[2] == "restore" then
  if charData:get("backupfolder", true) ~= nil then
    cecho("\n&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n\n")

    restoreFile("chardata.dat")
    restoreFile("stats.dat")
    restoreFile("wholist_v3")

    restoreFile("toril.map")

    loadwholist()
    
    local level=charData:get("level")

    charData:load()

    charData:init("level", level)

    initFullData()

    map:loadMap()

    buttons:sync()

    setBorder()
  else
    cecho("&lt;red&gt;[No backup folder selected]\n")
  end

  return
end

cecho("&lt;green&gt;[&lt;red&gt;WARNING:&lt;green&gt; This does not copy script changes]\n\n")
cecho("&lt;green&gt;[Usage: @backup set     - choose backup folder]\n")
cecho("&lt;green&gt;[       @backup copy    - copy data files to folder]\n")
cecho("&lt;green&gt;[       @backup restore - overwrite profile data files with backup folder]\n")
cecho("&lt;green&gt;[       @backup logs    - copy profile logfiles into backup folder\n")

if charData:get("backupfolder", true) ~= nil then
  cecho("\n&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n")
else
  cecho("\n&lt;red&gt;[No backup folder selected]\n")
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@backup ?(set|copy|restore|logs)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@help</name>
					<script>--function mainpath(xname)
--  This function returns the full pathname inside the profile of a specific file
--end

function showHelp(xindex)
  local index, name
  local found=false
  
  cecho("\n")
  
  for line in io.lines(mainpath("helpfile.dat")) do
    if string.find(line, ";;") ~= nil then
      if found == false then
        index,name = string.match(line, ";;([0-9]+),([@0-9a-zA-Z _]+)")
      else
        -- end of help entry
        cecho("\n")
        return
      end
    else
      if index == tostring(xindex) or name == xindex or name == ("@" .. xindex) then
        found=true
        --display(line)
        cecho(line .. "\n")
      end
    end
  end
  
  if found == false then
    cecho("&lt;red&gt;[No help information found for: " .. xindex .. "]\n")
  end
end

function showIndex()
  local index, name
  local found=false
  local count=0
  
  for line in io.lines(mainpath("helpfile.dat")) do
    if string.find(line, ";;") ~= nil then
        index,name = string.match(line, ";;([0-9]+),([@0-9a-zA-Z _]+)")
        
        count=count+1
        
        cecho( string.format("&lt;green&gt;%-16s", name) )
    
        if count % 6 == 0 then
          echo("\n")
        end
    end
  end

  echo("\n\n")
end

if matches[2] == "" then
  showHelp("contents")
elseif matches[2] == "index" then
  cecho(string.format("&lt;red&gt;%50s\n\n", "Help Entries") )
  showIndex()
else
  showHelp(matches[2])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@help ?(.*)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@at (attack dir)</name>
					<script>if NyyLIB.target == nil then
  echo("[No target is currently set.]\n")
else
  mud:send(matches[2])
  mud:send("BACKSTAB " .. NyyLIB.target)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@at([nsewud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@attack</name>
					<script>NyyLIB.target = matches[2]

if matches[2] == nil then
  cecho("&lt;red&gt;[Target cleared]\n")
else
  cecho("&lt;red&gt;[Target is now set to: &lt;green&gt;" .. NyyLIB.target .. "&lt;red&gt;]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@attack ?([0-9.a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@chkstat</name>
					<script>cecho("&lt;red&gt;\n[Checking status on group]\n")

for k,char in pairs(groupList:pc()) do
  sendStatus(char)
end

for k,petname in pairs(pet:getTable()) do
  sendStatus(petname)
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@chkstat$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@setroom</name>
					<script>local matchvalue = tonumber(matches[2])

if roomLocked(matchvalue) == false then
  cecho("&lt;green&gt;[Room set to " .. matchvalue .. "]\n")

  map:setRoom(matchvalue)
  centerview( map:getRoom() )
else
  cecho("&lt;red&gt;[Room " .. matchvalue .. " doesn't exist.]\n")
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@setroom( [0-9]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@cd</name>
					<script>function countdown()
  NyyLIB.countdown = NyyLIB.countdown - 1

  local dir= string.upper(NyyLIB.fulldirs[string.lower(tostring(NyyLIB.countdir:trim()))])

  if NyyLIB.countdown &gt; 0 then
    mud:send("GSAY &lt;" .. NyyLIB.countdown .. "&gt; to movement " .. dir )
    tempTimer(1, [[countdown()]])
  else
    mud:send("GSAY &lt; ATTACKING " .. string.title(tostring(NyyLIB.target)) .. " " .. dir .. "! &gt;" )
    
    expandAlias("movea " .. NyyLIB.countdir, false)

    if NyyLIB.target ~= nil then
      mud:send("KILL " .. NyyLIB.target)
    else
      mud:send("HITALL all")
    end
  end
end

if matches[2] == nil then
  if NyyLIB.target == nil then
    cecho("&lt;red&gt;[Countdown script: No target set]\n")
  else
    cecho("&lt;red&gt;[Countdown script: " .. NyyLIB.target .. "]\n")
  end
else
  -- disable rescue
  if checkMask("fighter") then
    if charData:get("rescuetype") ~= "off" then
      buttons:change("rescuetype", "off", "rescue")
    end
  end

  -- change fleemode to 'lich'
  buttons:change("flee", "lich", "flee")

  NyyLIB.countdown = 6

  NyyLIB.countdir = matches[2]

  countdown()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@cd( [nsewud])?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@fwalk</name>
					<script>-- map:getRoom() = nil (unknown) throws error

-- ^fwalk( [0-9A-Za-z]+)?( [A-Za-z]+)?


-- fwalk roomnum
-- fwalk add/del bookmarkname
-- fwalk bookmarkname

local var1
local var2

local addfwalk
local action=0

local tmpvar=charData:get("fwalk", true)

local tmplist={}

function fastwalk(xroomid)
  fwalkQue=false
  
  if roomLocked(xroomid) then
    cecho("&lt;red&gt;[Error: Destination room " .. xroomid .. " is locked]\n")
    return
  end

  if map:getRoom() == nil then
    cecho("&lt;red&gt;[Error: source room id is nil]\n")
    return
  end

  if getPath( map:getRoom(), xroomid) then
    doSpeedWalk()
  else
    cecho("&lt;red&gt;[Unable to find path to room#" .. xroomid .. "]\n")
  end
end

if tonumber(matches[2]) ~= nil then
  
  if inCombat() then
    fwalkQue=false

    cecho("&lt;red&gt;[Can't fwalk while in combat]\n")
    return(false)
  end

  fastwalk(tonumber(matches[2]))
else
  var1=string.trim(matches[2])
  var2=string.trim(matches[3])
  var3=string.trim(matches[4])

  if var1 == "help" then
    cecho("&lt;red&gt;Usage: @fwalk roomnumber    - fastwalk to specified room number\n")
    cecho("&lt;red&gt;       @fwalk name          - fastwalk to room indicated by fwalk name\n")
    cecho("&lt;red&gt;       @fwalk add name      - adds a fastwalk to the currently occupied room using 'name' \n")
    cecho("&lt;red&gt;       @fwalk add name vnum - adds a fastwalk to vnum using 'name' \n")
    cecho("&lt;red&gt;       @fwalk del name      - deletes fastwalk 'name'\n")
    cecho("&lt;red&gt;       @fwalk all           - list all fwalks regardless of location\n")
    cecho("&lt;red&gt;       @fwalk area          - list all fwalks in current area\n")
    return
  end
  
  echo("\n")

  if var1 == "all" then

    for k,v in pairs(charData:get("fwalk", true)) do

      if roomExists(v) then
        local zoneid=tonumber(getRoomUserData(v, "zoneid") )
        local pathlength=0

        if roomLocked(v) == false then
          if getPath( map:getRoom(), v) then
            pathlength=#speedWalkPath
          end
        end

        if pathlength ~= 0 then
          tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
        else
          tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
        end
      else
        tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3s] %s\n", "", v, k, "", "")
      end
    end

    cecho("&lt;white&gt;             Area                  Room#      fwalk     Distance          Room Name\n")
    printSorted(tmplist)

    return
  end

  if var1 == "area" then

    local roomid= map:getRoom()

    local internalid = getRoomArea( roomid )
    local zone=getRoomUserData(roomid, "zoneid")
    local currentareazoneid=tonumber(zone)

    for k,v in pairs(charData:get("fwalk", true)) do

      if roomExists(v) then
        local zoneid=tonumber(getRoomUserData(v, "zoneid") )
        local pathlength=0

        if roomLocked(v) == false then
          if getPath( map:getRoom(), v) then
            pathlength=#speedWalkPath
          end
        end

        if zoneid == currentareazoneid then
          if pathlength ~= 0 then
            tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
          else
            tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
          end
        end
      --else
      --  tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3s] %s\n", "", v, k, "", "")
      end
    end

    cecho("&lt;white&gt;             Area                  Room#      fwalk     Distance          Room Name\n")
    printSorted(tmplist)

    return
  end


  if map:getRoom() == nil then
    cecho("&lt;red&gt;[Current room is unknown. Type @find or scan]\n")
    return
  end

  -- check if var1 is existing marker - if so, fastwalk and exit

  for k,v in pairs(charData:get("fwalk", true)) do
    if k == var1 then
      cecho("&lt;green&gt;[Issue speedwalk to " .. var1 .. " at " .. v .. "]\n")
  
      fastwalk(v)

      return
    end
  end

  if var1 == "add" and var2 ~= nil then
    local targetroom = tonumber(var3) or map:getRoom()
   
    cecho("&lt;green&gt;[Adding fwalk for (" .. var2 .. ") to destination " .. targetroom .. "]\n")

    tmpvar[var2] = targetroom
    charData:set("fwalk", tmpvar, true)

    return
  end

  if var1 == "del" and tmpvar[var2] ~= nil then
    cecho("&lt;green&gt;[Deleting fwalk for (" .. var2 .. ") at destination " .. tmpvar[var2] .. "]\n")

    tmpvar[var2] = nil
    charData:set("fwalk", tmpvar, true)

    return
  end

  for k,v in pairs(tmpvar) do

    if roomExists(v) then
      local zoneid=tonumber(getRoomUserData(v, "zoneid") )
      local pathlength=0

      if roomLocked(v) == false then
        if getPath( map:getRoom(), v) then
          pathlength=#speedWalkPath
        end
      end

      if pathlength ~= 0 or map:getRoom() == v then
        tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
      end
    end
  end

  cecho("&lt;white&gt;             Area                  Room#      fwalk     Distance          Room Name\n")
  printSorted(tmplist)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@fwalk( [0-9a-zA-Z]+)?( [0-9a-zA-Z]+)?( [0-9]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@path</name>
					<script>-- findpath either to room number or fwalk name

function tt(s)
   local t={}

   for p in s:gmatch("..?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?") do
       t[#t+1]=p
   end

   for i,v in ipairs(t) do
       print("." .. v)
   end

  echo("\n")
end


function showfastwalk(xroomid)
  if roomLocked(xroomid) then
    cecho("&lt;red&gt;[Error: Destination room is locked]\n")
    return
  end

  assert(map:getRoom(), "[Error: source room id is nil]")

  if getPath(map:getRoom(), xroomid) then
    local path= compressSpeedwalk()

    if #speedWalkPath &gt; 100 then
      cecho("&lt;red&gt;Path length: &lt;green&gt;" .. #speedWalkPath .. " &lt;red&gt;rooms 100th room &lt;green&gt; " .. speedWalkPath[100] .. "\n\n")
    else
      cecho("&lt;red&gt;Path length: &lt;green&gt;" .. #speedWalkPath .. " &lt;red&gt;rooms\n\n")
    end

    cecho("&lt;red&gt;Path from current room (" .. map:getRoom() .. ") to " .. xroomid .. " (" .. getRoomName(xroomid) .. ")\n")


    --echo("Rooms we'll pass through: " .. table.concat(speedWalkPath, ", ") .. "\n\n")

    cecho("&lt;green&gt;Speedwalk: ." .. compressSpeedwalk() .. "\n\n")

    if string.len(path) &gt; 100 then
      tt(path)
    end

    cecho("&lt;red&gt;Reverse path from " .. xroomid ..  " (" .. getRoomName(xroomid) .. ") to current room: " .. map:getRoom() .. " (" .. getRoomName(map:getRoom()) .. ")\n")

    getPath(xroomid, map:getRoom())

    cecho("&lt;green&gt;Speedwalk: ." .. compressSpeedwalk() .. "\n\n")

  else
    cecho("&lt;red&gt;[Unable to find path to room vnum " .. xroomid .. "]\n")
  end
end

if tonumber(matches[2]) ~= nil then
  showfastwalk(tonumber(matches[2]))
else
  for k,v in pairs(charData:get("fwalk", true)) do
    if k == matches[2] then
      showfastwalk(v)
      return
    end
  end
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@path ?([0-9a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@room</name>
					<script>-- toggle display of room window on/off

roomWindow:toggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@room$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@pracall</name>
					<script>enableTrigger("resend practice")

if table.size(toPractice) == 0 then
  cecho("&lt;red&gt;[No skills to practice]\n")
  return
end

for k,v in pairs(toPractice) do
  -- display(k)
  mud:send("prac " .. k)
  toPractice[k]=nil
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@pracall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@scribeall</name>
					<script>if table.size(toScribe) == 0 then
  cecho("&lt;red&gt;[No spells to scribe]\n")
  return
end

if matches[2] == "start" then
  enableTrigger("scribenext")

  for k,v in pairs(toScribe) do
    mud:send("prac " .. k)
    --mud:send("scribe " .. k)

    toScribe[k]=nil
    return
  end

  return
end

cecho("\n&lt;red&gt;[Type: '@scribeall start' to begin scribing the following spells:]\n")

for k,v in pairs(toScribe) do
  cecho("&lt;green&gt;" .. k .. "\n")
end

echo("\n")
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@scribeall ?(start)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@ungag</name>
					<script>local tmpvar = charData:get("gags", true)

if matches[2] == "" then
  echo("usage: @ungag text to ungag\n")
  echo("Existing gags:\n")
  display(tmpvar)
else
  for key,val in pairs(tmpvar) do
    if string.findPattern(matches[2]:lower(), val) then
      tmpvar[key]=nil
      echo(matches[2]:lower() .. " has been removed from gags.\n")
    end
  end

  charData:set("gags", tmpvar, true)

  display(tmpvar)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@ungag ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@roll</name>
					<script>if matches[2] == nil then
  cecho("&lt;red&gt;[Autoroller disabled.]\n")
  disableTrigger("RollerTrigger")
  return
end

local rollvalue = tonumber(matches[2])

charData:set("autoroll", rollvalue, true)

cecho("&lt;cyan&gt;[Autoroller enabled: Target= " .. rollvalue .. "]\n")

enableTrigger("RollerTrigger")
--mud:send("y")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@roll ?([0-9]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@fpet</name>
					<script>local currentroom = map:getRoom()
local missingpet

cecho("&lt;red&gt;@fpet: find pets\n")
cecho("&lt;red&gt;Type '@fpet get' to retrieve lost pets\n\n")

if currentroom ~= nil then
  cecho("&lt;green&gt;Currently in: (" .. currentroom .. ") " .. getRoomName(currentroom) .. "\n\n")
else
  cecho("&lt;red&gt;Current room: unknown\n\n")
end

for k, petname in pairs(pet:getTable()) do
  local petroom = pet:getRoom(petname)

  if currentroom ~= nil and petroom ~= nil then
    local roomname = getRoomName(petroom)

    if petroom == currentroom then
        cecho(string.format("&lt;green&gt;%16s : (%6s) %s\n", petname, tostring( pet:getRoom(petname) ), roomname) )
    else
        cecho(string.format("&lt;red&gt;%16s : (%6s) %s\n", petname, tostring( pet:getRoom(petname) ), roomname) )
      missingpet = pet:getRoom(petname)
    end
  else
    cecho(string.format("&lt;red&gt;%16s : %6s\n", petname, tostring( pet:getRoom(petname) ) ) )
  end
end

if matches[2] == "get" then
  if currentroom == nil or missingpet == nil then
    cecho("&lt;green&gt;\n[No missing pets]\n")
    return
  end

  if not charData:get("autoopen") then
    cecho("&lt;red&gt;\n[autoopen is currently disabled. '&lt;green&gt;set autoopen true&lt;red&gt;' prior to using fpet get]\n")
    return
  end

  -- fwalk to room, then return to current room

  cecho("&lt;green&gt;Retrieving pet from: " .. missingpet .. "\n")

  local path=getPath( currentroom, missingpet )

  if path then
    path= compressSpeedwalk()
  end

  local reversepath= getPath( missingpet, currentroom)

  if reversepath then
    reversepath= compressSpeedwalk()
  end


  if path and reversepath then
    cecho("&lt;green&gt;Moving: " .. path .. ", " .. reversepath .. "\n")

    expandAlias("." .. path, false)
    expandAlias("." .. reversepath, false)
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@fpet ?(get)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@gag</name>
					<script>local tmpvar = charData:get("gags", true)

if matches[2] == "reset" then
  cecho("&lt;red&gt;[ Resetting all custom gags ]\n")
  charData:set("gags", {}, true)
else
  if matches[2] == "" then
    cecho("&lt;red&gt;Usage:\n&lt;green&gt; @gag text to gag\n&lt;green&gt; @gag reset\n")
    cecho("&lt;red&gt;Existing gags:\n")
    display(tmpvar)
  else
    table.insert(tmpvar, matches[2]:lower())
    cecho("&lt;red&gt;[New gag created for: &lt;green&gt;" .. matches[2] .. "&lt;red&gt;]\n")
    charData:set("gags", tmpvar, true)
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@gag ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>claimall</name>
					<script>mud:send("auction list " .. whoami() )</script>
					<command></command>
					<packageName></packageName>
					<regex>^claimall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@version</name>
					<script>-- http://www.grokh.com/toril.db

NyyLIB.version = NyyLIB.version or "NyyLIB013dev"
NyyLIB.dbversion = NyyLIB.dbversion or "6/25/2023"

cecho ("\n&lt;red&gt;Script version: 6/27/2023 " .. NyyLIB.version .. " https://github.com/Nyyrazzilyss/NyyLIB\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@version$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>test</name>
					<script>-- setMapBackgroundColor() 
-- lua addSpecialExit(96415,96589, "enter portal")


--permAlias("full harm", "Cle", "^(?:fhm)( .+)?$", [[
--spell:setMoving(false)
--spell:setNext("FHM" .. (matches[2] or "") )
--]] )


--mud:send("tog wimp 0")
--mud:send("tog rescue-assist")


-- erase labels: for k,_ in pairs(getAreaTableSwap()) do for l,_ in pairs(getMapLabels(k)) do deleteMapLabel(k,l) end end

--for k,v in pairs(getRooms())do
-- if table.size(getRoomUserDataKeys(k)) == 0 then
--    display(k)
--    display( getRoomUserDataKeys(k) )
--  end
--end


--local nx=0

--for nx=1, table.size(NyyLIB.classes), 1 do
--  display(NyyLIB.classes[nx])
--end




-- set the ID to Mudlets own as an example
-- setDiscordApplicationID("450571881909583884")

-- display( setDiscordApplicationID("450571881909583884") )


--setDiscordApplicationID("499213906070339595")



-- set detail to your character name in-game, as an example
--display( setDiscordDetail("testing") )
--
--setDiscordGame("TorilMud")



-- NyyLIB.mapwindow = Geyser.Mapper:new({name="mapper",x="66%",y=0,width="33%",height="50%"})

--testwindow = Geyser.Label:new({name="minimap", x=0, y=0, width="100%", height="100%"}, NyyLIB.mapwindow)


-- lua Geyser.Label:getWindow("gIconBarWindow"):setStyleSheet([[background-color: black]])

--rollerstats=nil
--rollTime=nil

--display( getUrl("http://regexlib.com/CheatSheet.aspx") )


--testArray= { [0]={}, [1]={}}

--display( table.size(testArray[0]) )


--testArray[1]= {"test1"}
--testArray[2] = {"test2"}



--display( string.format("%02x", 0) )

--lineCapture = {}
--currentLine = line

--local nx

--local r,g,b


--for nx=1, #currentLine, 1 do
--  selectSection(nx, 1)
  
--  r,g,b = getFgColor()
  
--  lineCapture[nx]={ string.sub(currentLine, nx, nx), r, g, b }
--end

--display(lineCapture)

--hechoLink("winALL", "|ca00040black!", [[send("hi")]], "This is a tooltip", true)

--getFgColor(windowName)
--This function returns the rgb values of the color of the first character of the current selection on mini console (window) windowName. If windowName is omitted Mudlet will use the main screen.
--Parameters
--windowName:
--A window to operate on - either a miniconsole or the main window.
--Example
--local r,g,b;
--selectString("troll",1)
--r,g,b = getFgColor()
--if r == 255 and g == 0 and b == 0 then
--    echo("HELP! troll is written in red letters, the monster is aggressive!\n");
--end





--for k,v in pairs(demonnic.chat.windows) do
--  display(k)
--end

--display(demonnic.chat.windows["ALL"].name)

--display( equip:getWeapon() )


--local lastRoom=map:getRoom()
--local lastRoomName= map:getRoomname()


--echo("KILLED in " .. lastRoomName .. " (" .. lastRoom .. ")" )

--testvar2 = getLines(getLineNumber()-500, getLineNumber())

--display(testvar2)

--display( string.byte(testvar2, 7) )
--display( string.byte(testvar2, 8) )
--display( string.byte(testvar2, 9) )

--display( string.by

--local testString= "the name of an item (magic) (illum) (damaged)"


--display( string.gsub(testString, " %(.+%)", "") )


--capture = string.gsub(capture, "%(magic%)", "")
--capture = string.gsub(capture, "%(illuminating%)", "")
--capture = string.gsub(capture, "%(glowing%)", "")
--capture = string.gsub(capture, "%(damaged%)", "")




--local roomid = map:getRoom()

--if roomid ~= nil then
--  local zoneid=tonumber(getRoomUserData(roomid, "zoneid") )

--  echo(roomid .. ", " .. getRoomName(roomid) .. " : " .. NyyLIB.areaTable[zoneid] .. "\n")
--end


--cmi:checkConnection()
--cmi:labelCmudZones(cmi.con)

--NyyLIB.broken = {}

--for line in io.lines(homepath("roomfix.txt")) do
--  NyyLIB.broken[tonumber(line)]=true
--end

--for k,v in pairs(NyyLIB.broken) do
--  local roomnumber=k
--  local zone=map:getZone(roomnumber)
--  local roomname = getRoomName(k)

--  if zone ~= nil then
--    echo( string.format("%s %d %s\n", zone, roomnumber, roomname) )
--  else
--    display(roomnumber)
--  end
  --display(k)
  --display(getRoomName(k))
--end


--  display( rex.match( "http://www.yahoo.com",
--            "\b(?:(?:(?:https?|ftp|telnet)://[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+|www|ftp)(?:\.[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+)+|[\w\d._%+\-]+@[\w\d.\-]+\.[\w]{2,4})\b"
--          ) )




--function testFunction()
--  return 1, 2
--nd


--local v1, v2 = testFunction()


--display( v1 )
--display( v2 )


--local v1 = testFunction()
--display(v1)


--display( tonumber( charData:get("movebuffer") ) )


--openUserWindow("testwindow")
--cecho("testwindow", "&lt;red&gt;hello &lt;blue&gt;bob!")
--resizeWindow("testwindow", 100, 100) -- name,width,height)


--for roomid, roomname in pairs(fullmap) do
--  local internalid = getRoomArea(roomid)

--  local zone=getRoomUserData(roomid, "zoneid")
--  local zoneid=tonumber(zone)

  -- first letter is lowercase

--  if string.findPattern(roomname, "^[a-z]") then
  --  echo ( string.format("%6d %20s %20s\n", roomid, NyyLIB.areaTable[zoneid], roomname ) )
--        echo ( string.format("[%25s] %20s\n", NyyLIB.areaTable[zoneid], roomname ) )
--  end

  -- last letter is a period

  --if string.findPattern(roomname, "[.]$") then
    --echo ( string.format("%6d %20s %20s\n", roomid, NyyLIB.areaTable[zoneid], roomname ) )
  --    echo ( string.format("[%25s] %20s\n", NyyLIB.areaTable[zoneid], roomname ) )
  --end
--end


--getPath( 48603, 86738)
--display(speedWalkDir)

-- cecho("&lt;red&gt;&lt;test line&gt; extra st--uff")

-- window:setStyleSheet([[border-image: url(]] .. mainpath("roomborder.png") .. [[)]])


--display( setLabelStyleSheet("gRoomWindow", [[border-image: url(]] .. mainpath("roomborder.png") .. [[)]]) )


--roomLabel = Geyser.Label:new({name="gRoomLabel", x="33%", y="0%", width="33%", height="15c",}) -- -92c, -80c
-- roomLabel:setStyleSheet([[border-image: url(]] .. mainpath("roomborder.png") .. [[)]])

--roomLabel:setStyleSheet([[border-image: url(]] .. mainpath("flames.png") .. [[)]])


--local WindowWidth, WindowHeight = getMainWindowSize()

--display(WindowWidth)
--display(WindowHeight)

--splashwindow:move("10%", "10%")
--splashwindow:resize("50%", "75%")

--for k,v in pairs(pet:getTable()) do
--  display(v)
--  display( pet:getHP(v) / pet:getMaxHP(v) )
--end

--local spectrename=pet:getTable("ghast")[1]

--display(spectrename)


--if pet:status("spectre") then



--if charData:get("autoglobe") then
--  for k,char in pairs(groupList:pc("hitter")) do
--    local hp=tonumber(groupList:getHP(char))

--    if not buff:get("globe_of_invulnerability", char) and hp ~= 0 then
--      display(char)
--    end
--  end
--end




--display( pet:isNamed("ghost ayngst undead") )


--testwindow = Geyser.Label:new({name="vote", x="20%", y="10%", width="60%", height="60%"})
--testwindow:setStyleSheet([[border-image: url(]] .. mainpath("splash.png") .. [[)]])



--display( string.match("test string", "aa") )

--display( string.match( "You peer into a wormhole and see", "You peer into (.*) and see" ) )

--  local dopplechar = string.match(spellname, "^dopple (.*)")

--for k,v in pairs( groupList:pc("psi") ) do
--  display(v)
--end












--display( string.find("aff test", "^ff") )



--local mobnames=
--    { "zombie", "ghoul", "skeleton", "wight", "spectre", "ghast", "ghost"}

--for k,v in pairs(mobnames) do
--  display(v)
--end



--if string.findPattern("2.merchant", "(x[0-9]+)" ) ~= nil then
--  cecho(" &lt;red&gt;(x" .. (tonumber(string.findPattern(string.findPattern(previousline, "%(x([0-9]+)%)" ), "[0-9]+" ))+1) .. ")")
--end


--local tmp=to_snake("Globe of Invuln")

--display(tmp)

--display( to_english(tmp) )




--local scanresults = {}

--if #scanresults == 0 then
--  display("X")
--end



--  local WindowWidth, WindowHeight = getMainWindowSize()
--  local wwidth,wheight = calcFontSize(demonnic.chat.config.fontSize)

--  local tmp = (WindowWidth/3)/ wwidth
 

--display(tmp)


--   demonnic.chat.windows[tab]:setWrap(demonnic.chat.config.width)
--   demonnic.chat.windows[tab]:setWrap(tmp) 



--labelID = createMapImageLabel(areaID, filePath, posx, posy, posz, width, height, zoom, showOnTop)

--Creates an image label on the map at the given coordinates, with the given dimensions and zoom. You might find the default room and image size correlation to be too big - try reducing the width and height of the image then, while also zooming in the same amount.
--The coordinates 0,0 are in the middle of the map, and are in sync with the room coordinates - so using the x,y values of getRoomCoordinates() will place the label near that room.
--See also: deleteMapLabel
--Example
-- 138 is our pretend area ID
-- next, inside [[]]'s, is the exact location of our image
-- 0,0,0 are the x,y,z coordinates - so this will place it in the middle of the map
-- 482 is the width of the image - we divide it by 100 to scale it down, and then we'll zoom it by 100 - making the image take up about 4 rooms in width then
-- 555 is the original width of the image
-- 100 is how much we zoom it by, 1 would be no zoom
-- and lastly, false to make it go below our rooms
--createMapImageLabel(138, [[/home/vadi/Pictures/You only see what shown.png]], 0,0,0, 482/100, 555/100, 100, false)


--display ( getAreaTable() )

--display( iconpath("back1.png") )

--local testpath="C:\\Users\\Chris\\.config\\mudlet\\profiles\\toril010rc2-2\\NyyLIB010rc2\\back1.png"

--display ( createMapImageLabel(8, testpath, 46, 19, 0, 200, 200, 100, true) )



--for i,v in pairs(Geyser.Label) do

--  display(v.name)

  --display(v.name)

  --if v.name == othername then
  --  return v
  --end
--end

-- regex match
--display( string.match("You scan north...", "You scan (%w)") )


--playSoundFile("\\tmp\\165331__ani-music__tubular-bell-of-death.wav")
--playSoundFile("\\tmp\\209740__yummie__minion-yahoo-2.wav")
--playSoundFile("\\tmp\\274736__sforsman__distort-ring-2.wav")
--playSoundFile("\\tmp\\85568__joelaudio__dragon-roar.wav")
--playSoundFile("\\tmp\\45809__themfish__gas-fire-catch.wav")
--sound("365641__furbyguy__8-bit-alarm.wav")
--sound("105308__kovrov__rumble.wav")
--sound("139025__rj10328__131659-bertrof-game-sound-intro-to-game-80921-justinbw-buttonchime02up-4.wav")


--local testpattern =string.gsub("test-st", "-", "[-]")

--if string.findPattern("thisisatest-string", testpattern) then
--  display("match")
--end



--  NyyLIB.RightLabel:move(nil, "50%")

-- the entire window is 100%, just partially off screen

--  demonnic.chat.container:move(nil, 0)
--  demonnic.chat.container:resize(nil, "40%")

-- iconbar = 20
-- bottomcount = 

--local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")

--clearWindow("gGroupStatusWindow")
--bottomWindow:show()

--bottomWindow:echo( parseLine("&lt;red&gt;test1 \ntest2 \n") )
</script>
					<command></command>
					<packageName></packageName>
					<regex>^test$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>. speedwalk (tintin)</name>
					<script>if pagingmode then
  mud:send("")
  return
end

local dirString   =   matches[2]:lower()

for count, direction in string.gmatch(dirString, "([0-9]*)([neswud])") do      
  count = (count == "" and 1 or count)
   for i=1, count do
       expandAlias(direction)
   end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^[.]([0-9nsweudNSWEUD]+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>..reverse speedwalk (zmud)</name>
					<script>-- Walk reverse of path provided.
-- ..5ne will walk w5s

local reversePath = ""

local dirString   =   matches[2]:lower()

for count, direction in string.gmatch(dirString, "([0-9]*)([neswud])") do      
  reversePath = count .. NyyLIB.reversedirs[direction] .. reversePath
end

expandAlias("." .. reversePath, false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^[.][.]([0-9nsweudNSWEUD]+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name># repeat (tintin)</name>
					<script>for nx=1, matches[2], 1 do
  mud:send(matches[3])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#([0-9]+) (.+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>masks</name>
					<script>local printcount=0


for k,v in pairs(masks) do
  if table.size(v) == 1 then
    echo( string.format("%-6s ", k) )
    --printcount=printcount+1

    --if printcount==5 then
    --  printcount=0
    --  echo("\n")
    --end
  end
end

echo("\n\n")

for k,v in pairs(masks) do
  if table.size(v) ~= 1 then
    echo( string.format("%-20s %s\n", k, table.concat(v, "|") ) )
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^masks$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>advert</name>
					<script>mud:send("NHC Toril Mud Client Script Updated: 1/27/19 011 http://www.torilmud.com/phpBB3/viewtopic.php?f=4%26t=27194")
-- http://www.torilmud.com/phpBB3/viewtopic.php?f=4&amp;t=27194
-- https://bit.ly/2IkmckD</script>
					<command></command>
					<packageName></packageName>
					<regex>^advert$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>lf</name>
					<script>-- mud:send("gcc LF: phantom quill, talisman of demonic rage")
-- mud:send("gcc FT: skull-cap of truespeed, ashen cage, loop of shale, smoke filled crystal ball, seaweed ring, pelt of demonhide, headbands a-&gt;j, more")</script>
					<command></command>
					<packageName></packageName>
					<regex>^lf$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>sound</name>
					<script>mud:send("GCC LF: suggested sound id#'s and events to play them - https://www.freesound.org/")</script>
					<command></command>
					<packageName></packageName>
					<regex>^sound$</regex>
				</Alias>
				<Alias isActive="no" isFolder="no">
					<name>p</name>
					<script>mud:send(p(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^p (.*)</regex>
				</Alias>
				<Alias isActive="no" isFolder="no">
					<name>g</name>
					<script>mud:send(g(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^g (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>loot</name>
					<script>for nx=matches[2], 1, -1 do
  mud:send("GET all.coins " .. nx .. ".corpse")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^loot ([0-9]+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>meph</name>
					<script>mud:send("rescue ekahk")
mud:send("rescue mephit")
mud:send("rescue 2.mephit")
mud:send("rescue 3.mephit")
mud:send("rescue 4.mephit")
mud:send("rescue 5.mephit")
mud:send("rescue slaad")</script>
					<command></command>
					<packageName></packageName>
					<regex>^meph$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^swap ?(girdle|loop|slaad)?$</name>
					<script>local item=matches[2]

if item == nil then
  cecho("&lt;red&gt;[swap volance|onevolance|girdle|loop|slaad|slaads|time|oneslaad to change item]\n")
  return
end

if item == "volance" then
  mud:send("rem volance")
  mud:send("rem volance")
  mud:send("wear volance")
  mud:send("wear volance")
  timer:set("TiaVolance", 1)
elseif item == "warder" then
  mud:send("get warder hole")
  mud:send("rem warder")
  mud:send("put warder hole")
  mud:send("wear warder")
elseif item == "onevolance" then
  mud:send("get volance hole")
  mud:send("rem volance")
  mud:send("put volance hole")
  mud:send("wear volance")
elseif item == "sleeves" then
  timer:set("TiaSleeves", 0)
  mud:send("get gossamer hole")
  mud:send("rem gossamer")
  mud:send("put gossamer hole")
  mud:send("wear gossamer")
elseif item == "manacle" then
  mud:send("get unfettered hole")
  mud:send("rem unfettered")
  mud:send("put unfettered hole")
  mud:send("wear unfettered")
  timer:set("TiaManacle", nil)
elseif item == "manacles" then
  mud:send("rem manacle")
  mud:send("rem manacle")
  mud:send("wear 2.manacle")
  mud:send("wear manacle")
  timer:set("TiaManacle", nil)
elseif item == "time" then
  mud:send("rem time")
  mud:send("get 3.time hole")
  mud:send("wear time")
  mud:send("put time hole")
elseif item == "loop" then
  mud:send("rem loop")
  mud:send("rem loop")
  mud:send("wear 2.loop")
  mud:send("wear loop")
  timer:set("TiaLoop", 1)
elseif item == "slaad" then
  mud:send("rem baatorian")
  mud:send("rem baatorian")
  mud:send("wear 2.baatorian")
  mud:send("wear baatorian")
  timer:set("baatorian", 1)
elseif item == "slaads" then
  mud:send("get baatorian hole")
  mud:send("get baatorian hole")
  mud:send("rem baatorian")
  mud:send("rem baatorian")
  mud:send("put baatorian hole")
  mud:send("put baatorian hole")
  mud:send("wear baatorian")
  mud:send("wear baatorian")
  timer:set("baatorian", 1)
elseif item == "oneslaad" then
  mud:send("get 4.baatorian portable")
  mud:send("rem baatorian")
  mud:send("put baatorian hole")
  mud:send("wear baatorian")
elseif item == "girdle" then
  mud:send( g("girdle") )
  mud:send("rem girdle")
  mud:send( p("girdle") )
  mud:send("wear girdle")
  timer:set("SuppleGirdle", 1)
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^swap ?(sleeves|girdle|loop|slaad|slaads|time|oneslaad|volance|onevolance|manacle|manacles|warder)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>dresschar</name>
					<script>mud:send("storage retrieve hole")

mud:send("get insignia hole")
mud:send("wear insignia")

if whoami() == "Innanin" then
  mud:send("get merchants hole")
  mud:send("wear merchants")
  mud:send("get matriarch merchants")
  mud:send("wield matriarch")
  mud:send("get bane merchants")
  mud:send("wield bane")
  mud:send("get serpent hole")
  mud:send("get cringing merchants")
  mud:send("get buckles merchants")
  mud:send("get silvered merchants")
  mud:send("wear all")
  mud:send("get crescent merchants")
  mud:send("get kossuth merchants")
  mud:send("get congealed merchants")
  mud:send("get congealed merchants")
  mud:send("get cincture merchants")
  mud:send("get demonleather merchants")
  mud:send("wear all")
  mud:send("get lustrous merchants")
  mud:send("get lustrous merchants")
  mud:send("get darkness merchants")
  mud:send("get marilith merchants")
  mud:send("get extremely merchants")
  mud:send("get protruding merchants")
  mud:send("get gauntlets merchants")
  mud:send("get rakshasa merchants")
  mud:send("wear all")
  mud:send("get seal hole")
end

if whoami() == "Bombad" then
  mud:send("storage retrieve glory")
  mud:send("wield glory")
  mud:send("get chimera hole")
  mud:send("wear chimera")
  mud:send("get ashstone hole")
  mud:send("wear ashstone")
  mud:send("get fires hole")
  mud:send("wear fires")
  mud:send("get stud hole")
  mud:send("wear stud")
  mud:send("get segmented hole")
  mud:send("wear segmented")
  mud:send("get segmented hole")
  mud:send("wear segmented")
  mud:send("get mask hole")
  mud:send("wear mask")
  mud:send("get selari hole")
  mud:send("wear selari")
  mud:send("get waistwrap hole")
  mud:send("wear waistwrap")
  mud:send("get warder hole")
  mud:send("wear warder")
  mud:send("get time hole")
  mud:send("wear time")
  mud:send("get unfettered hole")
  mud:send("wear unfettered")
  mud:send("get baatorian hole")
  mud:send("wear baatorian")
  mud:send("get planetar hole")
  mud:send("wear planetar")
  mud:send("get rock hole")
  mud:send("get rock hole")
  mud:send("wear rock")
  mud:send("wear rock")
  mud:send("get balor hole")
  mud:send("wear balor")
  mud:send("get flame hole")
  mud:send("wear flame")
  mud:send("get seal hole")
end

if whoami() == "Rrissun" then
  mud:send("storage retrieve glory")
  mud:send("wield glory")
  mud:send("get chimera hole")
  mud:send("wear chimera")
  mud:send("get drow.mask hole")
  mud:send("wear mask")
  mud:send("get warder hole")
  mud:send("wear warder")
  mud:send("get baatorian hole")
  mud:send("wear baatorian")
  mud:send("get rock hole")
  mud:send("get rock hole")
  mud:send("wear rock")
  mud:send("wear rock")
  mud:send("get waistwrap hole")
  mud:send("get time hole")
  mud:send("get planetar hole")
  mud:send("get matter hole")
  mud:send("wear all")
  mud:send("get unfettered hole")
  mud:send("get selari hole")
  mud:send("get symbol.ashstone hole")
  mud:send("get symbol hole")
  mud:send("get nine.pearls hole")
  mud:send("wear all")
  mud:send("get seal hole")
  mud:send("powers info vit")
end

if whoami() == "Adud" or whoami() == "Wopur" or whoami() == "Samem" or whoami() == "Ihgod" or whoami() == "Tutenef" then
  mud:send("storage retrieve valhalla")
  mud:send("wield valhalla")

  if whoami() ~= "Tutenef" then
    mud:send("get shield hole")
    mud:send("wear shield")
    mud:send("get berserker hole")
  else
    mud:send("get electricity hole")
    mud:send("get graven hole")
    mud:send("wield graven")
  end
  
  mud:send("get serpent hole")
  mud:send("get girdle hole")
  mud:send("get mask hole")
  mud:send("get stud hole")
  mud:send("get stud hole")
  mud:send("wear all")
  mud:send("get quiver hole")
  mud:send("get isha hole")
  mud:send("get cenobite hole")
  mud:send("get mail hole")
  mud:send("get stability hole")
  mud:send("get sorcerous.loop hole")
  mud:send("get sorcerous.loop hole")
  mud:send("wear all")
  mud:send("get volance hole")
  mud:send("get volance hole")
  
  mud:send("get shard hole")
  mud:send("get plates hole")
  mud:send("get bracer.mithril.mesh hole")
  mud:send("get darkwood hole")
  mud:send("wear all")
  mud:send("get seal hole")
end

if whoami() == "Samem" then
  mud:send("storage retrieve planetar")
end

if whoami() == "Nyyrazzilyss" then
  mud:send("get barrier hole")
  mud:send("wear barrier")
  mud:send("get arch hole")
  mud:send("get fires hole")
  mud:send("get all.drow hole")
  mud:send("get force hole")
  mud:send("get swirling.mantle hole")
  mud:send("wear all")
  mud:send("put drow hole")
  mud:send("get gossamer hole")
  mud:send("get slaadi hole")
  mud:send("get breeches hole")
  mud:send("get kinesis hole")
  mud:send("get kinesis hole")
  mud:send("wear all")
  mud:send("get sandals hole")
  mud:send("get baatorian hole")
  mud:send("get baatorian hole")
  mud:send("wear all")
end

if whoami() == "Bonble" then
  mud:send("get merchants hole")
  mud:send("wear merchants")
  mud:send("get matriarch merchants")
  mud:send("wield matriarch")
  mud:send("get ravenous merchants")
  mud:send("wield ravenous")
  mud:send("get serpent hole")
  mud:send("get gossamer hole")
  mud:send("get cringing merchants")
  mud:send("get buckles merchants")
  mud:send("get silvered merchants")
  mud:send("get crescent merchants")
  mud:send("wear all")
  mud:send("get gorget hole")
  mud:send("get congealed merchants")
  mud:send("wear congealed")
  mud:send("get baatorian hole")
  mud:send("get baatorian hole")
  mud:send("get insignia hole")
  mud:send("get girdle hole")
  mud:send("wear all")
  mud:send("get batskull hole")
  mud:send("get swirling hole")
  mud:send("get kinesis hole")
  mud:send("get rock hole")
  mud:send("get scalemail merchants")
  mud:send("get sharp hole")
  mud:send("get marilith merchants")
  mud:send("wear all")
  mud:send("get seal hole")
end

if whoami() == "Vottoc" then
  mud:send("get merchants hole")
  mud:send("wear merchants")
  mud:send("get matriarch merchants")
  mud:send("wield matriarch")
  mud:send("get bane merchants")
  mud:send("wield bane")
  mud:send("get blue.scale merchants")
  mud:send("get magma.boots hole")
  mud:send("get fireballs merchants")
  mud:send("get cringing merchants")
  mud:send("get congealed merchants")
  mud:send("get congealed merchants")
  mud:send("wear all")
  mud:send("get gorget hole")
  mud:send("get gorget hole")
  mud:send("get gloomhaven hole")
  mud:send("get baatorian hole")
  mud:send("get bracer hole")
  mud:send("get insignia hole")
  mud:send("wear all")
  mud:send("get liquid.rock hole")
  mud:send("get liquid.rock hole")
  mud:send("get dwarfhide merchants")
  mud:send("get fire.giant merchants")
  mud:send("get studs merchants")
  mud:send("get scalemail merchants")
  mud:send("get swirling.shadows hole")
  mud:send("get girdle hole")
  mud:send("wear all")
  mud:send("get seal hole")
end

if whoami() == "Ajac" or whoami() == "Imseh" or whoami() == "Aynep" or whoami() == "Cajeed" then
  mud:send("get barrier hole")
  mud:send("wear barrier")
  mud:send("get arch hole")
  mud:send("hold arch")
  mud:send("get chimera hole")
  mud:send("get mauve hole")
  mud:send("get batskull hole")
  mud:send("get fires hole")
  mud:send("get all.drow hole")
  mud:send("wear all")
  mud:send("get all.force hole")
  mud:send("get swirling hole")
  mud:send("get slaadi hole")
  mud:send("get gossamer hole")
  mud:send("wear all")
  mud:send("get kinesis hole")
  mud:send("get kinesis hole")
  mud:send("get breeches hole")
  mud:send("wear all")
  mud:send("get baatorian hole")
  mud:send("get baatorian hole")
  mud:send("get sharp hole")
  mud:send("wear all")
  mud:send("get sandals hole")
  mud:send("wear sandals")
end

if whoami() == "Rrassulis" then
  mud:send("get barrier hole")
  mud:send("wear barrier")
  mud:send("get arch hole")
  mud:send("hold arch")
  mud:send("get chimera hole")
  mud:send("get mauve hole")
  mud:send("get amethyst hole")
  mud:send("get all.force hole")
  mud:send("wear all")
  mud:send("get all.drow hole")
  mud:send("get swirling hole")
  mud:send("get slaadi hole")
  mud:send("get gossamer hole")
  mud:send("wear all")
  mud:send("get kinesis hole")
  mud:send("get rock hole")
  mud:send("wear all")
  mud:send("get baatorian hole")
  mud:send("get baatorian hole")
  mud:send("get sharp hole")
  mud:send("wear all")
  mud:send("get diamond hole")
  mud:send("wear diamond tail")
  mud:send("get seal hole")
end

mud:send("equip")</script>
					<command></command>
					<packageName></packageName>
					<regex>^dresschar$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>undresschar</name>
					<script>function removeAll()
  mud:send("rem all")
  mud:send("put all hole")
  mud:send("rem all")
  mud:send("put all hole")
  mud:send("rem all")
  mud:send("put all hole")
end

mud:send("storage access nyyrazzilyss")

mud:send("rem insignia")
mud:send("put insignia hole")

if whoami() == "Innanin" then
  mud:send("rem insignia")
  mud:send("rem circlet")
  mud:send("put all hole")
  mud:send("rem all")
  mud:send("put all merchants")
  mud:send("rem all")
  mud:send("put all merchants")
  mud:send("rem all")
  mud:send("put all merchants")
  mud:send("get portable merchants")
  mud:send("put merchants portable")
end
  
if whoami() == "Rrissun" or whoami() == "Bombad" then
  mud:send("rem warmaul")
  mud:send("storage store warmaul")
  removeAll()
end

if whoami() == "Ajac" or whoami() == "Imseh" or whoami() == "Aynep" or whoami() == "Rrassulis" or whoami() == "Cajeed" then
  removeAll()

  if whoami() == "Aynep" then
    mud:send("get tome hole")
  elseif whoami() == "Ajac" then
    mud:send("get midnight-blue hole")
  else
    mud:send("get planetar hole")
  end

     mud:send("get barrel hole")
end

if whoami() == "Nyyrazzilyss" then
  mud:send("rem barrier")
  mud:send("put barrier hole")
  mud:send("rem fires")
  mud:send("put fires hole")
  mud:send("rem ice")
  mud:send("put ice hole")
  mud:send("rem drow")
  mud:send("rem drow")
  mud:send("put all.drow hole")
  mud:send("rem force")
  mud:send("put force hole")
  mud:send("rem swirling")
  mud:send("put swirling hole")
  mud:send("rem pixie")
  mud:send("put pixie hole")
  mud:send("rem belt")
  mud:send("put belt hole")
  mud:send("rem sleeves")
  mud:send("put sleeves hole")
  mud:send("rem bracer")
  mud:send("rem bracer")
  mud:send("put all.bracer hole")
  mud:send("rem ring")
  mud:send("rem ring")
  mud:send("put all.ring hole")
  mud:send("rem staff")
  mud:send("put staff hole")
  mud:send("rem breeches")
  mud:send("put breeches hole")
  mud:send("rem sandals")
  mud:send("put sandals hole")
end

if whoami() == "Samem" then
  mud:send("rem planetar")
  mud:send("storage store planetar")
end

if whoami() == "Adud" or whoami() == "Wopur" or whoami() == "Samem" or whoami() == "Ihgod" or whoami() == "Tutenef" then
  mud:send("rem valhalla")
  mud:send("storage store valhalla")
  removeAll()
end

if whoami() == "Bonble" then
  mud:send("rem gossamer")
  mud:send("rem serpent")
  mud:send("rem swirling")
  mud:send("rem baatorian")
  mud:send("rem baatorian")
  mud:send("rem kinesis")
  mud:send("rem rock")
  mud:send("rem sharp")
  mud:send("rem batskull")
  mud:send("put all hole")
  mud:send("rem sandals")
  mud:send("put sandals hole")
  mud:send("rem girdle")
  mud:send("put girdle hole")
  mud:send("rem all")
  mud:send("put all merchants")
  mud:send("rem all")
  mud:send("put all merchants")
  mud:send("get hole merchants")
  mud:send("put merchants hole")
end

if whoami() == "Vottoc" then
  mud:send("rem crown")
  mud:send("put crown merchants")
  mud:send("rem blood")
  mud:send("rem blood")
  mud:send("rem batskull")
  mud:send("put batskull merchants")
  mud:send("put all.blood merchants")
  mud:send("rem cringing")
  mud:send("put cringing merchants")
  mud:send("rem blue.scale")
  mud:send("put blue.scale merchants")
  mud:send("rem scalemail")
  mud:send("put scalemail merchants")
  mud:send("rem swirling")
  mud:send("put swirling hole")
  mud:send("rem sleeves")
  mud:send("put sleeves merchants")
  mud:send("rem baatorian")
  mud:send("rem baatorian")
  mud:send("put all.baatorian hole")
  mud:send("rem liquid.rock")
  mud:send("put rock hole")
  mud:send("rem liquid.rock")
  mud:send("put rock hole")
  mud:send("rem matriarch")
  mud:send("put matriarch merchants")
  mud:send("rem bane")
  mud:send("put bane merchants")
  mud:send("rem magma.boots")
  mud:send("put boots hole")
  mud:send("rem merchants")
  mud:send("rem studs")
  mud:send("put studs hole")
  mud:send("rem gorget")
  mud:send("put gorget hole")
  mud:send("rem gorget")
  mud:send("put gorget hole")
  mud:send("put merchants hole")
end

mud:send("put sack hole")

mud:send("storage store hole")

mud:send("equip")</script>
					<command></command>
					<packageName></packageName>
					<regex>^undresschar$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>encon</name>
					<script>mud:send("rem circlet")
mud:send("get hat hole")
mud:send("wear hat")
mud:send("put circlet hole")
mud:send("rem kinesis")
mud:send("rem kinesis")
mud:send("put kinesis hole")
mud:send("put kinesis hole")
mud:send("get power hole")
mud:send("wear power")
mud:send("get power hole")
mud:send("wear power")
mud:send("rem staff")
mud:send("put staff hole")
mud:send("get dagger hole")
mud:send("wield dagger")
mud:send("rem mask")
mud:send("get gem hole")
mud:send("wear gem")
mud:send("put mask hole")
mud:send("powers info time")
mud:send("powers info gi")
mud:send("powers info blur")
mud:send("powers info hs")</script>
					<command></command>
					<packageName></packageName>
					<regex>^encon$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>encoff</name>
					<script>mud:send("rem hat")
mud:send("get circlet hole")
mud:send("wear circlet")
mud:send("put hat hole")
mud:send("rem power")
mud:send("rem power")
mud:send("put power hole")
mud:send("put power hole")
mud:send("get kinesis hole")
mud:send("wear kinesis")
mud:send("get kinesis hole")
mud:send("wear kinesis")
mud:send("rem dagger")
mud:send("put dagger hole")
mud:send("get staff hole")
mud:send("hold staff")
mud:send("rem gem")
mud:send("put gem hole")
mud:send("get mask hole")
mud:send("wear mask")
mud:send("powers info time")
mud:send("powers info gi")
mud:send("powers info blur")
mud:send("powers info hs")</script>
					<command></command>
					<packageName></packageName>
					<regex>^encoff$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>fly</name>
					<script>if charData:get("container") == nil then
  cecho("&lt;red&gt;[container not set]\n")
  return
end

mud:send("rem swirling")
mud:send( p("swirling") )
mud:send( g("wings") )
mud:send("wear wings")</script>
					<command></command>
					<packageName></packageName>
					<regex>^ffly$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>walk</name>
					<script>if charData:get("container") == nil then
  cecho("&lt;red&gt;[container not set]\n")
  return
end

mud:send("rem wings")
mud:send( p("wings") )
mud:send( g("swirling") )
mud:send("wear swirling")</script>
					<command></command>
					<packageName></packageName>
					<regex>^walk$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>food</name>
					<script>local container=charData:get("container")

if container == "" then
  cecho("&lt;red&gt;[container not set]\n")
  return
end

mud:send("EAT " .. charData:get("food") .. " " .. container)
mud:send( g(charData:get("canteen")) )
mud:send("DRINK " .. charData:get("canteen") )
mud:send( p(charData:get("canteen")) )</script>
					<command></command>
					<packageName></packageName>
					<regex>^food$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>seal</name>
					<script>mud:send( g("seal") )
mud:send("rec seal me")</script>
					<command></command>
					<packageName></packageName>
					<regex>^seal$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>vitme</name>
					<script>mud:send("quaff cactus " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^vitme$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>armor</name>
					<script>mud:send( g("ab") )
mud:send("rec ab me")</script>
					<command></command>
					<packageName></packageName>
					<regex>^armor$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>scaleme</name>
					<script>mud:send("quaff blood hole")
--mud:send("quaff blood " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^scaleme$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>hasteme</name>
					<script>mud:send("quaff haste " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^hasteme$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>zzz</name>
					<script>mud:send("get mistwalker hole")
mud:send("rec mistwalker me")

if checkMask("psi") then
  mud:send("darkness")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^zzz$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>multidrag</name>
					<script>display("drag " .. matches[2] .. " corpses " .. matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^multidrag ([0-9]+) ([nsewud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>tiap ?(gsay|acc)?</name>
					<script>if matches[2] == "gsay" then
  --send("gsay * Tiamat Points - This does NOT include current run")
end

for k,char in pairs(groupList:pc()) do
  if inwho(char) then
    local temp=string.format("[%11s] (%13s) %6d\n", char,  "@" .. inwho(char),getPoints(inwho(char)) )

    if matches[2] == nil then
      echo(temp)
    end

    if matches[2] == "gsay" then
      mud:send("GSAY * " .. temp)
    end

    if matches[2] == "acc" then
      mud:send("ACC * " .. temp)
    end
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^tiap ?(gsay|acc)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>testportal</name>
					<script>enteredPortal={}

alreadyEnteredPortal=true

spell:clear()

mud:send("ST")

display( map:getRoom())

if map:getRoom() ~= nil then
    local specialexit = getSpecialExitsSwap( map:getRoom() )

    display(specialexit)

    if table.size(specialexit) == 1 then
      for k,v in pairs(specialexit) do
          local exitcmd=string.split(k, "|")[1]

          display(exitcmd)

          
          map:processMovement(exitcmd)
          --mud:send (exitcmd)
      end
    end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^testportal$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@ynnd</name>
					<script>mud:send("t Ynndchiarhlizz worm " .. whoami() )</script>
					<command></command>
					<packageName></packageName>
					<regex>^@ynnd$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@fol mobname</name>
					<script>-- follow an unfollowable mob

toFollow = matches[2]

cecho("&lt;green&gt;[Now following: " .. string.title(matches[2]) .. "]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@fol (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@dp - divine powers/ bracelet</name>
					<script>mud:send("get mist.realms hole")
mud:send("rem baatorian")
mud:send("wear mist.realms")
mud:send("SAY stronmaus")
mud:send("rem mist.realms")
mud:send("put mist.realms hole")
mud:send("wear baatorian")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@dp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@minimap</name>
					<script>-- toggle display of room window on/off

miniMap:toggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@minimap$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@resize</name>
					<script>-- 1920x1080 (1920x923, 1920x687)
-- 1280x687
-- 1366x625
-- 1280x700
-- 1024x768

if matches[2] ~= nil and matches[3] ~= nil then
  setMainWindowSize( tonumber(matches[2]), tonumber(matches[3])+129 )

  cecho("&lt;red&gt;[ Screen resized to x: " .. tonumber(matches[2]) .. " y: " .. tonumber(matches[3]) .. " ]")
else
  local WindowWidth, WindowHeight = getMainWindowSize()
  
  cecho("&lt;red&gt;Screen size: X: &lt;green&gt;" .. WindowWidth .. " &lt;red&gt;Y: &lt;green&gt;" .. WindowHeight .. "\n")

  cecho("&lt;red&gt;Usage: @resize xs ys\n\n")

  echo("1920x1080 (1920 923, 1920 687\n")
  echo("1280x687\n")
  echo("1366x625\n")
  echo("1280x700\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@resize(?: ([0-9]+) ([0-9]+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@chat</name>
					<script>chat:toggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@chat$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>New alias</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@hide</name>
					<script>chatAdjCon:hide()
minimapAdjCon:hide() -- minimap
NyyLIB.mapwindow:hide()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@hide$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@resetgui</name>
					<script>
if minimapAdjCon.isUserWindow then
  minimapAdjCon:onDoubleClick()
  convertAdj.sendToPosition(nil, nil, "48.16%", 0, "main")
  minimapAdjCon:resize("15.64%", "31.23%")
else
  minimapAdjCon:move("48.16%", 0)
  minimapAdjCon:resize("15.64%", "31.23%")
  miniMap:center()
  minimapAdjCon:show()
end


if mapAdjCon.isUserWindow then
  mapAdjCon:onDoubleClick()
  convertAdj.sendToPosition(nil, nil, "63.6%", 0, "main")
  mapAdjCon:resize("36.2%", "30.9%")
else
  mapAdjCon:move("63.6%", 0)
  mapAdjCon:resize("36.2%", "30.9%")
  mapAdjCon:show()
end

NyyLIB.mapwindow:show()

if chatAdjCon.isUserWindow then
  chatAdjCon:onDoubleClick()
  convertAdj.sendToPosition(nil, nil, "59.6%", "31.2%", "main")
  chatAdjCon:resize("40.11%", "17.18%")
else
  chatAdjCon:resize("40.11%", "17.18%")
  chatAdjCon:move("59.6%", "31.2%")
  chatAdjCon:show()
end

--NyyLIB.buttonpanel:show()

NyyLIB.settingsbutton:setStyleSheet(
  [[ QLabel{ border-image: url(]] .. iconpath("settings.png") .. [[);} ]] )
    
NyyLIB.settingsbutton:setClickCallback("toggleRightIconWindow")

if buttonPanel then
  toggleRightIconWindow()
end

cecho("&lt;red&gt;[ GUI window positioning reset ]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@resetgui$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@chatfs</name>
					<script>chatAdjCon:show()

if matches[2] == " partial" then
  chatAdjCon:move("20%",0)
else
  chatAdjCon:move(0,0)
end

if chatAdjCon.isUserWindow then
  chatAdjCon:onDoubleClick()
  convertAdj.sendToPosition(nil, nil, 0, 0, "main")
else
  chatAdjCon:move(0, 0)
  chatAdjCon:show()
end

chatAdjCon:resize("100%", "100%")

demonnic.chat:fixWrap()

NyyLIB.settingsbutton:setStyleSheet(
   [[ QLabel{ border-image: url(]] .. iconpath("tiles.png") .. [[);} ]] )

NyyLIB.settingsbutton:setClickCallback("toggleRightIconWindow")

--NyyLIB.settingsbutton:setToolTip("tile", "10")
--NyyLIB.settingsbutton:setClickCallback("tile:toggle")

NyyLIB.settingsbutton:raise()

NyyLIB.buttonpanel:hide()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@chatfs( partial)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@uptime</name>
					<script>display(getMudletVersion())

echo ("Mudlet has been runnning:\n")
shms(getEpoch()-startupTime, true)

echo ("\nCurrent profile has been connected:\n")
shms(getEpoch()-connectTime, true)
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@uptime$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@updatedb</name>
					<script>cecho("&lt;red&gt;Downloading current Katumi database.\n")
downloadFile( homepath("toril.db"), "http://www.grokh.com/toril.db")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@updatedb$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@cleanup</name>
					<script>display("This is the unwritten @cleanup command")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@cleanup$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@coltable</name>
					<script>local colourtable=getCustomEnvColorTable()

echo("257-272 are defaults\n")

for k,v in pairs(colourtable) do

  --if (k &lt; 257 or k &gt; 272) then
    hecho(string.format("\n#%02x%02x%02x Color entry: %d { %d %d %d }", v[1], v[2], v[3], k, v[1], v[2], v[3]) )
  --end
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@coltable$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@listenv</name>
					<script>local env= tonumber(matches[2])
local roomTable= getRooms()

--hecho(string.format("\n#%02x%02x%02x Color entry: %d { %d %d %d }", v[1], v[2], v[3], k, v[1], v[2], v[3]) )

for k,v in pairs(roomTable) do
  if getRoomEnv(k) == env then
    cecho(string.format("&lt;green&gt;%30s Room ID: %6d  %s\n", getRoomAreaName(getRoomArea(k)), k, v))
  end
end


</script>
					<command></command>
					<packageName></packageName>
					<regex>^@listenv ([0-9]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>save colour table</name>
					<script>local roomTable= getRooms()

colourtable = {}

colourtable.rooms={}

for k,v in pairs(roomTable) do
  colourtable.rooms[k]=getRoomEnv(k)
end

colourtable.env= getCustomEnvColorTable()

table.save(getMudletHomeDir().."/colours.lua", colourtable)
</script>
					<command></command>
					<packageName></packageName>
					<regex>^savecol$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@stylerooms</name>
					<script>-- 7/7 added * as search pattern to return entire map (or rooms in zone if zonenumber include)

-- setCustomEnvColor(environmentID, r,g,b,a)

-- default room: 600 {47,79,79}
-- setCustomEnvColor(600, 47, 79, 79, 255)

--silverymoon: zone 237
-- @stylerooms park 258 237
-- @stylerooms silverglen 258 237

-- @stylerooms * 600 237

-- ashstone
-- @stylerooms dragonride 259 85
-- @stylerooms Caravansary Way 259 85
-- @stylerooms Caravansery Way 259 85
-- @stylerooms Dragon Plaza 259 85
-- @stylerooms garden 258 85

--jungle
-- Terrain: Roads/Trails, Color entry: 259 { 128 128 0 }'        road|street|avenue|path
-- park
-- greycloak hills 258
-- somewhere in the hills 258
-- lost in a hill 258
-- evermoor way 258
-- reaching woods 258
-- sylvan glades
-- ancient trees
-- the eastway
-- forest
-- trail
-- field
-- bridge
-- wastelands               (avernus)
-- wasteland 272
-- base of the pillar 272
-- alleyway 517
-- (water)

-- matches[2] search pattern 
-- matches[3] colour table entry
-- matches[4] optional zone number


local targetzone=0

if matches[4] ~= nil then
  targetzone=tonumber(matches[4])
end

local rooms

if matches[2] == "*" then
  rooms = getRooms()
else
  rooms = searchRoom(matches[2])
end

for roomID,v in pairs(rooms) do
  local rzone=tonumber(getRoomUserData(roomID, "zoneid"))
  
  if targetzone == 0 or targetzone == rzone then
    echo(v .. "\n")
    setRoomEnv(roomID, tonumber(matches[3]))
  end
end

--display(matches[2])
--display(matches[3])
--display(targetzone)</script>
					<command></command>
					<packageName></packageName>
					<regex>^@stylerooms ([a-z*A-Z'\(\) -]+) (\d+)( \d+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@freqtable</name>
					<script>local ftable={}
local targetzone=0

if matches[2] then
  targetzone=tonumber(matches[2])
end

for k,v in pairs(getRooms()) do
  local rzone=tonumber(getRoomUserData(k, "zoneid"))
    
  if targetzone==0 or targetzone==rzone then
    roomwords= string.split( string.lower(v), " ")

    for k2, v2 in pairs(roomwords) do
      if not table.contains({ "the", "a", "of", "in", "an", "at", "on" }, v2) then -- words to exclude
        ftable[v2]=ftable[v2] or 0
        ftable[v2]=ftable[v2]+1
      end
    end
  end
end


local arr = {}

for key, value in pairs(ftable) do
  arr[#arr + 1] = {key, value}
end


table.sort(arr, function(a,b) return a[2] &gt; b[2] end )

display(#arr)


for nx=0,38,1 do  -- math.floor(#arr/7)
  for dx=1,7,1 do
    local entry=nx*7+dx
    
    if arr[entry] then
      echo( string.format("%d) %s (%d) ", entry, arr[entry][1], arr[entry][2]) )
    end
  end
    
  echo("\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@freqtable( [0-9]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@recol</name>
					<script>-- westgate

expandAlias("@stylerooms * 600 356") -- set all rooms in westgate to 600

expandAlias("@stylerooms (water) 268 356") -- water

for _,x in ipairs({"way", "lane", "ride", "walk", "march", 
                   "spur", "street", "loop"}) do
  expandAlias("@stylerooms " .. x .. " 85 356")
end





-- setRoomEnv

-- setCustomEnvColor(environmentID, r,g,b,a)

-- default room: 600 {47,79,79}
-- setCustomEnvColor(600, 47, 79, 79, 255)

setCustomEnvColor(600, 47, 79, 79, 255)

expandAlias("@stylerooms * 600 237") -- set all rooms in silverymoon to 600

expandAlias("@stylerooms park 258 237")
expandAlias("@stylerooms silverglen 258 237")

expandAlias("@stylerooms road 527 237")
expandAlias("@stylerooms approaching 527 237")

-- inner roads

for _,x in ipairs({"ghostwalk", "wallrun", "ride", "lane", "avenue", 
                   "helmer", "moonway", "druinwood", "street"}) do
  expandAlias("@stylerooms " .. x .. " 272 237")
end

-- silverymoon guildmasters

setRoomEnv(48586, 269) -- Ersenas
setRoomEnv(49036, 269) -- Dragor
setRoomEnv(49025, 269) -- Voundeld
setRoomEnv(49021, 269) -- Paol
setRoomEnv(49135, 269) -- Ultruum
setRoomEnv(49032, 269) -- Arkhen
setRoomEnv(48882, 269) -- Willa
setRoomEnv(49054, 269) -- Tathshandra
setRoomEnv(48934, 269) -- Atenman
setRoomEnv(48863, 269) -- Baerim

-- Ashstone

expandAlias("@stylerooms Caravansary Way 259 85")
expandAlias("@stylerooms road 259 85")
expandAlias("@stylerooms Caravansery Way 259 85")
expandAlias("@stylerooms Dragon Plaza 259 85")
expandAlias("@stylerooms garden 258 85")
expandAlias("@stylerooms dragonride 259 85")

-- Scardale
expandAlias("@stylerooms lane 272 213")
expandAlias("@stylerooms street 272 213")
expandAlias("@stylerooms park 258 213")
expandAlias("@stylerooms Bazaar 600 213")
expandAlias("@stylerooms Arena 600 213")
expandAlias("@stylerooms Cemetery 600 213")

-- banks
setRoomChar(44, "$")    -- The Banker Of Mithril Hall
setRoomChar(4644, "$")  -- First Merchantile Bank of Scornubel
setRoomChar(4901, "$")  -- The Bank
setRoomChar(7307, "$")  -- The Royal Bank of Leuthilspar
setRoomChar(8386, "$")  -- United Luiren Bank of Faerun
setRoomChar(9017, "$")  -- The Bank of Zhentil Keep
setRoomChar(10703, "$") -- The Bank of Northern Waterdeep
setRoomChar(10894, "$") -- The Bank of Southern Waterdeep
setRoomChar(11602, "$") -- The Bank of Faang
setRoomChar(11967, "$") -- The Bank of Ghore
setRoomChar(15459, "$") -- The Northern Bank of Bryn Shander
setRoomChar(15505, "$") -- The Eastern Bank of Bryn Shander
setRoomChar(73057, "$") -- The Gloomhaven First Trust Bank
setRoomChar(90028, "$") -- The Bank of Bloodtusk
setRoomChar(74573, "$") -- A Dark Hidden Bank
setRoomChar(84203, "$") -- The Bank of Silverymoon
setRoomChar(80637, "$") -- Skullport Bank
setRoomChar(45963, "$") -- The Scardale Common Bank
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@recol$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@reset</name>
					<script>-- force reset of a couple variables that might have caused a script lockup

look:set(nil)

spell:stop() -- set spell.casting=nil

meleePowerUsed=nil
setBashing(false)

send("LOOK")
send("GROUP")

cecho("&lt;red&gt;[ Potentially blocking variables Reset ]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@reset$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@grill</name>
					<script>local keylist=
{"hi", "hello", "yes", "no", "item", "items", "reward", "worth", "cost", "value", "quest",
"mission", "job", "work", "deal", "trade", "task", "aid", "need", "looking", "help", "assist", "assistance",
"need", "needs", "collect", "gather", "errand", "hire", "treasure", "something",
"it", "who", "what", "when", "why", "how", "want" }

for k,v in pairs(keylist) do
  mud:send("tell " .. matches[2] .. " " .. v)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@grill (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@links</name>
					<script>expandAlias("@help links", false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^@links$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>MudAliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>follow</name>
					<script>mud:send ("FOL " .. matches[2] )</script>
					<command></command>
					<packageName></packageName>
					<regex>^fol (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>powers</name>
					<script>mud:send("POWERS " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^powers (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>help</name>
					<script>mud:send("HELP " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^help (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>forget spellname</name>
					<script>mud:send("FORGET " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^forget (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>eq</name>
					<script>mud:send("EQ")</script>
					<command></command>
					<packageName></packageName>
					<regex>^eq$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>mem spellname</name>
					<script>spell:clear()
spell:stop()

mud:send("MEM " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^mem (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>tog</name>
					<script>mud:send("TOG " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^tog (.+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>scan</name>
					<script>scanned={}
mud:send("SCAN")</script>
					<command></command>
					<packageName></packageName>
					<regex>^scan$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>l (look)</name>
					<script>gaglook=nil

mud:send("L" .. (matches[3] or "") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^(l|look)( .*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>nhc</name>
					<script>if charData:get("swedish", true) then
  mud:send ("NHC " .. swedish(matches[2]) )
else
  mud:send ("NHC " .. matches[2] )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^nhc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>tell</name>
					<script>-- que tell

mud:send ("T " .. matches[2] )</script>
					<command></command>
					<packageName></packageName>
					<regex>^t (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>gcc (swedish)</name>
					<script>if charData:get("swedish", true) then
  mud:send ("GCC " .. swedish(matches[2]) )
else
  mud:send ("GCC " .. matches[2] )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^gcc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>say swedish</name>
					<script>-- swedish disabled because it doesn't proc properly

mud:send ("SAY " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^say (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>ooc swedish</name>
					<script>if charData:get("swedish", true) then
  mud:send ("OOC " .. swedish(matches[2]), false)
else
  mud:send ("OOC " .. matches[2], false)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^ooc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>acc swedish</name>
					<script>if charData:get("swedish", true) then
  mud:send ("ACC " .. swedish(matches[2]) )
else
  mud:send ("ACC " .. matches[2] )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^acc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>gsay (gcmd)</name>
					<script>charData:init("gcmd", false)

-- don't gsay if only a single groupmember and train is active

if isActive("SMTrain", "trigger") ~= 0 and groupList:size() == 1 then
  return
end

if charData:get("gcmd") then
  if charData:get("swedish", true) then
    mud:send("GCMD " .. swedish(matches[2]) )
  else
    mud:send("GCMD " .. matches[2])
  end
else
  if charData:get("swedish", true) then
    mud:send("GSAY " .. swedish(matches[2]) )
  else
    mud:send("GSAY " .. matches[2] )
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^gsay (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>gcmd</name>
					<script>
-- don't gcmd if only a single groupmember and train is active

if isActive("SMTrain", "trigger") ~= 0 and groupList:size() == 1 then
  
  -- if current line isn't blank send a newline
  if getCurrentLine() ~= "" then
    echo("\n")
  end
  
  -- since not gcmd'ing, echo locally
  cecho("&lt;green&gt;" .. matches[2] .. "\n\n")
  
  return
end

if charData:get("swedish", true) then
  mud:send("GCMD " .. swedish(matches[2]) )
else
  mud:send("GCMD " .. matches[2])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^gcmd (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>consent</name>
					<script>consent.chars= {}
mud:send("CONSENT", false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^consent$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>escape</name>
					<script>if checkMask("rogue") then
  NyyLIB.escapedir = matches[2]
  mud:send("ESCAPE " .. matches[2])
else
  NyyLIB.escapedir = matches[2]

  if checkMask("caster") then
    -- erase spellqueue if any spells present
    spell:eraseQueue()

    -- disable autocast
    buttons:change("autocast", false, "SpellsButton")

    spell:clear()
  end

  -- set as currently moving
  spell:setMoving(true)

  mud:send("FLEE", false)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^escape ([neswud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>mem</name>
					<script>-- Can't be moving if mem has been sent
spell:setMoving(false)
setQuake(false)

if checkMask("blk") then
  return
end

automem = 2

if memsent == true then
  cecho("&lt;red&gt;[Mem previously sent: type 'prepare' to force]\n")
  return
end

if spell:getMem() == true then
  cecho("&lt;red&gt;\n[Already meming - If not type 'prepare']\n")
  return
end


if charData:get("memcount") == nil or charData:get("memcount") == 0 and not checkMask("psi") then
  cecho("&lt;red&gt;\n[Mem has completed. Type 'memd' or 'prayd' to list spells. Type 'prepare' to force mem]\n")
  return
end

if inCombat() then
  echoDebug("&lt;red&gt;[Fighting, can't memorize]\n")
  return
end

if checkMask("singer") == false then
  mud:send("REST")
else
  cecho("&lt;red&gt;[Singers can't memorize.]\n")
  return
end

local label=findlabel("MemButton")

-- replace with function call

if label ~= nil then
  setLabelImage("MemButton", "stand.png")
  
  --label:setStyleSheet([[border-image: url(]] .. iconpath("stand.png") .. [[)]])
  --echoDebug("&lt;red&gt;[Setting membutton to stand]")
end

if checkMask("psi") then
  if charData:get("psicrystal") ~= "" then
    mud:send("chargepsp " .. charData:get("psicrystal") )
  end

  mud:send("MED")
else
  if checkMask("caster") then
    spell:clear()
  end

  -- prepare doesn't give spell count
  --send("prepare")

  memsent=true

  if checkMask("pray") then
    mud:send("PRAY")
  else
    mud:send("MEM")
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(mem|pray)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>checkbucket</name>
					<script>function getbuckets()
  disableTrigger("Zurg")

  if #NyyLIB.buckets &gt; 0 then
    echo("[Buckets]\n")
    display( NyyLIB.buckets )

    mud:send("st")
    expandAlias("enter pathway", false)

    getPath(85075, NyyLIB.buckets[1])
     expandAlias("." .. compressSpeedwalk(), false)

    mud:send("darkness")
    mud:send("get all")
    mud:send("darkness")

    getPath(NyyLIB.buckets[1], 79574)
     expandAlias("." .. compressSpeedwalk(), false)

    table.remove(NyyLIB.buckets, 1)

    mud:send("put all.bucket hole")
    mud:send("drop all.squash")

    tempTimer(10, [[getbuckets()]])  
  else
    echo("[No buckets found.]\n")

    mud:send("rest")
    mud:send("darkness")
  end
end

expandAlias("@find", false)


local currentroom = map:getRoom()

if currentroom == 79573 or currentroom == 79574 then
  echo("[Running Zurg script]\n")

  NyyLIB.buckets={}
  enableTrigger("Zurg")

  tempTimer(3600, [[expandAlias("checkbucket")]])

  if currentroom == 79573 then
    expandAlias(".uw", false)
  end

  mud:send("st")
  mud:send("project schism")
  expandAlias("enter pathway")
  expandAlias(".2w2s2enwn2e", false)

  tempTimer(10, [[getbuckets()]])
else
  echo("[Not in Wagontrack Pass - Zurg script cancelled.]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^checkbucket$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>who</name>
					<script>mud:send("WHO " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^who (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>status</name>
					<script>showstatus=true

local charname=matches[2]

if charname ~= nil then
  mud:send("STATUS " .. charname)
else
  mud:send("STATUS")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^status ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>con</name>
					<script>if matches[2] == nil then
  mud:send("CON")
else
  mud:send("CON " .. matches[2])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^con ?([A-Za-z]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>followers</name>
					<script>gagfollowers=nil

-- reset flag and resend
sendFollowers(false)
sendFollowers()
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(fols|followers)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>automem=0

mud:send("ST")</script>
					<command></command>
					<packageName></packageName>
					<regex>^st$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>group</name>
					<script>mud:send("GROUP")

-- send followers after group if not rogue
if not checkMask("rog") then
  sendFollowers()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^group$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>order</name>
					<script>mud:send("ORDER " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^o (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>recharge</name>
					<script>nogagRecharge = true

mud:send("RECHARGE")</script>
					<command></command>
					<packageName></packageName>
					<regex>^recharge$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@entrance</name>
					<script>-- display location of all entrances to a zone

-- portals
-- zone edges

local targetZone = tonumber(matches[2])

for k,v in pairs(getRooms()) do
  -- k=room number
  -- v=room name
  
  -- if zone of any exit from this room is target zone, print k,v
  
  -- portals
  
  -- should exclude if target zone -&gt; target zone
  
  local exits = getSpecialExits(k)
  
  if tonumber(getRoomUserData(k, "zoneid")) ~= targetZone then
    if table.size(exits) &gt; 0 then
      for k1, v1 in pairs(exits) do

        local zone=getRoomUserData(k1, "zoneid")
        local zoneid=tonumber(zone)

        -- [Zone Name] room# roomname : command
        --     echo(string.format("%30s Room ID: %6d  %s\n", , roomid, roomname))
      
      
        if zoneid == targetZone then
          for k2,v2 in pairs(v1) do
            echo( string.format("[%s] %d : %s : %s\n", getRoomAreaName(getRoomArea(k)), k, 
                  getRoomName(k), k2) )
          end
        end
      end
    end
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@entrance ([0-9]+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>rent</name>
					<script>noreconnect = true

mud:send("RENT")</script>
					<command></command>
					<packageName></packageName>
					<regex>^rent$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>camp</name>
					<script>noreconnect = true

mud:send("CAMP")</script>
					<command></command>
					<packageName></packageName>
					<regex>^camp$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Demonnic</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Shared</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Reset chasing</name>
						<script>demonnic.chaser:reset()</script>
						<command></command>
						<packageName></packageName>
						<regex>^chaseres$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Debug</name>
						<script>-- commented out 10/11/16

--if matches[2] then
--  demonnic:listCategories()
--else
--  demonnic:toggleDebug()
--end</script>
						<command></command>
						<packageName></packageName>
						<regex>^debug(?: (list))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>debug categories</name>
						<script>if matches[2] then
  demonnic:watchCategory( matches[2] )
else
  demonnic:listCategories()
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^debugc(?: (.*))?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Tabbed Chat</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="no" isFolder="no">
						<name>Toggle blinking (temporary change)</name>
						<script>if demonnic.chat.config.blink then
  demonnic.chat.config.blink = false
  demonnic.chat.tabsToBlink = {}
  demonnic:echo("Blinking temporarily turned &lt;red&gt;off&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to false in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
else
  demonnic.chat.config.blink = true
  demonnic.chat:blink()
  demonnic:echo("Blinking temporarily turned &lt;red&gt;on&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to true in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^dblink$</regex>
					</Alias>
					<Alias isActive="no" isFolder="no">
						<name>fixChat</name>
						<script>local currentsetting = demonnic.chat.config.location
local newsetting = ""
if currentsetting == "topright" then 
  newsetting = "bottomleft" 
elseif currentsetting == "topleft" then
  newsetting = "bottomright"
elseif currentsetting == "bottomleft" then
  newsetting = "topright"
elseif currentsetting == "bottomright" then
  newsetting = "topleft"
end

demonnic.chat.config.location = newsetting
demonnic.chat:create()
demonnic.chat.config.location = currentsetting
demonnic.chat:create()</script>
						<command></command>
						<packageName></packageName>
						<regex>^fixchat$</regex>
					</Alias>
				</AliasGroup>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>SplitClass</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@bid</name>
					<script>local biditem= matches[4], bids, bidders
local xname=string.lower(matches[3]):title()

if matches[2] == "help" then
  echo("\n@bid init\n")
  echo("@bid addchar name, bid delchar name\n")
  echo("\n@bid start\n")
  echo("@bid open\n")
  echo("@bid stop\n")
  echo("\n@bid add charname itemname\n")
  echo("@adddice charname roll\n")
  echo("\n@bid status\n")
end

if matches[2] == "status" then  
  local allbidders

  allbidders=table.deepcopy(NyyLIB.validbidders)

  if NyyLIB.bids == nil then
    echo("Bidding is currently closed. Type 'bid help' for commands.\n")
    return
  end

  echo("Bids received:\n\n")

  display(NyyLIB.bids)

  for k,v in pairs(NyyLIB.bids) do
    table.remove(allbidders, table.index_of(allbidders, k))
    echo(k .. " - " .. v .. "\n")
  end

  echo("\nMissing bids:\n")

  display(allbidders)

  --display(NyyLIB.validbidders)

  echo("\nDice:\n")

  display(NyyLIB.trackbid)

end


if matches[2] == "init" then
  mud:send("GLIST")
  NyyLIB.validbidders = groupList:pc("all")

  disableTrigger("acceptbid")
  disableTrigger("acceptdice")

  NyyLIB.trackbid = {}

  cecho("\n&lt;green&gt;[Split script enabled:]\n")

  cecho("&lt;green&gt;[Total number of bidders: " .. #NyyLIB.validbidders .. "]\n")
  display(NyyLIB.validbidders)
end

if matches[2] == "delchar" then
  table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, xname))
  display(NyyLIB.validbidders)
end

if matches[2] == "addchar" then
  table.insert(NyyLIB.validbidders, 1, xname)
  display(NyyLIB.validbidders)
end

if matches[2] == "start" then
  mud:send("gsay [--------------------------]")
  mud:send("gsay tell " .. whoami() .. " 'bid itemname' or 'bid abstain'")
  mud:send("gsay Resend the tell if you wish to change it.")
  mud:send("gsay You will receive a confirmation tell on")
  mud:send("gsay a successful bid. Bids can NOT be changed")
  mud:send("gsay after all bids have been received.")
  
  NyyLIB.fullbidderlist=NyyLIB.validbidders

  expandAlias("@bid open")

end

if matches[2] == "open" then
  NyyLIB.bidding=1
  NyyLIB.bids={}

  mud:send("gsay Bids will now be accepted from " .. table.concat(NyyLIB.validbidders, "|"))
  enableTrigger("acceptbid")
end

if matches[2] == "add" then
  local abort=1
  local itemMatches=0

  if isActive("acceptbid", "trigger") == 0 then
    cecho("\n&lt;red&gt;[Bidding is currently closed.]\n")
    return
  end


  for nx=1, #NyyLIB.validbidders, 1 do
    if NyyLIB.validbidders[nx]:lower() == string.lower(matches[3]) then
      abort=0
    end
  end

  if abort == 1 then
    cecho("&lt;red&gt;[Not a valid bidder]\n")
    return
  end

  if table.contains(NyyLIB.groupitems, matches[3]) then
    biditem= NyyLIB.groupitems[table.index_of(NyyLIB.groupitems, xname)]
  else
    local nx
    local founditem
    local testitem = string.gsub(biditem, "-", "[-]") -- testitem is regex

    for nx=1, #NyyLIB.groupitems, 1 do
      if string.findPattern(NyyLIB.groupitems[nx]:lower(), testitem:lower()) then
        founditem = NyyLIB.groupitems[nx]
        itemMatches=itemMatches+1
      end
    end

    if itemMatches == 1 then
      biditem=founditem
    end
  end
  
  if biditem == "abstain" or table.contains(NyyLIB.groupitems, biditem) and itemMatches &lt; 2 then
    local dup=0

    mud:send("t " .. matches[3] .. " Bid received for " .. biditem)

    NyyLIB.bids[xname] = biditem

    bids= table.size(NyyLIB.bids)
    bidders = table.size(NyyLIB.validbidders)

    mud:send("gsay " .. bids .. "/" .. bidders .. " bids received")

    RedrawGroupStatus()
 
       if bids == bidders then
      NyyLIB.activebids = NyyLIB.bids
      disableTrigger("acceptbid")
          expandAlias("@sortbids", false)
    end
  else
    if itemMatches &gt; 1 then
      mud:send("t " .. matches[3] .. " Which " .. biditem .. "? There's more then one.")
    else
      mud:send("t " .. matches[3] .. " failed bid on " .. biditem)
    end
  end
end

if matches[2] == "stop" then
  cecho("\n&lt;red&gt;[Disabled bid script.]\n")
  NyyLIB.bidding=0
    NyyLIB.bids=nil
    NyyLIB.activebids=nil
    NyyLIB.groupitems=nil
    NyyLIB.validbidders=nil
    NyyLIB.trackbid=nil
    NyyLIB.fullbidderlist=nil
    NyyLIB.biditem=nil
    NyyLIB.trackbid2=nil

  disableTrigger("acceptbid")

  RedrawGroupStatus()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@bid ([A-Za-z]+)? ?([A-Za-z-']+)? ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@sortbids</name>
					<script>local abstain=0
local abstainwho=""
local abort=0
local nx
local key, val

-- remove abstain
for key,val in pairs(NyyLIB.activebids) do
  if val == "abstain" then
    abstain=abstain+1
  
    abstainwho = abstainwho .. " " .. key

    table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, key))
    NyyLIB.activebids[key] = nil
    abort=1
  end
end

if abstainwho ~= "" then
  mud:send("gsay &lt;&lt;&lt; " .. abstain .. " abstain by " .. abstainwho .. " &gt;&gt;&gt;")
end

for key,val in pairs(NyyLIB.activebids) do  
  local compete=0
  local who = key
  local item = val

  for k,v in pairs(NyyLIB.bids) do
    if item == v and who ~= k then
      compete=1
    end
  end

  if compete == 0 then
    mud:send("gsay &lt;&lt;&lt; Sole Bidder: " .. key .. " - " .. val .. " &gt;&gt;&gt;")

    table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, key))
    NyyLIB.activebids[key] = nil

    abort=1
  end
end

if abort == 0 then
  expandAlias("@nextbid", false)
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@sortbids$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@nextbid</name>
					<script>local abort = 0
local nx


if isActive("acceptbid", "trigger") ~= 0 or isActive("acceptdice", "trigger") ~= 0 then
  display("acceptbid " .. isActive("acceptbid", "trigger"))
  display("acceptdice " .. isActive("acceptdice", "trigger"))

  echo("\nBidding is currently ongoing.\n")
  return
end

NyyLIB.trackbid= {}

for key,val in pairs(NyyLIB.activebids) do
  if abort == 0 then
    local compete=""
    local who = key
    NyyLIB.biditem= val

    compete = NyyLIB.biditem .. ": " .. who    

    NyyLIB.trackbid[who] = 0

    NyyLIB.activebids[who]=nil

    for k,v in pairs(NyyLIB.activebids) do
      if NyyLIB.biditem == v then
        compete= compete .. ", " .. k

        NyyLIB.trackbid[k] = 0
        NyyLIB.activebids[k]=nil
      end
    end

    enableTrigger("acceptdice")
    send("gsay &lt;&lt;&lt; Competition! " .. compete .. " &gt;&gt;&gt;")
    abort=1
  end
end

if abort == 0 then
  disableTrigger("acceptdice")
  send("gsay This round of bidding has now completed.")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@nextbid$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@adddice</name>
					<script>local xname, xdice

NyyLIB.trackbid2={}

xname=string.lower(matches[2]):title()
xdice=tonumber(matches[3])

if NyyLIB.trackbid == nil then
  echo("[Bidding is not currently open. Type 'bid help' for commands.]\n")
  return
end


if NyyLIB.trackbid[xname] == nil then
  echo("[ " .. xname .. " doesn't exist in valid dice rollers]\n")
  return
end

cecho("\n&lt;red&gt;[Setting " .. xname .. " to dice roll of " .. xdice .. ".]\n")

NyyLIB.trackbid[xname] = xdice

if table.contains(NyyLIB.trackbid, 0) == false then
  local winval=0
  local winkey=""
  local tie=0
  local temp= "Dice: |"
  
  for k,v in pairs(NyyLIB.trackbid) do
    temp = temp .. k .. "-" .. v .. "|"
    if v &gt; winval then
      winval = v
      winkey = k
    end
  end

  mud:send("gsay " .. temp .. " &gt;&gt;")

  temp = winkey
  
  -- display(NyyLIB.trackbid)

  for k,v in pairs(NyyLIB.trackbid) do
    if (v == winval) and k ~= winkey then
      tie = 1
      NyyLIB.trackbid2[k] = 0
      temp = temp .. ", " .. k
    end
  end

  if tie == 1 then
    mud:send("gsay &lt;&lt; Finish Him! " .. winval .. " by " .. temp)

    NyyLIB.trackbid2[winkey] = 0
    NyyLIB.trackbid = NyyLIB.trackbid2
  else
    mud:send("gsay &lt;&lt; Winner: " .. winkey .. " (" .. winval .. ") " .. NyyLIB.biditem .. " &gt;&gt;")
    disableTrigger("acceptdice")
  
    table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, winkey))
    NyyLIB.activebids[winkey] = nil
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@adddice ([A-Za-z]+) ([0-9]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>createhistory</name>
					<script>local mydb = db:create("bidhistory",
    {
    bids = {
      whatgroup = db:Timestamp("CURRENT_TIMESTAMP"),
         itemname = "",
         round = 0,
         charname = "",
         diceroll = 0,
           _index = { {"itemname"} }
    }
  } )</script>
					<command></command>
					<packageName></packageName>
					<regex>^createhistory$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Counters</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@stats</name>
					<script>-- c_block: Shield block
-- c_glances: Glances off shield - will also hit
-- c_svamp: Vamp from shield

-- c_deflect: Deflect from sword
-- c_pdeflect: Partially deflect from sword - will also hit    "defParryPartial"
-- c_parry: Parry attack (count as miss)

-- c_dodge: dodge attack (count as miss)
-- c_graze: partial dodge - will also hit

-- c_hit: hit
-- c_miss: miss

--NyyLIB.c_crit

-- 'all avoidance is checked before ac'


if matches[2] == "heals" then
  printHeals()
  return
end

if matches[2] == "reset" then
  resetStats()

  return
end

local cntRescueFail=getStat(whoami(), "failedrescue")
local cntRescueSuccess=getStat(whoami(), "successrescue")

local c_attackmiss=getStat(whoami(), "offMiss")
local c_attackhit=getStat(whoami(), "offHit")

local c_block=getStat(whoami(), "defShieldBlock")
local c_dodge=getStat(whoami(), "defDodge")
local c_graze=getStat(whoami(), "defGraze")
local c_deflect=getStat(whoami(), "defWeaponDeflect")
local c_glances=getStat(whoami(), "defShieldGlance")
local c_svamp=getStat(whoami(), "shieldvamp")
local c_parry=getStat(whoami(), "defParry")
local c_pdeflect=getStat(whoami(), "defParryPartial")
local c_crit=getStat(whoami(), "crithit")

local c_hit=getStat(whoami(), "defHit")
local c_miss=getStat(whoami(), "defMiss")


local c_all=c_hit+c_miss + c_parry + c_deflect + c_dodge + c_block


local c_adjhit=c_all-c_miss

local output = {}

local skillblocked = c_block + c_parry + c_deflect + c_dodge
local partialblock=  c_pdeflect + c_graze + c_glances


local v2allhit = c_hit + skillblocked
local v2weapon = c_parry + c_deflect + c_pdeflect

-- csv line

output[#output+1] = string.format("//%s,%s,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n", 
                      charData:get("statname"), whoami(), NyyLIB.str, NyyLIB.agibonus, NyyLIB.hitroll, NyyLIB.damroll,
                        cntRescueFail, cntRescueSuccess, c_attackmiss, c_attackhit,
                      c_block,c_dodge,c_graze,c_deflect,c_glances,c_svamp,c_parry,c_pdeflect, c_crit,c_hit,c_miss)

--output[#output+1] = string.format("[Based on AC alone, %2.1f%% (%d) hit, %2.1f%% (%d) missed]\n",
--              v2allhit*100/c_all, c_all,
--              c_miss*100/c_all, c_miss)
              
--output[#output+1] = string.format("[Of hits/potential hits (%d), %2.1f%% (%d) of them were dodged, %2.1f%% (%d) of them partially]\n",
--                v2allhit,
--                (c_dodge+c_graze)*100/v2allhit,
--                 c_dodge+c_graze,
--                c_graze*100/(c_dodge+c_graze),
--                c_graze )

--output[#output+1] = string.format("[Of available attacks (%d), %2.1f%% (%d) were shield blocked, %2.1f%% (%d) of them partially]\n",
--                 v2allhit-c_dodge-c_graze,
--                (c_block+c_glances)*100/(v2allhit-c_dodge-c_graze), c_block+c_glances,
--                c_glances*100/(c_block+c_glances), c_glances)

--output[#output+1] = string.format("[Of the remaining %d attacks, %2.1f%% (%d) were riposted, %2.1f%% (%d) of them partially]\n",
--                 v2allhit-c_dodge-c_graze-c_block-c_glances,
--                v2weapon*100/(v2allhit-c_dodge-c_graze-c_block-c_glances), v2weapon,
--                c_pdeflect*100/(v2weapon), c_pdeflect   )

--output[#output+1] = string.format("[%2.1f%% (%d) partially dodged, %2.1f%% (%d) glanced off shield, %2.1f%% (%d) partially deflected]\n",
--                      c_graze*100/c_hit, c_graze,
--                      c_glances*100/c_hit, c_glances,
--                      c_pdeflect*100/c_hit, c_pdeflect)

--output[#output+1] = string.format("[%2.1f%% (%d) attacks went through all defenses]\n", 
--              (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances) )

--output[#output+1] = string.format("[The final hit rate is %2.1f%% (%d)]\n",
--                      c_hit*100/c_all,  c_hit )

output[#output+1] = string.format("[Defense: Hit %2.1f%% (%d/%d) : %2.1f%% (%d) direct, %2.1f%% (%d) dodge, %2.1f%% (%d) shield, %2.1f%% (%d) weapon]\n",
                        c_hit*100/c_all, c_hit, c_all,
                        (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances),
                        c_graze*100/c_hit, c_graze,
                        c_glances*100/c_hit, c_glances,
                        c_pdeflect*100/c_hit, c_pdeflect   )

output[#output+1] = string.format("[+HIT %d +DAM %d : Missed %2.1f%% (%d) Hit %2.1f%% (%d)]\n", 
                NyyLIB.hitroll, NyyLIB.damroll,
                c_attackmiss*100/(c_attackhit+c_attackmiss), c_attackmiss,
                c_attackhit*100/(c_attackhit+c_attackmiss), c_attackhit)


if cntRescueFail + cntRescueSuccess &gt; 0 then
  output[#output+1] = string.format("[%2.2f%% (%d) failed rescues, %2.2f%% (%d) success]\n", 
                      cntRescueFail*100 / (cntRescueFail+cntRescueSuccess), cntRescueFail, 
                      cntRescueSuccess*100 / (cntRescueFail+cntRescueSuccess), cntRescueSuccess)
end

local nx

if matches[2] == "write" then
  local file = io.open(homepath("stats.dat"), "a")

  io.output(file)

  io.write("\n")

  for nx=1, #output, 1 do
    io.write(output[nx])
  end

  io.close(file)

  return
end

if matches[2] == "read" then
  --local file = io.open(, "r")

  for line in io.lines(homepath("stats.dat")) do
    echo(line .. "\n")
  end


  --io.close(file)
  return
end

if matches[2] == "gcc" then
  for nx=1, #output, 1 do
    mud:send("gcc " .. output[nx])  
  end
  return
end

if matches[2] == "gsay" then
  for nx=1, #output, 1 do
    mud:send("gsay " .. output[nx])  
  end
  return
end

echo("\n")

printStats()

echo("\n")

display(NyyLIB.stats[whoami()])

--for nx=2, #output, 1 do
--  echo(output[nx])
--end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@stats ?(write|read|reset|gcc|gsay|heals)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@gstats</name>
					<script>printStats()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@gstats$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>TorilMapper</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@map</name>
					<script>if matches[2] == nil then
  -- toggle map on/off

  if charData:get("map") == "on" then
    expandAlias("@map off", false)
    cecho("&lt;red&gt;[NyyMap display is OFF.]\n")
  else
    expandAlias("@map on", false)
    cecho("&lt;red&gt;[NyyMap display is ON.]\n")
  end
end

if matches[2] == "score" then
  local list = getAreaTable()
  local fullmap = getRooms()

  local totalmap=0
  local totalfound=0

  local totalcoloured=0

  local totalarea=0
  local areasfound=0

  local maprooms = {}

  for roomid, roomname in pairs(fullmap) do
    local internalid = getRoomArea(roomid)

    local zone=getRoomUserData(roomid, "zoneid")
    local zoneid=tonumber(zone)

    local env=getRoomEnv(roomid)

    if zoneid ~= nil then
      -- first appearance of room in area
      if maprooms[NyyLIB.areaTable[zoneid]] == nil then
        maprooms[NyyLIB.areaTable[zoneid]] = {0,0,0}
      end

      if internalid == -1 then
        -- undiscovered room
        maprooms[NyyLIB.areaTable[zoneid]][2] = maprooms[NyyLIB.areaTable[zoneid]][2] + 1
      else
        -- discovered room
        maprooms[NyyLIB.areaTable[zoneid]][1] = maprooms[NyyLIB.areaTable[zoneid]][1] + 1
      
        -- room is coloured
        if env ~= 271 then
          maprooms[NyyLIB.areaTable[zoneid]][3] = maprooms[NyyLIB.areaTable[zoneid]][3] + 1
        end
      end
    else
      -- echo("nil room " .. roomid .. "\n")
    end
  end

  for k,v in pairs(maprooms) do
    if v[1] ~= 0 then
     
      echo ( string.format("%45s %4d/%4d  rooms, ( %5.2f%% )  Coloured: ( %5.2f%% )\n", k, v[1], v[1]+v[2], v[1]*100/(v[1]+v[2]), v[3]*100/(v[1]) ) )
      
      totalfound=totalfound+v[1]
      areasfound=areasfound+1
      
      totalcoloured=totalcoloured+v[3]
    end
    totalmap=totalmap+v[1]+v[2]
  end

  echo( string.format("\n             found %3d/%-3d included areas      %d/%d rooms  ( %5.2f%% ) Coloured: ( %5.2f%% )\n\n", 
    areasfound, table.size(maprooms), totalfound, totalmap, totalfound*100/totalmap, totalcoloured*100/totalfound) )
end

if matches[2] == "undiscovered" then
  local list = getAreaTable()
  local fullmap = getRooms()

  local totalmap=0
  local totalfound=0

  local totalarea=0
  local areasfound=0

  local maprooms = {}

  for roomid, roomname in pairs(fullmap) do
    local internalid = getRoomArea(roomid)

    local zone=getRoomUserData(roomid, "zoneid")
    local zoneid=tonumber(zone)

    if zoneid ~= nil then
      -- first appearance of room in area
      if maprooms[NyyLIB.areaTable[zoneid]] == nil then
        maprooms[NyyLIB.areaTable[zoneid]] = {0,0}
      end

      if internalid == -1 then
        -- undiscovered room
        maprooms[NyyLIB.areaTable[zoneid]][2] = maprooms[NyyLIB.areaTable[zoneid]][2] + 1
      else
        -- discovered room
        maprooms[NyyLIB.areaTable[zoneid]][1] = maprooms[NyyLIB.areaTable[zoneid]][1] + 1
      end
    else
      -- echo("nil room " .. roomid .. "\n")
    end
  end

  for k,v in pairs(maprooms) do
    if v[1] == 0 then
      echo ( string.format("%45s %4d  rooms\n", k, v[1]+v[2] ) )

      totalfound=totalfound+v[1]
      areasfound=areasfound+1
    end
    totalmap=totalmap+v[1]+v[2]
  end

  echo( string.format("\n             unfound %3d/%-3d included areas      %d/%d rooms  ( %5.2f%% )\n\n", 
    areasfound, table.size(maprooms), totalfound, totalmap, totalfound*100/totalmap) )
end

if matches[2] == "help" then
  cecho("&lt;red&gt;Usage: @map              - turn on/off the mapper display\n")
  cecho("&lt;red&gt;       @map update       - update the map after a new NyyLIB is installed\n")
  cecho("&lt;red&gt;       @map score        - list size/name of found areas in the map\n")
  cecho("&lt;red&gt;       @map info         - list size/name of all areas in the map\n")
  cecho("&lt;red&gt;       @map undiscovered - lists all zones not discovered by user - Go here to explore something new!\n")
  cecho("&lt;red&gt;       @find             - attempt to locate the currently occupied room on the map\n")
  cecho("&lt;red&gt;       @find roomname    - list of previously located rooms\n")
  cecho("&lt;red&gt;       @fwalk roomnum    - fastwalk from the current room to roomnum\n")
end

if matches[2] == "info" then
  local list = getAreaTable()
  local fullmap = getRooms()

  local totalmap=0
  local totalfound=0

  local totalarea=0
  local areasfound=0

  local maprooms = {}

  for roomid, roomname in pairs(fullmap) do
    local internalid = getRoomArea(roomid)
    local zone=getRoomUserData(roomid, "zoneid")
    local zoneid=tonumber(zone)


    if zoneid ~= nil then
      -- first appearance of room in area
      if maprooms[NyyLIB.areaTable[zoneid]] == nil then
        maprooms[NyyLIB.areaTable[zoneid]] = {0,0}
      end

      if internalid == -1 then
        -- undiscovered room
        maprooms[NyyLIB.areaTable[zoneid]][2] = maprooms[NyyLIB.areaTable[zoneid]][2] + 1
      else
        -- discovered room
        maprooms[NyyLIB.areaTable[zoneid]][1] = maprooms[NyyLIB.areaTable[zoneid]][1] + 1
      end
    else
      -- echo("nil room " .. roomid .. "\n")
    end
  end

  for k,v in pairs(maprooms) do
    echo ( string.format("%45s %4d/%4d  rooms, ( %5.2f%% )\n", k, v[1], v[1]+v[2], v[1]*100/(v[1]+v[2])) )

    totalfound=totalfound+v[1]
    areasfound=areasfound+1

    totalmap=totalmap+v[1]+v[2]
  end

  echo( string.format("\n             found %3d/%-3d included areas      %d/%d rooms  ( %5.2f%% )\n\n", 
    areasfound, table.size(maprooms), totalfound, totalmap, totalfound*100/totalmap) )
end

if matches[2] == "update" then
  cecho("&lt;green&gt;[Running the map update will take 5-10 minutes.]\n")
  cecho("&lt;green&gt;[Mudlet will appear to be frozen while running. Don't close it.]\n")
  cecho("\n&lt;red&gt;[Use the '&lt;green&gt;@backup&lt;red&gt;' command to make a backup of data files before updating!]\n\n")
  cecho("&lt;green&gt;[Type '&lt;red&gt;@map updateok&lt;green&gt;' to start update]\n")
end

if matches[2] == "updateok" then
  local fullmap = getRooms()
  local nx

  local mapdata={}

  -- check existing toril.map file
  for roomid, roomname in pairs(fullmap) do
    local internalid = getRoomArea(roomid)

    if internalid ~= -1 and internalid ~= nil then
      mapdata[#mapdata+1]=roomid
    end
  end

  loadMap(mainpath("toril.map"))

  for nx=1,#mapdata,1 do
    if mapdata[nx] ~= 1 then
      unhideRoom(mapdata[nx])
    end
  end

  expandAlias("@map save", false)

  cecho("&lt;red&gt;[Done]\n")
end

if matches[2] == "reset" then
  loadMap(mainpath("toril.map"))

  expandAlias("@find", false)

  cecho("&lt;red&gt;[Default map loaded]\n")
end

if matches[2] == "on" then
  charData:set("map", "on")

  if map:getRoom() == nil then
    tempTimer(3, [[expandAlias("@find", false)]])
  end
  map:show()
  mapAdjCon:show()
elseif matches[2] == "off" then
  charData:set("map", "off")

  mapAdjCon:hide()
  map:hide()
elseif matches[2] == "save" then
  local mapname = homepath("toril.map")
  local savedok = saveMap(mapname)

  if not savedok then
      cecho("\n&lt;red&gt;[Failed map save: " .. mapname .. "]\n")
  else
      cecho("\n&lt;red&gt;[Saved map: " .. mapname .. "]\n")
  end

elseif matches[2] == "init" then
  -- mapfile is also loaded from mudlet saved data by the creation command

  display("map loaded from @map init")

  cecho("&lt;red&gt;[Creating mapper window and loading mudlet saved data]\n")

  mudlet = mudlet or {}; mudlet.mapper_script = true

  mapAdjCon = mapAdjCon or Adjustable.Container:new({name="mapAdjCon" })
  mapAdjCon:setTitle("NyyMap")
  
  if charData:get("mapAdjCon", true) then
    mapAdjCon:onDoubleClick()
  else
    if mapAdjCon.x == "10px" and mapAdjCon.y == "10px" then
      mapAdjCon:move("63.6%", 0)
      mapAdjCon:resize("36.2%", "30.9%")
    end
  end
   
  NyyLIB.mapwindow = Geyser.Mapper:new({name="NyyMapper",x=0,y=10,width="100%",height="100%-10px"}, mapAdjCon)

  if setDefaultAreaVisible ~= nil then
    setDefaultAreaVisible(false)
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@map ?(help|score|info|on|off|reset|update|updateok|save|init|empty|undiscovered)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@find</name>
					<script>forceFind=nil

-- empty movement queue

map:clearQueue()

-- pattern provided, locate rooms in map
if matches[2] ~= nil and matches[2] ~= "" then
  local fullmap = getRooms()

  cecho("\n&lt;red&gt;[Matching Rooms in the Known World]\n\n")

  if tonumber(matches[2]) then
    local roomid=tonumber(matches[2])
    local roomname=getRoomName(roomid)

    if getRoomArea(roomid) ~= -1 then
      local pathlength=0

      if roomLocked(roomid) == false then
        if map:getRoom() ~= nil then
          if getPath( map:getRoom(), roomid) then
            pathlength=#speedWalkPath
          end
        end
      end

      cecho(string.format("&lt;green&gt;%31s Room ID: %6d [%3d]  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, pathlength, roomname))
    end

    return
  end

  -- match room name
  local roomCount=0
  
  if matches[2] == [[""]] then
    matches[2] = ""
  end
  
  
  for roomid, roomname in pairs(fullmap) do
    if matches[2] == "*" then
      if getRoomArea(roomid) ~= -1 and roomid ~= 1 then
        echo(string.format("%31s Room ID: %6d  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, roomname))
      end
    elseif matches[2] == "" then
      if roomname == "" then
        if getRoomArea(roomid) ~= -1 then
          local pathlength=0

          roomCount=roomCount+1
          
          if roomLocked(roomid) == false then
            if map:getRoom() ~= nil then
              if getPath( map:getRoom(), roomid) then
                pathlength=#speedWalkPath
              end
            end
          end

          cecho(string.format("&lt;green&gt;%31s Room ID: %6d [%3d]  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, pathlength, roomname))
        end    
      end
    else
      -- need to plain match
      -- string.find(s, pattern [, index [, plain]])
      --   if string.find(previousline, newline, 1, true) ~= nil then
      
      --if string.findPattern(roomname:lower(), matches[2]:lower()) then
      if string.find(roomname:lower(), matches[2]:lower(), 1, true) ~= nil then
        if getRoomArea(roomid) ~= -1 then
          local pathlength=0

          roomCount=roomCount+1
          
          if roomLocked(roomid) == false then
            if map:getRoom() ~= nil then
              if getPath( map:getRoom(), roomid) then
                pathlength=#speedWalkPath
              end
            end
          end

          cecho(string.format("&lt;green&gt;%31s Room ID: %6d [%3d]  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, pathlength, roomname))
        end
      end
    end
  end

  cecho(string.format("\n&lt;red&gt;Matching rooms: %5d\n", roomCount) )

  return
end

-------

-- no pattern provided, locate current room
local current=map:getRoom()

cecho("\n&lt;red&gt;[Searching... ")

-- use scanned info if present

if table.size(scanned) &gt; 0 then
  local scanroom = solveScan()
  
  if scanroom ~= nil then
    map:setRoom( scanroom )
  end
else
  if map:getRoomname() ~= nil and map:getExits() ~= nil then
    map:setRoom( map:findRoomID( map:getRoomname(), map:getExits() ) )
  end
end

if map:getRoom() ~= nil then
  --if   charData:get("map") == "off" then
  --  cecho("&lt;red&gt;Mapper is currently off. Type '@map on' to enable it.\n")
  --end

  unhideRoom( map:getRoom() )
  map:update(nil)
else
  NyyLIB.lastRoomID = nil
  centerview(1) -- blank room number
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@find ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@afind - find room in current area</name>
					<script>local fullmap = getRooms()

cecho("\n&lt;red&gt;[Matching discovered rooms in current area]\n")

if matches[2] ~= nil and matches[2] ~= "" then
  local fullmap = getRooms()

  local zoneid
  local internalid

  if map:getRoom() ~= nil then
    zoneid=tonumber(getRoomUserData( map:getRoom(), "zoneid") )
    internalid= map:findAreaID(NyyLIB.areaTable[zoneid])
  end

  if internalid == nil then
    return
  end

  for roomid, roomname in pairs(fullmap) do
    if getRoomArea(roomid) == internalid then
      if string.findPattern(roomname:lower(), matches[2]:lower()) then

        local pathlength=0

        if roomLocked(roomid) == false then
          if map:getRoom() ~= nil then
            if getPath( map:getRoom(), roomid) then
              pathlength=#speedWalkPath
            end
          end
        end

        cecho(string.format("&lt;green&gt;%30s Room ID: %6d [%3d]  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, pathlength, roomname))
      end
    end
  end

  return
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@afind ?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>setroom</name>
					<script>if map:getRoom() ~= nil then
  if getRoomArea(map:getRoom()) ~= -1 then
    echo("[Room set]\n")
    map:setRoom(matches[2])
    centerview(map:getRoom())
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^setroom ([0-9]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>emptyroom</name>
					<script>local fullmap = getRooms()

for roomid, roomname in pairs(fullmap) do
  if string.findPattern(roomname:lower(), "unmapped") then
    echo("Empty room already exists: " .. roomid .. "\n")
    setRoomArea(1, map:findAreaID("The Great Unknown"))
    return
  end
end

map:addArea(6)

local newroomid = createRoomID()

addRoom(newroomid)

echo("\nCreated room number: " .. newroomid .. "\n")

setRoomArea(newroomid, map:findAreaID("The Great Unknown"))

setRoomName(newroomid, "Unmapped")


echo("Centering map.\n")
centerview(newroomid)</script>
					<command></command>
					<packageName></packageName>
					<regex>^emptyroom$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>enter</name>
					<script>map:processMovement("ENTER " .. matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^(en|ent|ente|enter) (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>recall</name>
					<script>tempTimer(1.5, [[expandAlias("@find", false)]])
mud:send("RECALL", false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^recall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>movement commands</name>
					<script>if pagingmode then
  mud:send("")
  return
end

-- currently moving
spell:setMoving(true)

-- erase spellqueue if any spells present
spell:eraseQueue()


-- erase scanned table
scanned={}

local dir=matches[2]:sub(1,1):lower()

map:processMovement(dir)

toGagLook=nil
gaglook=nil</script>
					<command></command>
					<packageName></packageName>
					<regex>^(n|no|nor|nort|north|s|so|sou|sout|south|e|ea|eas|east|w|we|wes|west|u|up|d|do|dow|down)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>doorbash</name>
					<script>local dir=matches[3]:sub(1,1):lower()

NyyLIB.doorbash = dir

mud:send("DOORBASH " .. dir, false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^(doo|door|doorb|doorba|doorbas|doorbash) ([nsewud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>drag</name>
					<script>-- drag corpse in direction

-- set as currently moving
spell:setMoving(true)

if checkMask("caster") then
  -- erase spellqueue if any spells present
  spell:eraseQueue()

  -- disable autocast
  buttons:change("autocast", false, "SpellsButton")
end

-- erase scanned table
scanned={}

local dir=matches[3]:sub(1,1):lower()

echoDebug("Drag: " .. matches[1] .. "\n")

toGagLook=nil
gaglook=nil

map:processMovement("DRAG " .. matches[2] .. " " .. matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^drag (.*) ([ewnsud].*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@zone</name>
					<script>--This alias will list all zones matching a pattern

for id, name in pairs(NyyLIB.areaTable) do
  if string.findPattern(name:lower(), matches[2]:lower()) then
    cecho("&lt;red&gt;(" .. id .. ") " .. name .. "\n")
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@zone (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>movealone</name>
					<script>-- currently moving
spell:setMoving(true)

-- erase spellqueue if any spells present
spell:eraseQueue()


-- erase scanned table
scanned={}

local dir=matches[2]:sub(1,1):lower()

toGagLook=nil
gaglook=nil

map:processMovement("MOVEA " .. dir)</script>
					<command></command>
					<packageName></packageName>
					<regex>^movea(?:lone)? (n|e|s|w|u|d)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@updatemap</name>
					<script>cecho("&lt;red&gt;Downloading current mapfile.\n")
downloadFile("toril.map", "https://github.com/Nyyrazzilyss/NyyLIB/raw/master/map/toril.map")

cecho("\n")
cecho("&lt;green&gt;This downloads a current mapfile from github.")
cecho("\n")
cecho("&lt;green&gt;To merge your personal mapfile against it, type &lt;red&gt;@map update\n\n")
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@updatemap$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>SQL Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@clist</name>
					<script>local nx
local matchchar = matches[2]:title()
local charlist

local tmpchar

if matchchar == nil then
  echo("[clist charname]\n")
  return
end

matchchar = string.lower(matches[2]):title()

cecho("&lt;red&gt;[Matching characters for " .. matchchar .. " as at Katumi: " .. NyyLIB.dbversion .. "]\n\n")

if getProfile(matchchar) ~= nil then
  matchchar=getProfile(matchchar)
end

charlist = sqlclist(matchchar)

for k,v in pairs(charlist) do
  cecho(string.format("&lt;green&gt;[%2d %15s] %20s %-15s (@%s)\n", v[1], v[2], v[3], 
        string.format("(%s)", v[4]), v[5]))
end

cecho("\n&lt;red&gt;[Matching characters from local database]\n\n")

whoclist(matchchar)

mud:send("\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@clist ?([A-Za-z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@gall</name>
					<script>-- create gags for all of a persons characters
local matchchar=matches[2]

if matchchar ~= nil then
  echo("[Gagging all characters for " .. matchchar:title() .. "]\n")

  matchchar = sqlclist(matchchar)

  for k,v in pairs(matchchar) do
    expandAlias("@gag " .. v[3], false)
  end
else
  echo("usage: @gall charactername - creates a gag for all associated characters\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@gall ?([A-za-z]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@id</name>
					<script>local data


if matches[2] == "" then
  expandAlias("@help id")
  return
end

cecho("&lt;red&gt;[Attempting to identify " .. matches[2] .. "]\n")

data = sqlshortstats(matches[2])


for k,v in pairs(data) do
  cecho("\n&lt;green&gt;" .. v .. "\n")
end

cecho ("&lt;red&gt;[" .. #data .. " matches in database]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@id ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@statitems ?(gsay)?$</name>
					<script>local stats

local togsay = matches[2]

if NyyLIB.groupitems == nil then
  cecho("&lt;red&gt;[groupitems is nil]\n")
  return
end

for k,v in pairs(NyyLIB.groupitems) do
  stats = sqliditem(v)

  -- need to distinguish between multiple return values

  if #stats &gt; 1 then
    for nx=1,#stats,1 do
      if string.find(stats[nx], v .. " 1") then
        stats[1] = stats[nx]
      end    
    end
    echo("[multiple return values]\n")
  end

  if togsay == "gsay" then
    if stats[1] ~= nil then
      mud:send("gsay * " .. stats[1])
    else
      mud:send("gsay * " .. v .. " : not found in database. identify and mmail to katumi")
    end
  else
    if stats[1] ~= nil then
      echo(stats[1] .. "\n")
    else
      echo(v .. " : not found in database. identify and mmail to katumi\n")
    end
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@statitems ?(gsay)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@fstat</name>
					<script>display(matches)</script>
					<command></command>
					<packageName></packageName>
					<regex>^@fstat (?: *([a-z]+) ?([&lt;&gt;=]) ?([a-z0-9]+,?))+$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@cid</name>
					<script>if matches[2] == nil then
  for k,v in pairs(noIdItems) do
    display(v)
  end
  
  return
end

disableTrigger("DisplayPotions")
enableTrigger("DisplayContainer")

mud:send("examine " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^@cid ?([a-z]+)?$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>BOTS</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@stoptrain</name>
					<script>silent=nil

if trainMode == "tank" then
  cecho("&lt;red&gt;[Stopping: Train engine triggers]\n")
  NyyLIB.smtrainposition=nil
  disableTrigger("trainstation")
  expandAlias("@set statname unset", false)

  if checkMask("fighter") then
    buttons:change("rescuetype", "basic", "rescue")
  end

  if checkMask("ran") or checkMask("hex") then
    buttons:change("rescuetype", "off", "rescue")
  end
else
  cecho("&lt;red&gt;[Stopping: Train car triggers]\n")
  disableTrigger("SMTrainCaster")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@stoptrain$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@starttrain</name>
					<script>trainMode=matches[2]

if matches[2] == nil then
  cecho("&lt;red&gt;                   The Adud XP Train\n")
  cecho("&lt;green&gt;@starttrain tank          - start running train as tank\n")
  cecho("&lt;green&gt;@starttrain tank silent   - suppress all gsay messages\n")
  cecho("&lt;green&gt;@starttrain tank moblist  - run train as tank using an alternate created mob list\n")
  cecho("&lt;green&gt;@starttrain fol           - start running train as a follower\n")       
  return
end

if matches[3] == "silent" then
  silent=true
end

trainList = matches[4]

configureTrain()

if trainMode == "tank" then
  trainEngine()

  cecho("&lt;green&gt;[Sending starting movement]\n")
  NextTrainStop()
else
  trainCar()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@starttrain ?(tank|fol)? ?(silent)? ?([A-Za-z0-9]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@inittrain</name>
					<script>if map:getRoom() == nil then
  cecho("&lt;red&gt;[Map is not currently in sync]\n")
  return
end

if map:getCurrentZone() == "Ashstone" then
  cecho("&lt;red&gt;[Unlock path in Ashstone. This starts at Stephan]\n")
  expandAlias("@fwalk 87411", true)
  expandAlias(".w4ns4wseduwn3e2n5w2sw2sw2se4nene3se2wese2wese2wesew2s2en4e4ws2w9n4e5s2e", true)
else
  cecho("&lt;red&gt;[Unlock path in Silverymoon]\n")
  expandAlias("@fwalk 48603", true)
  expandAlias(".neswen12e2n2sw2new2nsen2snesn3w2new2s13w3s3w5neudw2s3wnew4s9e2s2w2e5sesn5esudn11w3nud3s5e7nws", true)
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@inittrain$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@genseal</name>
					<script>mud:send("get dust " .. charData:get("container") )
mud:send("give dust lavis")
mud:send("put scroll " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^@genseal$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@resettrain</name>
					<script>-- turn it off in full

NyyLIB.nextroomstop=nil
NyyLIB.castertrain=nil
NyyLIB.smtrainposition=nil

disableTrigger("trainstation")
expandAlias("@set statname unset", false)

disableTrigger("SMTrainCaster")
disableTrigger("SMTrain")

if checkMask("ran") or checkMask("hex") then
  --disable rescue
  buttons:change("rescuetype", "off", "rescue")
else
  if checkMask("fighter") then
    --basic rescue
    buttons:change("rescuetype", "basic", "rescue")
  end
end

if checkMask("war") then
  buttons:change("warbh", false, "bash")
  buttons:change("warkc", false, "kick")
end


cecho("&lt;red&gt;[All train triggers disabled]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@resettrain$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Utilities</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>CapturePowers</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>genalias</name>
						<script>sortpowerslist={}

for nx=#powerslist,1,-1 do
  mud:send("powers info " .. powerslist[nx][1])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^genalias$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>showalias</name>
						<script>-- sortpowerslist[#sortpowerslist+1] = {to_snake(powername), matches[2]:trim(), level, "", ""}


for nx=1,#sortpowerslist,1 do
  echo("{ " .. [["]] .. sortpowerslist[nx][1] .. [[", "]] .. sortpowerslist[nx][2] .. [[", ]] .. sortpowerslist[nx][3] .. [[, "", ""},]] .. "\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^showalias$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>classpowers</name>
						<script>powerslist = {}

enableTrigger("CapturePowers")

mud:send("powers list")

-- tempTimer(5, [[expandAlias("genalias")]] )</script>
						<command></command>
						<packageName></packageName>
						<regex>^classpowers$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>createspellalias</name>
						<script>
for ix=1, #powerslist, 1 do
  --if exists(powerslist[ix][1]:lower(), "alias") == 0 then
    permAlias(powerslist[ix][1]:lower(), whoclass() .. "Spells", "^(?:" .. powerslist[ix][2] .. ")( .+)?$", [[
spell:setMoving(false)
spell:setNext("]] .. powerslist[ix][2]:upper() .. [[" .. (matches[2] or "") )
]] )

  --end
end





--permAlias("full harm", "Cle", "^(?:fhm)( .+)?$", [[
--spell:setMoving(false)
--spell:setNext("FHM" .. (matches[2] or "") )
--]] )</script>
						<command></command>
						<packageName></packageName>
						<regex>^createspellalias$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>ZoneImport</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>readobj</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex>^readobj$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>cMud Map Importer</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Create map from cmud</name>
						<script>local ok, msg = cmi:importAll()
if ok then
  echo("&lt;green&gt;cMud map successfully imported.  Use 'centerview #' in a script to orient yourself, where # is a room id\n")
else
  echo("&lt;firebrick&gt;Didn't import; "..msg..".\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud importmap$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>purgemap</name>
						<script>--this method is meant for a clean import from cmud
local maxid = table.maxn(getRooms())
local i

for i = 1, maxid  do
  if roomExists(i) then
    deleteRoom(i)
  end
end

--delete labels for all areas
local areatable = getAreaTable()
for i,v in pairs(areatable) do
  local labels = getMapLabels(v)
  if type(labels) == 'table' then
    for j,k in pairs(labels) do
      deleteMapLabel(v,j)
    end
  end
  deleteArea(v)
end
cecho("&lt;red&gt;[Wiped all data from loaded map]\n")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud purgemap$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Clear sqlite connection</name>
						<script>cmi:getConnection()</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud resetConnection$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Import rooms</name>
						<script>cmi:checkConnection()
cmi:addRooms(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud addRooms$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Color rooms</name>
						<script>cmi:checkConnection()
cmi:colorRooms(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud colorRooms$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Import Favorites</name>
						<script>cmi:checkConnection()
cmi:addFavorites(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud addFavs$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Label Zones</name>
						<script>cmi:checkConnection()
cmi:labelCmudZones(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud labelZones$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>List areas</name>
						<script>cmi:listAreas()</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud listareas$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>import</name>
						<script>local passwords = {
[2371] = "ugracht",
[5678] = "auril",
[14334] = "jasmine",
[16418] = "netheril",
[71573] = "silverwing",
[77932] = "kostchtchie",
[79128] = "glukknukkle",
[41212] = "tug plank",
[47888] = "laduguer",
[48565] = "hanali",
[48806] = "moradin",
[14237] = "hi",
[11687] = "paradox",
[17103] = "wind",
[70373] = "kossuth",
[74115] = "annam",
[74325] = "Athzaganaroul",
[75603] = "sunbat",
[78269] = "jess",
[78562] = "trahern",
[78577] = "vrazgal",
[79003] = "yylirmog",
[84994] = "blood",
[87034] = "bloodstone",
[92742] = "death",
[92882] = "ancients",
[94218] = "dugmaren",
[94219] = "clangeddin",
[94220] = "moradin",
[94221] = "berronar",
[94222] = "marthammor",
[95059] = "kartagan"
}

--GN hall- say 'uthgar'
--door to chief in SS- say 'ugracht'
--fire giant village- say 'annam'
--secret room in Ghore- say 'paradise'
-- citadel
--say 'shalafi'
--say 'black'
--say 'wind'
--Room on MS- say 'enigma'
--Yath Oloth- say 'athzaganaroul'
--bronze door in Demi- say 'nevarlith'
--Waterdeep graveyard- say 'Torm'
--Skerttd-Gul king- say 'Kartagan'
--Skerttd-Gul tower- say 'wine' 'sand' and 'wind' for the next room. 
--Leuthilspar gates- say 'peace'
--Kobold village- tug plank
--mines near GH- say 'glukknukkle'
--Swift Steel Merc company- say 'ssc'
--Demi tower- say 'nevarlith'
--MH mines to beholder area- say 'orlean' (sw from the dwarf corpse)
--Bloodtusk gates- say 'death', 'blood or 'war'
--CP, door to Sheik Akalon- say 'lore'
--Blood Bayou blood pool- says 'yylirmog'
--Kobold mines- say i&gt;|uub
--Longhollow- say 'selune'



--cmud listareas
--genimport


echo("[Starting map import]\n")

-- loadMap("_") -- erase map

for k,v in pairs(mudAreaTable) do
  local mudid= v
  local cmudid=cmudAreaTable[k]
  local zonename=k

  display(mudid)
  display(cmudid)

  if mudid ~= nil then
    if tonumber(cmudid) ~= nil then
      echo ( string.format("%3d %3d &gt;&gt; %s\n\n", tonumber(mudid), tonumber(cmudid), zonename ) )

      cmi:importArea(cmudid, mudid)
    end
  end
end

echo("[Adding exits]\n")
cmi:addExits(cmi.con)

echo("[Colouring rooms]\n")
cmi:colorAreas()

echo("[Labeling zone edges]\n")
cmi:labelCmudZones(cmi.con)

-- set weight on specific exits to exclude from path finding

setExitWeight(48767, "down", 500) -- down entrance to underdark from silverymoon

echo("[Adding room password information]\n")

for k,v in pairs(passwords) do
  if roomExists(k) then
    echo("Room: " .. k .. " PW: " .. v .. "\n")
    setRoomUserData(k, "password", v)
  else
    echo("Room: " .. k .. " does not exist in map\n")
  end
end

expandAlias("emptyroom")

echo("[End import]\n")</script>
						<command></command>
						<packageName></packageName>
						<regex>^import$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>areaname util</name>
						<script>cmi:checkConnection()</script>
						<command>^areanames$</command>
						<packageName></packageName>
						<regex></regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gennyyareatable</name>
						<script>local areaTable={}
local nx=0

for k,v in pairs(mudAreaTable) do
--  echo("[" .. v .. "] = " .. [["]] .. k .. [[",]] .. "\n")

  areaTable[v] = k
end


for nx=0, table.size(areaTable), 1 do
  if areaTable[nx] ~= nil then
    echo("[" .. nx .. "] = " .. [["]] .. areaTable[nx] .. [[",]] .. "\n")
  end
end

--for k,v in ipairs(areaTable) do
--  echo("[" .. k .. "] = " .. [["]] .. v .. [[",]] .. "\n")
--end

display(table.size(areaTable))
--table.insert(table, [pos,] value)</script>
						<command></command>
						<packageName></packageName>
						<regex>^gennyyareatable$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>spell powers v2</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>generate spell text</name>
						<script>-- elemental_ward={"Elemental|Ward"},

for nx=1, #capSpellList, 1 do
  local spell= capSpellList[nx]
  local formattedSpell=spell
  
  local _, count = string.gsub(spell, " ", "|")

  if count &lt; 2 then
    formattedSpell=string.gsub(spell, " ", "|")
  end
  
  echo( to_snake(spell) .. [[= {"]] .. formattedSpell .. [["},]] .. "\n" )
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^gentext$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>reset text</name>
						<script>capSpellList=nil</script>
						<command></command>
						<packageName></packageName>
						<regex>^resettext$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>addRooms</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>@addarea</name>
						<script>addAreaName(matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^@addarea (.*)</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@e</name>
						<script>local x,y,z = getRoomCoordinates( map:getRoom() )

x=x+1

local newroomid = createRoomID()
addRoom(newroomid)

setExit( map:getRoom(), newroomid, "e")
setExit( newroomid, map:getRoom(), "w")

setRoomCoordinates(newroomid, x, y, z)

setRoomArea(newroomid, getRoomArea(map:getRoom()) )</script>
						<command></command>
						<packageName></packageName>
						<regex>^@e$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@upd</name>
						<script>local roomID=map:getRoom()

setRoomName(roomID, map:getRoomname() )

setRoomUserData(roomID, "zoneid", 356 )

--map:getExits()
--setExitStub(roomID, direction, set/unset)

--lua getRoomExits(69)
--{
--  west = 85591
--}

if map:getExits()[1] == 1 then
  if getRoomExits(roomID)["north"] == nil then
    setExitStub(roomID, "n", true)
  end
end

if map:getExits()[2] == 1 then
  if getRoomExits(roomID)["south"] == nil then
    setExitStub(roomID, "s", true)
  end
end

if map:getExits()[3] == 1 then
  if getRoomExits(roomID)["east"] == nil then
    setExitStub(roomID, "e", true)
  end
end

if map:getExits()[4] == 1 then
  if getRoomExits(roomID)["west"] == nil then
    setExitStub(roomID, "w", true)
  end
end

if map:getExits()[5] == 1 then
  if getRoomExits(roomID)["up"] == nil then
    setExitStub(roomID, "u", true)
  end
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^@upd$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@n</name>
						<script>local x,y,z = getRoomCoordinates( map:getRoom() )

y=y+1

local newroomid = createRoomID()
addRoom(newroomid)

setExit( map:getRoom(), newroomid, "n")
setExit( newroomid, map:getRoom(), "s")

setRoomCoordinates(newroomid, x, y, z)

setRoomArea(newroomid, getRoomArea(map:getRoom()))</script>
						<command></command>
						<packageName></packageName>
						<regex>^@n$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@s</name>
						<script>local x,y,z = getRoomCoordinates( map:getRoom() )

y=y-1

local newroomid = createRoomID()
addRoom(newroomid)

setExit( map:getRoom(), newroomid, "s")
setExit( newroomid, map:getRoom(), "n")

setRoomCoordinates(newroomid, x, y, z)

setRoomArea(newroomid, getRoomArea(map:getRoom()))</script>
						<command></command>
						<packageName></packageName>
						<regex>^@s$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@w</name>
						<script>local x,y,z = getRoomCoordinates( map:getRoom() )

x=x-1

local newroomid = createRoomID()
addRoom(newroomid)

setExit( map:getRoom(), newroomid, "w")
setExit( newroomid, map:getRoom(), "e")

setRoomCoordinates(newroomid, x, y, z)

setRoomArea(newroomid, getRoomArea(map:getRoom()))</script>
						<command></command>
						<packageName></packageName>
						<regex>^@w$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@d</name>
						<script>local x,y,z = getRoomCoordinates( map:getRoom() )

z=z-1

local newroomid = createRoomID()
addRoom(newroomid)

setExit( map:getRoom(), newroomid, "d")
setExit( newroomid, map:getRoom(), "u")

setRoomCoordinates(newroomid, x, y, z)

setRoomArea(newroomid, getRoomArea(map:getRoom()))</script>
						<command></command>
						<packageName></packageName>
						<regex>^@d$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@u</name>
						<script>local x,y,z = getRoomCoordinates( map:getRoom() )

z=z+1

local newroomid = createRoomID()
addRoom(newroomid)

setExit( map:getRoom(), newroomid, "u")
setExit( newroomid, map:getRoom(), "d")

setRoomCoordinates(newroomid, x, y, z)

setRoomArea(newroomid, getRoomArea(map:getRoom()))</script>
						<command></command>
						<packageName></packageName>
						<regex>^@u$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@l</name>
						<script>display(matches[2])

--map.farseeRoomname = teststring
--getExitTable ( map.farseeExits )

local x,y,z = getRoomCoordinates( map:getRoom() )

  if matches[2] == "n" then
    y=y+1
  end

  if matches[2] == "s" then
    y=y-1
  end

  if matches[2] == "w" then
    x=x-1
  end

  if matches[2] == "e" then
    x=x+1
  end

  if matches[2] == "u" then
    z=z+1
  end

  if matches[2] == "d" then
    z=z-1
  end


  local newroomid = createRoomID()
  addRoom(newroomid)

  display(newroomid)

  if matches[2] == "e" then
    setExit( map:getRoom(), newroomid, "e")
    setExit( newroomid, map:getRoom(), "w")
  end

  if matches[2] == "w" then
    setExit( map:getRoom(), newroomid, "w")
    setExit( newroomid, map:getRoom(), "e")
  end

  if matches[2] == "n" then
    setExit( map:getRoom(), newroomid, "n")
    setExit( newroomid, map:getRoom(), "s")
  end

  if matches[2] == "s" then
    setExit( map:getRoom(), newroomid, "s")
    setExit( newroomid, map:getRoom(), "n")
  end

  if matches[2] == "u" then
    setExit( map:getRoom(), newroomid, "u")
    setExit( newroomid, map:getRoom(), "d")
  end

  if matches[2] == "d" then
    setExit( map:getRoom(), newroomid, "d")
    setExit( newroomid, map:getRoom(), "u")
  end

  setRoomCoordinates(newroomid, x, y, z)

  setRoomArea(newroomid, getRoomArea(map:getRoom()) )</script>
						<command></command>
						<packageName></packageName>
						<regex>^@l ([neswud])$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@fpd</name>
						<script>local roomID=tonumber(matches[2])
local exits= getExitTable ( map.farseeExits )

--map.farseeRoomname = teststring
--getExitTable ( map.farseeExits )


setRoomName(roomID, map.farseeRoomname)

setRoomUserData(roomID, "zoneid", 356 )

map:setDoNotEnter(roomID)

--map:getExits()
--setExitStub(roomID, direction, set/unset)

--lua getRoomExits(69)
--{
--  west = 85591
--}

if exits[1] == 1 then
  if getRoomExits(roomID)["north"] == nil then
    setExitStub(roomID, "n", true)
  end
end

if exits[2] == 1 then
  if getRoomExits(roomID)["south"] == nil then
    setExitStub(roomID, "s", true)
  end
end

if exits[3] == 1 then
  if getRoomExits(roomID)["east"] == nil then
    setExitStub(roomID, "e", true)
  end
end

if exits[4] == 1 then
  if getRoomExits(roomID)["west"] == nil then
    setExitStub(roomID, "w", true)
  end
end

if exits[5] == 1 then
  if getRoomExits(roomID)["up"] == nil then
    setExitStub(roomID, "u", true)
  end
end

if exits[6] == 1 then
  if getRoomExits(roomID)["down"] == nil then
    setExitStub(roomID, "d", true)
  end
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^@fpd ([0-9]+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>@renumber</name>
						<script>if matches[2] == nil then
  cecho("&lt;green&gt;Renumber all rooms in an area\n")
  cecho("&lt;red&gt;Usage: @renumber zonenumber newstartingroomid\n")
  return
end

local area=tonumber(matches[2])
local range=tonumber(matches[3])

cecho("&lt;green&gt;Renumbering area: (" .. area .. ") " .. getAreaTableSwap()[area] .. "\n")
cecho("&lt;green&gt;New starting room " .. range .. "\n")

local roomList= getAreaRooms(area)

local roomTable= {}

for k,v in pairs(roomList) do
  local roomExistingNumber = v
  local roomName = getRoomName(v)
  local roomArea = getRoomArea(v)
  
  local roomChar = getRoomChar(v)
  local roomCharR, roomCharG, roomCharB = getRoomCharColor(v)
  
  local roomX, roomY, roomZ =getRoomCoordinates(v)
  local roomEnv= getRoomEnv(v)
  local roomExits= getRoomExits(v)
  local roomSpecialExits= getSpecialExits(v)
  local roomUserData= getAllRoomUserData(v)
  
  local roomWeight = getRoomWeight(v)
  local roomExitWeights= getExitWeights(v)
 
  local roomDoors= getDoors(v)
  local _roomLocked= roomLocked(v)
  
  
  roomTable[table.size(roomTable)+1] = { roomExistingNumber, roomName, roomArea, roomChar, roomCharR, roomCharG, roomCharB,
    roomX, roomY, roomZ, roomEnv, roomExits, roomSpecialExits, roomUserData, roomWeight, roomExitWeight, roomDoors, _roomLocked }
  
  echo (k .. " " .. v .. " " .. getRoomName(v) .. "\n")

  --local newroomid = createRoomID(range)
  --addRoom(newroomid)
  
  --setRoomCoordinates(newroomid, roomX, roomY, roomZ)

  --setRoomName(newroomid, roomName)
  --setRoomArea(newroomid, area)
  --setRoomChar(newroomid, roomChar)
end

--display(roomTable)

for k,v in pairs(roomTable) do
  display(v)
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^@renumber(?: ([0-9]+) ([0-9]+))?$</regex>
					</Alias>
				</AliasGroup>
			</AliasGroup>
			<Alias isActive="yes" isFolder="no">
				<name>spamcmd</name>
				<script>send("ack " .. matches[2])
send("afk " .. matches[2])
send("agree " .. matches[2])
send("amaze " .. matches[2])
send("apologize " .. matches[2])
send("applaud " .. matches[2])
send("arch " .. matches[2])
send("ayt " .. matches[2])
send("bang " .. matches[2])
send("bark " .. matches[2])
send("bathe " .. matches[2])
send("bbl " .. matches[2])
send("beer " .. matches[2])
send("beg " .. matches[2])
send("bird " .. matches[2])
send("bite " .. matches[2])
send("bleed " .. matches[2])
send("blink " .. matches[2])
send("blow " .. matches[2])
send("blush " .. matches[2])
send("boggle " .. matches[2])
send("bonk " .. matches[2])
send("bored " .. matches[2])
send("bounce " .. matches[2])
send("bow " .. matches[2])
send("brb " .. matches[2])
send("burp " .. matches[2])
send("bye " .. matches[2])
send("cackle " .. matches[2])
send("calm " .. matches[2])
send("caress " .. matches[2])
send("censor " .. matches[2])
send("cheek " .. matches[2])
send("cheer " .. matches[2])
send("choke " .. matches[2])
send("chuckle " .. matches[2])
send("clap " .. matches[2])
send("comb " .. matches[2])
send("comfort " .. matches[2])
send("congratulate " .. matches[2])
send("cough " .. matches[2])
send("cringe " .. matches[2])
send("cry " .. matches[2])
send("cuddle " .. matches[2])
send("curious " .. matches[2])
send("curse " .. matches[2])
send("curtsey " .. matches[2])
send("dance " .. matches[2])
send("doh " .. matches[2])
send("dream " .. matches[2])
send("drool " .. matches[2])
send("dropkick " .. matches[2])
send("duck " .. matches[2])
send("embrace " .. matches[2])
send("envy " .. matches[2])
send("eyebrow " .. matches[2])
send("fart " .. matches[2])
send("fidget " .. matches[2])
send("flame " .. matches[2])
send("flash " .. matches[2])
send("flex " .. matches[2])
send("flip " .. matches[2])
send("flirt " .. matches[2])
send("flutter " .. matches[2])
send("fondle " .. matches[2])
send("fool " .. matches[2])
send("french " .. matches[2])
send("frown " .. matches[2])
send("full " .. matches[2])
send("fume " .. matches[2])
send("fuzzy " .. matches[2])
send("gag " .. matches[2])
send("gape " .. matches[2])
send("gasp " .. matches[2])
send("giggle " .. matches[2])
send("glare " .. matches[2])
send("grin " .. matches[2])
send("groan " .. matches[2])
send("grope " .. matches[2])
send("grovel " .. matches[2])
send("growl " .. matches[2])
send("grumble " .. matches[2])
send("grunt " .. matches[2])
send("hand " .. matches[2])
send("happy " .. matches[2])
send("hero " .. matches[2])
send("hiccup " .. matches[2])
send("hiss " .. matches[2])
send("hi5 " .. matches[2])
send("holdon " .. matches[2])
send("hop " .. matches[2])
send("hug " .. matches[2])
send("hum " .. matches[2])
send("hunger " .. matches[2])
send("imitate " .. matches[2])
send("impale " .. matches[2])
send("insult " .. matches[2])
send("introduce " .. matches[2])
send("jam " .. matches[2])
send("jk " .. matches[2])
send("jump " .. matches[2])
send("kiss " .. matches[2])
send("kneel " .. matches[2])
send("stand")
send("laugh " .. matches[2])
send("lag " .. matches[2])
send("lean " .. matches[2])
send("lick " .. matches[2])
send("love " .. matches[2])
send("lost " .. matches[2])
send("lucky " .. matches[2])
send("massage " .. matches[2])
send("melt " .. matches[2])
send("moan " .. matches[2])
send("moon " .. matches[2])
send("mosh " .. matches[2])
send("mourn " .. matches[2])
send("mutter " .. matches[2])
send("nap " .. matches[2])
send("nibble " .. matches[2])
send("nod " .. matches[2])
send("nog " .. matches[2])
send("noogie " .. matches[2])
send("nose " .. matches[2])
send("nudge " .. matches[2])
send("nuzzle " .. matches[2])
send("ogle " .. matches[2])
send("panic " .. matches[2])
send("pant " .. matches[2])
send("pat " .. matches[2])
send("peer " .. matches[2])
send("pet " .. matches[2])
send("pillow " .. matches[2])
send("pinch " .. matches[2])
send("plonk " .. matches[2])
send("point " .. matches[2])
send("poke " .. matches[2])
send("ponder " .. matches[2])
send("pose " .. matches[2])
send("pounce " .. matches[2])
send("pout " .. matches[2])
send("protect " .. matches[2])
send("pucker " .. matches[2])
send("puke " .. matches[2])
send("pull " .. matches[2])
send("punch " .. matches[2])
send("purr " .. matches[2])
send("push " .. matches[2])
send("puzzle " .. matches[2])
send("raise " .. matches[2])
send("ready " .. matches[2])
send("roar " .. matches[2])
send("rofl " .. matches[2])
send("roll " .. matches[2])
send("rose " .. matches[2])
send("rub " .. matches[2])
send("ruffle " .. matches[2])
send("salute " .. matches[2])
send("scare " .. matches[2])
send("scold " .. matches[2])
send("scratch " .. matches[2])
send("scream " .. matches[2])
send("seduce " .. matches[2])
send("shake " .. matches[2])
send("shiver " .. matches[2])
send("shove " .. matches[2])
send("shrug " .. matches[2])
send("shudder " .. matches[2])
send("shush " .. matches[2])
send("sigh " .. matches[2])
send("sing " .. matches[2])
send("skip " .. matches[2])
send("slap " .. matches[2])
send("slobber " .. matches[2])
send("smell " .. matches[2])
send("smile " .. matches[2])
send("smirk " .. matches[2])
send("smoke " .. matches[2])
send("snap " .. matches[2])
send("snarl " .. matches[2])
send("sneer " .. matches[2])
send("sneeze " .. matches[2])
send("snicker " .. matches[2])
send("sniff " .. matches[2])
send("snoogie " .. matches[2])
send("snore " .. matches[2])
send("snort " .. matches[2])
send("snuggle " .. matches[2])
send("spam " .. matches[2])
send("spank " .. matches[2])
send("spin " .. matches[2])
send("spit " .. matches[2])
send("squeeze " .. matches[2])
send("squirm " .. matches[2])
send("stare " .. matches[2])
send("steam " .. matches[2])
send("stomp " .. matches[2])
send("strangle " .. matches[2])
send("stretch " .. matches[2])
send("strut " .. matches[2])
send("sulk " .. matches[2])
send("swat " .. matches[2])
send("sweat " .. matches[2])
send("sweep " .. matches[2])
send("tackle " .. matches[2])
send("tango " .. matches[2])
send("tap " .. matches[2])
send("tarzan " .. matches[2])
send("taunt " .. matches[2])
send("tease " .. matches[2])
send("thank " .. matches[2])
send("think " .. matches[2])
send("thirst " .. matches[2])
send("throw " .. matches[2])
send("tickle " .. matches[2])
send("tip " .. matches[2])
send("tiptoe " .. matches[2])
send("tongue " .. matches[2])
send("toss " .. matches[2])
send("touch " .. matches[2])
send("trip " .. matches[2])
send("tug " .. matches[2])
send("tweak " .. matches[2])
send("twibble " .. matches[2])
send("twiddle " .. matches[2])
send("twirl " .. matches[2])
send("undress " .. matches[2])
send("veto " .. matches[2])
send("wait " .. matches[2])
send("wave " .. matches[2])
send("welcome " .. matches[2])
send("wet " .. matches[2])
send("whap " .. matches[2])
send("whatever " .. matches[2])
send("wheeze " .. matches[2])
send("whimper " .. matches[2])
send("whine " .. matches[2])
send("whistle " .. matches[2])
send("wiggle " .. matches[2])
send("wince " .. matches[2])
send("wink " .. matches[2])
send("woops " .. matches[2])
send("worship " .. matches[2])
send("yawn " .. matches[2])
send("yodel " .. matches[2])
send("zone " .. matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^spamcmd (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>genimport</name>
				<script>-- mudAreaTable, cmudAreaTable

-- ^cmud listareas$

for k,v in pairs(mudAreaTable) do
  
  zoneName = k
  mudZoneNumber=v
  cmudZoneNumber=tostring(cmudAreaTable[k])
  
  if cmudZoneNumber == "nil" then
    echo(zoneName .. " " .. mudZoneNumber .. " " .. cmudZoneNumber .. "\n")
  end
end

echo("\n")

for k,v in pairs(cmudAreaTable) do
  
  zoneName = k
  cmudZoneNumber=v
  mudZoneNumber=tostring(mudAreaTable[k])
  
  if mudZoneNumber == "nil" then
    echo(zoneName .. " " .. mudZoneNumber .. " " .. cmudZoneNumber .. "\n")
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^genimport$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>colwater</name>
				<script>for k,v in pairs(getRooms()) do
  if string.find(v:lower(), "%(water%)", 1, nil) then
    echo(v .. "\n")
  end
end
-- lua for k,v in pairs(getRooms()) do if string.find(v:lower(), "%(water%)", 1, nil) then setRoomEnv(k, 268) end end
-- lua for k,v in pairs(getRooms()) do if string.find(v:lower(), "road", 1, nil) then setRoomEnv(k, 519) end end    -- street, trail, avenue
-- lua for k,v in pairs(getRooms()) do if string.find(v:lower(), "park", 1, nil) then setRoomEnv(k, 525) end end    -- forest, field
-- lua for k,v in pairs(getRooms()) do if string.find(v:lower(), "fields of the dead", 1, nil) then setRoomEnv(k, 272) end end  </script>
				<command></command>
				<packageName></packageName>
				<regex>^colwater$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>NyyLIB</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>changelog</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- 013dev

-- Map: 327 areas, 47413 rooms (Westgate, Crypt of Dragons)
-- Hexblade: Hellborne, Voidcaller initial scripts added
-- Major refactor of spellcast/powers usage across all classes
-- call function movingClassSubclass if it exists when groupleader says 'moving'
-- groupList:totalMobsTanked() return total mobs in room being tanked
-- begin adding Sorcerer
-- newprompt
-- subClass
-- @cid container - identify all items in a container
-- @id - prefixing a keyword with a minus sign will exclude the pattern from the results
-- resend practice no longer enabled by default
-- Shaman now has option to cast raise dead
-- @grill mobname - Ask a mob '20 questions'
-- @reset - force reset of a couple variables that might have locked the script
-- @starttrain tank silent -- no gsay messages from train
-- @resetgui to restore floated windows to original positioning
-- bugfixes from the mud 'focus' changes
-- Doubleclick the title bar of adjustable windows to change them to userwindows
-- all floated windows now start as adjustable windows
-- disabled autodock with the floated windows
-- @updatemap download a current copy of the mapfile from github
-- chance of attempting to rescue a hexblade lowered to 25%
-- @set condensed powersbar - gags the powers bar out of the prompt
-- removed consent requirement for ressurect
-- 2 years of no updates to changelog. a lot of changes (bugfixes).
-- 2023-01-01 New years resolution - changelog!

-- 012dev

-- smartprompt forced off
-- @fwalk add name vnum - can now add a room number to create a bookmark to that room
-- @freqtable display word occurance in room names. optionally add zone number
-- @stylerooms set all room names matching provided pattern to the target colour
-- @listenv display list of rooms set to a specific colour
-- @coltable display room colour table
-- triggers corrected for 'tog accountnames'
-- spellout messages now filtered if groupsize &gt; 8 people
-- @updatedb - download an updated katumi database
-- @uptime - time since start of current connection to the mud
-- Logging renabled on login to a character
-- Mud connect will timeout after 10 minutes and attempt connecting again
-- gui redesign
-- rent,camp temporarily disables reconnect option
-- warrior: added no opening
-- warrior/ranger powers updated to match 7-20-2020 patch notes
-- @id command rewritten to use multiple comma seperated substrings
-- map, minimap moved to floated resizable windows
-- removed auction from chat alltab
-- refactored powers attack aliases
-- remove p/g aliases
-- @set autoproc true|false - autoproc tiamat equipment
-- Katumi database updated with new equipment - Thanks @Raiwen!
-- bugfix: reconnect
-- Map updated: full size 325 areas 46506 rooms : Unseelie Faerie Court
-- bugfix: mudlet 4.8.0 gui problem
-- changed to mudlet 4.6 tooltips
-- bugfix: autoroller
-- bugfix: weapon powers on removal of weapon
-- bugfix: letter substitution during character generation
-- autobless fixed for bar/ctr
-- spellcast alias added to Blk, Ran, Hex
-- switch to singleline if a twoline prompt arrives
-- script initialization now occurs on receipt of first prompt from the mud
-- Hexblade
-- Icons updated - Thanks @Blaez!
-- 4k gui fixes
-- @entrance zonenumber - display entrances to zone
-- @resize command added to resize screen
-- lich fixes
-- added tts support to chat capture (@set tts 0-99 0=off, 99=max volume)
-- Katumi database update - 10/15/20
-- various bugfixes

--011

-- @set autoweapon auto|Bow|Dual|TwoHand|Shield|None - force weapon buttons for item unlisted in katumi
-- Katumi database update - 2/17/19
-- Map updated: full size 324 areas 46229 rooms : Bahamut, Keprum updates
-- @cgag to gag text from chat window (not main)
-- powers cooldown will show bottom left corner when switching weapons
-- fwalk paths won't pass through locked doors
-- added drow sign to chat capture
-- chars, items table is cached from katumi
-- bard now supports using 'flamekissed' as instrument type
-- "alert" is sent when needed
-- profilename displayed after who on anon characters
-- gcmd tab in chat window captures group leader only
-- @minimap - displays minimap window (and also gags from main display)
-- Command structure change: @map, @map help
-- Fixed roller
-- train fixes
-- various bugfixes

-- 011rc2

-- Katumi database update - 4/15/18
-- Map updated: full size 317 areas 45465 rooms
-- bugfixes
-- guard, vigiliant protector use the wuss
-- xp train will disable itself on petition
-- added warrior
-- @set border now accepts colorname, hex value
-- autoroller: status display reformatted, added anti timeout
-- @fol mobname - follows an unfollowable mob
-- @set font - font to use for buttons
-- @set colbuttonoff - use to set the button text colour when off
-- @set colbuttonon  - use to set the button text colour when on
-- @set condensed echosend - enabled displays everything sent to mud (for debug purposes)
-- @set maperror false - disable map room error suppression
-- @cd changes fleemode to 'lich'
-- autoassist is disabled by default after joining a group
-- buttons are now generated realtime from a table
-- url's in the chat window are now clickable
-- name in chat window now shows timestamp on mouseover
-- captures to the chat windows have been reformatted to remove redundant information
-- Added pause to train on low hp/movement, thanks @Afu for idea
-- Ranger, Paladin, and Blackguard refactored
-- added blackguard
-- spellcasting added to paladin
-- direction added to @cd
-- An error message will be displayed if mapper has likely gone out of sync
-- A helpfile entry was submitted! Thanks @Areh

-- 011rc1

-- Katumi database update - 12/23/17
-- Map updated: full size 317 areas 45344 rooms
-- Any players present at a train station will skip the room
-- telling someone '@room' will return location information
-- @set condensed spellout true - supresses local spellout messages
-- Taunts added to paladin
-- Ranger, Paladin: bugfixes
-- cooldown counters added to powers skills (ranger/paladin)
-- spells button replaced with an icon, added to rangers
-- bugfix: special exits recognized if an abbreviated command typed
-- Paladins: old-code spells removed
-- Paladins: 1h, 2h powers added
-- mapper bugfixes
-- added tooltips to lower icons
-- autoroller accelerated
-- buttons were added for autoportal, autoopen
-- imm echoes of format [immname] message now captured
-- rangers: misty path, cloak of protection, cloak of resilience
-- added autohide to ranger, removed kick, mount
-- urls in the main window are now clickable
-- rangers won't rescue rangers, and warriors will rescue rangers 25% of the time
-- added new ranger spells
-- bugfixes
-- Many commands now have '@' at the start of the alias
-- @help index will list all help entries
-- rangers archery powers added
-- buttons will be redrawn when you level
-- (some) helpfile updates
-- some rangers stuff added
-- 'powers prompt' added to prompt regex
-- @find will accept room numbers when searching
-- bash will be switched to powersbash if you bounce off something
-- @set movebuffer # - how many rooms should be sent to the mud before buffering
-- @fwalk buffers path, and sends in 5-10 room bursts
-- Removed @fwalk distance limit
-- changed # command prefix to @

-- 011c (update1)

-- added failed spellcast: You may not cast offensive spells on other players.
-- bugfix: casting ff
-- bugfix: casting: realm
-- Map updated: full size 317 areas 44959 rooms

-- 011c

-- bugfixes
-- poisons will be identified when looking in containers
-- added autohide to rogue
-- .. will walk reverse paths example: ..5ne will walk .w5s
-- katumi database update - 7/11/17
-- looting is disabled when you join a group
-- #room window is now flicker free
-- #fpet - retrieves lost pets
-- ungrouped followers are shown on group display
-- added ancient staff of the ashen soul
-- pet casting scripts
-- pet followers are named/numbered with unique names
-- gui windows redesign
-- spirit wrack added to a-p, fell frost to invoker
-- some text buttons have been replaced with icons
-- generated room, status, group, followers requests are gagged
-- incorrect group classes will be corrected if you type 'who'
-- equipment buttons will update immediatly when you remove/wear the item
-- code for buttons and timers changed
-- starttrain tank moblist : optional, moblist is the name of a variable with a list of mobs to attack
-- improved necro pet (ghost) spellcast
-- more code refactors
-- all generated status requests are now gagged
-- #fwalk area - list fwalks for current area only
-- lich/necro buttons
-- autoassist will work with ungrouped pet followers
-- added outflank
-- refactored train - use 'starttrain tank' to start as engine
-- Added say, auction to tabbed chat windows
-- Map updated: full size 317 areas 44958 rooms

-- 011b

-- the function 'initCustom' will be called on initialization if it exists
-- self in group display if more then 1 person uses cyan colour 
-- file structure and installation updated - mudlet 3.1+ recommended
-- grouped hell hounds are named 'wolf'
-- set poisonbag - name of container containing all poisons
-- buttons refactored
-- set hideequip true/false - left equip bar shows on mouseover
-- clairvoyance will now show the room number viewed and zone name (if available)
-- spell buttons / cast script refactored
-- map window resized
-- changes to casting code
-- xp train starts fights with bodyslam (if ogre)
-- added most spells for all classes
-- pets/undead/mounts added to grouplist / displayed on screen
-- Change from necro to lich in wholist if needed
-- bugfixes
-- Map updated: full size 317 areas 44822 rooms

-- 011a

-- set echodrag true - gsay if a corpse is dragged into your room
-- rot/rain of blood buttons added
-- added tms to vote link
-- cleric: autorealm - keep the entire group realm'd
-- more xp train updates
-- kick enabled kicks mobs after you bash them
-- heal/harm buttons have been redone
-- bash changes to mounted charge after mounting
-- summount mount changes to mount/dismount button after summoning
-- refactored gui buttons
-- type prac, then 'scribeall' to scribe all spells
-- type prac, then 'pracall' to practice all skills
-- scripted: magic missile, earth darts, totem darts, shadow bolt
-- can't cast when paralyzed
-- 'scan' will attempt to solve for unknown map locations
-- half orcs will now use furious assault
-- rogue: assassinate timer
-- illusionist, druid, elementalist, invoker, paladin, anti, ranger, rogue added
-- changed #cd to disable rescue
-- bugfix: casting after gsay of 'moving'
-- Map updated: full size 314 areas 44262 rooms

-- 010

-- refactored and fixed gui sizing
-- set sound on|off|limited - limited plays sounds from tell, petition only
-- #zone command added to list zones example: '#zone swamp'
-- earthquake changed to use non-powers
-- hs being properly distinguished for haste/hamstring
-- fixed mapper not updating properly on dragon autoreturn
-- mapper fixed for passing through magically darkened rooms
-- autotank will not fire if less then 75% hp
-- more sounds!
-- pet rescue button added
-- sounds added for group members getting killed/ressurected 
-- set autohuw - enable/disable casting of holy/unholy word
-- buff:get function changed
-- change bid script to distinguish/display/match capital letters, hyphens
-- icy bash now recognized for success/failure
-- bless button for bard changed to cast harmonious blessing whenever needed
-- set forcerenew - bard will sing renew even at full psp
-- send stand before assist if memorizing
-- stand trigger: In your haste to slam people around, you slip and fall!
-- Get off your knees! added to stand triggers
-- disruption burst added to clerics
-- consent will be provided to anyone that asks
-- Map updated: full size 313 areas 44229 rooms

-- 010rc2

-- another shaman casting groupheal clears blind properly
-- escape working properly for rogues
-- #backup restore updates highlighted buttons
-- Map updated: full size 311 areas 43864 rooms
-- No more split maps - only toril.map used now
-- update map for movement when dragging corpses
-- enchanter will cast prismatic spray
-- clerics will cast holy/unholy word
-- bottom left corner counter changed to show stun
-- set vit nopriest - exclude cleric, shaman, druid from vit
-- fixed inittrain in silverymoon
-- local spell count is updated when casting begins (powerAliases)
-- set wuss charname - this character will be rescued and enchanter spelled regardless of settings
-- groupheal scripted for shaman
-- casting is now autocast on/off
-- set grpfontsize to change font used if &gt; 2 in group
-- 'spells' button changed to cast various spells while enabled (on/off)
-- spellcast/command queue refactored
-- set autores true - res any grouped (consented) corpses present in room
-- cdaura now part of autoheal
-- autoflee is temporarily disabled after 3 failed attempts in the same room
-- set swedish true/false - translate ooc/acc/etc to swedish
-- bugfix: autoflee/mem with caster train
-- set autoquake true - quake certain mobs if seen standing
-- queue cure blind as needed, clear cb from queue on groupheal
-- set autocb true - auto cast cure blind
-- autoenter portal/rift/gate if more people have entered it then grouped warriors
-- special entrances/exits working on map
-- various refactors

-- 010rc1

-- Map updates: full size 289 areas 42082 rooms
-- xp train fixed for an emerald and ruby encrusted dagger
-- xp train fixed for an onyx dagger with a pulsing ruby hilt
-- added bot warning to xp train
-- added hell hound to mounts list
-- shift alias changed to use powers relocate
-- triggers changed from mem autostand
-- casting now echoes the name of the spell being cast
-- autovit - vit after every mem
-- improved #clist
-- display position is now forced true
-- brief mode no longer required to be used with the mapper
-- set style to change css style of buttons
-- fixed autopen door names with newer map format
-- #cd delay changed to 5 sec for casting purposes

-- 010e

-- The script is now running with Mudlet release 30 pr308 of mudlet (compiled)
-- windows: https://github.com/Nyyrazzilyss/NyyLIB/raw/master/mudlet_w32_pr308.zip
-- osx: https://github.com/Nyyrazzilyss/NyyLIB/raw/master/Mudlet.app.zip

-- It should still work with -delta, though attempting to use the full Toril map will be SLOW
-- Map updates are no longer occuring to the individual mapsfiles, only to the toril.map file

-- THE BELOW STEPS SHOULD NOT BE EVEN ATTEMPTED ON MUDLET 3.0-DELTA - ONLY PR308

-- map has been combined into a single mapfile - to switch to using it, type #map toril
-- type #map update after the first time switching to the toril map to update with previously saved map progress

-- Map updates: Full size 254 areas 37958 rooms

-- bugfix: mem'ing darkness won't give illithid messages
-- the script will force restarting now after installation
-- scaleskin button only shown for yuan-ti
-- heal button for clerics will que healing aura on warriors when casting
-- petitions are placed on the 'tells/all' communication tab
-- added labels on map to zone edges

-- 010d

-- Map: Clouds, Ethereal Plane
-- character change after camping fixed
-- Baldurs Gate map fixed (dire raider guildhall)
-- #path command will now provide reverse paths from current room
-- Map: Dragonspear Castle
-- updates to Skullport map
-- Map: Tower of the Elementalist, Keep of Finn McCumhail
-- bidscript won't allow bids with mutiple possible matches
-- set chatfontsize fixed
-- 'starttrain tank' to start as head, regardless of not being warrior class
-- mesh manacle will proc at 70% hp
-- volance will proc at 60% hp
-- warder cloak will proc at 30% hp
-- supple girdle, tiamat sleeves will proc at 25% hp
-- bard singing renew by choice will switch to heal at maxpsp
-- maps: Lizard Marsh, Fire Giants Lair
-- centralized debug messages - set condensed debug
-- groupList:whoTanking() - table with how many mobs are on each character
-- #clist list chars now from both katumi database and local cache
-- prompt variables are now located in a prompt:get function
-- fixed condensed duplicate with signs
-- dire raiders
-- starttrain now checks area, and runs different paths for ashstone/silverymoon
-- prime.map split into prime1, prime2. type '#map split'
-- alias: cast - start casting (same as spells button)
-- added maps: Icecrag 2, Hulburg, the Temple of Twisted Flesh, Skerttd-Gul, Mistywood                                      
-- alternate button for check status: group
-- some buttons converted to nesting labels
-- even more cleric stuff
-- more refactors
-- bugfixes

-- 010c

-- set numcolor color to change number colors from the default blue
-- set pokehaste true/false to cast haste when poked
-- set gcmd true/false to use gcmd for gsay
-- some more cleric stuff
-- more refactors
-- bugfixes

-- 010b

-- Map updates: Ashstone, Nightwood, Splitshield
-- aliases: guide, forum, quest open browsers to the newbie guide, torilmud forums, and vb quest website
-- tabs will now be drawn properly (primarily visible in trophy, attributes &lt; level 20)
-- directions bound to keypad: 7=u 8=n 9=d 4=w 5=s 6=e
-- problem with saving map files fixed
-- 'send command' will insert a command into spell queue for immediate execution

-- 010a

-- major refactoring
-- 'resettrain' will disable all train triggers if ended incorrectly
-- added 'starttrain' triggers for casters
-- some cleric icons
-- tweaked valhalla icon
-- #fwalk all - list all fwalks regardless of area
-- the set command rewritten
-- Map updates: Muspelhiem 
-- various changes to add ansi
-- group commands sent by the script itself will be gagged
-- clicking the memorize/pray button will stand if currently mem'ing
-- memorize/pray button now show countdown for remaining spells
-- Updated caster buttons - counters for memorized spells
-- New buttons: bracers of time, warmaul, ocular disc
-- updates to mudlet condensed mode
-- some shaman triggers

-- 009 (final)

-- bugfixes

-- 009rc2

-- misc bugfixes/code cleanup
-- set group true|false - use redesigned group display

-- 009rc1

-- stats tracking added to 'group' command
-- #help astral - zone directions
-- #backup logs - copies contents of profile log files into backup folder
-- map density increased to maximum
-- set border default|none|file - changes the background image used (.png file)
-- added condensed modes - set condensed {dragon|combat|spells|items|arrows|misc|duplicate}
-- various map fixes
-- various bugfixes
-- maps added: The Lurkwood

-- 009d

-- misc bugfixes
-- fwalk/doubleclicking on map room to speedwalk will no longer send a 'stand' command (it breaks hide)
-- path corrected for #backup on osx/linux
-- fwalk will no longer run if path is longer then 100 rooms
-- maps added: Basin Wastes
-- maps fixed: Magma


-- 009c

-- #backup command added: type #backup for more information
-- misc bug fixes
-- permenantly 'locked' rooms flagged in maps - speedwalks will never pass through these rooms
-- #path now provides room path split at 50 rooms
-- #path now works with #fwalk names
-- update map on doorbash
-- maps added: Dark Forest, Orcish Halls of Plunder
-- maps fixed: CPV, Twisted Rune, Roads of the Heartland 1/2, VB Guildhall, UM2


-- 009b

-- map will update properly when tracking
-- Abreviations when loading maps: ud=underdark, em=evermeet
-- enlarge option added to enchanter resize button
-- some (most) buttons recoloured
-- more map updates (Ice, Faerie Realms, Seelie Faerie Court)
-- character profilenames will be updated from more sources
-- #stats - warrior statistics
-- #save - save chardata, loaded map
-- es[dir][b/c/p] - p=powers backstab
-- added room name to #room window
-- prompt won't be echoed to chat/room window if the mud doesn't send newline

-- 009a

-- map density increased 16x
-- Type #room to show/hide room capture window
-- #cd [dir] - countdown script - attacks targetname from #attack command, if none does hitall
-- #fwalk now shows length in rooms to destination, only shows destinations reachable from current location
-- es[dir][b/c] - escape direction, return, and backstab/circle targetname from #attack (example: eswb, esnc) 
-- #at[dir] (example #atn, #ats, etc) - move direction and backstab target
-- #attack targetname - set targetname variable
-- gui has been changed around

-- 008 (final)

-- Faang, Darktree moved to Underdark map
-- Added maps: Various Moonshaes - Added to 'evermeet' map
-- Added maps: Conqured Village, Baphomet
-- Room colours added
-- #fwalk results sorted by area
-- #path command to display path/length to room number

-- 008rc3

-- Added maps: Drulak, Plane of Fire 1&amp;2, Water, Yggdrasil
-- #afind pattern - find discovered rooms matching pattern in current area
-- #map update - update loaded map without resetting unlocked rooms
-- #fwalk shows area rooms are located in

-- 008rc2

-- Katumi database updated 2015/10/10
-- To help with map related slowdowns, it has been split to multiple files: scardale, prime, underdark, evermeet, planes
-- example: type: '#map scardale' to switch to Scardale map (Scardale map also includes Waterdeep)
-- 'set autoopen false' to disable opening doors
-- Doors added to map, and moving/fwalk through them will attempt to open first
-- misc updates to mapper
-- Added Maps: Temple of Dumathoin, Lair of the Deep Dragon, Yath Olath, more!
-- Added maps: Evermeet Bay, Manscorpions, Seer Kings, Ixarkon Prison, Githyanki, Choking Palace, Twisted Rune

-- 008rc1

-- sm xp train - type 'inittrain' in Silverymoon to setup map.
--    (note this will run several minutes, and look like it's frozen), starttrain, stoptrain
-- #help command

-- 008g

-- #fwalk information now profile specific, not stored by character.
-- set vnum true/false - display room vnum after exits
-- tank rescue will occur at ph/awful, if self &gt; .30 maxhp
-- bash corrected if not warrior
-- Added maps: Imphras Guildhall, Trollbark Forest, Spiderhaunt, Thunderhead Peak, Earth Plane

-- 008f

-- major improvements to keeping map in sync
-- alias: fwalk changed to #fwalk, new command structure
--    #fwalk  - instructions, list of existing fwalks
--     #fwalk roomnumber - fastwalk to specific room number
--    #fwalk name - fastwalk to room indicated by previously added name
--    #fwalk add name - adds a fastwalk using 'name' to the currently occupied room
--    #fwalk del name - deletes fastwalk 'name'
-- profile names are displayed after character names on 'group'
-- Added maps: The Evermoors, Undermountain 1&amp;2, The Underdark Trade Route, The Underworld, Nizari, Labyrinth of No Return, The Spirit Raven (Pirate Ship), Calimsham Desert, 
-- misc bugfixes

-- 008e

-- 3 choices now on enchanter globe: off, hitters, or all (hitters+warriors)
-- alias: #find - findroom merged with this alias, type #find to locate current position/or #find roomname
--  #find * - list all discovered rooms
-- autoroller: 
--    mighty=1 heroic=2 perfect=3
--    mighty heroic heroic perfect = 1 + 2 + 2 + 3 = 8
--  set autoroll 8    - stop on rolls &gt;= 8
--  alias: #roll - start autoroller
-- alias: map - updated, type 'map' for more information
-- alias: castspells - same as clicking spells button
-- alias: #id itemname - identify matching items
-- alias: dep - deposit all coins held or inside main storage container to the bank
-- disarm button added
-- More maps: New Cavecity, Klauthen Vale, The Shadow Swamp, The Swamps of Meilech, Darklake, Tunnel of Dread
-- size, buffs removed on death
-- more fixes to mapper to locate rooms / keep in sync
-- warrior will auto rescue other warriors if awful/ph/nasty and &gt;400hp
-- alias: #clist charname - list all known characters for that char's profile
-- alias: #gall charname - gag all characters for that char's profile
-- when examining containers, potions, scrolls will be identified on screen
-- alias: #statitems gsay - echo glist stats to gsay
-- alias: #statitems - echo glist stats to screen
-- katumi database incorporated
-- bid script: type 'bid help' for commands
-- rm (rescue me) alias changed to 'rme' not to conflict with righteous might
-- update map on escape

-- 008d

-- #gag/#ungag commands
-- enchanter: swapts alias - switch ds and ts in memorized spells
-- size button for enchanter: reduce halfing/gnome casters, enlarge ogre warriors
-- players added to onscreen group if not present and they gsay
-- set autotank true/false
-- set powersbash true/false
-- set valhalla defend/berserk
-- no more rescuing paladins/antipaladins in basic rescue mode

-- 008c

-- added some more documentation
-- mapper updates
-- 16765 rooms / 91 areas now included

-- 008b

-- All rooms are now hidden on the map until you have discovered it
-- find now checks for matching room name + exits

-- 008a - The mapper!

-- addarea - by itself for available areas, with an area number to add a blank map for the area
-- fwalk roomid - Fastwalk to roomid
-- findroom name - Search entire map for matching rooms
-- find - set your location on the map (Only Silverymoon, Scardale, Vipertounge, Western Realms at this time)
-- map load/save - to save your own map
-- map on/off - turn map display on or off

-- 007

--  Final release of 007 series

--007rc4b, 007rc4c

-- bugfix

-- 007rc4

-- added 'escape direction' for all classes
-- show body size
-- kill people if they're charmed
-- gsay on size change, consent
-- added feeblemind to group display
-- updated fastwalks (mostly wd area)

-- 007rc3

-- fwalk now includes reversed fastwalks
-- skill improvement capture window
-- bugfixes, mostly for warrior - rescue seems to work now

-- 007rc2

-- auto assist and rescue improved
-- bugfixes

-- 007h

-- meditate/stand button for psi
-- generic spells button for all script-less casters
--    set masscast powersname to spell name for it to cast
-- equip procs: bane
-- set automem (start memorizing if the majority of the group does)
-- fly now an option on endspell
-- added para, blind, silent to group display
-- on screen xp counter (until level 50)
-- misc bugfixes

-- 007g

-- song of miscast magic added (commandline only)
-- misc bug fixes

-- 007f

-- shaman now has functioning generic spells button
--   set masscast powersname to spell name for it to cast
-- added 'pwt' to endspell options
-- internal buff lengths update based on powers info / sf enc
-- added 'version' command
-- regen song button in place of heal song for lower level bard
-- mem on bard/battlechanter now handled properly
-- add people to grouplist if they gsay
-- some work done with rescue
-- updated fastwalks
-- disabled spellguard kill trigger
-- bugfix on adding to who database

-- 007e

-- self will be autoadded to wholist on initial login
-- improved autoassist
-- deathfield button for unquested psi
-- updated fastwalks
-- added rescue/bash/kick (such that they are) from War to Pal, A-P, Ran, Dir
-- some basic instructions added (type 'client' to read them)

-- 007d

-- set endspell (vit, dsp) - change the final spell displayed in group window
-- marking dead is now done by the new death message
-- updated buttons (sleeves, sandals, loop, grin)
-- set assocchar (charname) - connect to association chat on login
-- spellout messages are now changeable
-- minimum level now on button creation
-- fwalk alias for fastwalks</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>ClassScripts</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>ClassHeader</name>
					<packageName></packageName>
					<script>buttonText = buttonText or {}

powersTable = powersTable or {}
-- alias = { fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powerAliases= powerAliases or {}

-- automissile: circle 1-6 single target
-- autoarea: circle 1-6 area
-- autohlmissle: circle7+ single target
-- autohlarea: circle 7+ area

-- Spellcast selection priority occurs by position of the spell in the table for the class.
-- The script starts at the end of the table, and works backwords until it hits a spell to cast.
-- To increase the priority of a spell being cast, move it down in the table.

--TODO: add field (true/false) re: spell count (auto-recharge circles don't have spell counts)
-- add field: effect (damage, heal, cure blind, resistance, supervit)


-- spell full name, alias, level, charData, ???

meleePowers = meleePowers or {}

-- alias={ full name, level, weapontype, buttonnumber, chardata}

-- TODO: change charData entry to be generated / Class+Alias example: 'blksp'
-- Eventually entry could be automatic
-- generation should work button 20-&gt;1, first valid hit starting from end - pairs list=random?
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SingerScript</name>
					<packageName></packageName>
					<script>
-- bard/battlechanter

--buttonText{"barBless" = {"Bless"} }
--buttonText{"StopMusic" = {"Stop|Music"} )
--buttonText{"RegenSong = {"Regen"},
--HealSong = {"Heal"},
--HasteSong = {"Haste"},
--SlowSong = {"Slow"},
--HarmSong = {"Harm"},
--RenewSong = {"Renew"},
--ProtectSong = {"Protect"},
--TravelSong = { "Travel"},
--Accompany = {"Accompany"},

-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }


-- spell full name, alias, level, charData, ???
powerAliases["Bar"] =
            {
{ "minor_creation", "minor", 6, "", false},
{ "detect_magic", "dm", 6, "", false},
{ "detect_invisibility", "di", 6, "", false},
{ "phantom_armor", "pa", 16, "", false},
{ "invisibility", "invis", 16, "", false},
{ "faerie_fire", "ff", 16, "autoffire", false, "Faerie_Fire"},
{ "ray_of_enfeeblement", "ray", 26, "", false},
{ "levitate", "lv", 26, "", false},
{ "harmonious_blessing", "hbl", 36, "", false, "Bless"},
{ "feeblemind", "feeb", 36, "", false},
{ "dispel_magic", "dism", 36, "", false},
{ "sonic_wave", "sw", 46, "", false},
{ "displacement", "ds", 46, "", false},
            }

powerAliases["Ctr"] =
            {
{ "minor_creation", "minor", 6, "", false},
{ "detect_magic", "dm", 6, "", false},
{ "detect_invisibility", "di", 6, "", false},
{ "phantom_armor", "pa", 16, "", false},
{ "invisibility", "invis", 16, "", false},
{ "faerie_fire", "ff", 16, "autoffire", false, "Faerie_Fire"},
{ "ray_of_enfeeblement", "ray", 26, "", false},
{ "levitate", "lv", 26, "", false},
{ "harmonious_blessing", "hbl", 36, "", false, "Bless"},
{ "feeblemind", "feeb", 36, "", false},
{ "dispel_magic", "dism", 36, "", false},
{ "sonic_wave", "sw", 46, "", false},
{ "displacement", "ds", 46, "", false},
            }

function initCtr()
  initBar()
end

function initBar()
  setSpellCount("harmonious_blessing", 3)

  charData:init("song", "")
  charData:init("_song", "")
  charData:init("effect", "")
  charData:init("_wield", 0)

  charData:init("currentInstrumentType", "")

  NyyLIB.songtimer = ""
  NyyLIB.accompany = 0

  addbutton("barBless", 0, 1, 36)
  addbutton("StopMusic", 0, 2, 0)

  if charData:get("level") &gt;= 31 then
    addbutton("HealSong", 0, 3, 31)
  else
    addbutton("RegenSong", 0, 3, 1)
  end

  addbutton("HasteSong", 0, 4, 11)
  addbutton("SlowSong", 0, 5, 11)
  addbutton("HarmSong", 0, 6, 41)
  addbutton("RenewSong",0, 7, 11)
  addbutton("ProtectSong", 0, 8, 1)
  addbutton("TravelSong", 0, 9, 31)
  addbutton("Accompany", 0, 10, 20)

  addbutton("circle",0, 11, 22)
end

function resetSongs()

  if charData:get("level") &gt;= 31 then
    HealSong("HealSong", buttons.INIT)
  else
    RegenSong("RegenSong", buttons.INIT)
  end

  HasteSong("HasteSong", buttons.INIT)
  SlowSong("SlowSong", buttons.INIT)
  HarmSong("HarmSong", buttons.INIT)
  RenewSong("RenewSong", buttons.INIT)
  ProtectSong("ProtectSong", buttons.INIT)
  TravelSong("TravelSong", buttons.INIT)
end

function barBless(fname, xcommand)
  if xcommand ~= buttons.INIT then
    shiftSkillButton("barBless", "autobless", xcommand)
  end

  if charData:get("autobless") then
    setLabelImage(fname, fname .. "-on.png")
  else
    setLabelImage(fname, fname .. "-off.png")
  end
end

function StopMusic(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "stopmusic.png")
  else
    mud:send("stopmusic")
  end
end

function HealSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barHeal-off.png")
  else
    mud:send("heal")
  end
end

function RegenSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barRegen-off.png")
  else
    mud:send("regen")
  end
end

function HasteSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barHaste-off.png")
  else
    mud:send("haste")
  end
end

function RenewSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barRenew-off.png")
  else
    mud:send("renew")
  end
end

function HarmSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barHarm-off.png")
  else
    mud:send("harm")
  end
end

function SlowSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barSlow-off.png")
  else
    mud:send("slow")
  end
end

function TravelSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barTravel-off.png")
  else
    mud:send("travel")
  end
end

function ProtectSong(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barProtect-off.png")
  else
    mud:send("prot")
  end
end

function Accompany(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "barAccompany-off.png")
  else
    mud:send("accompany")
  end
end

-- xinstrumentType= (lute, piccolo, trumpet, drum, harp, mandolin)
-- xsong= name of song to play
-- xtarget= target

function music(xinstrumentType, xsong, xtarget)
  if checkMask("singer") == false then
    return
  end

  switchInstrument=true
  
  newInstrumentType = xinstrumentType
  
  switch()
  
  charData:set("song", xsong)
  charData:set("effect", xtarget)
  
  playsong()
  
  switchInstrument=nil
end

function playsong()
 local song=charData:get("song")
 local effect=charData:get("effect")

 if song ~= "" then
   if effect == "" then
     mud:send("sing '" .. song .. "'")
   else
     mud:send("sing '" .. song .. "' " .. effect )
   end
 end
end

function switch()
  local gigbag=charData:get("gigbag")

  -- a song is currently being played
  if charData:get("song") ~= "" then
    mud:send("play")
  end

  if charData:get("_wield") ~= 1 then
    local currentInstrumentName = charData:get( charData:get("currentInstrumentType") ) or ""
    local newInstrumentName = charData:get(newInstrumentType) or ""

    -- flamekissed item proc
     if currentInstrumentName == "flamekissed" and newInstrumentName == "flamekissed" then
      if newInstrumentType == "piccolo" then
        mud:send("say candledance")
      elseif newInstrumentType == "drum" then
        mud:send("say bonfires alight")
      elseif newInstrumentType == "lute" then
        mud:send("say searing harmony")
      elseif newInstrumentType == "horn" then
        mud:send("say inferno dance")
      elseif newInstrumentType == "harp" then
        mud:send("say flame medley")
      end
      
      return
    end
  
    -- switch instruments
    if charData:get("currentInstrumentType") ~= newInstrumentType then
      if charData:get("currentInstrumentType") ~= '""' then
         if currentInstrumentName ~= "" then
          mud:send("rem " .. currentInstrumentName)

           if gigbag ~= '""' then
             mud:send("put " .. currentInstrumentName .. " " .. gigbag )
          end
         end
        
        charData:set("currentInstrumentType", "")
       end

      if newInstrumentType ~= '""' then
        if gigbag ~= '""' then
          mud:send("get " .. newInstrumentName .. " " .. gigbag )
         end
      end

      charData:set("currentInstrumentType", newInstrumentType )

      if newInstrumentType ~= '""' then
        mud:send("hold " .. newInstrumentName )
      end
    end
   end
end

function tr_renew()
  music("piccolo", "song of renewal", "")
end

-- this function will be called on all mud prompts
function SingerScript(event)
  if checkMask("singer") then

    -- cast harmonious blessing if down and not moving
    if charData:get("autobless") then
      if not buff:get("harmonious_blessing") then
        if getSpellCount("harmonious_blessing") &gt; 0 then
          if not spell:getMoving() then
            spell:cast("hbl")
          end
        end
      end
    end

    if prompt:get("psp") == prompt:get("maxpsp") and not switchInstrument and not charData:get("forcerenew") then
      if charData:get("_song") ~= charData:get("song") then
        if charData:get("_song") ~= ""  and charData:get("song") ~= "" then
          cecho("&lt;red&gt;\n[Max mana : switching songs]\n")
          if charData:get("_song") == "song of harming" or charData:get("_song") == "song of offensive disruption" then
            music(charData:get("_instrument"), charData:get("_song"), charData:get("effect") )
          else
            music(charData:get("_instrument"), charData:get("_song"), "")
          end
        elseif charData:get("_song") == "" and charData:get("song") == "song of renewal" then
          --  if max psp and singing renew switch to heal (or regen)

          if charData:get("level") &gt;= 31 then
            cecho("&lt;red&gt;\n[Max mana : switching songs to heal]\n")
            music("lute", "song of healing", "")
          else
            cecho("&lt;red&gt;\n[Max mana : switching songs to regen]\n")
            music("lute", "song of regeneration", "")
          end
        end
      end
    end
  end
end</script>
					<eventHandlerList>
						<string>promptEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PsiScript</name>
					<packageName></packageName>
					<script>
powerAliases["Psi"] = { }

function initPsi()
  charData:init("autohide", false)

  spell:setMem(false)

  addbutton("MemButton", 0, 1, 0)

  if charData:get("ultraquested") ~= nil then
    addbutton("ultrablast", 0, 2, 47)
  else
    addbutton("deathfield", 0, 2, 20)
  end

  addbutton("battletrance", 0, 3, 45)
  addbutton("tower", 0, 4, 37)
  addbutton("combatmind", 0, 5, 0)
  addbutton("psidarkness", 0, 6, 35)
  addbutton("wormhole", 0, 7, 46)
end

function wormhole(fname, xcommand)
  shiftSkillButton("wormhole", "wormhole", xcommand)
end

function psidarkness(fname, xcommand)
  if xcommand ~= buttons.INIT then
    if charData:get("autohide") then
      charData:set("autohide", false)
      cecho("\n&lt;red&gt;Some illithids choose not to hide.\n")
    else
      charData:set("autohide", true)
      cecho("\n&lt;green&gt;A cautious illithid brings up darkness to hide after fleeing.\n")
    end
  end

  if charData:get("autohide") then
    setLabelImage(fname, "darkness-on.png")
  else
    setLabelImage(fname, "darkness-off.png")
  end
end

function tower(fname, xcommand)
  if xcommand ~= buttons.INIT then
    if charData:get("autotower") then
      charData:set("autotower", false)
    else
      charData:set("autotower", true)
      mud:send("tower me")
      NyyLIB.psilag="tower"
    end
  end

  if charData:get("autotower") then
    setLabelImage(fname, fname .. "-on.png")
  else
    setLabelImage(fname, fname .. "-off.png")
  end
end

function combatmind(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, fname .. "-off.png")
  else
    local cmblist = {}

    for k,char in pairs(groupList:pc("hitterSinger")) do
      if not buff:get("combatmind", char) then
        -- verify in room
        if groupList:getHP(char) ~= 0 and not table.contains(NyyLIB.deadpeople, char) then
          mud:send("combatm " .. char)
          NyyLIB.psilag="combatmb"
          break
        end
      end
    end
  end
end

function dropcombatmind()
  setLabelImage("combatmind", "combatmind-off.png")
end

function battletrance(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, fname .. "-off.png")
  else
    mud:send("battletr")
  end
end

function ultrablast(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, fname .. "-off.png")
  else
    if NyyLIB.psilag == "none" then
      setLabelImage(fname, fname .. "-on.png")
      mud:send("ultra")
      NyyLIB.psilag="ultra"
    end
  end
end

function deathfield(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, fname .. "-off.png")
  else
    if NyyLIB.psilag == "none" then
      setLabelImage(fname, fname .. "-on.png")
      mud:send("deathfield")
      NyyLIB.psilag="death"
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EncScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

-- note: globe blocks 1-6, needs to be 7+

powersTable["Enc"] = powersTable["Enc"] or {}
powersTable["Enc"][""] =
            {
  {"mf", "mage_flame", nil, "", nil, 1, 1},
  {"erase", "erase", nil, "", nil, 1, 1},
  {"dm", "detect_magic", nil, "", nil, 1, 1},
  {"di", "detect_invisibility", nil, "", nil, 1, 1},
  {"minor", "minor_creation", nil, "", nil, 6, 1},
  {"invis", "invisibility", nil, "", nil, 6, 1},
  {"ff", "faerie_fire", "Faerie|Fire", "autoffire", nil, 6, 1},
  {"es", "energy_shield", nil, "", nil, 6, 1},
  {"ct", "chill_touch", "Chill|Touch", "automissile", nil, 6, 1},
  {"bh", "burning_hands", "Burning|Hands", "automissile", nil, 6, 1},
  {"str", "strength", nil, "", nil, 11, 1},
  {"ray", "ray_of_enfeeblement", "Enfeeble", "", nil, 11, 1},
  {"ms", "missile_shield", nil, "", nil, 11, 1},
  {"loco", "locate_object", nil, "", nil, 11, 1},
  {"disi", "dispel_invisible", nil, "", nil, 11, 1},
  {"dex", "dexterity", nil, "", nil, 11, 1},
  {"co", "chromatic_orb", "Chromatic|Orb", "automissile", nil, 11, 1},
  {"bk", "blink", nil, "", nil, 11, 1},
  {"weye", "wizard_eye", nil, "", nil, 16, 1},
  {"tele", "teleport", nil, "", nil, 16, 1},
  {"slp", "sleep", nil, "", nil, 16, 1},
  {"minp", "minor_paralysis", nil, "", nil, 16, 1},
  {"massi", "mass_invisibility", nil, "", nil, 16, 1},
  {"lb", "lightning_bolt", "Lightning|Bolt", "automissile", nil, 16, 1},
  {"lv", "levitate", nil, "", nil, 16, 1},
  {"hs", "haste", nil, "", nil, 16, 1},
  {"fmb", "fumble", nil, "", nil, 16, 1},
  {"fs", "farsee", nil, "", nil, 16, 1},
  {"dism", "dispel_magic", nil, "", nil, 16, 1},
  {"stm", "stumble", nil, "", nil, 21, 1},
  {"ss", "stoneskin", nil, "autostone", nil, 21, 1},
  {"slow", "slowness", nil, "", nil, 21, 1},
  {"mgi", "minor_globe_of_invulnerability", nil, "", nil, 21, 1},
  {"iv", "infravision", nil, "", nil, 21, 1},
  {"fsh", "fireshield", nil, "", nil, 21, 1},
  {"dim", "dimension_door", nil, "", nil, 21, 1},
  {"csh", "coldshield", nil, "", nil, 21, 1},
  {"chp", "charm_person", nil, "", nil, 21, 1},
  {"id", "identify", nil, "", nil, 26, 1},
  {"fbl", "fireball", "Fireball", "autoarea", nil, 26, 1},
  {"feeb", "feeblemind", nil, "", nil, 26, 1},
  {"env", "enervate", nil, "", nil, 26, 1},
  {"enchw", "enchant_weapon", nil, "", nil, 26, 1},
  {"cone", "cone_of_cold", "Cone Of|Cold", "autoarea", nil, 26, 1},
  {"clv", "clairvoyance", nil, "", nil, 26, 1},
  {"bl", "blur", "Blur", "autoblur", nil, 26, 1},
  {"mg", "magic_missile", "Magic|Missile", "automissile", nil, 1, 1},
  {"ns", "needle_swarm", "Needle|Swarm", "automissile", nil, 26, 1},
  {"sfog", "solid_fog", nil, "", nil, 31, 1},
  {"rps", "repulsion", nil, "", nil, 31, 1},
  {"red", "reduce", nil, "", nil, 31, 1},
  {"pwb", "power_word_blind", nil, "", nil, 31, 1},
  {"fly", "fly", nil, "", nil, 31, 1},
  {"enl", "enlarge", nil, "", nil, 31, 1},
  {"cn", "constriction", "Cnstrctn", "autohlmissile", nil, 41, 1},
  {"mp", "major_paralysis", nil, "", nil, 36, 1},
  {"gi", "globe_of_invulnerability", nil, "autoglobe", nil, 36, 1},
  {"bb", "blacklight_burst", "Blacklight|Burst", "autohlarea", nil, 36, 1},
  {"ps", "prismatic_spray", "Prismatic|Spray", "autohlarea", nil, 31, 1},
  {"airy", "airy_water", nil, "", nil, 36, 1},
  {"brc", "breach", nil, "", nil, 41, 1},
  {"grf", "aura_of_the_griffon", nil, "", nil, 46, 1},
  {"relo", "relocate", nil, "", nil, 41, 1},
  {"mb", "mind_blank", nil, "", nil, 41, 1},
  {"gate", "gate", nil, "", nil, 41, 1},
  {"ts", "time_stop", "Time Stop", "autots", nil, 46, 1},
  {"ds", "dragonscales", "Dragon|Scales", "autoscale", nil, 46, 1}
            }


function initEnc()
  addbutton("stoneskin", 0, 7, 21)
  addbutton("dragonscales", 0, 8, 46)
  addbutton("blur", 0, 9, 26)
--  addbutton("haste",10, 16)
  addbutton("globe_of_invulnerability", 0, 10, 36)

  addbutton("time_stop", 0, 11, 46)

--  addbutton("encBard",11, 0)

  addbutton("encSelf", 0, 12, 0)
  addbutton("encResize", 0, 13, 0)

  powerAliases:addButtons()
  
  --mud:send("powers info time stop")
  --mud:send("powers info blur")
  --mud:send("powers info globe")
end

function SpellsEnc()

  -- if blind, no casting
  -- will need to be altered for area offensives
  if   buff:get("blind") or buff:get("blindness") then
    return
  end

  -- bring up timestop if not fighting

  if charData:get("autots") then
    if not inCombat() and assistSent == nil then
      if not buff:get("time_stop") then
        if getSpellCount("time_stop") &gt; 0 then
          spell:cast("ts")
          return
        end
      end
    end
  end

  -- check tank for needed spells

  if scr_tank() then
    return
  end

  if   scr_globe() then
    return
  end

  if   scr_scale() then
    return
  end

  -- blur group members

  if   scr_blur() then
    return
  end

  if   scr_stoneskin() then
    return
  end

  -- stoneskin

  if   scr_stoneskin() then
    return
  end

  -- enlarge or reduce group members

  if   scr_resize() then
    return
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end

  -- if fighting and no other spells - fire bolt
  if charData:get("automissile") then
    if inCombat() and spell:count() == 0 then
      spell:cast("fb")
    end
  end
end  

function time_stop(fname, xcommand)
  local current=buff:get("time_stop")

  if xcommand == buttons.UPDATE then
    if not current then
      updateButton(fname)
    end

    return
  end

  if xcommand ~= buttons.INIT then
    if charData:get("autots") then
      charData:set("autots", false)
      cecho("\n&lt;green&gt;[Time Stop will not be used.]\n")
    else
      charData:set("autots", true)
      mud:send("\n")
      cecho("\n&lt;green&gt;[Time Stop will be used.]\n")
    end
  end

  if charData:get("autots") then
    if current then
      setLabelImage(fname, "time_stop-active.png")
    else
      setLabelImage(fname, "time_stop-on.png")
    end
  else
    setLabelImage(fname, "time_stop-off.png")
  end

  if current then
    PopulateTimestop()
  else
    time_stop("time_stop", buttons.UPDATE)
  end
end

function PopulateTimestop()
  local var = buff:get("time_stop")
  local label=findlabel("time_stop")

  if var then
    label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. timedisplay(var) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])    
  else
    label:echo([[&lt;p style="font-size:14px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;   &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
  end
end

function encBard(fname, xcommand)
  shiftSkillButton("encBard", "bard", xcommand)
end

function encSelf(fname, xcommand)
  shiftSkillButton("encSelf", "self", xcommand)
end

function encResize(fname, xcommand)
  shiftSkillButton("encResize", "resize", xcommand)
end

function scr_tank()
  local tank=prompt:get("tank")

  if tank == nil or tank == "" then
    return
  end

  if charData:get("level") &gt;= 26 then
    if spell:attempt(tank, "blur", "bl") then
      return(true)
    end
  end

  if charData:get("level") &gt;= 46 then
    if spell:attempt(tank, "dragonscales", "ds") then
      return(true)
    end
  end
end

function scr_resize()
  local tmpvar = charData:get("resize")

  if tmpvar == "small" or tmpvar == "all" then
    for k,char in pairs(groupList:pc("casterSinger")) do
      if table.contains( {"Halfling", "Gnome"}, whorace(char) ) then
        if consent:get(char) then
          if spell:attempt(char, "reduce", "red") then
            return(true)
          end
        end
      end
    end
  end

  if tmpvar == "large" then
    for k,char in pairs(groupList:pc("casterSinger")) do
      if consent:get(char) then
        if spell:attempt(char, "enlarge", "enl") then
          return(true)
        end
      end
    end
  end
  
  if tmpvar == "all" then
    for k,char in pairs(groupList:pc("war")) do
      if whorace(char) == "Ogre" then
        if consent:get(char) then
          if spell:attempt(char, "enlarge", "enl") then
            return(true)
          end
        end
      end
    end
  end  
end

function scr_globe()
  if charData:get("autoglobe") == true then
    for k,char in pairs(groupList:pc()) do
      if checkMask("hitter", char ) then
        if spell:attempt(char, "globe_of_invulnerability", "gi") then
          return(true)
        end
      end

      if charData:get("bard") and checkMask("singer", char ) then
        if spell:attempt(char, "globe_of_invulnerability", "gi") then
          return(true)
        end
      end
    end

    for k,char in pairs(groupList:pc("war")) do
      if spell:attempt(char, "globe_of_invulnerability", "gi") then
        return(true)
      end
    end
  elseif charData:get("autoglobe") == "hitters" then
    for k,char in pairs(groupList:pc()) do
      if checkMask("hitter", char ) then
        if spell:attempt(char, "globe_of_invulnerability", "gi") then
          return(true)
        end
      end
    
      if whoclass(char) == "War" and whorace(char) == "Ogre" then
        if spell:attempt(char, "globe_of_invulnerability", "gi") then
          return(true)
        end
      end

      if charData:get("bard") and checkMask("singer", char ) then
        if spell:attempt(char, "globe_of_invulnerability", "gi") then
          return(true)
        end
      end
    end
  end
end

function scr_blur()
  if charData:get("autoblur") then
    for k,char in pairs(groupList:pc("casterPsiSinger")) do
      if char ~= whoami() then
        if spell:attempt(char, "blur", "bl") then
          return(true)
        end
      end
    end
  end

  for k,char in pairs(groupList:pc("warrior")) do
    if spell:attempt(char, "blur", "bl") then
      return(true)
    end
  end

  if charData:get("self") then
    if spell:attempt(whoami(), "blur", "bl") then
      return(true)
    end
  end

  
  local wuss=charData:get("wuss")

  if groupList:ingroup( wuss ) then
    if spell:attempt(wuss, "blur", "bl") then
      return(true)
    end
  end
end

function scr_scale()
  local wuss=charData:get("wuss")

  if groupList:ingroup( wuss ) then
    if spell:attempt(wuss, "dragonscales", "ds") then
      return(true)
    end
  end

  if charData:get("self") then
    if spell:attempt(whoami(), "dragonscales", "ds") then
      return(true)
    end
  end

  for k,char in pairs(groupList:pc("warrior")) do
    if spell:attempt(char, "dragonscales", "ds") then
      return(true)
    end
  end

  if charData:get("autoscale") then
    for k,char in pairs(groupList:pc("casterPsiSinger")) do
      if char ~= whoami() then
        if spell:attempt(char, "dragonscales", "ds") then
          return(true)
        end
      end
    end
  end
end

function scr_haste()
  -- placeholder
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>WarScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, 1=oldcaster 2=instacast, 3=instacast+cooldown, powertype }

powersTable["War"] = powersTable["War"] or {}
powersTable["War"][""] =
    { {"fa", "furious_assault", 1},
      
      {"bds", "bodyslam",1,nil,nil,"warbds"},

      {"wu", "warriors_ultimatum", "Warriors|Ultimatum", "warwu", nil, 30, nil, "All"},
      {"cc", "combat_challenge", "Combat|Challenge", "warcc", 12, 1, nil, "All"},

      {"cs", "comeback_strike", "Comeback|Strike", "warcs", 14, 1, nil, "Shield"},
      {"sb", "shield_bash", "Shield|Bash", "warsb", 3, 5, nil, "Shield"},
      {"ds", "defensive_strike", "Defensive|Strike", "wards", 9, 15, nil, "Shield"},
      {"bs", "brutal_strike", "Brutal|Strike", "warbs", 10, 25, nil, "Shield"},
      {"ra", "relentless_assault", "Relentless|Assault", "warra", 15, 30, nil, "Shield"},
      
      {"cv", "cleave", "Cleave", "warcv", 14, 1, nil, "TwoHand"},
      {"ss", "spinning_sweep", "Spinning|Sweep", "warss", 3, 5, nil, "TwoHand"},
      {"sk", "skullcrusher", "Skull|Crusher", "warsk", 9, 15, nil, "TwoHand"},
      {"ua", "unyielding_avalanche", "Unyieldng|Avalnche", "warua", 10, 25, nil, "TwoHand"},
      {"ros", "rain_of_steel", "Rain Of|Steel", "waros", 15, 30, nil, "TwoHand" },

      {"vip", "vigilant_protector", "Vigilant|Protector", "warvip", 11, 25, nil, "All"},
      
      {"nop", "no_opening", "No|Opening", "warnop", 5, 1, 2},
      {"ut", "unstoppable", "Un|Stoppable", "warut", 1, 10, 2},
      {"ub", "unbreakable", "Un|Breakable", "warub", 2, 5, 2},
      {"hd", "heroic_defense", "Heroic|Defiance", "warhd", nil, 20, 2},
      {"sod", "storm_of_destruction", "Storm of|Destruct", "warsod", 6, 35, 3},
      {"dsd", "diamond_shield_defense", "Diamond|Shield", "wardsd", 7, 30, 2},
      {"iw", "iron_warrior", "Iron|Warrior", "wariw", 8, 40, 2},
    }

function initWar()
  meleePowers:addButtons()
end

function procPromptWar()
  if getBashing() then
    return
  end

  -- can't cast or use powers if stunned, parad, in fugue, etc
  if not spell:castOK() then
    return
  end

  -- blinded. venom (heroic defiance to heal)

  if buff:get("blind") or buff:get("blindness") or buff:get("venom") then
    useMeleePower("hd", true)
    return
  end

  -- melee powers

  -- taunts : need to change usage - should be after spells, not before

  if meleePowers:use("cc") then return end -- combat challenge

  -- 1h/shield melee powers
  if equip:getWeapon() == "Shield" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then

       -- storm of destruction
  
       if charData:get("warsod") then
          if timer:get("storm_of_destruction") == nil then
            useMeleePower("sod") -- added cooldown to sod
          end
       end

        if meleePowers:use("sb") then return end -- shield bash
      end
    end

    if meleePowers:use("ds") then return end -- defensive strike
    if meleePowers:use("cs") then return end -- comeback strike
    if meleePowers:use("ra") then return end -- relentless assault
    if meleePowers:use("bs") then return end -- brutal strike
  end

  -- 2h powers
  if equip:getWeapon() == "TwoHand" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then

       -- storm of destruction
  
       if charData:get("warsod") then
          if timer:get("storm_of_destruction") == nil then
            useMeleePower("sod") -- added cooldown to sod
          end
       end

        if meleePowers:use("ss") then return end -- spinning sweep
      end
    end

    if meleePowers:use("sk") then return end -- skullcrusher
    if meleePowers:use("ua") then return end -- unyielding avalanche
    if meleePowers:use("ros") then return end -- rain of steel
    if meleePowers:use("cv") then return end -- cleave
  end
end

-- 'SpellsWar' is the special effect warrior skills

function SpellsWar()
  local percent=prompt:get("hp%")

  -- blind, venom : heroic defiance
  if (buff:get("blind") or buff:get("blindness") or buff:get("venom") ) then
    if timer:get("heroic_defiance") == nil then
      useMeleePower("hd")
    end
    return
  end

  -- The following skills are only used in combat

  if not inCombat() then
    return
  end
  
  -- iron warrior
  
  if percent &lt; 70 then
    if charData:get("wariw") then
      if timer:get("iron_warrior") == nil then
        useMeleePower("iw")
      end
    end
  end
  
  -- warrior heal - unstoppable (ut)
  if percent &lt; 50 then
    if charData:get("warut") then
      if timer:get("unstoppable") == nil then
        useMeleePower("ut")
      end
    end
  end

  -- unbreakable
  
  if percent &lt; 80 then
    if charData:get("warub") then
      if timer:get("unbreakable") == nil then
        useMeleePower("ub")
      end
    end
  end

  -- no opening
  
  if charData:get("warnop") then
    if timer:get("no_opening") == nil then
      useMeleePower("nop")
    end
  end

  -- diamond shield defense
  
  if charData:get("wardsd") then
    if timer:get("diamond_shield_defense") == nil then
      useMeleePower("dsd")
    end
  end

  -- storm of destruction
  
  if charData:get("warsod") then
    if timer:get("storm_of_destruction") == nil then
      useMeleePower("sod") -- added cooldown to sod
    end
  end
end

function vigilant_protector(fname, xcommand)
  if xcommand == buttons.INIT then
    if charData:get("warvip") then
      setLabelImage(fname, fname .. "-on.png")
    else
      setLabelImage(fname, fname .. "-off.png")
    end
    return
  end
    
  if xcommand == buttons.CLICK then
    shiftSkillButton(fname, "warvip", xcommand)
  
    if charData:get("warvip") then
      if groupList:ingroup( charData:get("wuss") ) then
        mud:send("VIP " .. charData:get("wuss"))
      end
    else
      mud:send("VIP off")
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ShaScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Sha"] = powersTable["Sha"] or {}
powersTable["Sha"][""] =
            {   
{ "curel", "cure_light", "Cure|Light", "autoheal", nil, 1, 1},
{ "crw", "create_water", "Create|Water", "", nil, 1, 1},
{ "cfood", "create_food", "Create|Food", "", nil, 1, 1},
{ "caul", "cause_light", "Cause|Light", "autoharm", nil, 1, 1},
{ "am", "armor", nil, "", nil, 1, 1},
{ "vl", "vigorize_light", nil, "", nil, 6, 1},
{ "sk", "spiritknife", "Spirit|Knife", "automissile", nil, 6, 1},
{ "invis", "invisibility", nil, "", nil, 6, 1},
{ "dm", "detect_magic", nil, "", nil, 6, 1},
{ "di", "detect_invisibility", nil, "", nil, 6, 1},
{ "dg", "detect_good", nil, "", nil, 6, 1},
{ "de", "detect_evil", nil, "", nil, 6, 1},
{ "cs", "cure_serious", "Cure|Serious", "autoheal", nil, 6, 1},
{ "causs", "cause_serious", "Cause|Serious", "autoharm", nil, 6, 1},
{ "bls", "bless", nil, "", nil, 6, 1},
{ "word", "word_of_recall", nil, "", nil, 11, 1},
{ "vs", "vigorize_serious", nil, "", nil, 11, 1},
{ "sen", "sense_life", nil, "", nil, 11, 1},
{ "rp", "remove_poison", nil, "", nil, 11, 1},
{ "prs", "preserve", nil, "", nil, 11, 1},
{ "js", "jar_the_soul", "Jar The|Soul", "automissile", nil, 11, 1},
{ "bl", "blindness", nil, "", nil, 11, 1},
{ "vc", "vigorize_critic", nil, "", nil, 16, 1},
{ "uf", "unlease_fetish", "Unleash|Fetish", "automissle", nil, 16, 1},
{ "minp", "minor_paralysis", nil, "", nil, 16, 1},
{ "ff", "faerie_fire", "Faerie|Fire", "autoffire", nil, 16, 1},
{ "eaq", "earthquake", "Earth|Quake", "autoquake", nil, 16, 1},
{ "ccr", "cure_critic", "Cure|Serious", "autoheal", nil, 16, 1},
{ "cb", "cure_blind", nil, "", nil, 16, 1},
{ "cauc", "cause_critical", "Cause|Critical", "autoharm", nil, 16, 1},
{ "sum", "summon", nil, "", nil, 16, 1},
{ "slow", "slowness", nil, "", nil, 21, 1},
{ "remc", "remove_curse", nil, "", nil, 21, 1},
{ "rd", "raise_dead", "Raise|Dead", "", nil, 21, 1},
{ "pp", "puppet", "Puppet", "automissile", nil, 21, 1},
{ "pfl", "protection_from_lightning", nil, "", nil, 21, 1},
{ "pfd", "protection_from_good", nil, "", nil, 21, 1},
{ "pfg", "protection_from_gas", nil, "", nil, 21, 1},
{ "pff", "protection_from_fire", nil, "", nil, 21, 1},
{ "pfe", "protection_from_evil", nil, "", nil, 21, 1},
{ "pfc", "protection_from_cold", nil, "", nil, 21, 1},
{ "pfa", "protection_from_acid", nil, "", nil, 21, 1},
{ "ffog", "faerie_fog", nil, "", nil, 21, 1},
{ "comu", "command_undead", nil, "", nil, 21, 1},
{ "ss", "stoneskin", nil, "autostone", nil, 26, 1},
{ "ray", "ray_of_enfeeblement", nil, "", nil, 26, 1},
{ "hx", "hex", nil, "", nil, 26, 1},
{ "hl", "heal", "Heal", "autoheal", nil, 26, 1},
{ "fe", "fear", nil, "", nil, 26, 1},
{ "fs", "farsee", nil, "", nil, 26, 1},
{ "dism", "dispel_magic", nil, "", nil, 26, 1},
{ "cnl", "continual_light", nil, "", nil, 26, 1},
{ "td", "totem_darts", "Totem|Darts", "automissile", nil, 1, 1},
{ "vt", "vitality", "Vitality", "autovit", nil, 31, 1},
{ "stp", "soul_tempest", "Soul|Tempest", "autohlarea", nil, 31, 1},
{ "sp", "silence_person", nil, "", nil, 31, 1},
{ "mgi", "minor_globe_of_invulnerability", nil, "", nil, 31, 1},
{ "gvig", "group_vigorize", nil, "", nil, 31, 1},
{ "dkn", "darkness", nil, "", nil, 31, 1},
{ "wb", "water_breathing", nil, "", nil, 31, 1},
{ "sw", "sprit_wrack", "Spirit|Wrack", "autohlmissile", nil, 36, 1},
{ "ms", "missile_shield", nil, "", nil, 36, 1},
{ "screm", "scry_remains", nil, "", nil, 36, 1},
{ "cnw", "control_weather", nil, "", nil, 36, 1},
{ "swalk", "spirit_walk", nil, "", nil, 41, 1},
{ "psh", "plane_shift", nil, "", nil, 41, 1},
{ "afu", "ancestral_fury", "Ancestral|Fury", "autohlarea", nil, 46, 1},
{ "gh", "group_heal", "Group|Heal", "autogh", nil, 41, 1},
{ "ash", "ancestral_shield", "Ancestral|Shield", "autoashield", nil, 46, 1},
            }

function initSha()
  addbutton("group_heal", 0, 4, 41)
  addbutton("ancestral_shield", 0, 11, 46)
  addbutton("stoneskin", 0, 10, 26)

  addbutton("encSelf", 0, 12, 0)

  powerAliases:addButtons()

  --mud:send("powers info vit")
end

-- this function will be called when shaman should cast
function SpellsSha()
  -- i'm blind: gheal, or cast heal on me if none left
  if buff:get("blind") or buff:get("blindness") then
    --display("X")
    if getSpellCount("group_heal") &gt; 0 then
      spell:cast("gh")
    else
      if getSpellCount("heal") &gt; 0 then
        spell:cast("HL")
      end
    end

    return
  end

  -- check if anyone blind
  for k,char in pairs(groupList:pc()) do
    if buff:get("blind", char) or buff:get("blindness", char) then
      --display("Y")
      if charData:get("autogh") then
        if getSpellCount("group_heal") &gt; 0 then
          spell:cast("gh")
          return
        end
      end
    end
  end

  -- earthquakes
  if castQuake() then
    return
  end

  -- stone if not stoned/scaled
  if scr_stoneskin(true) then
    return
  end

  -- group heal if multiple characters damaged
  local damaged=0
  for k,char in pairs(groupList:pc()) do
    local hp=tonumber(groupList:getHP(char))
    local maxhp= tonumber(groupList:getMaxHP(char))
    local percent = hp/maxhp

    if hp &lt; .9 * maxhp then
      damaged = damaged + 1
    end
  end
  
  if damaged &gt;= 3 and getSpellCount("group_heal") &gt; 0 and charData:get("autogh") then
    spell:cast("gh")
    return
  end

  -- stone remaining characters
  if scr_stoneskin() then
    return
  end

  -- vit self if needed / autovit enabled

  if charData:get("autovit") and charData:get("level") &gt;= 21 then
    if spell:attempt(whoami(), "vitality", "vt") then
      return
    end
  end
  
  -- cast heal on self?
  
  if prompt:get("hp%") &lt; 80 then
    if getSpellCount("group_heal") &gt; 0 and charData:get("autogh") then
      spell:cast("gh")
      return
    end

    if getSpellCount("hl") &gt; 0 then
      spell:cast("hl me")
      return
    end
  end


-- heal spirit - this will happen regardless of in or out of combat
  if charData:get("autoheal") and pet:status("spirit") then
    local petname=pet:getTable("spirit")[1]
    
    if pet:getHP(petname) &lt; .8 * pet:getMaxHP(petname) and pet:getInRoom(petname) then
        if getSpellCount("hl") &gt; 0 then
          spell:cast("hl " .. petname)
          return
        end
    end
  end

  -- ancestral shield
  if charData:get("autoashield") and inCombat() then
    if not buff:get("ancestral_shield") then
      if getSpellCount("ancestral_shield") &gt; 0 then
        spell:cast("ash")
        return
      end
    end
  end

  -- queue vitality
  if charData:get("autovit") and charData:get("level") &gt;= 21 then
    if scr_vitality() then
      return
    end
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end
end

function hex(fname, xcommand)
  if xcommand == buttons.UPDATE then
    updateButton(fname)
    return
  end

  if xcommand == buttons.INIT then
    setLabelImage(fname, "hex-off.png")
    hex("hex", buttons.UPDATE)
  else
    spell:cast("hex")
  end
end

function silence_person(fname, xcommand)
  if xcommand == buttons.UPDATE then
    updateButton(fname)
    return
  end

  if xcommand == buttons.INIT then
    setLabelImage(fname, "silence_person-off.png")
    silence_person(fname, buttons.UPDATE)
  else
    spell:cast("sp")
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>CleScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Cle"] = powersTable["Cle"] or {}
powersTable["Cle"][""] =
            {   
  { "dm", "detect_magic", nil, "", nil, 1, 1},
  { "dg", "detect_good", nil, "", nil, 1, 1},
  { "de", "detect_evil", nil, "", nil, 1, 1},
  { "curel", "cure_light", "Cure|Light", "autoheal", nil, 1, 1},
  { "crw", "create_water", "Create|Water", "", nil, 1, 1},
  { "cfood", "create_food", "Create|Food", "", nil, 1, 1},
  { "caul", "cause_light", "Cause|Light", "autoharm", nil, 1, 1},
  { "am", "armor", nil, "", nil, 1, 1},
  { "word", "word_of_recall", nil, "", nil, 6, 1},
  { "vl", "vigorize_light", nil, "", nil, 6, 1},
  { "slp", "slow_poison", nil, "", nil, 6, 1},
  { "prs", "preserve", nil, "", nil, 6, 1},
  { "cs", "cure_serious", "Cure|Serious", "autoheal", nil, 6, 1},
  { "causs", "cause_serious", "Cause|Serious", "autoharm", nil, 6, 1},
  { "bls", "bless", nil, "", nil, 6, 1},
  { "vs", "vigorize_serious", nil, "", nil, 11, 1},
  { "sen", "sense_life", nil, "", nil, 11, 1},
  { "eaq", "earthquake", "Earth|Quake", "autoquake", nil, 11, 1},
  { "dispg", "dispel_good", nil, "", nil, 11, 1},
  { "dev", "dispel_evil", nil, "", nil, 11, 1},
  { "ccr", "cure_critic", "Cure|Critical", "autoheal", nil, 11, 1},
  { "cb", "cure_blind", nil, "", nil, 11, 1},
  { "comu", "command_undead", "Command|Undead", "", nil, 11, 1},
  { "cauc", "cause_critical", "Cause|Critical", "autoharm", nil, 11, 1},
  { "wu", "ward_undead", "Ward|Undead", "turnundead", nil, 16, 1},
  { "tvp", "transport_via_plants", nil, "", nil, 16, 1},
  { "sum", "summon", nil, "", nil, 16, 1},
  { "rp", "remove_poison", nil, "", nil, 16, 1},
  { "remc", "remove_curse", nil, "", nil, 16, 1},
  { "pfl", "protection_from_lightning", nil, "", nil, 16, 1},
  { "pfd", "protection_from_good", nil, "", nil, 16, 1},
  { "pfg", "protection_from_gas", nil, "", nil, 16, 1},
  { "pff", "protection_from_fire", nil, "", nil, 16, 1},
  { "pfe", "protection_from_evil", nil, "", nil, 16, 1},
  { "pfc", "protection_from_cold", nil, "", nil, 16, 1},
  { "pfa", "protection_from_acid", nil, "", nil, 16, 1},
  { "fs", "flame_strike", "Flame|Strike", "automissile", nil, 16, 1},
  { "bl", "blindness", nil, "", nil, 16, 1},
  { "vt", "vitality", "Vitality", "autovit", nil, 21, 1},
  { "vc", "vigorize_critic", nil, "", nil, 21, 1},
  { "rd", "raise_dead", "Raise|Dead", "", nil, 21, 1},
  { "hl", "heal", "Heal", "autoheal", nil, 21, 1},
  { "dism", "dispel_magic", "dism", 21, "", 1},
  { "sp", "silence_person", "Silence|Person", "", nil, 26, 1},
  { "hm", "harm", "Harm", "autoharm", nil, 26, 1},
  { "fe", "fear", "Fear", "", nil, 26, 1},
  { "dun", "destroy_undead", "Destroy|Undead", "turnundead", nil, 26, 1},
  { "dkn", "darkness", nil, "", nil, 26, 1},
  { "curi", "curse_item", nil, "", nil, 26, 1},
  { "cr", "curse", nil, "", nil, 26, 1},
  { "cnl", "continual_light",nil, "", nil, 26, 1},
  { "wb", "water_breathing", nil, "", nil, 31, 1},
  { "gvig", "group_vigorize", nil, "", nil, 31, 1},
  { "fh", "full_heal", "Full|Heal", "autoheal", nil, 31, 1},
  { "fhm", "full_harm", "Full|Harm", "autoharm", nil, 36, 1},
  { "eu", "eradicate_undead", "Eradicate|Undead", "turnundead", nil, 36, 1},
  { "dpu", "divine_purification", nil, "", nil, 41, 1},
  { "dvb", "divine_blessing", nil, "", nil, 41, 1},
  { "realm", "greater_realm_of_protection", "Greater|Realm", "autorealm", nil, 46, 1},
  { "dp", "divine_power", "Divine|Power", "", nil, 16, 1},
  { "ha", "healing_aura", "Healing|Aura", "autoheal", nil, 36, 1},
  { "rm", "righteous_might", nil, "", nil, 41, 1},
  { "psh", "plane_shift", nil, "", nil, 41, 1},
  { "resu", "resurrect", "Resurrect", "autores", nil, 46, 1},
  { "uw", "unholy_word", "Unholy|Word", "autohlarea", nil, 31, 1},
  { "hw", "holy_word", "Holy|Word", "autohlarea", nil, 31, 1},
  { "db", "disruption_burst", "Disruption|Burst", "turnundead", nil, 46, 1}
            }

function initCle()
  addbutton("greater_realm_of_protection", 0, 3, 46)
  --  addbutton("silence_person",9, 26)
  addbutton("resurrect", 0, 4, 46)
  powerAliases:addButtons()
  --  if whoami() ~= nil then
  --    if whorace(whoami()) ~= nil then
  --      if whorace(whoami()) == "Yuan-Ti" then
  --        addbutton("scale_skin", 13, 1)
  --      end
  --    end
  --  end
  --mud:send("powers info vit")
end

function SpellsCle()
  -- this script will only be called if autocast enabled
  --echo("Z")
  if buff:get("blind") or buff:get("blindness") then
    --display("i'm blind")
    if prompt:get("hp") &lt; .9 * prompt:get("maxhp") then
      if getSpellCount("full_heal") &gt; 0 then
        --display("fh")
        spell:cast("fh")
        return
      end
    end
    if getSpellCount("cure_blind") &gt; 0 then
      --display("cb")
      spell:cast("cb")
      return
    end
    if getSpellCount("full_heal") &gt; 0 then
      --display("fh2")
      spell:cast("fh")
      return
    end
  end
  -- queue purify/etc
  if procClericPurify() then
    return
  end
  -- earthquakes
  if castQuake() then
    return
  end
  -- healing aura main tank if injured
  if charData:get("autoheal") then
    if NyyLIB.mtank ~= nil then
      local char = NyyLIB.mtank
      local hp = tonumber(groupList:getHP(char))
      local maxhp = tonumber(groupList:getMaxHP(char))
      local percent = hp / maxhp
      if
        getSpellCount("healing_aura") &gt; 0 and percent &lt; .7 and not buff:get("healing_aura", char)
      then
        spell:cast("ha " .. char)
        return
      end
    end
  end
  -- queue any needed heals
  if charData:get("autoheal") then
    if procClericHeal() then
      return
    end
  end
  -- queue vitality
  if charData:get("autovit") and charData:get("level") &gt;= 21 then
    if scr_vitality() then
      return
    end
  end

  -- scaleskin
  procYuanInnates()
  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end
  if procClericRealm() then
    return
  end
  -- process cast/send queue if not currently casting
  --if spell:getCurrent() == nil then
  --  spell:cast()
  --end
end

function procYuanInnates()
  if charData:get("yuan") then
    if not charData:get("scaleskin") then
      mud:send("innate scaleskin")
    end
  end
end

reversePairs = function ( aTable )
	local keys = {}

	for k,v in pairs(aTable) do keys[#keys+1] = k end
	table.sort(keys, function (a, b) return a&gt;b end)

	local n = 0

	return function ( )
		n = n + 1
		return keys[n], aTable[keys[n] ]
	end
end

function procClericHeal()
  -- Cleric heal event
  -- healing aura needs to be manually added to buffs
  -- otherwise, ha already present on self and damaged cleric (self) will stop moving further on script
  local ha_count = getSpellCount("healing_aura")
  local fh_count = getSpellCount("full_heal")
  if prompt:get("hp") &lt; .8 * prompt:get("maxhp") then
    -- first choice = healing aura if &lt; .8 hp
    if ha_count &gt; 0 then
      if not buff:get("healing_aura") then
        echoDebug("\n&lt;red&gt;[que ha on self]\n")
        spell:cast("ha " .. whoami())
        return (true)
      end
    end
    -- alternate choice = full heal if no aura and &lt; .65 hp
    if fh_count &gt; 0 and (prompt:get("hp") &lt; .65 * prompt:get("maxhp")) then
      echoDebug("\n&lt;red&gt;[que fh on self]\n")
      spell:cast("fh")
      return (true)
    end
  end
  for k, char in pairs(groupList:pc()) do
    local hp = tonumber(groupList:getHP(char))
    local maxhp = tonumber(groupList:getMaxHP(char))
    local percent = hp / maxhp
    if spell:getCurrent() ~= ("fh " .. char) then
      if getSpellCount("full_heal") &gt; 0 then
        if hp &lt; .75 * maxhp then
          echoDebug("\n&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting fh on " .. char .. "]")
          spell:cast("fh " .. char)
          return (true)
        elseif percent &lt; .8 and whoclass(char) == "War" then
          echoDebug("\n&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting ha on " .. char .. "]")
          if getSpellCount("healing_aura") &gt; 0 then
            spell:cast("ha " .. char)
            return (true)
          end
        end
      end
    end
  end
  -- healing aura tank at few wounds
  if prompt:get("tankcondition") == "few wounds" then
    if getSpellCount("healing_aura") &gt; 0 then
      spell:cast("ha " .. prompt:get("tank"))
      return (true)
    end
  end
  -- full heal anyone at &lt; .6 maxhp
  for k, char in pairs(groupList:pc()) do
    local hp = tonumber(groupList:getHP(char))
    local maxhp = tonumber(groupList:getMaxHP(char))
    if spell:getCurrent() ~= ("fh " .. char) then
      if getSpellCount("full_heal") &gt; 0 then
        if hp &lt; .6 * maxhp then
          echoDebug("&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting fh on " .. char .. "]")
          spell:cast("fh " .. char)
          return (true)
        end
      end
    end
  end
  return (false)
end

function procClericRealm()
  -- Greater Realm Of Protecti ( 43:59)
  if charData:get("autorealm") then
    for k, char in pairs(groupList:pc("all")) do
      if getSpellCount("greater_realm_of_protection") &gt; 0 then
        if char ~= "wolf" and char ~= "drider" and char ~= "slaad" then
          if not buff:get("greater_realm_of_protecti", char) and groupList:getHP(char) ~= 0 then
            spell:cast("realm " .. char)
            return (true)
          end
        end
      end
    end
  end
  return (false)
end

function procClericPurify()
  -- check for anyone paralyzed
  for k, char in pairs(groupList:pc()) do
    if buff:get("minor_paralysis", char) or buff:get("major_paralysis", char) then
      if charData:get("autopurify") then
        if getSpellCount("divine_purification") &gt; 0 then
          spell:cast("dpu " .. char)
          return (true)
        end
      end
    end
  end
  -- check for anyone blinded
  for k, char in pairs(groupList:pc()) do
    local hp = tonumber(groupList:getHP(char))
    local maxhp = tonumber(groupList:getMaxHP(char))
    local percent = hp / maxhp
    if buff:get("blind", char) or buff:get("blindness", char) then
      if charData:get("autocb") then
        if char == whoami() then
          if percent &lt; .9 then
            if getSpellCount("heal") &gt; 0 then
              spell:cast("hl")
              return (true)
            end
          end
          spell:cast("cb")
          return (true)
        else
          if percent &lt; .9 then
            if getSpellCount("hl") &gt; 0 then
              spell:cast("hl " .. char)
              return (true)
            end
          end
          spell:cast("cb " .. char)
          return (true)
        end
        return (false)
      end
    end
  end
end

function scr_vitality()
  local var = buff:get("vitality") or 0
  if getSpellCount("vitality") == 0 then
    return
  end
  if var == 0 then
    spell:cast("vt " .. whoami())
    return (true)
  end
  if charData:get("autovit") then
    local vit = charData:get("vit")
    --echoDebug("&lt;red&gt;[Queuing vitality for: " .. vit .. "]\n")
    
    -- lua #(groupList:pc("cle"))

    for k, char in pairs(groupList:pc(vit)) do
      -- don't vit dead people
      if table.contains(NyyLIB.deadpeople, char) == false then
        if groupList:getHP(char) ~= 0 then
          var = buff:get("vitality", char) or 0
          if var == 0 then
            spell:cast("vt " .. char)
            return (true)
          end
        end
      end
    end
  end
end

function scale_skin(fname, xcommand)
  -- innate vipermind, scaleskin
  if xcommand == buttons.UPDATE then
    --    updateButton(fname)
    return
  end
  if xcommand ~= buttons.INIT then
    if charData:get("yuan") then
      charData:set("yuan", false)
    else
      charData:set("yuan", true)
    end
  end
  if charData:get("yuan") then
    setLabelImage(fname, "scale_skin-on.png")
  else
    setLabelImage(fname, "scale_skin-off.png")
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MiscButtons</name>
					<packageName></packageName>
					<script>
function baseButtons()
  addbutton("ticktimer", 0, 0.2, 0, "4c", "2c")
  addbutton("mysizeDisplay", 0, 0.6, 0, "3c", "2c")

  -- non-class specific buttons at far right

  if checkMask("fighter") and not checkMask("rangerhex") then
    addbutton("autotank", 0, 16, 0, "2.4%")
  end


  addbutton("chkstat", 0, 17, 0, "2.4%")
  addbutton("flee", 0, 17.5, 0, "2.4%")
  addbutton("autoassist", 0, 18, 0, "2.4%")
  addbutton("autoloot", 0, 18.5, 0, "2.4%")  
  addbutton("autoopen", 0, 19, 0, "2.4%")  
  addbutton("autoportal", 0, 19.5, 0, "2.4%")  
  
  if checkMask("petrescue") then
    --addbutton("pet_rescue", 0, 15, 1)
      addbutton("pet_rescue", 0, 16.5, 0, "2.4%")
  end

  -- buttons at the bottom

  if checkMask("fighter") and not checkMask("rangerhex") then
    addbutton("rescue", 0, 4, 1)
  end
 
  if checkMask("rangerhex") or checkMask("pal") or checkMask("war") then
    addbutton("SpellsButton", 0, 16.5, 0, "2.4%")
  end
  
  if checkMask("caster") or checkMask("nonPriestCaster") then 
    addbutton("SpellsButton", 0, 16.5, 0, "2.4%")
  end

  if (checkMask("caster") or checkMask("nonPriestCaster")) and not checkMask("noMemCaster") then 
    addbutton("MemButton", 0, 1, 0)
  end

  if whoclass() == "Rog" then
    -- removed disarm button
    --addbutton("DisarmButton", 0, 11, 10)  
  end

  if checkMask("summonmount") then
    addbutton("SummonMount", 0, 10, 15)
  end


  -- faerie fire

  if checkMask("ffire") then
    addbutton("faerie_fire", 0, 14, 6)
  end

  -- group window bar button

  if NyyLIB.groupwindowbutton == nil then
    groupButtonCon = groupButtonCon or Geyser.Label:new({name = "groupButtonCon"}, NyyLIB.buttonpanel)
    groupButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
    
    NyyLIB.groupwindowbutton = Geyser.Label:new({name="groupwindowbutton", x=0, y=0, width="100%", height="100%"}, groupButtonCon)
    
    NyyLIB.groupwindowbutton:setStyleSheet(
    [[ QLabel{ border-image: url(]] .. iconpath("network.png") .. [[);} ]] )
  
    NyyLIB.groupwindowbutton:setToolTip("group","10")

    NyyLIB.groupwindowbutton:setClickCallback("toggleGroupwindow")
  end


  -- xp display window

  if NyyLIB.xpwindow == nil then
    NyyLIB.xpwindow = Geyser.Label:new({name="xpwin", x=0, y=0, width="160px", height="32px"})
  end

  if charData:get("level") == 50 then
    NyyLIB.xpwindow:show()
    NyyLIB.xpwindow:hide()
  else
    NyyLIB.xpwindow:show()
  end

  -- vote button

  --charData:init("vote", 0, true)
  --charData:set("vote", charData:get("vote", true)+1, true)

  --if charData:get("vote", true) &gt; 10 then
  -- NyyLIB.votewindow = Geyser.Label:new({name="vote", x=0, y=0, width="225px", height="125px"})
  --  NyyLIB.votewindow:setClickCallback("mudvote")
  --  NyyLIB.votewindow:setStyleSheet([[border-image: url(]] .. iconpath("vote.png") .. [[)]])

  --  checkVoteButton()
  --end
end


function createGearButtons()
  -- 64x64?  480/5=96

  -- settings button (gear icon)

 if NyyLIB.settingsbutton == nil then
    NyyLIB.settingsbutton = Geyser.Label:new({name="settingsbutton", x=-(96+20), y=0, width="96px", height="96px"})
    
    NyyLIB.settingsbutton:setStyleSheet(
    [[ QLabel{ border-image: url(]] .. iconpath("settings.png") .. [[);} ]] )
    
  
    NyyLIB.settingsbutton:setToolTip("Windows", "10")
    NyyLIB.settingsbutton:setClickCallback("toggleRightIconWindow")
        
  end

  -- right icon panel

  if NyyLIB.buttonpanel == nil then
    
    NyyLIB.buttonpanellabel = Geyser.HBox:new({name="buttonpanellabel", x=-(96+20+480), y=0, width="480px", height="96px"})
    NyyLIB.buttonpanel = Geyser.HBox:new({name="buttonpanel", x=0, y=0, width="100%", height="100%"}, NyyLIB.buttonpanellabel)
    
    
    
    --NyyLIB.buttonpanel:setToolTip("Windows", "10")
  
  end

  -- tile button

  if NyyLIB.tilebutton == nil then
    NyyLIB.tilebutton = Geyser.Label:new({name="tilebutton"}, NyyLIB.buttonpanel)
    
    NyyLIB.tilebutton:setStyleSheet(
    [[ QLabel{ border-image: url(]] .. iconpath("tiles.png") .. [[);} ]] )
    
  
    NyyLIB.tilebutton:setToolTip("resetgui", "10")
    NyyLIB.tilebutton:setClickCallback("resetgui")
  end

  -- map button

  if NyyLIB.mapbutton == nil then
    mapButtonCon = mapButtonCon or Geyser.Label:new({name = "mapButtonCon"}, NyyLIB.buttonpanel)
    mapButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")

    NyyLIB.mapbutton = Geyser.Label:new({name="mapbutton", x=0, y=0, width="100%", height="100%"}, mapButtonCon)
  
    NyyLIB.mapbutton:setStyleSheet(
    [[ QLabel{ border-image: url(]] .. iconpath("map.png") .. [[);} ]] )
  
    NyyLIB.mapbutton:setToolTip("map", "10")
    NyyLIB.mapbutton:setClickCallback("map:toggle")
  end

  -- minimap button
  
  if NyyLIB.minimapbutton == nil then
    minimapButtonCon = minimapButtonCon or Geyser.Label:new({name = "minimapButtonCon"}, NyyLIB.buttonpanel)
    minimapButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")

    minimapButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
        
    NyyLIB.minimapbutton = Geyser.Label:new({name="minimapbutton", x=0, y=0, width="100%", height="100%"}, minimapButtonCon)
    
    NyyLIB.minimapbutton:setStyleSheet(
    [[ QLabel{ border-image: url(]] .. iconpath("minimap-on.png") .. [[);} ]] )
  
    NyyLIB.minimapbutton:setToolTip("Minimap", "10")

    NyyLIB.minimapbutton:setClickCallback("miniMap:toggle")
  end

  -- chat button
  
  if NyyLIB.chatbutton == nil then
    chatButtonCon = chatButtonCon or Geyser.Label:new({name = "chatButtonCon"}, NyyLIB.buttonpanel)
        
    if chatAdjCon.hidden then
      chatButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
    else
      chatButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
    end
    
    NyyLIB.chatbutton = Geyser.Label:new({name="chatbutton", x=0, y=0, width="100%", height="100%"}, chatButtonCon)
    
    NyyLIB.chatbutton:setStyleSheet(
    [[ QLabel{ border-image: url(]] .. iconpath("chat.png") .. [[);} ]] )
    
  
    NyyLIB.chatbutton:setToolTip("chat", "10")

    NyyLIB.chatbutton:setClickCallback("chat:toggle")
  end

  -- icon bar button

  if NyyLIB.iconbarbutton == nil then
    iconbarButtonCon = iconbarButtonCon or Geyser.Label:new({name = "iconbarButtonCon"}, NyyLIB.buttonpanel)
    iconbarButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
    
    NyyLIB.iconbarbutton = Geyser.Label:new({name="iconbarbutton", x=0, y=0, width="100%", height="100%"}, iconbarButtonCon)
    
    NyyLIB.iconbarbutton:setStyleSheet(
    [[ QLabel{ border-image: url(]] .. iconpath("management.png") .. [[);} ]] )
    
  
    NyyLIB.iconbarbutton:setToolTip("iconbar", "10")

    NyyLIB.iconbarbutton:setClickCallback("toggleIconbar")
  end

  buttonPanel=false
  NyyLIB.buttonpanel:hide()
end

function pet_rescue(fname, xcommand)
  shiftSkillButton("pet_rescue", "petrescue", xcommand)
end

function ticktimer()
  return
end

function checkVoteButton()
  local val=getTime()

  if NyyLIB.votewindow ~= nil then
    if charData:get("lastvote", true) ~= nil  then
      if val.day == charData:get("lastvote", true) then
        NyyLIB.votewindow:show()
        NyyLIB.votewindow:hide()
      else
        --display("XXXDISPLAYXXX")
        --display(val)
        --display(val.day)
        --display(charData:get("lastvote", true))
        --mud:send("TIME")

        NyyLIB.votewindow:show()
      end
    end
  end
end

function SummonMount(fname, xcommand)
  local label=findlabel(fname)

  if xcommand ~= buttons.INIT then
    mud:send("summon mount")
  end

  setLabelImage(fname, "summon_mount.png")
end

function MountDismount(fname, xcommand)
  local label=findlabel(fname)

  if xcommand ~= buttons.INIT then
    if mount:getMounted() then
      mud:send("dismount")
    else
      mud:send("mount")
    end
  end

  if mount:getMounted() then
    setLabelImage(fname, "dismount.png")
  else
    setLabelImage(fname, "mount.png")
  end
end

function MemButton(fname, xcommand)
  local label=findlabel(fname)

  if xcommand == buttons.UPDATE then
    if label ~= nil then
      charData:init("memcount", 0)

      if spell:getMem() then
        if charData:get("memcount") ~= 0 then
          label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. charData:get("memcount") .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
        else
          label:clear()
          spell:setMem(false)
        end
      else
        MemButton(fname, buttons.INIT)
      end
    end
    return
  end

  if xcommand == buttons.INIT then
    echoDebug("&lt;red&gt;[Setting membutton to mem/med/pray]")

    if label ~= nil then
      label:clear()
    end

    if checkMask("psi") then
      setLabelImage(fname, "psiMeditate.png")
    elseif checkMask("priest") or checkMask("pray") then
      setLabelImage(fname, "pray.png")
    else
      setLabelImage(fname, "encMem.png")
    end
  else
    if checkMask("psi") then
      if spell:getMem() then
        setLabelImage(fname, "psiMeditate.png")
        mud:send("ST")      
      else
        setLabelImage(fname, "stand.png")
        mud:send("mem")
      end
    else
      if not spell:getMem() then
        mud:send("mem")
      else
        spell:setMem(false)
        mud:send("ST")
      end
    end
  end
end

function SpellsButton(fname, xcommand)
  if xcommand ~= buttons.INIT then
    if charData:get("autocast") then
      charData:set("autocast", false)
      cecho("&lt;red&gt;[Autocasting and Automem are disabled.]\n")
      spell:clear()
    else
      charData:set("autocast", true)
      cecho("&lt;green&gt;[Autocasting and Automem are enabled.]\n")
      spell:setMoving(false)
      mud:send("\n")
    end
  end

  if charData:get("autocast") then
    setLabelImage(fname, "SpellsButton-on.png")
  else
    setLabelImage(fname, "SpellsButton-off.png")
  end
end

function mudvote()
  local val=getTime()

  openUrl("http://www.topmudsites.com/vote-shev.html")
  --openUrl("https://www.mudconnect.com/cgi-bin/vote.cgi?mud=TorilMud,+the+Sojourner%27s+Home")
  
  charData:set("lastvote", val.day, true)
  NyyLIB.votewindow:show()
  NyyLIB.votewindow:hide()
end

function mysizeDisplay(fname, xcommand)
  local fname="mysizeDisplay"
  local mysize = whosize()

  if mysize ~= nil then
    charData:init("bodysize", mysize)
  else
    charData:init("bodysize", "M")
  end

  local tmpvar=charData:get("bodysize")

  if tmpvar == "T" then
    setLabelImage(fname, "sizet.png")
  elseif tmpvar == "S" then
    setLabelImage(fname, "sizes.png")
  elseif tmpvar == "M" then
    setLabelImage(fname, "sizem.png")
  elseif tmpvar == "L" then
    setLabelImage(fname, "sizel.png")
  elseif tmpvar == "H" then
    setLabelImage(fname, "sizeh.png")
  end
end

function autoportal(fname, xcommand)
  shiftSkillButton("autoportal", "autoportal", xcommand)
end

function autoopen(fname, xcommand)
  shiftSkillButton("autoopen", "autoopen", xcommand)
end

function autoassist(fname, xcommand)
  shiftSkillButton("autoassist", "autoassist", xcommand)
end

function autotank(fname, xcommand)
  shiftSkillButton("autotank", "autotank", xcommand)
end

function flee(fname, xcommand)
  shiftSkillButton("flee", "flee", xcommand)
end

function chkstat(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "chkstat.png")
  else
    mud:send("@chkstat")
  end
end

function autoloot(fname, xcommand)
  shiftSkillButton("autoloot", "autoloot", xcommand)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>RogScript</name>
					<packageName></packageName>
					<script>
function initRog()
  addbutton("assassinate", 0, 1, 40)
  addbutton("trip", 0, 2, 25)
  addbutton("circle", 0, 3, 15)
  addbutton("autohide", 0, 6, 1)
  addbutton("poisonRogue", 0,  11, 20)

end

function setTripping(xval)
  tripping = xval
end

function getTripping()
  if tripping == nil then
    tripping=false
  end

  return(tripping)
end

function sendTrip()
  if timer:get("wraithform") or timer:get("notrip") then
    return
  end
  
  
  -- can only trip if standing

  if not prompt:get("position") == "std" then
    return
  end

  -- can't trip if stunned

  if buff:get("stun") then
    return
  end

  if not getTripping() then
    cecho("&lt;green&gt;\n[trip]\n")

    mud:send("trip")

    setTripping(true)
  end
end

function sendAssassinate(xtarget)
  if charData:get("autoassassinate") then
    if timer:get("assassinatetimer") == nil and charData:get("level") &gt; 39 then
      timer:set("assassinatetimer", 25*60)

      if xtarget == nil then
        cecho("&lt;red&gt;[Assassinate target is nil]\n")
        return(false)
      end

      mud:send("ASSASSINATE " .. xtarget)
      look:send()
      return(true)
    end
  end

  return(false)
end

function sendPoison()
  if charData:get("autopoison") then
    local primaryp=charData:get("primaryp")
    local secondaryp=charData:get("secondaryp")
    local poisonbag = charData:get("poisonbag")

    if primaryp ~= "" then
      
      --  apply &lt;poison&gt; &lt;weapon_name&gt; &lt;container&gt;

      mud:send("apply " .. primaryp .. " primaryweapon " .. poisonbag)
    end

    if secondaryp ~= "" then
      mud:send("apply " .. secondaryp .. " secondaryweapon " .. poisonbag)
    end
  end
end

function assassinate(fname, xcommand)
  shiftSkillButton("assassinate", "autoassassinate", xcommand)
end

function trip(fname, xcommand)
  shiftSkillButton("trip", "autotrip", xcommand)
end

function autohide(fname, xcommand)
  shiftSkillButton("autohide", "autohide", xcommand)
end

function circle(fname, xcommand)
  shiftSkillButton("circle", "autocircle", xcommand)
end

function poisonRogue(fname, xcommand)
  shiftSkillButton("poisonRogue", "autopoison", xcommand)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EleScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Ele"] = powersTable["Ele"] or {}
powersTable["Ele"][""] =
      {
    {"minor", "minor_creation", nil, "", nil, 1, 1},
    {"mf", "mage_flame", nil, "", nil, 1, 1},
    {"erase", "erase", nil, "", nil, 1, 1},
    {"di", "detect_invisibility", nil, "", nil, 1, 1},
    {"is", "ice_spear", "Ice|Spear", "automissile", nil, 6, 1},
    {"dm", "detect_magic", nil, "", nil, 6, 1},
    {"ekin", "summon_elemental_kin", nil, "", nil, 11, 1},
    {"loco", "locate_object", nil, "", nil, 11, 1},
    {"dism", "dispel_magic", nil, "", nil, 11, 1},
    {"ab", "air_blast", "Air|Blast", "automissile", nil, 11, 1},
    {"slp", "sleep", nil, "", nil, 16, 1},
    {"ray", "ray_of_enfeeblement", nil, "", nil, 16, 1},
    {"lv", "levitate", nil, "", nil, 16, 1},
    {"fbl", "fireball", "Fireball", "autoarea", nil, 16, 1},
    {"ffog", "faerie_fog", nil, "", nil, 16, 1},
    {"tl", "thunder_lance", "Thunder|Lance", "automissile", nil, 21, 1},
    {"slp", "sleep", nil, "", nil, 16, 1},
    {"tele", "teleport", nil, "", nil, 21, 1},
    {"iv", "infravision", nil, "", nil, 21, 1},
    {"gl", "glitterdust", "Glitter|Dust", "autoblind", nil, 21, 1},
    {"fsh", "fireshield", nil, "", nil, 21, 1},
    {"ele", "conjure_elemental", nil, "", nil, 21, 1},
    {"csh", "coldshield", nil, "", nil, 21, 1},
    {"ss", "stoneskin", nil, "autostone", nil, 26, 1},
    {"feeb", "feeblemind", nil, "", nil, 26, 1},
    {"ed", "earth_darts", "Earth|Darts", "automissile", nil, 1, 1},
    {"es", "earth_stones", "Earth|Stones", "automissile", nil, 26, 1},
    {"cone", "cone_of_cold", "Cone of|Cold", "autoarea", nil, 26, 1},
    {"clv", "clairvoyance", nil, "", nil, 26, 1},
    {"bs", "blizzard_sphere", "Blizzard|Sphere", "autoarea", nil, 26, 1},
    {"it", "ice_tongue",  nil, "", nil, 31, 1},
    {"il", "ice_layer", nil, "", nil, 31, 1},
    {"hs", "haste", "Haste", "pokehaste", nil, 31, 1},
    {"ewe", "elemental_water_embodiment", nil, "", nil, 31, 1},
    {"dim", "dimension_door", nil, "", nil, 31, 1},
    {"ww", "whirlwind", "Whirlwind", "autohlmissile", nil, 36, 1},
    {"pws", "power_word_stun", nil, "", nil, 36, 1},
    {"pwb", "power_word_blind", nil, "", nil, 36, 1},
    {"iw", "icewave", "Icewave", "autohlarea", nil, 36, 1},
    {"fw", "firewave", "Firewave", "autohlarea", nil, 36, 1},
    {"fifog", "fire_fog", nil, "", nil, 36, 1},
    {"eae", "elemental_air_embodiment", nil, "", nil, 36, 1},
    {"efog", "earth_fog", nil, "", nil, 36, 1},
    {"eb", "earthblood", "Earth|Blood", "autohlmissile", nil, 41, 1},
    {"relo", "relocate", nil, "", nil, 41, 1},
    {"gate", "gate", nil, "", nil, 41, 1},
    {"lb", "lava_burst", "Lava|Burst", "autohlarea", nil, 46, 1},
    {"ew", "elemental_ward", "Elemental|Ward", "autoward", nil, 46, 1},
    {"eee", "elemental_earth_embodiment", nil, "", nil, 41, 1},
    {"efe", "elemental_fire_embodiment", nil, "", nil, 46, 1},
      }

function initEle()
  addbutton("stoneskin", 0, 7, 26)
  addbutton("elemental_ward", 0, 8, 46)
  addbutton("glitterdust", 0, 9, 21)
  addbutton("haste", 0, 10, 31)

  powerAliases:addButtons()
end

function SpellsEle()
  --display("X")
  
  if scr_stoneskin(true) then
    return
  end

  local wuss=charData:get("wuss")

  if groupList:ingroup( wuss ) then
    if spell:attempt(wuss, "elemental_earth_embodiment", "eee") then
      return(true)
    end
  end

  if scr_ward() then
    return
  end

  if charData:get("autoblind") then
    if inCombat() and spell:count() == 0 then
      if getSpellCount("glitterdust") &gt; 0 then
        spell:cast("gl")
        return
      end
    end
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end
end

function scr_ward()
  if charData:get("autoward") == true then
    for k,char in pairs(groupList:pc()) do
      if checkMask("hitter", char ) then
        if spell:attempt(char, "elemental_ward", "ew") then
          return(true)
        end
      end
    
      if whoclass(char) == "War" then
        if spell:attempt(char, "elemental_ward", "ew") then
          return(true)
        end
      end

      if whoclass(char) == "Bar" then
        if spell:attempt(char, "elemental_ward", "ew") then
          return(true)
        end
      end
    end
  end
end


function scr_stoneskin(xfirsttime)

  if charData:get("self") then
    -- stone self if not stoned/scaled
    if not buff:get("stoneskin") and not buff:get("dragonscales") then
      if getSpellCount("stoneskin") &gt; 0 then
        spell:cast("ss")
        return
      end
    end
  end

  if charData:get("autostone") == "off" then
    return
  end

  --local wuss=charData:get("wuss")

  --if groupList:ingroup( wuss ) then
  --  if spell:attempt(wuss, "stoneskin", "ss") then
  --    return(true)
  --  end
  --end

  -- in combat, no other spells queued
  if charData:get("autostone") == "tanks" then
    if inCombat() and spell:count() == 0 then
      local tank=prompt:get("tank")

      if not (tank == nil or tank == "") then
        if charData:get("level") &gt;= 31 then
          if spell:attempt(tank, "stoneskin", "ss") then
            return(true)
          end
        end
      end
    end
  end

  if charData:get("autostone") == "rogues" then
    for k,char in pairs(groupList:pc("hitterToRescue")) do
      if spell:attempt(char, "stoneskin", "ss") then
        return(true)
      end
    end
  end

  if charData:get("autostone") == "all" then
    for k,char in pairs(groupList:pc("all")) do
      if spell:attempt(char, "stoneskin", "ss") then
        return(true)
      end
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>NecScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Nec"] = powersTable["Nec"] or {}
powersTable["Nec"][""] =
            {
{"prs", "preserve", nil, "", nil, 1, 1},
{"mf", "mage_flame", nil, "", nil, 1, 1},
{"erase", "erase", nil, "", nil, 1, 1},
{"dm", "detect_magic", nil, "", nil, 1, 1},
{"di", "detect_invisibility", nil, "", nil, 1, 1},
{"skel", "animate_skeleton", nil, "", nil, 1, 1},
{"pfu", "protection_from_undead", "Prot From|Undead", "autopfu", nil, 6, 1},
{"pfc", "protection_from_cold", nil, "", nil, 6, 1},
{"minor", "minor_creation", nil, "", nil, 6, 1},
{"ff", "faerie_fire", "Faerie|Fire", "autoffire", nil, 6, 1},
{"acb", "acid_blast", "Acid|Blast", "automissile", nil, 6, 1},
{"invis", "invisibility", nil, "", nil, 6, 1},
{"comu", "command_undead", nil, "", nil, 6, 1},
{"ct", "chill_touch", "Chill|Touch", "automissile", bil, 6, 1},
{"zomb", "animate_zombie", nil, "", nil, 6, 1},
{"sb", "soul_bind", nil, "", nil, 11, 1},
{"loco", "locate_object", nil, "", nil, 11, 1},
{"lb", "lightning_bolt", "Lightning|Bolt", "automissile", nil, 11, 1},
{"rjm", "rejuventate_minor",  nil, "", nil, 11, 1},
{"pt", "pain_touch", "Pain|Touch", "automissile", nil, 11, 1},
{"ghoul", "animate_ghoul",  nil, "", nil, 11, 1},
{"wt", "wither",  nil, "", nil, 16, 1},
{"str", "strength",  nil, "", nil, 16, 1},
{"sh", "spectral_hand", "Spectral|Hand", "automissile", nil, 16, 1},
{"slp", "sleep", nil, "", nil, 16, 1},
{"dism", "dispel_magic", nil, "", nil, 16, 1},
{"comh", "command_horde", nil, "", nil, 16, 1},
{"shadow", "animate_shadow", nil, "", nil, 16, 1},
{"minp", "minor_paralysis", nil, "", nil, 16, 1},
{"fbl", "fireball", "Fireball", "autoarea", nil, 16, 1},
{"fs", "farsee", nil, "", nil, 16, 1},
{"dism", "dispel_magic", nil, "", nil, 16, 1},
{"tele", "teleport", nil, "", nil, 21, 1},
{"snp", "snapping_teeth", "Snapping|Teeth", "automissile", nil, 21, 1},
{"ray", "ray_of_enfeeblement", "Enfeeble", "", nil, 21, 1},
{"lv", "levitate", nil, "", nil, 21, 1},
{"iv", "infravision", nil, "", nil, 21, 1},
{"slow", "slowness", nil, "", nil, 21, 1},
{"is", "ice_storm", "Ice Storm", "autoarea", nil, 21, 1},
{"hu", "heal_undead", "Heal|Undead", "autoheal", nil, 21, 1},
{"feeb", "feeblemind", nil, "", nil, 21, 1},
{"ed", "energy_drain", "Energy|Drain", "automissile", nil, 21, 1},
{"cone", "cone_of_cold", "Cone Of|Cold", "autoarea", nil, 21, 1},
{"csh", "coldshield", nil, "", nil, 21, 1},
{"wight", "animate_wight", nil, "", nil, 21, 1},
{"wu", "ward_undead", "Ward|Undead", "turnundead", nil, 26, 1},
{"vt", "vampiric_touch", nil, "", nil, 26, 1},
{"rejuv", "rejuvenate_major", nil, "", nil, 26, 1},
{"nd", "nerve_dance", "Nerve|Dance", "automissile", nil, 26, 1},
{"mgi", "minor_globe_of_invulnerability", nil, "", nil, 26, 1},
{"ghast", "animate_ghast", nil, "", nil, 26, 1},
{"age", "age", nil, "", nil, 26, 1},
{"mg", "magic_missile", "Magic|Missile", "automissile", nil, 1, 1},
{"pu", "protect_undead", nil, "", nil, 31, 1},
{"hs", "haste", "Haste", "pokehaste", nil, 31, 1},
{"dim", "dimension_door", nil, "", nil, 31, 1},
{"cglam", "corpse_glamor", nil, "", nil, 31, 1},
{"bbb", "beltyns_burning_blood", "Burning|Blood", "autohlmissile", nil, 31, 1},
{"wraith", "animate_wraith", nil, "", nil, 31, 1},
{"ssh", "soul_shackles", nil, "", nil, 36, 1},
{"dun", "destroy_undead", "Destroy|Undead", "turnundead", nil, 36, 1},
{"ctg", "contagion", nil, "", nil, 36, 1},
{"bm", "blackmantle", nil, "", nil, 36, 1},
{"spect", "animate_spectre",  nil, "", nil, 36, 1},
{"gi", "globe_of_invulnerability", nil, "autoglobe", nil, 41, 1},
{"eu", "eradicate_undead", "Eradicate|Undead", "turnundead", nil, 41, 1},
{"ghost", "animate_ghost", nil, "", nil, 41, 1},
{"vc", "vampiric_curse", "Vampiric|Curse", "autovcurse", nil, 41, 1},
{"lwalk", "life_walk", nil, "", nil, 41, 1},
{"soul", "soul_walk", nil, "", nil, 41, 1},
{"abi", "abi_dalzims_horrid_wilting", "Horrid|Wilting", "autohlmissile", nil, 41, 1},
{"rb", "rain_of_blood", "Rain Of|Blood", "autohlarea", nil, 46, 1},
{"bs", "boneshatter", "Boneshatter", "autohlmissile", nil, 46, 1},
{"bw", "banshee_wail", "Banshee|Wail", "autowail", nil, 46, 1},
{"au", "annihilate_undead", "Annihilate|Undead", "turnundead", nil, 46, 1}
    }

function initNec()
  addbutton("protection_from_undead", 0, 7, 6)
  addbutton("globe_of_invulnerability", 0, 10, 41)
  addbutton("haste", 0, 11, 31)

  addbutton("banshee_wail", 0, 13, 46)
  addbutton("SoulShackleButton", 0, 14, 36)

  powerAliases:addButtons()
end

function SpellsNec()
  if charData:get("autopfu") then
    if scr_pfu() then
      return
    end
  end

  -- powers pfu spectre whether enabled or not
  if pet:status("spectre") then
    local petname= pet:getTable("spectre")[1]

    if not buff:get("protection_from_undead", petname) and pet:getInRoom(petname) then
      if getSpellCount("protection_from_undead") &gt; 0 then
        spell:cast("pfu " .. petname)
        buff:set(petname, "protection_from_undead", 15)
        return
      end
    end
  end

  if   scr_globe() then
    return
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>LicScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Lic"] = powersTable["Lic"] or {}
powersTable["Lic"][""] =
            {
{"prs", "preserve", nil, "", nil, 1, 1},
{"mf", "mage_flame", nil, "", nil, 1, 1},
{"erase", "erase", nil, "", nil, 1, 1},
{"dm", "detect_magic", nil, "", nil, 1, 1},
{"di", "detect_invisibility", nil, "", nil, 1, 1},
{"skel", "animate_skeleton", nil, "", nil, 1, 1},
{"pfu", "protection_from_undead", "Prot From|Undead", "autopfu", nil, 6, 1},
{"pfc", "protection_from_cold", nil, "", nil, 6, 1},
{"minor", "minor_creation", nil, "", nil, 6, 1},
{"ff", "faerie_fire", "Faerie|Fire", "autoffire", nil, 6, 1},
{"acb", "acid_blast", "Acid|Blast", "automissile", nil, 6, 1},
{"invis", "invisibility", nil, "", nil, 6, 1},
{"comu", "command_undead", nil, "", nil, 6, 1},
{"ct", "chill_touch", "Chill|Touch", "automissile", bil, 6, 1},
{"zomb", "animate_zombie", nil, "", nil, 6, 1},
{"sb", "soul_bind", nil, "", nil, 11, 1},
{"loco", "locate_object", nil, "", nil, 11, 1},
{"lb", "lightning_bolt", "Lightning|Bolt", "automissile", nil, 11, 1},
{"rjm", "rejuventate_minor",  nil, "", nil, 11, 1},
{"pt", "pain_touch", "Pain|Touch", "automissile", nil, 11, 1},
{"ghoul", "animate_ghoul",  nil, "", nil, 11, 1},
{"wt", "wither",  nil, "", nil, 16, 1},
{"str", "strength",  nil, "", nil, 16, 1},
{"sh", "spectral_hand", "Spectral|Hand", "automissile", nil, 16, 1},
{"slp", "sleep", nil, "", nil, 16, 1},
{"dism", "dispel_magic", nil, "", nil, 16, 1},
{"comh", "command_horde", nil, "", nil, 16, 1},
{"shadow", "animate_shadow", nil, "", nil, 16, 1},
{"minp", "minor_paralysis", nil, "", nil, 16, 1},
{"fbl", "fireball", "Fireball", "autoarea", nil, 16, 1},
{"fs", "farsee", nil, "", nil, 16, 1},
{"dism", "dispel_magic", nil, "", nil, 16, 1},
{"emm", "embalm", nil, "", nil, 16, 1},
{"tele", "teleport", nil, "", nil, 21, 1},
{"snp", "snapping_teeth", "Snapping|Teeth", "automissile", nil, 21, 1},
{"ray", "ray_of_enfeeblement", "Enfeeble", "", nil, 21, 1},
{"lv", "levitate", nil, "", nil, 21, 1},
{"iv", "infravision", nil, "", nil, 21, 1},
{"slow", "slowness", nil, "", nil, 21, 1},
{"is", "ice_storm", "Ice Storm", "autoarea", nil, 21, 1},
{"hu", "heal_undead", "Heal|Undead", "autoheal", nil, 21, 1},
{"feeb", "feeblemind", nil, "", nil, 21, 1},
{"ed", "energy_drain", "Energy|Drain", "automissile", nil, 21, 1},
{"cone", "cone_of_cold", "Cone Of|Cold", "autoarea", nil, 21, 1},
{"csh", "coldshield", nil, "", nil, 21, 1},
{"wight", "animate_wight", nil, "", nil, 21, 1},
{"wu", "ward_undead", "Ward|Undead", "turnundead", nil, 26, 1},
{"vt", "vampiric_touch", nil, "", nil, 26, 1},
{"rejuv", "rejuvenate_major", nil, "", nil, 26, 1},
{"nd", "nerve_dance", "Nerve|Dance", "automissile", nil, 26, 1},
{"mgi", "minor_globe_of_invulnerability", nil, "", nil, 26, 1},
{"ghast", "animate_ghast", nil, "", nil, 26, 1},
{"age", "age", nil, "", nil, 26, 1},
{"mg", "magic_missile", "Magic|Missile", "automissile", nil, 1, 1},
{"pu", "protect_undead", nil, "", nil, 31, 1},
{"hs", "haste", "Haste", "pokehaste", nil, 31, 1},
{"dim", "dimension_door", nil, "", nil, 31, 1},
{"cglam", "corpse_glamor", nil, "", nil, 31, 1},
{"bbb", "beltyns_burning_blood", "Burning|Blood", "autohlmissile", nil, 31, 1},
{"wraith", "animate_wraith", nil, "", nil, 31, 1},
{"ssh", "soul_shackles", nil, "", nil, 36, 1},
{"dun", "destroy_undead", "Destroy|Undead", "turnundead", nil, 36, 1},
{"ctg", "contagion", nil, "", nil, 36, 1},
{"bm", "blackmantle", nil, "", nil, 36, 1},
{"spect", "animate_spectre",  nil, "", nil, 36, 1},
{"gi", "globe_of_invulnerability", nil, "autoglobe", nil, 41, 1},
{"eu", "eradicate_undead", "Eradicate|Undead", "turnundead", nil, 41, 1},
{"ghost", "animate_ghost", nil, "", nil, 41, 1},
{"vc", "vampiric_curse", "Vampiric|Curse", "autovcurse", nil, 41, 1},
{"lwalk", "life_walk", nil, "", nil, 41, 1},
{"soul", "soul_walk", nil, "", nil, 41, 1},
{"abi", "abi_dalzims_horrid_wilting", "Horrid|Wilting", "autohlmissile", nil, 41, 1},
{"rb", "rain_of_blood", "Rain Of|Blood", "autohlarea", nil, 46, 1},
{"bs", "boneshatter", "Boneshatter", "autohlmissile", nil, 46, 1},
{"bw", "banshee_wail", "Banshee|Wail", "autowail", nil, 46, 1},
{"au", "annihilate_undead", "Annihilate|Undead", "turnundead", nil, 46, 1},
{"rot", "rot", "Living|Rot", "autohlarea", nil, 46, 1},            
{"it", "ice_tomb", "Ice Tomb", "autohlmissile", nil, 46, 1},
{"su", "siphon_undead", "Siphon|Undead", "turnundead", nil, 46, 1},           
{"dp", "death_pact", "Death Pact", "autopact", nil, 46, 1}            
            }

function initLic()
  addbutton("protection_from_undead", 0, 7, 6)
  addbutton("death_pact", 0, 9, 46)
  addbutton("globe_of_invulnerability", 0, 10, 41)
--addbutton("haste", 0, 11, 31)

  addbutton("banshee_wail", 0, 13, 46)
  addbutton("SoulShackleButton", 0, 14, 36)

  powerAliases:addButtons()
end

function SpellsLic()

  -- healing - this will happen regardless of in or out of combat
  if charData:get("autoheal") then
    -- if in combat and less then .75hp heal self
    if inCombat() and prompt:get("hp") &lt; .75 * prompt:get("maxhp") then
      if getSpellCount("heal_undead") &gt; 0 then
        spell:cast("hu " .. whoami())
        return
      end

      -- use lifedrain if no heal undead left
      if charData:get("autohlmissile") then
        if getSpellCount("life_drain") &gt; 0 then
          spell:cast("ld")
          return
        end
      end
    end

    -- if not in combat and less then .95hp heal self
    if not inCombat() and prompt:get("hp") &lt; .95 * prompt:get("maxhp") then
      if getSpellCount("heal_undead") &gt; 0 then
        spell:cast("hu " .. whoami())
        return
      end
    end
  end

  if charData:get("autopfu") then
    if scr_pfu() then
      return
    end
  end

  -- powers pfu spectre whether enabled or not
  if pet:status("spectre") then
    local petname= pet:getTable("spectre")[1]

    if not buff:get("protection_from_undead", petname) and pet:getInRoom(petname) then
      if getSpellCount("protection_from_undead") &gt; 0 then
        spell:cast("pfu " .. petname)
        buff:set(petname, "protection_from_undead", 15)
        return
      end
    end
  end

  if charData:get("autopact") then
    if spell:attempt(whoami(), "death_pact", "dp") then
      return(true)
    end
  end

  if   scr_globe() then
    return
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end
end

-- loop through all casters and over them to cast

function undeadPetCast()
  if timer:get("petcast") or nomagic then
    return
  end

  for k, petname in pairs( pet:getCasterTable() ) do
    ghost_globe(petname)
    undeadSpell(petname)
  end
end

function undeadSpell(xcaster)
  -- spells to cast in or outside combat
  for k,v in pairs(pet:getTable()) do
    if pet:getMaxHP(v) ~= nil and pet:getHP(v) ~= nil and pet:getInRoom(v) and pet:isUndead(v) then
      if pet:getMaxHP(v) - pet:getHP(v)  &gt; 100 then
        mud:send("ORDER " .. xcaster .. " cast 'heal undead' " .. v)
        timer:set("petcast", 6)
        pet:setHP(v, pet:getHP(v)+100)
        return
      end
    end
  end

  -- self-buffing undead pets

  -- haste spectre
  if pet:status("spectre") then
    local petname= pet:getTable("spectre")[1]

    if not buff:get("haste", petname) and pet:getInRoom(petname) then
      mud:send("ORDER " .. xcaster .. " cast 'haste' " .. petname )
      timer:set("petcast", 6)
      buff:set(petname, "haste", 15)
      return
    end
  end

  -- caster undead - keep globed
  if pet:status("wraith") or pet:status("ghost") then
    if not buff:get("globe_of_invulnerability", xcaster) then
      mud:send("ORDER " .. xcaster .. " cast 'globe of invulnerability' " .. xcaster)
      timer:set("petcast", 6)
      buff:set(xcaster, "globe_of_invulnerability", 60)
      return
    end
  end

  -- these spells should only be cast in combat
  if inCombat() then
    if pet:status("ghost") then
      if charData:get("autowail") then
        if not (spell:getCast())["bw"] then
          mud:send("ORDER " .. xcaster .. " cast 'banshee wail'")
          spell:setCast("bw")
          timer:set("petcast", 6)
          return
        end
      end

      if charData:get("autohlarea") then
        mud:send("ORDER " .. xcaster .. " cast 'rain of blood'")
        timer:set("petcast", 6)
        return
      end

      mud:send("ORDER " .. xcaster .. " cast 'boneshatter'")
      timer:set("petcast", 6)
    end  

    if pet:status("wraith") then
      mud:send("ORDER " .. xcaster .. " cast 'abi dalzims'")
      timer:set("petcast", 6)
    end
  
    if pet:status("shadow") then
      mud:send("ORDER " .. xcaster .. " cast 'magic missile'")
      timer:set("petcast", 6)
    end
  else
    -- These spells are cast if not in combat

    -- vampiric touch (shadow can't cast)
    if pet:status("wraith") or pet:status("ghost") then
      if not buff:get("vampiric_touch", xcaster) then
        mud:send("ORDER " .. xcaster .. " cast 'vampiric touch'")
        timer:set("petcast", 6)
        buff:set(xcaster, "vampiric_touch", 60)
        return
      end
    end

    -- coldshield (shadow can't cast)
    if pet:status("wraith") or pet:status("ghost") then
      if not buff:get("coldshield", xcaster) then
        mud:send("ORDER " .. xcaster .. " cast 'coldshield'")
        timer:set("petcast", 6)
        buff:set(xcaster, "coldshield", 60)
        return
      end
    end
  end
end


function SoulShackleButton(fname, xcommand)
  if xcommand == buttons.INIT then
    setLabelImage(fname, "soul_shackles-off.png")
  else
    spell:setNext("ssh")
  end
end

function ghost_globe(xcaster)
  -- spells will be set to short times when order submited to cast. This will prevent multiple casting attempts
  if charData:get("autoglobe") then
    -- can only have 1 spectre + caster undead
    if pet:status("spectre") then
      local petname= pet:getTable("spectre")[1]

      if not buff:get("globe_of_invulnerability", petname) and pet:getInRoom(petname) then
        mud:send("ORDER " .. xcaster .. " cast 'globe of invulnerability' " .. petname )
        timer:set("petcast", 6)
        buff:set(petname, "globe_of_invulnerability", 15)
        return
      end
    end


    for k,char in pairs(groupList:pc("hitter")) do
      local hp=tonumber(groupList:getHP(char))

      if not buff:get("globe_of_invulnerability", char) and hp ~= 0 then
        mud:send("ORDER " .. xcaster .. " cast 'globe of invulnerability' " .. char )
        timer:set("petcast", 6)
        buff:set(char, "globe_of_invulnerability", 15)
        return
      end
    end
  end
end

function scr_pfu()
  for k,char in pairs(groupList:pc("all")) do
    if spell:attempt(char, "protection_from_undead", "pfu") then
      return(true)
    end
  end

  return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>InvScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Inv"] = powersTable["Inv"] or {}
powersTable["Inv"][""] =
            {
{ "mf", "mage_flame", nil, "", nil, 1, 1},
{ "erase", "erase", nil, "", nil, 1, 1},
{ "dm", "detect_magic", nil, "", nil, 1, 1},
{ "di", "detect_invisibility", nil, "", nil, 1, 1},
{ "ct", "chill_touch", "Chill|Touch", "automissile", nil, 1, 1},
{ "bh", "burning_hands", "Burning|Hands", "automissile", nil, 1, 1},
{ "sg", "shocking_grasp", "Shocking|Grasp", "automissile", nil, 6, 1},
{ "minor", "minor_creation", nil, "", nil, 6, 1},
{ "ff", "faerie_fire", "Faerie|Fire", "autoffire", nil, 6, 1},
{ "acb", "acid_blast", "Acid|Blast", "automissile", nil, 6, 1},
{ "loco", "locate_object", nil, "", nil, 11, 1},
{ "lb", "lightning_bolt", "Lightning|Bolt", "automissile", nil, 11, 1},
{ "invis", "invisibility", nil, "", nil, 11, 1},
{ "tele", "teleport", nil, "", nil, 16, 1},
{ "ray", "ray_of_enfeeblement", "Enfeeble", "", nil, 16, 1},
{ "msw", "mordenkainens_sword", "Mordenkainens|Sword", "automissile", nil, 16, 1},
{ "minp", "minor_paralysis", nil, "", nil, 16, 1},
{ "lv", "levitate", nil, "", nil, 16, 1},
{ "fbl", "fireball", "Fireball", "autoarea", nil, 16, 1},
{ "fs", "farsee", nil, "", nil, 16, 1},
{ "dism", "dispel_magic", nil, "", nil, 16, 1},
{ "slow", "slowness", nil, "", nil, 21, 1},
{ "iv", "infravision", nil, "", nil, 21, 1},
{ "fsh", "fireshield", nil, "", nil, 21, 1},
{ "dim", "dimension_door", nil, "", nil, 21, 1},
{ "cone", "cone_of_cold", "Cone Of|Cold", "autoarea", nil, 21, 1},
{ "is", "ice_storm", "Ice Storm", "autoarea", nil, 21, 1},
{ "csh", "coldshield", nil, "", nil, 21, 1},
{ "ma", "melfs_acid_arrow", "Melfs Acid|Arrow", "automissile", nil, 26, 1},
{ "clv", "clairvoyance", nil, "", nil, 26, 1},
{ "chain", "chain_lightning", nil, "", nil, 26, 1},
{ "mg", "magic_missile", "Magic|Missile", "automissile", nil, 1, 1},
{ "pws", "power_word_stun", nil, "", nil, 31, 1},
{ "bcf", "bigbys_clenched_fist", "Bigbys|Fist", "autohlmissile", nil, 31, 1},
{ "mm", "minute_meteors", "Minute|Meteors", "automissile", nil, 11, 1},
{ "tb", "thunderblast", nil, "", nil, 36, 1},
{ "mp", "major_paralysis", nil, "", nil, 36, 1},
{ "bb", "blazing_beam", "Blazing|Beam", "automissile", nil, 26, 1},
{ "frost", "fell_frost", "Fell|Frost", "autohlmissile", nil, 41, 1},
{ "fm", "force_missile", "Force|Missile", "autohlmissile", nil, 36, 1},
{ "sb", "sandblast", "Sand|Blast", "autohlmissile", nil, 46, 1},
{ "ic", "incendiary_cloud", "Incendiary|Cloud", "autohlarea", nil, 31, 1},
{ "ms", "meteorswarm", "Meteor|Swarm", "autohlarea", nil, 41, 1},
{ "relo", "relocate", nil, "", nil, 41, 1},
{ "gate", "gate", nil, "", nil, 41, 1},
{ "bl", "ball_lightning", "Ball|Lightning", "autohlarea", nil, 46, 1},
{ "inf", "inferno", "Inferno", "autohlarea", nil, 46, 1},
{ "ss", "sandstorm", "Sandstorm", "autostorm", nil, 46, 1},
      }

function initInv()
  powerAliases:addButtons()
end

function SpellsInv()

  -- if fighting - sandstorm
  if charData:get("autostorm") and not timer:get("sandstorm") then
    if getSpellCount("sandstorm") &gt; 0 then
      if inCombat() and spell:count() == 0 then
        spell:cast("ss")
      end
    end
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end

  -- if fighting and no other spells - ray of frost
  if charData:get("automissile") then
    if inCombat() and spell:count() == 0 then
      spell:cast("rf")
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>IllScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Ill"] = powersTable["Ill"] or {}
powersTable["Ill"][""] =
            {
{"mf", "mage_flame", nil, "", nil, 1, 1},
{"erase", "erase", nil, "", nil, 1, 1},
{"dm", "detect_magic", nil, "", nil, 1, 1},
{"di", "detect_invisibility", nil, "", nil, 1, 1},
{"minor", "minor_creation", nil, "", nil, 6, 1},
{"invis", "invisibility", nil, "", nil, 6, 1},
{"ff", "faerie_fire", "Faerie|Fire", "autoffire", nil, 6, 1},
{"disi", "dispel_invisible", nil, "", nil, 6, 1},
{"bt", "blackthorns", "Black|Thorns", "automissile", nil, 6, 1},          
{"pa", "phantom_armor", nil, "", nil, 11, 1},
{"massi", "mass_invisibility", nil, "", nil, 11, 1},
{"loco", "locate_object", nil, "", nil, 11, 1},
{"chs", "change_self", nil, "", nil, 11, 1},          
{"tele", "teleport", nil, "", nil, 11, 1},
{"sp", "spook", "Spook", "automissile", nil, 16, 1},
{"sct", "scarlet_outline", "Scarlet|Outline", "autoffire", nil, 16, 1},
{"pst", "phantom_steed", nil, "", nil, 16, 1},
{"lv", "levitate", nil, "", nil, 16, 1},
{"fs", "farsee", nil, "", nil, 16, 1},
{"dism", "dispel_magic", nil, "", nil, 16, 1},
{"btf", "beautify", nil, "", nil, 16, 1},
{"ts", "true_sight", nil, "", nil, 16, 1},
{"shm", "shadow_magic", "Shadow|Magic", "automissile", nil, 21, 1},
{"sb", "shadow_burst", "Shadow|Burst", "autoarea", nil, 21, 1},
{"dpl", "doppleganger", "Dopple|Ganger", "autodoppel", nil, 21, 1},
{"dim", "dimension_door", nil, "", nil, 21, 1},
{"tq", "tranquility", nil, "", nil, 26, 1},
{"shade", "summon_shade", nil, "", nil, 26, 1},
{"non", "nondetection", nil, "", nil, 26, 1},
{"ds", "displacement", "Displcmnt", "autodisplace", nil, 26, 1},
{"clv", "clairvoyance", nil, "", nil, 26, 1},
{"bolt", "shadow_bolt", "Shadow|Bolt", "automissile", nil, 1, 1},
{"sf", "shadow_flux", nil, "", nil, 31, 1},
{"sh", "shadechill", "Shadechill", "autohlmissile", nil, 31, 1},
{"sq", "sequester", nil, "", nil, 31, 1},
{"pb", "phantasmal_blades", "Phantasml|Blades", "autohlarea", nil, 31, 1},
{"cglam", "corpse_glamor", nil, "", nil, 31, 1},
{"camo", "camouflage", nil, "", nil, 31, 1},
{"sshd", "sun_shadow", nil, "", nil, 36, 1},
{"rp", "rainbow_pattern", nil, "", nil, 36, 1},
{"pheal", "phantom_heal", "Phantom|Heal", "autoheal", nil, 36, 1},
{"ml", "mislead", nil, "", nil, 36, 1},
{"mi", "mirror_image", nil, "", nil, 36, 1},
{"fnd", "feign_death", nil, "", nil, 36, 1},
{"fold", "dimensional_fold", nil, "", nil, 36, 1},
{"pk", "phantasmal_killer", "Phantasml|Killer", "autohlmissile", nil, 41, 1},
{"massm", "massmorph", nil, "", nil, 41, 1},
{"gate", "gate", nil, "", nil, 41, 1},
{"swalk", "shadow_walk", nil, "", nil, 41, 1},
{"nm", "nightmare", "Nightmare", "autohlmissile", nil, 46, 1},
{"pt", "phantasmal_tendrils", "Phantasml|Tendrils", "autohlarea", nil, 46, 1}
          }

function initIll()
  powerAliases:addButtons()

  addbutton("displacement", 0, 7, 26)
  addbutton("doppleganger", 0, 9, 31)
  -- addbutton("massmorph", 0, 10, 41)
end

function massmorph(fname, xcommand)
  if xcommand == buttons.UPDATE then
--    updateButton(fname)
    return
  end

  if xcommand ~= buttons.INIT then
    spell:cast("massmorph")
  end

  setLabelImage(fname, "massmorph-on.png")

end

function SpellsIll()

  -- phantom heal main tank if injured
  if charData:get("autoheal") then

    if scr_phantomheal() then
      return
    end
  end

  -- cast mirror image on self if needed and possible
  if getSpellCount("mirror_image") &gt; 0 then
    if not buff:get("mirror_image") then
      spell:cast("mi")
      return
    end
  end

  if charData:get("autodisplace") then
    if scr_displace() then
      return
    end
  end

  if charData:get("autodoppel") then
    if scr_doppelganger() then
      return
    end
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end

end

function scr_doppelganger()
  for k,char in pairs(groupList:pc("all")) do
    if spell:attempt(char, "doppleganger", "dopple") then
      return(true)
    end
  end

  return(false)
end

function scr_displace()
--  if inCombat() and spell:count() == 0 then
--    if spell:attempt(prompt:get("tank"), "displacement", "ds") then
--      return(true)
--    end
--  end

  for k,char in pairs(groupList:pc("displace")) do
--  for k,char in pairs(groupList:pc("all")) do
    if spell:attempt(char, "displacement", "ds") then
      return(true)
    end
  end

  --local wuss=charData:get("wuss")

  --if groupList:ingroup( wuss ) then
  --  if spell:attempt(wuss, "blur", "blur") then
  --    return(true)
  --  end
  --end
end

function scr_phantomheal()
  -- phantom heal anyone at &lt; .5 maxhp

  for k,char in pairs(groupList:pc()) do
    local hp=tonumber(groupList:getHP(char))
    local maxhp= tonumber(groupList:getMaxHP(char))

    if spell:getCurrent() ~= ("pheal " .. char) then
      if getSpellCount("phantom_heal") &gt; 0 then
        if hp &lt; .5 * maxhp then
          echoDebug("&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting pheal on " .. char .. "]")
          spell:cast("pheal " .. char)
          return(true)
        end
      end
    end
  end

  return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>DruScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Dru"] = powersTable["Dru"] or {}
powersTable["Dru"][""] =
            {   
{"shl", "shillelagh", "Shillelagh", "automissile", nil, 1, 1},
{"gdb", "goodberry", "Good|Berry", "", nil, 1, 1},
{"dm", "detect_magic", nil, "", nil, 1, 1},
{"curel", "cure_light", "Cure|Light", "autoheal", nil, 1, 1},
{"crw", "create_water", "Create|Water", "", nil, 1, 1},
{"caul", "cause_light", "Cause|Light", "autoharm", nil, 1, 1},
{"word", "word_of_recall", "Word Of|Recall", "", nil, 6, 1},
{"vl", "vigorize_light", "Vigorize|Light", "", nil, 6, 1},
{"pfan", "protection_from_animals", "Prot From|Animals", "", nil, 6, 1},
{"prs", "preserve", nil, "", nil, 6, 1},
{"ff", "faerie_fire", "Faerie|Fire", "autoffire", nil, 6, 1},
{"dg", "detect_good", nil, "", nil, 6, 1},
{"de", "detect_evil", nil, "", nil, 6, 1},
{"cs", "cure_serious", "Cure|Serious", "autoheal", nil, 6, 1},
{"causs", "cause_serious", "Cause|Serious", "autoharm", nil, 6, 1},
{"bls", "bless", nil, "", nil, 6, 1},
{"vs", "vigorize_serious", nil, "", nil, 11, 1},
{"si", "summon_insects", "Summon|Insects", "automissile", nil, 11, 1},
{"rp", "remove_poison", "Remove|Poison", "", nil, 11, 1},
{"pfl", "protection_from_lightning", nil, "", nil, 11, 1},
{"pfg", "protection_from_gas", nil, "", nil, 11, 1},
{"pff", "protection_from_fire", nil, "", nil, 11, 1},
{"pfc", "protection_from_cold", nil, "", nil, 11, 1},
{"pfa", "protection_from_acid", nil, "", nil, 11, 1},
{"ffog", "faerie_fog", "Faerie|Fog", "", nil, 11, 1},
{"bark", "barkskin", "Barkskin", "", nil, 11, 1},
{"sum", "summon", nil, "", nil, 16, 1},
{"sen", "sense_life", nil, "", nil, 16, 1},
{"eaq", "earthquake", "Earth|Quake", "autoquake", nil, 16, 1},
{"dd", "dust_devil", "Dust|Devil", "automissile", nil, 16, 1},
{"ccr", "cure_critic", "Cure|Critical", "autoheal", nil, 16, 1},
{"csp", "create_spring", "Create|Spring", "", nil, 16, 1},
{"cauc", "cause_critical", "Cause|Critical", "autoharm", nil, 16, 1},
{"vc", "vigorize_critic", "Vigorize|Critic", "", nil, 21, 1},
{"sr", "sunray", "Sunray", "", nil, 21, 1},
{"rd", "raise_dead", "Raise|Dead", "", nil, 21, 1},
{"hm", "harm", "Harm", "autoharm", nil, 21, 1},
{"dism", "dispel_magic", "Dispel|Magic", "", nil, 21, 1},
{"cnw", "control_weather", "Control|Weather", "", nil, 21, 1},
{"vt", "vitality", "Vitality", "autovit", nil, 26, 1},
{"suf", "suffocate", "Suffocate", "", nil, 26, 1},
{"ip", "insect_plague", "Insect|Plague", "autoarea", nil, 26, 1},
{"hl", "heal", "Heal", "autoheal", nil, 26, 1},
{"fst", "firestorm", "Firestorm", "autoarea", nil, 26, 1},
{"fe", "fear", "Fear", "", nil, 26, 1},
{"cnl", "continual_light", "Continual|Light", "", nil, 26, 1},
{"cstf", "changestaff", "Change|Staff", "", nil, 26, 1},
{"sts", "sticks_to_snakes", "Sticks To|Snakes", "automissile", nil, 6, 1},
{"pwt", "pass_without_trace", "Pass Without|Trace", "", nil, 31, 1},
{"gvid", "group_vigorize", "Group|Vigorize", "", nil, 31, 1},
{"fb", "flame_blade", "Flame|Blade", "autohlmissile", nil, 31, 1},
{"cy", "cyclone", "Cyclone", "autohlarea", nil, 31, 1},
{"wb", "water_breathing", "Water|Breathing", "", nil, 36, 1},
{"ss", "spiked_stones", "Spiked|Stones", "autohlmissile", nil, 36, 1},
{"rktm", "rock_to_mud", "Rock To|Mud", "", nil, 36, 1},
{"mudtr", "mud_to_rock", "Mud To|Rock", "", nil, 36, 1},
{"fs", "fire_seeds", "Fire|Seeds", "autohlmissile", nil, 36, 1},
{"hs", "hailstorm", "Hailstorm", "autohlarea", nil, 41, 1},
{"eng", "entangle", "Entangle", "", nil, 41, 1},
{"des", "dessicate", "Dessicate", "autohlarea", nil, 41, 1},
{"psh", "plane_shift", "Plane|Shift", "", nil, 41, 1},
{"gbark", "group_barkskin", "Group|Barkskin", "", nil, 46, 1},
{"cd", "creeping_doom", "Creeping|Doom", "", nil, 46, 1},
{"mw", "moonwell", "Moonwell", "", nil, 46, 1},
            }
            
function initDru()
  powerAliases:addButtons()

  --mud:send("powers info vit")
end

function SpellsDru()
  -- earthquakes
  if castQuake() then
    return
  end

  -- cure critic main tank if injured
  if charData:get("autoheal") then
    local tank=prompt:get("tank")

    if tank ~= "" then
      local char=tank
      local hp=tonumber(groupList:getHP(char))
      local maxhp= tonumber(groupList:getMaxHP(char))
      local percent = hp/maxhp

      if getSpellCount("cure_critic") &gt; 0 and percent &lt; .85 then
        spell:cast("ccr " .. char)
        return
      end
    end
  end

  -- queue vitality
  if charData:get("autovit") and charData:get("level") &gt;= 26 then
    if   scr_vitality() then
      return
    end
  end

  -- if fighting and no other spells cast damage spells
  if powerAliases:castDamage() then
    return
  end

  if charData:get("automissile") then
    if inCombat() and spell:count() == 0 then
      spell:cast("tw")
      return
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>RanScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Ran"] = powersTable["Ran"] or {}
powersTable["Ran"][""] =
    {
      {"fa", "furious_assault", nil, "", nil, 1 },
    
      {"tr", "triple_shot", "Triple|Shot", "rantr", 12, 1, nil, "Bow" }, 
      {"ks", "knockdown_shot", "Knckdown|Shot", "ranks", 3, 5, nil, "Bow"},      
      {"sp", "splintering_shot", "Splinter|Shot", "ransp", 14, 15, nil, "Bow" },
      {"cn", "concussive_shot", "Concusve|Shot", "rancn", 13, 25, nil, "Bow" },
      {"ha", "hail_of_arrows", "Hail Of|Arrows", "ranha", 15, 30, nil, "Bow" },
      
      {"ts", "twin_strike", "Twin|Strike", "rants", 12, 1, nil, "Dual" },
      {"ss", "sweeping_strike", "Sweeping|Strike", "ranss", 3, 5, nil, "Dual" },
      {"ap", "armor_splinter", "Armor|Splinter", "ranap", 14, 15, nil, "Dual" },
      {"ev", "eviscerate", "Evscerate", "ranev", 13, 25, nil, "Dual" },
      {"bs", "bladestorm", "Blade|Storm", "ranbs", 15, 30, nil, "Dual" },
      
      {"lst", "longstrider", nil, "", nil, 1 },
      {"hm", "hunters_mark", "Hunters|Mark", "ranhm", 5, 1, 4 },
      {"clv", "cloak_of_vigor", nil, "", nil, 1 },
      {"dr", "dawns_renewal", nil, "", nil, 10 },
      {"clw", "cloak_of_the_winds", "The|Winds", "ranclw", 7, 10, 4 },
      {"bse", "beast_sense", nil, "", nil, 10 },
      {"lita", "lightning_arrow", "Lightning|Arrow", "ranlita", 11, 20, 4, "Bow" },
      {"clp", "cloak_of_protection", "Cloak Of|Protect", "ranclp", 6, 20, 4 },
      {"bof", "blades_of_fire", "Blades Of|Fire", "ranbof", 9, 20, 4, "Dual" },
      {"trs", "tree_stride", nil, "", nil, 30 },
      {"hot", "hail_of_thorns", "Hail Of|Thorns", "ranhot", 9, 30, 4, "Bow" },
      {"eld", "electric_discharge", "Electric|Discharge", "raneld", 11, 30, 4, "Dual" },
      {"clr", "cloak_of_resilience", "Resilience", "ranclr", 8, 30, 4 },
      {"msp", "misty_path", "Misty|Path", "ranmsp", 4, 40 },
      {"grf", "greenfire", "Greenfire", "rangrf", 10, 40, 4, "Dual"},
      {"cll", "cloak_of_life", "Cloak of|Life", "", nil, 40},
      {"ab", "arctic_barrage", "Arctic|Barrage", "ranab", 10, 40, 4, "Bow"}
    }

function initRan()
  meleePowers:addButtons()

  addbutton("autohide", 0, 2, 1)
  addbutton("auto_heal", 0, 1, 10)
end

function auto_heal(fname, xcommand)
  shiftSkillButton("auto_heal", "auto_heal", xcommand)
end

function procPromptRan()
  -- Dual Weapon powers
  if equip:getWeapon() == "Dual" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("ss") then return end -- sweeping strike
      end
    end

    if meleePowers:use("bs") then return end -- bladestorm
    
    if not timer:get("wraithform") then
      if meleePowers:use("ap") then return end -- armor splinter
    end
    
    if meleePowers:use("ev") then return end -- eviscerate
    if meleePowers:use("ts") then return end -- twin strike
  end

  -- Archery powers
  if equip:getWeapon() == "Bow" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("ks") then return end -- knockdown shot
      end
      
      if meleePowers:use("cn") then return end -- concussive shot
    end

    if meleePowers:use("ha") then return end -- hail of arrows
    
    if not timer:get("wraithform") then
      if meleePowers:use("sp") then return end -- splintering shot
    end
    
    if meleePowers:use("cn") then return end -- concussive shot
    if meleePowers:use("tr") then return end -- triple shot
  end
end

function SpellsRan()
  local healSlot = 0
  local percent=prompt:get("hp%")

  -- can't cast if stunned, parad, in fugue, etc
  if not spell:castOK() then
    return
  end

  
  if charData:get("auto_heal") then
    healSlot=1
  end

  -- misty path
  if charData:get("ranmsp") then
    if not buff:get("misty_path") and spell:getSlot(5) &gt; 0 then
      spell:cast("MSP")
      return
    end
  end

  -- Only use cloaks if in combat
  
  if inCombat() then
    if charData:get("ranclr") then
      if not buff:get("cloak_of_resilience") and spell:getSlot(4) &gt; 0 then
        if percent &lt; tonumber(charData:get("ranclrpct")) then
          spell:cast("CLR")
          return
        end
      end
    end

    if charData:get("ranclp") then
      if not buff:get("cloak_of_protection") and spell:getSlot(3) &gt; 0 then
        if percent &lt; tonumber(charData:get("ranclppct")) then
          spell:cast("CLP")
          return
        end
      end
    end
  end

  -- offensive spells

  if inCombat() then
    
    -- hunters mark
    if charData:get("ranhm") then
      if not (spell:getCast())["hm"] and spell:getSlot(1) &gt; 0 then
        spell:setCast("hm")
        spell:cast("HM")
        return
      end
    end
    
    if charData:get("ranclw") then
      if not buff:get("cloak_of_the_winds") and spell:getSlot(2) &gt; healSlot then
        spell:cast("CLW")
        return
      end
    end

    -- Dual wield spell powers
    if equip:getWeapon() == "Dual" then
      -- Electric Discharge: don't cast if you want cloak of resilience (same circle)
      if charData:get("raneld") and not charData:get("ranclr") then
        if not buff:get("electric_discharge") and spell:getSlot(4) &gt; healSlot then
          spell:cast("ELD")
          return
        end
      end

      -- Greenfire
      if charData:get("rangrf") then
        if not buff:get("greenfire") and not buff:get("blades_of_fire") and spell:getSlot(5) &gt; healSlot then
          spell:cast("GRF")
          return
        end
      end

      -- Blades of Fire: don't cast if you want cloak of protection (same circle)
      if charData:get("ranbof") and not charData:get("ranclp") then
        if not buff:get("blades_of_fire") and not buff:get("greenfire") and spell:getSlot(3) &gt; healSlot then
          spell:cast("BOF")
          return
        end
      end
    end
    
    -- bow spell powers
  
    if equip:getWeapon() == "Bow" then
      -- Hail of Thorns: don't cast if you want cloak of resilience (same circle)
      if charData:get("ranhot") and not charData:get("ranclr") then
        if not buff:get("hail_of_thorns") and spell:getSlot(4) &gt; healSlot then
          spell:cast("HOT")
          return
        end
      end

      -- Arctic Barrage
      if charData:get("ranab") then
        if not buff:get("arctic_barrage") and spell:getSlot(5) &gt; healSlot then
          spell:cast("AB")
          return
        end
      end

      -- Lightning Arrow: don't cast if you want cloak of protection (same circle)
      if charData:get("ranlita") and not charData:get("ranclp") then
        if not buff:get("lightning_arrow") and spell:getSlot(3) &gt; healSlot then
          spell:cast("LITA")
          return
        end
      end
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PalScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Pal"] = powersTable["Pal"] or {}
powersTable["Pal"][""] =
    {
      {"fa", "furious_assault", 1},
      {"guard", "guard", "Guard", "palguard", 11, 30},
    
      {"lh", "lay_on_hands", "Lay On|Hands", "pallh", 1, 1, nil, "All"},
      {"ds", "divine_smite", "Divine|Smite", "palds", 2, 1, nil, "All" },
      {"tn", "true_nemesis", nil, "paltn", nil, 30},
      {"dc", "divine_challenge", "Divine|Challenge", "paldc", 12, 1, nil, "All"},

      {"bs", "bolstering_strike", "Bolsterng|Strike", "palbs", 14, 1, nil, "Shield"},
      {"rc", "radiant_charge", "Radiant|Charge", "palrc", 3, 5, nil, "Shield"},
      {"ss", "shielding_smite", "Shielding|Smite", "palss", 9, 15, nil, "Shield"},
      {"es", "enervating_smite", "Enervating|Smit", "pales", 10, 25, nil, "Shield"},
      {"ws", "wrathful_smite", "Wrathful|Smite", "palws", 15, 30, nil, "Shield"},

      {"vs", "valiant_strike", "Valiant|Strike", "palvs", 14, 1, nil, "TwoHand"},
      {"ts", "thunderous_smite", "Thunder|Smite", "palts", 3, 5, nil, "TwoHand"},
      {"brs", "brilliant_smite", "Brilliant|Smite", "palbrs", 9, 15, nil, "TwoHand"},
      {"trs", "terrifying_smite", "Terror|Smite", "paltrs", 10, 25, nil, "TwoHand"},
      {"wws", "whirlwind_smite", "Whirlwind|Smite", "palwws", 15, 30, nil, "TwoHand"},
      
      {"sf", "shield_of_faith", "Shield Of|Faith", "palsf", 8, 1, nil, "All"},
      {"hr", "heroism", "Heroism", "", nil, 1},
      {"hl", "healing_light", "Healing|Light", "", nil, 10},
      {"ag", "aura_of_glory", "Aura Of|Glory", "", nil, 10},
      {"boj", "brand_of_judgement", "Brand Of|Judgement", "palboj", 5, 20, nil, "All"},
      {"hs", "holy_sword", "Holy|Sword", "", nil, 20, nil, "All"},
      {"cs", "cleansing_spirit", "Cleaning|Sprit", "", nil, 20},
      {"db", "divine_bolt", "Divine|Bolt", "", nil, 30, nil, "All"},
      {"ns", "noble_shield", "Noble|Shield", "", nil, 30, nil, "All"},
      {"sw", "shield_of_warding", "Shield Of|Warding", "palsw", 8, 30, nil, "All"},
      {"sb", "sunburst", "Sunburst", "", nil, 40, nil, "All"},
      {"al", "aura_of_life", "Aura Of|Life", "palal", 7, 40, nil, "All"},
    }

function initPal()
  addbutton("damage_spells", 0, 6, 30)
  
  meleePowers:addButtons()
end

function procPromptPal()
  local hp=prompt:get("hp")
  local maxhp=prompt:get("maxhp")
  local percent=prompt:get("hp%")
  
  if getBashing() then
    return
  end

  -- blind needs to be checked here
  if (buff:get("blind") or buff:get("blindness")) and spell:getSlot(3) &gt; 0 then
    if spell:castOK() then
      spell:cast("CS")
    end
    return
  end
  
  -- melee powers

  -- taunts : need to change usage

  if meleePowers:use("dc") then return end -- divine challenge

  if prompt:get("tank") ~= "" and prompt:get("tank") ~= whoami() then
    if meleePowers:use("tn") then return end -- true nemesis
  end

  -- divine smite
  if meleePowers:use("ds") then return end 

  -- lay hands : use if pallh is enabled, full heal spells available

  if charData:get("pallh") then
    if not timer:get("lay_on_hands") and percent &lt; 50 then
      if meleePowers:use("lh") then return  end  
    end
  end


  -- 1h/shield melee powers
  if equip:getWeapon() == "Shield" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("rc") then return end -- radiant charge
      end
    end

    if meleePowers:use("ss") then return end -- shielding smite

    if maxhp-hp &gt; 50 then
      if meleePowers:use("bs") then return end --bolstering strike
    end
    
    if meleePowers:use("ws") then return end -- wrathful smite
    if meleePowers:use("es") then return end --enervating smite
    if meleePowers:use("bs") then return end --bolstering strike
  end
  
  -- 2h powers
  if equip:getWeapon() == "TwoHand" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("ts") then return end -- thunderous smite
      end
    end

    if meleePowers:use("trs") then return end --terrifying smite
    if meleePowers:use("vs") then return end --valiant strike
    if meleePowers:use("brs") then return end --brilliant smite
    if meleePowers:use("wws") then return end --whirlwind smite
  end
end

function SpellsPal()
  local healSlot = 0

  -- can't cast if stunned, parad, in fugue, etc
  if not spell:castOK() then
    return
  end

  if charData:get("pallh") then
    healSlot=1
  end

  -- blinded

  if (buff:get("blind") or buff:get("blindness")) and spell:getSlot(3) &gt; 0 then
    if spell:getSlot(3) &gt; 0 then
      spell:cast("CS")
      return
    else

    end
  end

  if inCombat() then
    -- shield of faith
    if charData:get("palsf") and charData:get("level") &lt; 30 then
      if not buff:get("shield_of_faith") and spell:getSlot(1) &gt; 0 then
        spell:cast("SF")
        return
      end
    end
    
    -- shield of warding
    if charData:get("palsw") then
      if not buff:get("shield_of_warding") and spell:getSlot(4) &gt; 0 then
        spell:cast("SW")
        return
      end
    end

    -- aura of life
    if charData:get("palal") then
      if not buff:get("aura_of_life") and spell:getSlot(5) &gt; 0 then
        spell:cast("AL")
        return
      end
    end
  
    -- brand of judgement
    if charData:get("palboj") then
      if not (spell:getCast())["boj"] and spell:getSlot(3) &gt; healSlot then
        spell:setCast("boj")
        spell:cast("BOJ")
        return
      end
    end
  
      -- damage spells
    
    if charData:get("autodspells") then
      -- sunburst
      if spell:getSlot(5) &gt; healSlot then
        spell:cast("SB")
        return
      end  

      -- corrupt weapon
      if not buff:get("holy_sword") and spell:getSlot(3) &gt; healSlot then
        spell:cast("hs")
        return
      end
  
      -- divine bolt
      if spell:getSlot(4) &gt; healSlot then
        spell:cast("db")
        return
      end
    end
  end
  
  return
end

function guard(fname, xcommand)
  if xcommand == buttons.INIT then
    if charData:get("palguard") then
      setLabelImage(fname, fname .. "-on.png")
    else
      setLabelImage(fname, fname .. "-off.png")
    end
    return
  end
    
  if xcommand == buttons.CLICK then
    shiftSkillButton(fname, "palguard", xcommand)
  
    if charData:get("palguard") then
      if groupList:ingroup( charData:get("wuss") ) then
        mud:send("guard " .. charData:get("wuss"))
      end
    else
      mud:send("guard me")
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>BlkScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Blk"] = powersTable["Blk"] or {}
powersTable["Blk"][""] =
    { {"fa", "furious_assault", 1},
    
      {"bc", "baleful_challenge", "Baleful|Challenge", "blkbc", 12, 45, nil, "All"},
      {"sot", "soul_touch", "Soul|Touch", "blksot", 1, 1, nil, "All"},
      {"drs", "dread_smite", "Dread|Smite", "blkdrs", 2, 1, nil, "All"},
      
      {"fr", "ferocious_rebuke", "", "blkfr", nil, 30},
      
      {"ps", "plundering_smite", "Plundrng|Smite", "blkps", 14, 1, nil, "Shield"},
      {"ds", "dominating_smite", "Domnatng|Smite", "blkds", 3, 5, nil, "Shield"},
      {"dm", "dark_majesty", "Dark|Majesty", "blkdm", 9, 15, nil, "Shield"},
      {"rs", "ruinous_smite", "Ruinous|Smite", "blkrs", 10, 25, nil, "Shield"},
      {"fs", "frenzying_smite", "Frenzying|Smite", "blkfs", 15, 30, nil, "Shield"},
      
      {"vs", "vengeance_strike", "Vengeance|Strike", "blkvs", 14, 1, nil, "TwoHand"},
      {"ss", "shattering_smite", "Shattering|Smite", "blkss", 3, 5, nil, "TwoHand"},
      {"md", "mortal_dread", "Mortal|Dread", "blkmd", 9, 15, nil, "TwoHand"},
      {"sph", "spirit_harrow", "Spirit|Harrow", "blksph", 10, 25, nil, "TwoHand"},
      {"uf", "uncontrolled_fury", "Uncntrld|Fury", "blkuf", 15, 30, nil, "TwoHand"},

      {"ua", "umbral_armor", "Umbral|Armor", "", nil, 1, nil, "All" },
      {"db", "dark_blessing", "Dark|Blessing", "", nil, 1, nil, "All" },
      {"sh", "shadow_healing", "Shadow|Healing", "", nil, 10},
      {"aod", "aspect_of_domination", nil, "", nil, 10 },
      {"sp", "sigil_of_pain", "Sigil Of|Pain", "blksp", 5, 20, nil, "All"},
      {"cw", "corrupt_weapon", "Corrupt|Weapon", "", nil, 20, nil, "All" },
      {"cs", "consumption", "Consumption", "", nil, 20 },
      {"soa", "scourge_of_agony", "Scourge Of|Agony", "", nil, 30 },
      {"dg", "dark_grace", "Dark|Grace", "", nil, 30 },
      {"sos", "shroud_of_shadow", "ShroudOf|Shadow", "blksos", 8, 30, nil, "All" },
      {"rav", "ravenous_shadows", "Ravenous|Shadows", "", nil, 40 },
      {"ad", "aura_of_death", "Aura Of|Death", "blkad", 7, 40, nil, "All" }
    }

function initBlk()
  addbutton("poisonRogue", 0, 11, 30)
  addbutton("damage_spells", 0, 6, 30)

  meleePowers:addButtons()
end

function procPromptBlk()
  local percent=prompt:get("hp%")
  
  if getBashing() then
    return
  end

  -- blind needs to be checked here
  if buff:get("blind") or buff:get("blindness") and spell:getSlot(3) &gt; 0 then
    if spell:castOK() then
      spell:cast("CS")
    end
    return
  end
  
  -- melee powers

  -- taunts : need to change usage - should be after spells, not before
  -- minimum 85% health to use

  if percent &gt; 85 then
    if meleePowers:use("bc") then return end -- baleful challenge

    if charData:get("blktn") then
      if timer:get("true_nemesis") == nil and not timer:get("cooldown") then
        if prompt:get("tank") ~= "" and prompt:get("tank") ~= whoami() then
          useMeleePower("tn")
          return
        end
      end
    end
  end

  if meleePowers:use("drs") then return end -- dread smite

  -- soul touch : use if blksot is enabled, full heal spells available

  if charData:get("blksot") then
    if not timer:get("soul_touch") and percent &lt; 50 then
      if meleePowers:use("sot") then return  end  
    end
  end

  -- 1h/shield melee powers
  if equip:getWeapon() == "Shield" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("ds") then return end -- dominating smite
      end
    end

    if meleePowers:use("dm") then return end -- dark majesty

    -- plundering smite is 120% max
    if percent &lt; 120 then
      if meleePowers:use("ps") then return end -- plundering smite
    end

    if meleePowers:use("fs") then return end -- frenzying smite
    if meleePowers:use("rs") then return end -- ruinous smite
  end

  -- 2h powers
  if equip:getWeapon() == "TwoHand" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("ss") then return end -- shattering smite
      end
    end

    if meleePowers:use("md") then return end -- mortal dread
    if meleePowers:use("vs") then return end -- vengeance strike
    if meleePowers:use("sph") then return end -- spirit harrow
    if meleePowers:use("uf") then return end -- uncontrolled fury
  end
end

function SpellsBlk()
  local healSlot = 0

  -- can't cast if stunned, parad, in fugue, etc
  if not spell:castOK() then
    return
  end

  if charData:get("blksot") then
    healSlot=1
  end

  -- blinded (consumption to heal)

  if buff:get("blind") or buff:get("blindness") and spell:getSlot(3) &gt; 0 then
    -- display("blind, casting CS")
    spell:cast("CS")
    return
  end
    
  if inCombat() then
    -- shroud of shadow
    if charData:get("blksos") then
      if not buff:get("shroud_of_shadow") and spell:getSlot(4) &gt; 0 then
        spell:cast("SOS")
        return
      end
    end

    -- aura of death
    if charData:get("blkad") then
      if not buff:get("aura_of_death") and spell:getSlot(5) &gt; 0 then
        spell:cast("AD")
        return
      end
    end

    -- if baleful challenege is active, use aspect of domination
    
    if charData:get("blkbc") then
      if not buff:get("aspect_of_domination") and spell:getSlot(2) &gt; healSlot then
        spell:cast("AOD")
        return
      end
    end
    
    -- sigil of pain
    if charData:get("blksp") then
      if not (spell:getCast())["sp"] and spell:getSlot(3) &gt; healSlot then
        spell:setCast("sp")
        spell:cast("SP")
        return
      end
    end
  
    -- damage spells
    
    if charData:get("autodspells") then
      -- ravenous shadows
      if spell:getSlot(5) &gt; healSlot then
        spell:cast("RAV")
        return
      end  

      -- corrupt weapon
      if not buff:get("corrupt_weapon") and spell:getSlot(3) &gt; healSlot then
        spell:cast("CW")
        return
      end
  
      -- scourge of agony
      if spell:getSlot(4) &gt; healSlot then
        spell:cast("SOA")
        return
      end
    end
  end
  
  return
end


function damage_spells(fname, xcommand)
  if xcommand == buttons.INIT then
    if charData:get("autodspells") then
      setLabelImage(fname, fname .. "-on.png")
    else
      setLabelImage(fname, fname .. "-off.png")
    end
    return
  end
  
  if xcommand == buttons.CLICK then
    shiftSkillButton(fname, "autodspells", xcommand)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SorDraconicScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, 1=oldcaster 2=instacast, 3=instacast+cooldown, powertype }

powersTable["Sor"] = powersTable["Sor"] or {}
powersTable["Sor"]["Draconic"] =
    { { "cw", "crackling_whip", "Crackling|Whip", "sorcw", 1, 1, 2},
      { "as", "arcane_sight", "Arcane|Sight", "", nil, 3, 2},
      { "ao", "acidic_orb", "Acidic|Orb", "sorao", 2, 5, 2},
      { "hov", "hover", "Hover", "", nil, 8, 2},
      { "ec", "ethereal_cloak", "Ethereal|Cloak", "", nil, 10, 2},
    }

function initSorDraconic()
  meleePowers:addButtons()
end

function SpellsSorDraconic()
  
  if timer:get("cooldown") then -- change to spell cooldown
    --display( timer:get("cooldown") )
    return
  end
    
  if inCombat() then
    if meleePowers:use("ao") then return end -- acidic orb
    if meleePowers:use("cw") then return end -- crackling whip
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>HexHellborneScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Hex"] = powersTable["Hex"] or {}
powersTable["Hex"]["Hellborne"] =
            {
      { "fa", "furious_assault", 1, nil, nil},
    
      { "su", "soulcutter", "Soul|Cutter", "hexsu", 12, 1, nil, "TwoHand"},
      { "hs", "hellstrike", "Hellstrike", "hexhs", 3, 5, nil, "TwoHand"},
      { "rb", "ruin_blade", "Ruin|Blade", "hexrb", 13, 13, nil, "TwoHand"},
      { "vf", "vortex_of_fire", "Vortex|Of Fire", "hexvf", 15, 31, nil, "TwoHand"},
      { "ib", "infernal_brand", "Infernal|Brand", "hexib", 2, 19, nil, "TwoHand"},
      { "fz", "fiendish_frenzy", "Fiendish|Frenzy", "hexfz", 14, 39, 2, "TwoHand"},
      
      { "ae", "astral_eyes", "Astral|Eyes", "", nil, 1},
      { "ss", "spider_scuttle", "Spider|Scuttle", "", nil, 1},
      { "sf", "spectral_fade", "Spectral|Fade", "", nil, 10},
      { "er", "eldritch_renewal", "Eldritch|Renewal", "", nil, 16},
      {"hxa", "hex_of_arcane_disruption", "arcane|disrupt", "hexhxa", 5, 22, 2, "All"},
      { "ec", "eldritch_chains", "Eldritch|Chains", "hexec", 4, 25, 2},
      {"bzd", "blazing_doom", "Blazing|Doom", "hexbzd", 11, 29, 2, "TwoHand"},
      { "hxl", "hex_of_lingering_doom", "Hex of|Lingering", "hexhxl", 6, 35, 2, "TwoHand"},
      { "cof", "cloak_of_flies", "Cloak|Of Flies", "hexcof", 4, 37, 2},
      {"hxs", "hex_of_shattered_defenses", "Shatter|Defense", "hexhxs", 15, 41, 2, "TwoHand"},
      { "shs", "shadowslip", "Shadowslip", "", nil, 44},
      { "ha", "hellforged_avatar", "Hellforged|Avatar", "hexha", 10, 46, 2},
            }


function initHexHellborne()
  --display("initHexHellborne")
  
  addbutton("auto_heal", 0, 1, 10)
  
  powerAliases:addButtons()

  meleePowers:addButtons()
end

function procPromptHexHellborne()
  -- single weapon powers
  
  -- hellborne is 2h powers only

  -- 2h powers
  
  --display("procPromptHexHellborne")
  
  if equip:getWeapon() == "TwoHand" then
    if prompt:get("combo") == 3 then

      if charData:get("hexfz") and not timer:get("fiendish_frenzy") then -- fiendish frenzy
        useMeleePower("fz")
        return
      end
      
      if meleePowers:use("ib") then return end -- infernal brand
      
      if meleePowers:use("rb") then return end -- ruin blade

      if meleePowers:use("vf") then return end -- vortex of fire
    end

    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("hs") then return end -- hellstrike
      end
    end

    --if not nomagic then -- baleful hex requires voice
    --  if meleePowers:use("bh") then return end -- baleful hex
    --end

    if meleePowers:use("su") then return end -- soulcutter
  end
end

function SpellsHexHellborne()
  local healSlot = 0

  --display("SpellsHexHellborne")

  -- can't cast if stunned, parad, in fugue, etc
  if not spell:castOK() then
    return
  end
  
  if charData:get("auto_heal") then
    healSlot=1
  end

  if inCombat() then
    -- prio casting armor spells if tank, twohanded
    if prompt:get("tank") == whoami() then
      if hexArmorHellborneSpells() then return end
    end

    if hexBladeHellborneSpells() then return end

    if charData:get("hexec") and spell:getSlot(2) &gt; 0 
         and not timer:get("eldritch_chains") then -- eldritch chains
      spell:cast("EC")
      return
    end
    
    if charData:get("hexds") and spell:getSlot(4) &gt; 0 then -- death shroud
      spell:cast("DS")
      return
    end
  end
end

function hexBladeHellborneSpells()
    --display("hexBladeHellborneSpells")
    
    if charData:get("hexha") and not timer:get("hellforged_avatar") then 
        useMeleePower("ha")
        return(true)
    end
      
    if charData:get("hexhxl") and not timer:get("hex_of_lingering_doom") then 
        useMeleePower("hxl")
        return(true)
    end
    
    if charData:get("hexbzd") and not timer:get("blazing_doom") then 
        useMeleePower("bzd")
        return(true)
    end

    if charData:get("hexhxs") and not timer:get("hex_of_shattered_defenses") then 
        useMeleePower("hxs")
        return(true)
    end
end


function hexArmorHellborneSpells()
  if charData:get("hexcof") and not timer:get("cloak_of_flies") then 
    useMeleePower("cof")
    return(true)
  end
end
  
function procHexHellborneHeal()
  local hp=prompt:get("hp")
  local maxhp=prompt:get("maxhp")
  local percent=prompt:get("hp%")

  -- exit if not in combat (no tank in prompt), or map has current room as fugue
  -- this should prevent (some) proc commands from being issued in fugue

  if prompt:get("tank") == "" or map:getRoom() == 93848 then
    return
  end

  -- hexblade heal procs are used if auto_heal is enabled
  if charData:get("auto_heal") then
 
    if not timer:get("eldritch_renewal") then
      if percent &lt; 65 and prompt:get("position") == "std" then
        spell:cast("ER")
      end
    end
  end
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>HexVoidcallerScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }

powersTable["Hex"] = powersTable["Hex"] or {}
powersTable["Hex"]["Voidcaller"] =
            {
      { "fa", "furious_assault", 1, nil, nil},
    
      { "hb", "hexblast", "Hex|Blast", "hexhb", 2, 1, nil, "Dual"},
      { "sd", "smothering_darkness", "Smthring|Darkness", "hexsd", 3, 5, nil, "Dual"},
      { "ss", "starless_shield", "Starless|Shield", "hexss", 12, 13, nil, "Dual"},
      { "vs", "void_star", "Void|Star", "hexvs", 11, 31, nil, "Dual"},
      { "hh", "horrific_howl", "Horrific|Howl", "hexhh", 9, 35, nil, "Dual"},
      
      { "ae", "astral_eyes", "Astral|Eyes", "", nil, 1, nil, "All"},
      { "sct", "spider_scuttle", "Spider|Scuttle", "", nil, 8, nil, "All"},
      { "sf", "spectral_fade", "Spectral|Fade", "", nil, 10, nil, "All"},
      { "er", "eldritch_renewal", "Eldritch|Renewal", "", nil, 16, nil, "All"},
      { "geo", "gift_of_the_everliving_ones", "Gift|EverLiving", "", nil, 19, 2, "All"},
      {"hxa", "hex_of_arcane_disruption", "arcane|disrupt", "hexhxa", 5, 22, 2, "All"},
      { "ec", "eldritch_chains", "Eldritch|Chains", "hexec", 4, 25, 2},
      { "boa", "blade_of_annihilation", "Blade|Annilatn", "hexboa", 10, 20, 2},
      { "aov", "armor_of_the_void", "Armor|Of Void", "hexaov", 8, 40, 2},
      { "hxv", "hex_of_void_embrace", "Hex of|Void", "hexhxv", 6, 41, 2, "Dual"},
      { "hn", "hex_of_null_resilience", "Hex of|Null Res", "hexhn", 7, 35, 2, "Dual"}, 
      { "shs", "shadowslip", "Shadowslip", "", nil, 44, nil, "All"},      
      { "vr", "void_rift", "Void Rift", "", nil, 46, nil, "All"},
            }


function initHexVoidcaller()
  --display("initHexHellborne")
  
  addbutton("auto_heal", 0, 1, 10)
  
  powerAliases:addButtons()

  meleePowers:addButtons()
end

function procPromptHexVoidcaller()
  local hp=prompt:get("hp")
  local maxhp=prompt:get("maxhp")
  local percent=prompt:get("hp%")

  
  -- single weapon powers
  
  -- voidcaller is dual wield only

  -- dual wield powers
  
  if equip:getWeapon() == "Dual" then
    if prompt:get("enemyposition") == "std" then
      if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
        if meleePowers:use("sd") then return end -- smothering darkness
      end
    end
    
    if prompt:get("combo") == 3 then
      if charData:get("auto_heal") then
        if percent &lt; 65 and prompt:get("position") == "std" then
          spell:cast("geo") -- gift of the everliving
          return
        end
      end
      
      if meleePowers:use("ss") then return end -- starless shield
      if meleePowers:use("vs") then return end -- voidstar
    end
    
    if meleePowers:use("hh") then return end -- horrific howl

    --use hexblast if no other choice 
    if meleePowers:use("hb") then return end -- hexblast
  end
end

function SpellsHexVoidcaller()
  local healSlot = 0

  --display("SpellsHexVoidcaller")

  -- can't cast if stunned, parad, in fugue, etc
  if not spell:castOK() then
    return
  end
  
  if charData:get("auto_heal") then
    healSlot=1
  end

  if inCombat() then
    -- prio casting armor spells if tank, twohanded
    if prompt:get("tank") == whoami() then
      if hexArmorVoidcallerSpells() then return end
    end

    if hexBladeVoidcallerSpells() then return end

    if charData:get("hexec") and not timer:get("eldritch_chains") then -- eldritch chains
      useMeleePower("ec")
      return
    end
    
    if charData:get("hexhxa") and not timer:get("hex_of_arcane_disruption") then
      useMeleePower("hxa")
      return
    end
    
    if charData:get("hexds") and spell:getSlot(4) &gt; 0 then -- death shroud
      spell:cast("DS")
      return
    end
  end
end

function hexBladeVoidcallerSpells()
    --display("hexBladeHellborneSpells")
    
    if not buff:get("frostblade") and not buff:get("blade_of_annihilation") and not buff:get("blazing_doom") then
      if charData:get("hexbzd") and spell:getSlot(5) &gt; 0 then -- blazing doom
        spell:cast("BZD")
        return(true)
      end

      if charData:get("hexboa") and not timer:get("blade_of_annihilation") then -- blade of annihilation
        useMeleePower("boa")
        return(true)
      end

      if charData:get("hexfb") and spell:getSlot(1) &gt; 0 then -- frostblade
        spell:cast("FB")
        return(true)
      end
    end
end


function hexArmorVoidcallerSpells()
    --display("hexArmorHellborneSpells")
    
      if not buff:get("armor_of_the_void") and not buff:get("armor_of_hexes") and not buff:get("armor_of_winters_grasp") and not buff:get("cloak_of_flies") then --no armors
        if meleePowers:use("aov") then return(true) end -- armor of the void
      end

      if charData:get("hexaoh") and not buff:get("blur") and spell:getSlot(4) &gt; 0 then -- armor of hexes
        spell:cast("AOH")
        return(true)
      end

      if charData:get("hexawg") and spell:getSlot(3) &gt; 0 then -- armor of winters grasp
        spell:cast("AWG")
        return(true)
      end
    
      if charData:get("hexcof") and spell:getSlot(4) &gt; 0 then -- cloak of flies
        spell:cast("COF")
        return(true)
      end
end
  
function procHexVoidcallerHeal()
  local hp=prompt:get("hp")
  local maxhp=prompt:get("maxhp")
  local percent=prompt:get("hp%")

  -- exit if not in combat (no tank in prompt), or map has current room as fugue
  -- this should prevent (some) proc commands from being issued in fugue

  if prompt:get("tank") == "" or map:getRoom() == 93848 then
    return
  end

  -- hexblade heal procs are used if auto_heal is enabled
  if charData:get("auto_heal") then
    -- cast gift of the everliving ones (geo) on &lt; 70% hp

    --if spell:getSlot(2) &gt; 0 then
    --  if percent &lt; 70 and prompt:get("position") == "std" then
    --    spell:cast("GEO")
    --  end
    --end
  
    if not timer:get("eldritch_renewal") then
      if percent &lt; 55 and prompt:get("position") == "std" then
        spell:cast("ER")
      end
    end
  end
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SorWild_magicScript</name>
					<packageName></packageName>
					<script>-- { alias, fullname, buttonname, charData, buttonNumber, level, 1=oldcaster 2=instacast, 3=instacast+cooldown, powertype }

powersTable["Sor"] = powersTable["Sor"] or {}
powersTable["Sor"]["Wild_magic"] =
    { { "cb", "chaos_bolt", "Chaos|Bolt", "sorcb", 1, 1, 2},
      { "as", "arcane_sight", "Arcane|Sight", "", nil, 3, 2},
      { "eb", "entropic_blast", "Entropic|Blast", "soreb", 2, 5, 2},
      { "hov", "hover", "Hover", "", nil, 8, 2},
      { "ec", "ethereal_cloak", "Ethereal|Cloak", "", nil, 10, 2},
      { "ps", "prismatic_sphere", "Prismatic|Sphere", "sorps", 3, 13, 2},
    }

function initSorWild_magic()
  meleePowers:addButtons()
end

function SpellsSorWild_magic()
  
  if timer:get("cooldown") then -- change to spell cooldown
    --display( timer:get("cooldown") )
    return
  end
    
  if inCombat() then
    if meleePowers:use("ps") then return end -- prismatic sphere
    if meleePowers:use("eb") then return end -- entropic blast
    if meleePowers:use("cb") then return end -- chaos bolt
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>EquipProcs</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Equipment Buttons</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

  equipment = equipment or {}

-- &lt;worn on body&gt;       a suit of spiked pure crystal armor

  equipment = {
    {"TiaScale", "a silvered scale of deepest blue hue", 5, "SAY deeply defend"},
    {"TiaOcular", "an ocular disc of mighty sight", 9, "SAY mine eyes divine"},
    {"TiaWarmaul", "the warmaul of celestial glory", 2},
    {"TiaSandals", "a pair of leathern sandals of Mystra's holy high order", 3, "SAY my heavenly home"},
    {"baatorian", "a smoking bracer forged from Baatorian steel", 1, "SAY demonic conjuration"},
--    {"WornBoots", "worn boots with mithril inlays"},
    {"TiaMask", "a set of gem studded tentacle rings", 5, "project schism"},
    {"TiaSleeves", "a set of gossamer sleeves of the mystic", 4, "SAY flesh mends"},
    {"TiaBracers", "the quickly pulsing bracers of time", 4, "SAY let minds quicken"},
    {"TiaClaws", "the wickedly sharp claws of a gelugon devil", 6, "SAY freezing flesh"},
    {"TiaStaff", "an ancient staff of the arch", 2},
    {"TiaBane", "the infernal stiletto of bane", 2},
    {"TiaLoop", "a fighter's loop of sorcerous ability", 2, "SAY aid of mage"},
    {"TiaManacle", "an unfettered manacle of thickly woven metallic mesh", 5, "SAY no focus"},
    {"FrenziedGrin", "a frenzied bloodthirsty grin", 7, "GRIN"},
    {"VermSleeves", "vermillion chainmail sleeves", 8, "SAY accelerate"},
    {"TiaValhalla", "the mighty scepter of valhalla", 4},
    {"SuppleGirdle", "a supple leather girdle with golden studs", 3, "SAY strength of stone"},
    {"TiaCincture", "a luminous cincture of nightfallen stars", 3, "SAY fell stars"},
    {"TiaStability", "the mystical boots of stability", 5, "SAY whirlwind"},
    {"TiaVolance", "a thick titanium band of volance", 1, "SAY mirrors"},
    {"SpikedArmor", "a suit of spiked pure crystal armor", 1, "SOUND BURST ME"},
    {"TiaWarder", "a dark gray cloak with a rune embroidered hem", 0, "SAY blend"},
    {"DragonCult", "the ceremonial robes of the Dragon Cult", 0, "SAY draconian protection"},
    {"TiaCrescent", "the black steel amulet of the crescent moon", 0, "SAY crescent moon"},
    {"AshenStaff", "an ancient staff of the ashen soul", 2, "SAY rot"}
        }


-- equipButton is a generic button script for single keyword proc'able equipment 
-- it uses information from the 'equipment' table

--{
--  "TiaClaws",
--  "the wickedly sharp claws of a gelugon devil",
--  6,
--  "say freezing flesh"
--}

function equipButton(fname, xcommand)
  local equipinfo = equipment:getByShortName(fname)

  if xcommand &gt;= buttons.TIMEREXPIRE and not isIconActive(fname) then
    return
  end

  if xcommand == buttons.INIT or xcommand == buttons.TIMEREXPIRE then
    if timer:get(fname) == nil then
      setLabelImage(fname, fname .. "-on.png")
    else
      setLabelImage(fname, fname .. "-off.png")
    end
  end

  if xcommand == buttons.CLICK then
    if timer:get(fname) == nil then
      timer:set(fname, 10)
      setLabelImage(fname, fname .. "-off.png")

      if equipinfo[2] == nil then
        display("error")
        display(fname)
        display(equipinfo)
      end

      cecho("&lt;cyan&gt;[Equipment proc: " .. equipinfo[2] .. "]\n")
      mud:send( equipinfo[4] )
    end
  end
end

function equipment:getByLongName(xname)
  for nx=1, #equipment, 1 do
    if equipment[nx][2] == xname then
      return(equipment[nx])
    end
  end

  return(nil)
end

-- This function returns the entire table entry that passed value matches shortname ( "TiaScale" )

function equipment:getByShortName(xname)
  for nx=1, #equipment, 1 do
    if equipment[nx][1] == xname then
      return(equipment[nx])
    end
  end

  return(nil)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Baatorian</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function baatorian(fname, xcommand)
  local label=findlabel(fname)

  local var= timer:get("baatorian")

  if xcommand &gt;= buttons.TIMEREXPIRE then
    if not isIconActive(fname) then
      return
    end
  end

  if xcommand &gt;= buttons.TIMEREXPIRE then
    if pet:status() then
      if xcommand ~= buttons.TIMEREXPIRE then
        if var &gt; (12*60) then
          var = var - (12*60)
        end
      end
    end

    if label ~= nil then
      if timer:get("baatorian") == nil then
        label:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;     &lt;br&gt;     &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
        setLabelImage(fname, "baatorian.png")
      else
        label:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] ..
                          charData:get("petrescue"):upper() .. "&lt;br&gt;" .. timedisplay(var) ..
                          "&lt;/center&gt;&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;")
      end
    end

    return
  end

  if xcommand == buttons.INIT then
    if timer:get("baatorian") == nil then
      setLabelImage(fname, "baatorian.png")
    else
      setLabelImage(fname, "baatorian-timer.png")
    end

    label:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;     &lt;br&gt;     &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
  end

  if xcommand == buttons.CLICK then
    mud:send("slaad")
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Misc equipment</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


function FrenziedGrin(fname, xcommand)
  equipButton(fname, xcommand)
end

function DragonCult(fname, xcommand)
  equipButton(fname, xcommand)
end

function VermSleeves(fname, xcommand)
  equipButton(fname, xcommand)
end

function SuppleGirdle(fname, xcommand)
  equipButton(fname, xcommand)
end

function SpikedArmor(fname, xcommand)
  equipButton(fname, xcommand)
end

function AshenStaff(fname, xcommand)
  equipButton(fname, xcommand)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Tiamat</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function TiaSleeves(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaCrescent(fname, xcommand)
  equipButton(fname, xcommand)
end


function TiaWarder(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaLoop(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaClaws(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaScale(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaCincture(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaManacle(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaStability(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaBracers(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaSandals(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaOcular(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaVolance(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaMask(fname, xcommand)
  equipButton(fname, xcommand)
end

function TiaValhalla(fname, xcommand)
  charData:init("valhalla", "defend")

  if xcommand &gt;= buttons.TIMEREXPIRE then
    return
  end

  if xcommand == buttons.CLICK then  
    if charData:get("valhalla") == "defend" then
      charData:set("valhalla", "berserk")
      mud:send("say berserker fury")
    else
      charData:set("valhalla", "defend")
      mud:send("say defender of asgard")
    end
  end

  if charData:get("valhalla") == "berserk" then
    setLabelImage(fname, "TiaValhalla-berserk.png")
  else
    setLabelImage(fname, "TiaValhalla-defend.png")
  end
end

function TiaStaff(fname, xcommand)
  if xcommand &gt;= buttons.TIMEREXPIRE and not isIconActive(fname) then
    return
  end

  if xcommand == buttons.INIT or xcommand == buttons.TIMEREXPIRE then
    setLabelImage(fname, "TiaStaff-off.png")
  end

  if xcommand == buttons.CLICK then
    if charData:get("TiaStaff") == nil or charData:get("TiaStaff") == "" then
      mud:send("protect")
    else
      mud:send("release")
    end
  end
end

function TiaWarmaul(fname, xcommand)
  local label=findlabel(fname)

  charData:init("warmaul", "off")

  if xcommand &gt;= buttons.TIMEREXPIRE then
    return
  end

  if xcommand == buttons.INIT then
    setLabelImage(fname, "TiaWarmaul-off.png")

    NyyLIB.warmaul = NyyLIB.warmaul or 0

    TiaWarmaul("TiaWarmaul", buttons.UPDATE )
  elseif xcommand == buttons.UPDATE then
    label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. NyyLIB.warmaul .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
  elseif xcommand == buttons.CLICK then
    local tmpvar=charData:get("warmaul")

    cecho("&lt;red&gt;[Warmaul: " .. tmpvar .. " type 'set warmaul off|aid|restore', or type 'aid' or 'restore' to proc accordingly]\n")

    if tmpvar == "aid" then
      mud:send("aid")
    elseif tmpvar == "restore" then
      mud:send("restore")
    end
  end
end

function TiaBane(fname, xcommand)
  local label=findlabel(fname)

  if xcommand == buttons.INIT then
    setLabelImage(fname, "TiaBane-off.png")

    charData:init("bane", "blind")
    charData:init("banecharges", 0)

    label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. charData:get("banecharges") .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
  elseif xcommand == buttons.UPDATE then
    --label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. charData:get("banecharges") .. [[z&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
    label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. charData:get("banecharges") .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
  elseif xcommand == buttons.CLICK then
    local tmpvar=charData:get("bane")

    if tmpvar == "blind" then
      mud:send("say Dragonblind")
    elseif tmpvar == "poison" then
      mud:send("say Dragonpoison")
    elseif tmpvar == "slow" then
      mud:send("say Dragonslow")
    elseif tmpvar == "strike" then
      mud:send("say Dragonstrike")
    end
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>BOTS</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>WaterXP</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>waterscripts</name>
						<packageName></packageName>
						<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


-- first level: .5ne5ne5ne5ne5ne
-- 2nd level: .5ne5ne5ne5ne5ne



function initwater()
  NyyLIB.bots= NyyLIB.bots or {}

  NyyLIB.bots.advfound=0
  
  NyyLIB.bots.advposition=0

  NyyLIB.bots.xval=0
  NyyLIB.bots.yval=0
  NyyLIB.bots.zval=0

  expandAlias(".6n")
  mud:send("snap")

  -- dirs to start room .nwnwndn

  --chklevel

  --#IF (@NyyLIB/WaterPlane/advfound = 0) {
   --NyyLIB/Waterplane/zval = 2
   -- .2d
   -- chklevel
end

function checklevel()
--#LOOP 1,5 {
--  chkrow
--  #IF (@NyyLIB/WaterPlane/advfound=1) {
--    #ABORT 1
--  }
--  {
--    NyyLIB/WaterPlane/xval = @NyyLIB/WaterPlane/xval+1
--    #IF (@NyyLIB/WaterPlane/xval &gt; 4) {
--      NyyLIB/WaterPlane/xval=0
--    }
    
--    w
--  }
--}
end

function checkrow()
--#LOOP 1,5 {
--  #IF (@NyyLIB/WaterPlane/advfound != 1) {
--    #wait 500
--    scan
--    #WAIT 750
--  }
--  #IF (@NyyLIB/WaterPlane/advfound=1) {
--    #ABORT 1
--  }
--  {
--    n
--    NyyLib/WaterPlane/yval=@NyyLib/WaterPlane/yval+1
--    #IF (@NyyLib/WaterPlane/yval&gt;4) {
--      NyyLib/WaterPlane/yval=0
--    }
--  }
--}
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>TrainScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- various functions used with the xp trains

function NextTrainStop()
  local currentroom = map:getRoom()
  local hpPercent = prompt:get("hp") / prompt:get("maxhp")
  local mvPercent = prompt:get("mv") / prompt:get("maxmv")

  callNextTrain=nil

  -- if currently tanking anything, don't move
  if inCombat() then
    cecho("&lt;red&gt;[Still in combat - not leaving room]\n")
    return
  end  

   -- Delay 60 seconds if less then 50% hp or movement
   if hpPercent &lt; .5 or mvPercent &lt; .5 then
    tempTimer(45, [[NextTrainStop()]])
    
    mud:send("gcmd [Train paused 45 seconds: Low movement or hp]")

    mud:send("bandage me")
    mud:send("bandage me")
    mud:send("bandage me")
    mud:send("bandage me")
    mud:send("bandage me")
    
    return
   end

  -- look has been sent but not received - recall function after 1 second if grouped player fighting
  if type(groupList:whoTanking()) == "table" and not look:get() then
    for k,v in pairs( groupList:whoTanking() ) do
      if groupList:ingroup(k) and v ~= 0 then
        echoDebug("&lt;red&gt;[look sent and not received]\n")
        tempTimer(1, [[NextTrainStop()]])
        return
      end
    end
  end

  if NyyLIB.smtrainposition == nil then
    assert(currentroom, "[Error: room id is nil]")

    if map:getCurrentZone() == "Ashstone" then
      getPath(currentroom, 87415)
      mud:send("gcmd [Stopping train and returning to bank (87415)" .. " &lt;." .. compressSpeedwalk() .. "&gt;]")
      expandAlias("@fwalk 87415", false)
    else
      getPath(currentroom, 48603)
      mud:send("gcmd [Stopping train and returning to inn (48603)" .. " &lt;." .. compressSpeedwalk() .. "&gt;]")
      expandAlias("@fwalk 48603", false)
    end

    expandAlias("@resettrain", false)
  else
    -- increment train position
    
    NyyLIB.smtrainposition = NyyLIB.smtrainposition + 1

    if NyyLIB.smtrainposition &gt; #NyyLIB.smtrainstops then
      NyyLIB.smtrainposition = 1

      if not silent then
        printStats(3)
      end

      expandAlias("@stats write", false)

      --mud:send("gcmd [Resetting Stats]")
      --resetStats()
    end

    NyyLIB.nextstop = NyyLIB.smtrainstops[NyyLIB.smtrainposition][1]
    enableTrigger("trainstation")

    assert(currentroom, "[Error: room id is nil]")
    if getPath(currentroom, NyyLIB.nextstop) then

      local str = NyyLIB.smtrainstops[NyyLIB.smtrainposition][2]
      local nextmob = string.gsub(" "..str, "%W%l", string.upper):sub(2)

      if not silent then
        mud:send("gcmd [Moving to: " .. nextmob ..
              " (" .. NyyLIB.smtrainstops[NyyLIB.smtrainposition][1] .. ") " ..
               " &lt;." .. compressSpeedwalk() .. "&gt;]")
      end
    end
    NyyLIB.traintarget=false
  
    if currentroom ~= NyyLIB.nextstop then
      -- maybe needed? map:countMovement() == 0
      if not fwalkQue then
        fwalkQue=true
        echoDebug("&lt;red&gt;[NextTrainStop() : Queueing fwalk in 3 seconds]\n")
        tempTimer(3, [[expandAlias("@fwalk " .. NyyLIB.nextstop)]])
      else
        echoDebug("&lt;red&gt;fwalk already queued]\n")
      end
    end
  end
end

function StartFight()
  if prompt:get("tank") ~= "" then
    return
  end
  
  -- train was just stopped
  if NyyLIB.smtrainposition == nil then
    return
  end
    
  local mobtarget = string.split(NyyLIB.smtrainstops[NyyLIB.smtrainposition][2], " ")[1]

  if NyyLIB.traintarget then
    setEnemy(mobtarget)

    spell:setMoving(false)

    raiseEvent("promptEvent")
    
    if groupList:size() == 1 then
      cecho("&lt;cyan&gt;\n[Attacking: " ..  string.title(mobtarget) .. "]\n\n")
    else
      if not silent then
        mud:send("gcmd [Attacking: " ..  string.title(mobtarget) .. "]")
      end
    end
    
    -- rogue, blackguard - apply poison
    if checkMask("venomer") then
      sendPoison()
    end  

    -- rogue: start with assassinate
    if checkMask("rog") then
      if not sendAssassinate(mobtarget) then
        mud:send("bs " .. mobtarget)
      end

      return
    end

    if checkMask("hex") then
      meleePowerUsed=false
        
      if subClass == "Hellborne" then
        useMeleePower("HS " .. mobtarget)
      end
      
      if subClass == "Voidcaller" then
        useMeleePower("SD " .. mobtarget)
      end
      
      -- recall in case power is in cooldown
      tempTimer(2, [[StartFight()]])
      return
    end



    if checkMask("ran") then
      meleePowerUsed=false
        
      if equip:getWeapon() == "Dual" then
        useMeleePower("SS " .. mobtarget)
      end
        
      if equip:getWeapon() == "Bow" then
        useMeleePower("KS " .. mobtarget)
      end
        
      -- recall in case power is in cooldown
      tempTimer(2, [[StartFight()]])
      return
    end

    if checkMask("pal") then
      -- ss is 2h, ds is 1h : TODO: need to check weapon
      if equip:getWeapon() == "TwoHand" then
        useMeleePower("ts " .. mobtarget)
      else
        useMeleePower("rc " .. mobtarget)
      end
        
      -- recall in case power is in cooldown
      tempTimer(2, [[StartFight()]])

      return
    end

    if checkMask("blk") then
      -- ss is 2h, ds is 1h : TODO: need to check weapon
      if equip:getWeapon() == "TwoHand" then
        useMeleePower("ss " .. mobtarget)
      else
        useMeleePower("ds " .. mobtarget)
      end

      -- recall in case power is in cooldown
      tempTimer(2, [[StartFight()]])

      return
    end

    if checkMask("war") then
      if table.contains( { "Ogre", "Barbarian", "Troll" }, whorace() ) then
        useMeleePower("BDS " .. mobtarget) -- bodyslam
      else
        if equip:getWeapon() == "TwoHand" then
          useMeleePower("ss " .. mobtarget) -- spinning sweep
        else
          useMeleePower("sb " .. mobtarget) -- shield block
        end

      end

      -- recall in case power is in cooldown
      tempTimer(2, [[StartFight()]])

      return
    end
    
    mud:send("kill " .. mobtarget)
  else
    -- [Players in room - Moving to next station]
    cecho("\n&lt;red&gt;[Target is damaged or already dead -  Moving to next station]\n")
    NextTrainStop()
  end
end

function bankDeposit()
  mud:send( g("coins") )
  mud:send( "deposit all")

  if groupList:size() &gt; 1 then
    if not silent then
      botWarning()
    end
  end

  local trainTime= trainStartTime or getEpoch()
  
  trainStartTime= getEpoch()

  if trainStartTime - trainTime ~= 0 then
    display( trainStartTime-trainTime)
  end

  display( getTime(true, "ddd hh:mm:ss AP") )
end

-- fightreturn false: send flee
-- fightreturn true: send assist

function fleeMem()
  -- ignore trigger if in fugue
  if map:getRoom() == 93848 then
    return
  end

  if charData:get("memcount") == nil or charData:get("memcount") == 0 and not checkMask("psi") then
    fightreturn=true
    return
  end

  if not NyyLIB.castertrain then
    -- mud:send("status " .. matches[2])
    mud:send("flee")
  end

  fightreturn=true
  NyyLIB.castertrain=true
end

function botWarning()
  mud:send("gsay * [       Warning! Use at own risk!       ]")
  mud:send("gsay * Toril discourages use of robots. Use may be")
  mud:send("gsay * permitted if at or near keys, but not for")
  mud:send("gsay * long periods of time. This may result in")
  mud:send("gsay * arbitrary punishment, including aggressive")
  mud:send("gsay * mob loads, caging, freezing or deletion.")
  mud:send("gsay * [       Warning! Use at own risk!       ]")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setupTrain config</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- TODO: update inittrain path in Silverymoon

  testtrain = {
    {48518, "Shalyssa Lurialar"},
    {48850, "Forell Luckaun"},
    {48721, "Seipora Rein"}
  }

  icecrag = {
    {5804, "commander"},
    {5735, "lieutenant"},
    {5739, "lieutenant"},
    {5769, "lieutenant"},
    {5684, "lieutenant"},
    {5833, "lieutenant"},
    {5842, "lieutenant"},
    {5780, "lieutenant"},
    {5850, "lieutenant"},
    {5752, "artist"},
    {5772, "sentinel"},
    {5748, "sentinel"}
  }

  smtrain = {
    {84203, "bankDeposit"},
    {48882, "Willa O'Greensleeves"},
    {48873, "Aratha Sul"},
    {48524, "Lavis Ryl"},
    {48525, "Elaith Waterstill"},
    {48518, "Shalyssa Lurialar"},
    {48850, "Forell Luckaun"},
    {48721, "Seipora Rein"},
    {48681, "Corland Deepforge"},
    {48586, "Ersenas"},
    {49135, "Ultrumm"},
--    {49054, "Tathshandra Tyrar"},
--    {94648, "Otasit"},
    {49117, "devout priest"},
    {49036, "Dragor Keenblade"}
  }

  ashtrain = {
    {87415, "bankDeposit"},
    {87411, "Stephan"},
    {87263, "gambler"},
    {87270, "bouncer"},
    {87272, "prostitute"},
    {87275, "aging prostitute"},
    {87276, "naked woman"},
    {87254, "Ashstone noble"},
    {87251, "Ashstone noble"},
    {87255, "Ashstone noble"},
    {87249, "Ashstone noble"},
--  priest has no plat  {87314, "kindly priest"}, 
    {87253, "Ashstone noble"},
    {87258, "Ashstone noble"},
    {87257, "Ashstone noble"}
  }

  wdtrain = {
    {13402, "elite"},
    {13359, "elite"},
    {13343, "elite"},
    {13354, "master"},
    {13397, "master"}
--    {85354, "elite guard"},
--    {85358, "elite guard"},
--    {85356, "elite guard"},
--    {85410, "elite guard"},
--    {85421, "elite guard"},
--    {85349, "elite guard"}
  }


function configureTrain()
  fwalkQue=false

  -- disable any active triggers prior to enabling
  expandAlias("@resettrain", false)

  cecho("&lt;green&gt;[Laying train tracks...]\n")

  if trainList ~= nil then
    if _G[trainList] ~= nil then
      NyyLIB.smtrainstops = _G[trainList]
      trainList=nil
      return
    end
  end

  if map:getCurrentZone() == "Ashstone" then
    NyyLIB.smtrainstops = ashtrain
  elseif map:getCurrentZone() == "Silverymoon, Gem of the North" then
    NyyLIB.smtrainstops = smtrain
  elseif map:getCurrentZone() == "Northern Waterdeep Main City" then
    NyyLIB.smtrainstops = wdtrain
  elseif map:getCurrentZone() == "The Great Harbor of Waterdeep" then
    NyyLIB.smtrainstops = wdtrain
  end
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setupTrain mode</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function trainEngine()

  buttons:change("autoloot", "coins", "autoloot")
  buttons:change("flee", "off", "flee")
  mud:send("tog wimp 0")
  mud:send("tog rescue-assist")

  if checkMask("rog") then
    buttons:change("autotrip", true, "trip")
  end

  -- enable spellcasting
  buttons:change("autocast", true, "SpellsButton")
  
  if checkMask("hex") then
    buttons:change("rescuetype", "all", "rescue")
    buttons:change("auto_heal", true, "auto_heal")
    
    buttons:change("hexbh", true, "hexbh", 1)
    
    buttons:change("hexhb", true, "hexhb", 1)
    buttons:change("hexsd", true, "hexsd", 5)
    buttons:change("hexdf", true, "hexdf", 15)
    buttons:change("hexse", true, "hexse", 25)
    buttons:change("hexmb", true, "hexmb", 30)
  end

  if checkMask("blk") then
    buttons:change("rescuetype", "all", "rescue")
  
    buttons:change("blkbc", true, "blkbc", 45)
    buttons:change("blksot", true, "blksot", 1)
    buttons:change("blkdrs", true, "blkdrs", 1)
    buttons:change("blkps", true, "blkps", 1)
    buttons:change("blkds", true, "blkds", 5)
    buttons:change("blkdm", true, "blkdm", 15)
    buttons:change("blkrs", true, "blkrs", 25)
    buttons:change("blkfs", true, "blkfs", 30)
    buttons:change("blkvs", true, "blkvs", 1)
    buttons:change("blkss", true, "blkss", 5)
    buttons:change("blkmd", true, "blkmd", 15)
    buttons:change("blksph", true, "blksph", 25)
    buttons:change("blkuf", true, "blkuf", 30)
  
    buttons:change("blksp", true, "blksp", 11)
    buttons:change("blkad", true, "blkad", 6)

    buttons:change("autodspells", true, "damage_spells")
  end

  if checkMask("war") then
    buttons:change("rescuetype", "all", "rescue")
  
    buttons:change("warcs", true, "warcs", 1)
    buttons:change("warsb", true, "warsb", 5)
    buttons:change("wards", true, "wards", 15)
    buttons:change("warbs", true, "warbs", 25)
    buttons:change("warra", true, "warra", 30)
    
    buttons:change("warcv", true, "warcv", 1)
    buttons:change("warss", true, "warss", 5)
    buttons:change("warsk", true, "warsk", 15)
    buttons:change("warua", true, "warua", 25)
    buttons:change("warros", true, "warros", 30)
  
    buttons:change("warub", true, "warub", 5)
    buttons:change("warut", true, "warut", 10)
    buttons:change("wardsd", true, "wardsd", 30)
    buttons:change("warsod", true, "warsod", 35)
    buttons:change("wariw", true, "wariw", 40)
  end

  if checkMask("pal") then
    buttons:change("rescuetype", "all", "rescue")
  
    buttons:change("palds", true, "palds", 1)
    
    buttons:change("paldc", true, "paldc", 1)
    buttons:change("pallh", true, "pallh", 1)

    buttons:change("palbs", true, "palbs", 1)
    buttons:change("palrc", true, "palrc", 5)
    buttons:change("palss", true, "palss", 15)
    buttons:change("pales", true, "pales", 25)
    buttons:change("palws", true, "palws", 30)
    buttons:change("palvs", true, "palvs", 1)
    buttons:change("palts", true, "palts", 5)
    buttons:change("palbrs", true, "palbrs", 15)
    buttons:change("paltrs", true, "paltrs", 25)
    buttons:change("palwws", true, "palwws", 30)
  
    buttons:change("palboj", true, "palboj", 20)
    buttons:change("palal", true, "palal", 40)

    buttons:change("autodspells", true, "damage_spells")
  end


  if checkMask("ran") then
    buttons:change("rescuetype", "all", "rescue")
    buttons:change("auto_heal", true, "auto_heal")
    
    buttons:change("rantr", true, "rantr", 1)
    buttons:change("ranks", true, "ranks", 5)
    buttons:change("ransp", true, "ransp", 15)
    buttons:change("rancn", true, "rancn", 25)
    buttons:change("ranha", true, "ranha", 30)
    buttons:change("rants", true, "rants", 1)
    buttons:change("ranss", true, "ranss", 5)
    buttons:change("ranap", true, "ranap", 15)
    buttons:change("ranev", true, "ranev", 25)
    buttons:change("ranbs", true, "ranbs", 30)
    
    buttons:change("ranhm", true, "ranhm", 1)
    buttons:change("ranlita", true, "ranlita", 20)
    buttons:change("ranbof", true, "ranbof", 20)
    buttons:change("ranhot", true, "ranhot", 30)
    buttons:change("raneld", true, "raneld", 30)
    buttons:change("rangrf", true, "rangrf", 40)
    buttons:change("ranab", true, "ranab", 40)
    buttons:change("ranclw", true, "ranclw", 10)
  end

  charData:set("statname", "train")

  mud:send("gcmd [Resetting Stats]")
  resetStats()

  NyyLIB.smtrainposition=0
  enableTrigger("SMTrain")
end

function trainCar()
  cecho("&lt;green&gt;[Starting train car...]\n")

  -- disable loot / enable flee, autoassist
  buttons:change("autoloot", "off", "autoloot")
  buttons:change("flee", "on", "flee")
  buttons:change("autoassist", true, "autoassist")

  -- set wimpy to maximum
  mud:send("tog wimp " .. prompt:get("maxhp") )

  if checkMask("missile") or checkMask("cle") then
    cecho("&lt;red&gt;[Starting: Caster train triggers]\n")
    enableTrigger("SMTrainCaster")

    -- enable spellcasting
    buttons:change("autocast", true, "SpellsButton")
    
    -- enable missile spells
    if checkMask("missile") then
      buttons:change("automissile", true)
    end
    
    -- enable autoharm (cleric only)
    if checkMask("cle") then
      buttons:change("autoharm", true)
    end
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Scripts</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>MapperScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
  
  NyyLIB = NyyLIB or {}
  
  map = map or {}

  map.movement = map.movement or {}
  map.movementIndex = 0

  scanned = scanned or {}

  exitMap = { n = 1, north = 1, e = 4, east = 4, w = 5, west = 5, s = 6, south = 6,
      u = 9, up = 9, d = 10, down = 10, ["in"] = 11, out = 12, [1] = "north", [4] = "east", [5] = "west",
      [6] = "south",  [9] = "up",  [10] = "down",  [11] = "in",  [12] = "out"}

  doorMap = { n = 1, north = 1, e = 4, east = 4, w = 5, west = 5, s = 6, south = 6,
      u = 9, up = 9, d = 10, down = 10, ["in"] = 11, out = 12, [1] = "n", [4] = "e", [5] = "w",
      [6] = "s",  [9] = "up",  [10] = "down",  [11] = "in",  [12] = "out"}

  NyyLIB.areaTable = NyyLIB.areaTable or
  {

[0] = "God Rooms",
[1] = "Misc Code Items/Mobs",
[2] = "The Day/Night Load Zone",
[3] = "The Quests Zone",
[4] = "Misc Code Items/Mobs 2",
[5] = "Kobold Settlement",
[6] = "None of Your Business",
[7] = "Ako Village",
[8] = "The High Road",
[9] = "The Troll Hills",
[10] = "Valley of Crushk",
[11] = "RP ZONE - Annam",
[12] = "The Day/Night Load Zone 2",
[13] = "The Conquered Village",
[14] = "The Long Delay Zone",
[15] = "the Deep Jungle",
[16] = "Southern Waterdeep Main City",
[17] = "Northern Waterdeep Main City",
[18] = "Central Waterdeep Main City",
[19] = "Wilderness Roads",
[20] = "Waterdeep Trails",
[21] = "The Scardale Sewers",
[22] = "The Elemental Groves",
[23] = "Caves of Mt. Skelenak",
[24] = "The Underworld",
[25] = "Alterian Region - Wilderness",
[26] = "Alterian Region - Mountains",
[27] = "Labyrinth of No Return",
[28] = "The Great Harbor of Waterdeep",
[29] = "The Guilds of Waterdeep",
[30] = "The Ashstone Trail",
[31] = "The Western Realms",
[32] = "The Chionthar Ferry",
[33] = "Scornubel",
[34] = "Mithril Hall - City of Dwarves",
[35] = "The Tunnel to Ardn'ir",
[36] = "Bloodstone Keep",
[37] = "Distro Rooms/Generic Objects",
[38] = "Leuthilspar - City of Elves",
[39] = "Ribcage: Gate Town to Baator",
[40] = "Keprum Vhai'rels Design",
[41] = "The Dark Gate",
[42] = "Keprum Vhai'rels Test",
[43] = "Keprum - Captain Quest",
[44] = "The Lost Treasure of Zaor",
[45] = "Klauthen Vale",
[46] = "Great Northern Road",
[47] = "Village of Split Shield",
[48] = "Griffon's Nest",
[49] = "The Valley of Graydawn",
[50] = "The Realms Master - Ship",
[51] = "The Silver Lady - Ship",
[52] = "IX Curtain",
[53] = "Ghore - City of Trolls",
[54] = "Lava Tubes One",
[55] = "Lava Tubes Two",
[56] = "Herd Island Chasm",
[57] = "Ixarkon Prison",
[58] = "The Temple of Baphomet",
[59] = "Lake Skeldrach Island",
[60] = "Lake Skeldrach Shore",
[61] = "Lake Skeldrach",
[62] = "The Citadel",
[63] = "The Adamantite Mine",
[64] = "The Lurkwood",
[65] = "The Evermoors",
[66] = "Talthalra Haszakkin",
[67] = "Faerie Realm",
[68] = "Wilderness Near Waterdeep",
[69] = "The Waterdeep Coast Road",
[70] = "Evermeet Bay",
[71] = "The_Wildland_Trails",
[72] = "Southern Forest",
[73] = "Tower of High Sorcery One",
[74] = "New Cavecity",
[75] = "Faang - City of Ogres",
[76] = "The Ice Prison",
[77] = "Beluir - City of Halflings",
[78] = "The Keep of Finn McCumhail",
[79] = "The Sunken Slave City",
[80] = "The Ant Farm",
[81] = "The Blood Bayou",
[82] = "Earth Plane",
[83] = "The Dread Mist",
[84] = "Ashstone Keep Road",
[85] = "Ashstone",
[86] = "The Nightwood",
[87] = "Nightwood Border",
[88] = "Ashstone Refugee Camp",
[89] = "The Astral Plane - Main Grid",
[90] = "The Astral Plane - Side Areas",
[91] = "The Astral Plane - Tiamat",
[92] = "Pirate Isles",
[93] = "Stronghold of Trahern Oakvale",
[94] = "New Nhavan Island",
[95] = "The Calimshan Desert",
[96] = "Viperstongue Outpost",
[97] = "The Roads of the Heartland",
[98] = "The Roads of the Heartland 2",
[99] = "Shaman Quest/Spirit World",
[100] = "Dobluth Kyor - Main City",
[101] = "The Forest of Mir",
[102] = "Rimi Greatoath dagger quest",
[103] = "Barnabas dagger quest",
[104] = "Conquest Armor Quest",
[105] = "The Marching Mountains",
[106] = "The Zone of Many Invasions",
[107] = "Bloodstone Keep II",
[108] = "Bloodstone Keep III",
[109] = "The Ethereal Plane",
[110] = "Deep Within the Toadsquat Mnts",
[111] = "Tiamat - The Pillar of Skulls",
[112] = "Tiamat - The Lair",
[113] = "Beneath the Ancient Pyramid",
[114] = "The Plane of Air Part One",
[115] = "The Plane of Fire Part One",
[116] = "The Plane of Fire Part Two",
[117] = "The Plane of Fire -Planar Grid-",
[118] = "Cityguard's Armoury",
[119] = "The Pit of Souls",
[120] = "The Shadow Swamp",
[121] = "Troll King",
[122] = "New Moonshae Island I",
[123] = "The Ancient Oak",
[124] = "Myrloch Vale",
[125] = "The Headquarters of the Twisted Rune",
[126] = "The New Trackless Sea",
[127] = "The Nine Hells - Avernus",
[128] = "The Nine Hells - Avernus - Bronze Citadel",
[129] = "Bryn Shander",
[130] = "The Eastway",
[131] = "The Elemental Plane of Magma",
[132] = "The Basin Wastes",
[133] = "Gloomhaven",
[134] = "The Derro Pit",
[135] = "The Tunnel of Dread",
[136] = "The Gloomhaven Barge",
[137] = "Ruins of Yath Oloth",
[138] = "The Jungle City of Hyssk",
[139] = "The River Trail to Hyssk",
[140] = "The Necromancer's Laboratory",
[141] = "Randars Hideout",
[142] = "The Orcish Hall of Plunder",
[143] = "Rurrgr T'ohrr",
[144] = "The Sylvan Glades",
[145] = "The Shining Sea One",
[146] = "Desert City of Nizari",
[147] = "The Sedawi Mountain Village",
[148] = "The Elder Anthology",
[149] = "The High Road - Side Areas",
[150] = "Dark Forest",
[151] = "Rogath Swamp",
[152] = "The Comarian Mines",
[153] = "The Temple of Blipdoolpoolp",
[154] = "The Temple of the Moon",
[155] = "The Elder Forest",
[156] = "Demiplane of Artimus Nevarlith",
[157] = "Ophidian Jungle",
[158] = "Hive of the Manscorpions",
[159] = "Lost Library of the Seer Kings",
[160] = "The Temple of Twisted Flesh",
[161] = "Mosswood Village",
[162] = "Calimport, the City",
[163] = "Calimport, the Sewers",
[164] = "Calimport, the Docks",
[165] = "Calimport, the Palace",
[166] = "Calimport, The Sea Sprite",
[167] = "Pirate Ship, Captain's Fancy",
[168] = "Calimport, The Barracuda",
[169] = "Hyssk Ship/Dragon Turtle Path",
[170] = "Hyssk Ship/Dragon Turtle Stuff",
[171] = "Thunderhead Peak",
[172] = "The Darktree",
[173] = "Caravan Trail to the Ten Towns",
[174] = "Calimport Palace Vault",
[175] = "Acheron 1, Avalas",
[176] = "Acheron 2, Thuldanin",
[177] = "Acheron 3, Tintibulus",
[178] = "Acheron 4, Ocanthus",
[179] = "Arnd'ir",
[181] = "Neshkal - The Dragon Trail",
[182] = "Hulburg Trail",
[183] = "The Onyx Tower of Illusion",
[184] = "Druids Grove",
[185] = "The Curse of Newhaven",
[186] = "The Curse of Newhaven_II",
[187] = "The Llyrath Forest",
[188] = "Choking Palace",
[189] = "The Swamps of Meilech",
[190] = "The Jungles of Ssrynss",
[191] = "Trollbark",
[192] = "A Halruaan Airship 1",
[193] = "A Halruaan Airship 2",
[194] = "The Floating Fortress of Izan Frosteyes",
[195] = "The Lost Pyramid",
[196] = "The Sewers of Waterdeep",
[197] = "The Blackwood",
[198] = "Cursed Cemetery",
[199] = "The Seven Heavens - Lunia",
[200] = "Bahamut's Palace",
[201] = "The Plane of Smoke",
[202] = "Cloud Realms of Arlurrium",
[203] = "Muspelhiem",
[204] = "Hulburg",
[205] = "The Minotaur Outpost",
[206] = "A'Quarthus Velg'Larn",
[207] = "The Para-Elemental Plane of Ice",
[208] = "Ashgorrock, the Gargoyle City",
[209] = "Tower of the Elementalist",
[210] = "The Druid Forest",
[211] = "Seelie Faerie Court",
[212] = "Yggdrasil",
[213] = "Scardale",
[214] = "Abandoned Temple",
[215] = "Soulprison of Bhaal",
[216] = "The Golem Forge",
[217] = "Ashrumite_Village",
[218] = "The Neverwinter Wood Beta",
[219] = "Jungle Village of the Batiri",
[220] = "The Drider Cavern",
[221] = "Unseelie Faerie Court",
[222] = "Skullport, Port of Shadows",
[223] = "Skullport Helper Zonelet",
[224] = "Wyllowwood",
[225] = "The Dwarven Mining Settlement",
[226] = "Spiderhaunt Woods",
[227] = "Farm of the Undead",
[228] = "Fire Giants Village",
[229] = "Temple of Dumathoin",
[230] = "Zhentil Keep",
[231] = "Lair of the Deep Dragon",
[232] = "UnderDark River Ruins",
[233] = "Myth Drannor-Eastern City",
[234] = "Roads of Cormanthor",
[235] = "Myth Drannor-Central City",
[236] = "Myth Drannor-Western City",
[237] = "Silverymoon, Gem of the North",
[238] = "Veldrin Z'har",
[239] = "Dragonsfall Forest",
[240] = "Menden-on-the-Deep",
[241] = "The Defense of Longhollow",
[242] = "The Cursed City of West Falls",
[243] = "The Bandit Hideout",
[244] = "Scornubel Ferry",
[245] = "Calimshan Beach",
[246] = "The Tarsellian Forest",
[247] = "The Dusk Road",
[248] = "The Fog Enshrouded Wood",
[249] = "The Northern High Road",
[250] = "The Northern High Road-2",
[251] = "The Northern Caravan Trail",
[252] = "The Mirar Ferry",
[253] = "The Abandoned Monastery",
[254] = "Baldur's Gate - Main City",
[255] = "Baldur's Gate - Docks",
[256] = "Baldur's Gate - Harbor",
[257] = "Baldur's Gate - Wave Dancer",
[258] = "The Ruins of Undermountain I",
[259] = "Myth Unnohyr",
[260] = "The Ruins of Undermountain II",
[261] = "The Trader's Road",
[262] = "The Reaching Woods - Part I",
[263] = "Darkhold Castle",
[264] = "Bloodtusk",
[265] = "Mistywood",
[266] = "Castle Drulak",
[267] = "Jotunheim",
[268] = "Talenrock",
[269] = "Ixarkon - City of Mindflayers",
[270] = "The Greycloak Hills",
[271] = "The Brain Stem Tunnel",
[272] = "IceCrag Castle",
[273] = "IceCrag Castle - Lower Level",
[274] = "Swift-Steel Company",
[275] = "Havenport",
[276] = "The Spirit Raven",
[277] = "Skerttd-Gul",
[278] = "Trade",
[279] = "Shadow Dimension Rooms",
[280] = "Guildhalls-Triterium",
[281] = "Imphras Guild Hall",
[282] = "Tooth and Maw - Grilled Grawl",
[283] = "Pride of the Sabertooth Guildhall",
[284] = "Valkurian Blades Guildhall",
[285] = "Guildhalls - Warder's Vault",
[286] = "Kingdoms and Houses",
[287] = "The Questbuilding Zone",
[288] = "Lizard Marsh",
[289] = "The Ruined Keep",
[290] = "The Stag Forest",
[291] = "The Stump Bog",
[292] = "The Way Inn",
[293] = "Evermeet- Elven Settlement",
[294] = "The Evermoor Way",
[295] = "The Rauvin Ride",
[296] = "Ogre Lair",
[297] = "Fire Giant Lair",
[298] = "Ancient Mines",
[299] = "Evermeet- Rogue's Lair",
[300] = "Kobold Caverns",
[301] = "Evermeet- Hidden Mine",
[302] = "Dragonspear Castle",
[303] = "Alabaster Caverns",
[304] = "Crystal Caverns",
[305] = "Seaweed Tribe",
[306] = "The Dark Dominion",
[307] = "Underdark Tunnels",
[308] = "The Luskan Outpost",
[309] = "The Dragonspine Mountains Trail",
[310] = "Darklake",
[311] = "The Trade Way",
[312] = "Illithid Enclave",
[313] = "The Labyrinth",
[314] = "The Tower of Kenjin",
[315] = "Settlestone",
[316] = "Wormwrithings",
[317] = "Menzoberranzan",
[318] = "Water Plane",
[319] = "The Temple of Ghaunadaur",
[320] = "The Fortress of the Dragon Cult",
[321] = "Evermeet- Scorched Forest",
[322] = "Evermeet- Serene Forest",
[323] = "Amenth'G'narr",
[324] = "Elg'cahl Niar",
[325] = "The Rat Hills",
[326] = "Mithril Hall Palace",
[327] = "Barbarian Encampment",
[328] = "Evermeet- Main Road",
[329] = "Evermeet- East Coast Road North",
[330] = "Evermeet- West Coast Road North",
[331] = "Evermeet- Ancient Forest-1",
[332] = "Evermeet- Misc. Rooms/Mobs",
[333] = "Evermeet- Road to Elven Settlement",
[334] = "The Underdark Trade Route",
[335] = "Grid-Desert-Calimport1",
[336] = "Grid-Desert-Calimport2",
[337] = "Grid-Forest-Bloodtusk",
[338] = "Grid-Hills-Bloodtusk",
[339] = "Grid-Hills-Bloodtusk2",
[340] = "Grid-Arctic-MH",
[341] = "Grid-Arctic-MH2",
[342] = "Grid-Arctic-GN",
[343] = "Grid-Hills-WD",
[344] = "Grid-Hills-Ashrumite",
[345] = "Grid-Hills-GN",
[346] = "Grid-Jungle-Hyssk",
[347] = "Grid-Jungle-Hyssk2",
[348] = "Grid-UD-Ixarkon",
[349] = "Grid-UD-GH",
[350] = "Grid-UD-Mir",
[351] = "Grid-Forest-WD",
[352] = "Grid-Forest-Faang",
[353] = "Grid-Forest-Leuthilspar",
[354] = "Grid-Forest-Leuthilspar2",
[355] = "The End of the World",
[356] = "Westgate",
[357] = "Crypt of Dragons"
}



function map:addArea(xarea)
  if xarea == nil then
    local count=0
    local line=""

    for areaid, areaname in pairs(NyyLIB.areaTable) do
      line = line .. string.format("%3d %-33s ", areaid, areaname)
      count=count+1

      if count == 3 then
        echo(line .. "\n")
        line="" 
        count=0
      end
    end

    if line ~= "" then
      echo(line .. "\n")
    end

    echo("\n")
  end

  if xarea ~= nil then
    local areaid = tonumber(xarea)
    local internalid = map:findAreaID( NyyLIB.areaTable[areaid] )

    if internalid ~= nil then
      echo("Map for " .. NyyLIB.areaTable[areaid] .. " already exists.\n")
    else
      cecho("\n&lt;green&gt;[Added area: (" .. areaid .. ") " .. NyyLIB.areaTable[areaid] .. "]\n")

      addAreaName(NyyLIB.areaTable[areaid])
    end
  end
end

-- pop and return last movement (if there was one)

function map:popMovement()
  if map:countMovement() &gt; 0 then
    --display(self.movement)

    local retval=self.movement[1]
    
    map:removeMovement()

    echoDebug("&lt;blue&gt;\n[map:popMovement " .. retval .. "] ")
        
    return(retval)
  end
  
  return(false)
end

-- peek and return next movement (if there is one)

function map:peekFutureMovement()
  if map:countMovement() &gt; 0 then
    local movement = self.movement[self.movementIndex+1]
        
    return(movement)
  end
  
  return(nil)
end

-- self.movement: List of all upcoming movements
-- self.movementIndex: Everything prior to this value has been sent/not receieved


function map:countMovement()
  return(#self.movement)
end

-- add a desired movement to the end of the queue

function map:addMovement(xdir)
  echoDebug("&lt;blue&gt;[map:addMovement queueing: " .. xdir .. "]")
  
  self.movement[#self.movement+1] = xdir
end

-- insert movement into queue at 1 before end

function map:insertMovement(xmove)
  local index=map:countMovement()
  
  if index == 0 then
    index=1
  end
  
  echoDebug("&lt;green&gt;[map:insertMovement at " .. index .. " " .. xmove .. "]\n")
  
  table.insert(self.movement, index, xmove)
end

-- return the next movement to send (and increment the index)
-- self.movementIndex : index of last movement sent

function map:nextMovement()
  --if self.movementIndex == 1 then
  --  echo("setting to 0")
  --  self.movementIndex=0
  --end
  
  
  if self.movement[self.movementIndex+1] == nil then
    echoDebug("&lt;green&gt;[map:nextMovement() all queued movements already sent]\n")
    --display(self.movementIndex)
    --display(self.movement)
    return(nil)
  end

  return( self.movement[self.movementIndex+1] )
end

-- send next queued movement

function map:sendNextMovement()
  -- Don't send any movements if more then "movebuffer" have been sent/not yet recieved.
  
  if self.movementIndex &gt; tonumber( charData:get("movebuffer", true) ) then
      return(nil)
  end

  local movement = map:nextMovement()
  
  if movement ~= nil then
    echoDebug("&lt;blue&gt;[map:sendNextMovement() self.movementIndex+1 " .. self.movementIndex+1 .. "]\n")
    
    self.movementIndex=self.movementIndex+1


    -- mud:send deletes duplicates
    send(movement, false)

    -- if movement was 'unlock', send following movement also (open)
    if string.find(movement, "unlock ") == 1 then
      send( map:nextMovement(), false)
      self.movementIndex=self.movementIndex+1
    end
  end
end

-- remove first movement from queue (exits: line has arrived)

function map:removeMovement()
  table.remove(self.movement, 1)
  
  self.movementIndex = self.movementIndex - 1
  
  if self.movementIndex &lt; 0 then
    self.movementIndex = 0
  end
end

-- remove all unsent movements from queue

function map:trimMovement()
  while map:countMovement() &gt; self.movementIndex do
    table.remove(self.movement, self.movementIndex+1)
  end
end

-- erase entire movement queue

function map:clearQueue()
  --display(self.movement)
  --display(self.movementIndex)
  --display(map:getFutureRoom())
  
  
  
  self.movement = {}

  self.movementIndex = 0

  map:setFutureRoom(nil)
end

-- before sending/queuing, need to check for doors in need of being opened

-- start from current room, and iterate queue with expectation of success

function map:processMovement(xdir)

  echoDebug("&lt;blue&gt;[map:processMovement : " .. tostring(xdir) .. "]")

  -- illithid - break hide

  if checkMask("psi") then
    setHide(false)
  end

  -- buffer movements if needed
  map:addMovement(xdir)

  -- send movement  mud:send eats duplicate commands
  
   -- map:queueMovement returns true a special exit was inserted
  if map:queueMovement(xdir) then
    map:sendNextMovement()
  end
  
  map:sendNextMovement()
end

function sendBufferedMovements()
  if map.movementIndex &gt; 5 then
    return
  end
    
  local sendCount = map:countMovement() - map.movementIndex
  local nx
  
  if sendCount &gt; 5 then
    sendCount=5
  end
  
  for nx=1,sendCount,1 do
    local movement= map:nextMovement()
    
    if movement ~= nil then
      -- -- if map:queueMovement returns true a special exit was inserted
      -- if map:queueMovement(movement) then
      --   --display("X")
      --   map:sendNextMovement()
      -- end
      
      map:sendNextMovement()
    end
  end
end

function map:queueMovement(xmove)
  if map:getFutureRoom() == nil or map:countMovement() == 0 then
    map:setFutureRoom( map:getRoom() )
  end

  if map:getFutureRoom() ~= nil then
    exits = getRoomExits( map:getFutureRoom() )

    if exits == nil then
      cecho("&lt;red&gt;[nil exits from " .. map:getFutureRoom() .. "]")
    end

    -- If this room has a special exit to pass, use it

    local specialexit = getSpecialExitsSwap( map:getFutureRoom() )

    if specialexit then
      for k,v in pairs(specialexit) do
        if v == exits[NyyLIB.fulldirs[xmove]] then
          echoDebug("MapperScripts: map:getRoom(): " .. map:getRoom() .. "\n")
          echoDebug("MapperScripts: map:getFutureRoom(): " .. map:getFutureRoom() .. "\n")
          
          -- insert special exit command - TODO: this is looping?
          map:insertMovement(k)
          return(true)
        end
      end
    end

    -- if there's a door in the way, open it
    local retval = map:autoOpen(xmove)

    if retval then
      --display(map:getFutureRoom())
    end

    if xmove == "n" then
      map:setFutureRoom( exits["north"] )
    elseif xmove == "s" then
      map:setFutureRoom( exits["south"] )
    elseif xmove == "e" then
      map:setFutureRoom( exits["east"] )
    elseif xmove == "w" then
      map:setFutureRoom( exits["west"] )
    elseif xmove == "u" then
      map:setFutureRoom( exits["up"] )
    elseif xmove == "d" then
      map:setFutureRoom( exits["down"] )
    end
  
    -- a command to open a door was inserted
    if retval then
      --display(map:getFutureRoom())
      return(true)
    end
  end
end

--open door (if there is one)

function map:autoOpen(xdir)
  
  -- TODO: Should doors be opened with fwalk regardless of autoopen?
  
  if charData:get("autoopen") then
    local doors = getDoors( map:getFutureRoom() )

    if xdir == "n" and doors["n"] then
      if doors["n"] == 3 then
        map:insertMovement("unlock " .. map:getDoorName(map:getFutureRoom(), "n") .. " north")
      end
      
      map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "n") .. " north")
      return(true)
    elseif xdir == "s" and doors["s"] then
      if doors["s"] == 3 then
        map:insertMovement("unlock " .. map:getDoorName(map:getFutureRoom(), "s") .. " south")
      end

      map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "s") .. " south")
      return(true)
    elseif xdir == "e" and doors["e"] then
      if doors["e"] == 3 then
        map:insertMovement("unlock " .. map:getDoorName(map:getFutureRoom(), "e") .. " east")
      end

      map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "e") .. " east")
      return(true)
    elseif xdir == "w" and doors["w"] then
      if doors["w"] == 3 then
        map:insertMovement("unlock " .. map:getDoorName(map:getFutureRoom(), "w") .. " west")
      end

      map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "w") .. " west")
      return(true)
    elseif xdir == "u" and doors["up"] then
      if doors["u"] == 3 then
        map:insertMovement("unlock " .. map:getDoorName(map:getFutureRoom(), "up") .. " up")
      end

      map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "up") .. " up")
      return(true)
    elseif xdir == "d" and doors["down"] then
      if doors["d"] == 3 then
        map:insertMovement("unlock " .. map:getDoorName(map:getFutureRoom(), "down") .. " down")
      end

      map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "down") .. " down")
      return(true)
    end
  end
end

function compressSpeedwalk()
  local t=speedWalkDir
  local ret = {}
  local nx

  for k,v in pairs(t) do
    if v == "down" then
      t[k] = "d"
    end
    if v == "up" then
      t[k] = "u"
    end
  end

   for i, v in ipairs(t) do
    if #v &gt; 4 then
      -- TODO: command seperator
      
      local seperator= getCommandSeparator()
      
      ret[#ret+1] = seperator .. string.split(v, "|")[1] .. seperator
    else
         if t[i-1] and v == t[i-1] then
             ret[#ret - 1] = ret[#ret - 1] + 1
        else
            ret[#ret + 1] = 1
             ret[#ret + 1] = v
         end
    end
   end

  for nx=1, #ret, 1 do
    if ret[nx] == 1 then
      ret[nx] = ""
    end
  end

   return table.concat(ret)
end

function doSpeedWalk()
  if #speedWalkDir &gt; 0 then
    cecho("&lt;green&gt;[Path: ." .. compressSpeedwalk() .. "]\n")
    
    if #speedWalkPath &gt; 1000 then
      cecho("&lt;red&gt;[Path in excess of 1000 rooms: " .. #speedWalkPath .. "]\n")
      cecho("&lt;red&gt;[1000th room: &lt;green&gt;" .. speedWalkPath[1000] .. "&lt;red&gt; ]\n")
      return
    end

    for k,v in pairs(speedWalkDir) do
      if v == "down" then
        speedWalkDir[k] = "d"
      end
      if v == "up" then
        speedWalkDir[k] = "u"
      end
    end
    
    --display(speedWalkDir)
    
    for k,v in ipairs(speedWalkDir) do
      if not string.find(v, "^[nwesud]$") then
        -- special entrance
        
        local testRoom = map:getFutureRoom()
        
        if testRoom == nil then
          testRoom = map:getRoom()
        end
        
        if testRoom == nil then
          -- first room in path, futureroom hasn't been set yet
          -- first room is using a special exit
          echo("Error: testRoom is nil\n")
        end
        
        local specialexit = getSpecialExitsSwap( testRoom )[v]
        v = string.split(v, "|")[1]
        
        testRoom = map:getFutureRoom()
        map:setFutureRoom(specialexit)
      
        echoDebug("speedwalk: adding movement " .. v .. "\n")
        map:addMovement(v)
        
        if testRoom == nil then
          -- first room in path
          expandAlias(v)
        end
      else
        expandAlias(v)
      end
    end
  
    echo("\n")
  end
end

function unhideRoom(xroomid)
  local zone=getRoomUserData(xroomid, "zoneid")

  if zone == "" then
    echo("Error xroomid: " .. xroomid .. "\n")
    return
  end

  local zoneid=tonumber(zone)

  local edgelabel=getRoomUserData(xroomid, "edge")

  local   internalid= map:findAreaID(NyyLIB.areaTable[zoneid])
  
  if xroomid == 1 then
    return
  end

  -- zone doesn't exist in arealist - add it
  if zoneid ~= nil and internalid == nil then
    map:addArea(zoneid)
    
    internalid= map:findAreaID(NyyLIB.areaTable[zoneid])

    if internalid == nil then
      cecho("[internalid error in room: " .. xroomid .. "]\n")
      display(zoneid)
      display( NyyLIB.areaTable[zoneid] )
      display( map:findAreaID(NyyLIB.areaTable[zoneid]) )
      display("X")
    end
  end

  -- echo("\n[Room: " .. xroomid .. " " .. NyyLIB.areaTable[zoneid] .. "]\n")

  if map:getDoNotEnter(xroomid) == false then
    lockRoom( xroomid, false) -- unlocks the room, adding it back to possible rooms that can be walked through.
  end

  if roomExists(xroomid) == false then
    cecho("&lt;red&gt;[&lt;green&gt;" .. xroomid .. " &lt;red&gt;does not exist]\n")
    return
  end

  if internalid == nil then
    -- will crash this run room has been removed
    display("Likely to crash")
    display("xroomid: " .. xroomid)
    display(zoneid)
    display(getRoomUserData(xroomid, "zoneid"))
    display(NyyLIB.areaTable[zoneid])
    display( map:findAreaID(NyyLIB.areaTable[zoneid]) )
  end

  setRoomArea( xroomid, internalid)

  -- add label indicating zone edges
  if edgelabel ~= "" and edgelabel ~= nil then
    cmi:roomLabel(edgelabel)
  end

  -- add label indicating password
  local pw=getRoomUserData(xroomid, "password")

  if pw ~= "" and pw ~= nil then
    cmi:passwordLabel(xroomid, pw)
  end
end

function map:update(xdir)
  local roomid
  local exits

  if xdir ~= nil then
    echoDebug("&lt;blue&gt;[map:update : " .. xdir .. "] ")
  
    -- command was movealone
    if string.match(xdir, "^MOVEA ([neswud]).*") then
      xdir=string.match(xdir, "^MOVEA ([neswud]).*")
    end
  else
    echoDebug("&lt;blue&gt;[map:update : nil] ")
  end

  if map:getRoom() ~= nil then
    NyyLIB.lastRoomID = map:getRoom()

    local specialexit = getSpecialExitsSwap( map:getRoom() )

    local exitlist={}

    -- build list of special exits
    for k,v in pairs(specialexit) do
      for k2,v2 in pairs(string.split(k, "|")) do
        echoDebug("&lt;green&gt;[Previous room has special exit: " .. k .. "]\n")
        exitlist[v2]=v
      end
    end

    if exitlist[xdir] ~= nil then
      roomid = exitlist[xdir]
    else
      exits = getRoomExits( map:getRoom() )

      if exits == nil and xdir ~= nil then
        echo("\n[No recorded exits: Room " .. map:getRoom() .. "]\n")
        map:setRoom(nil)
        return
      end

      if xdir == "n" then
        roomid  = exits["north"]
      elseif xdir == "s" then
        roomid  = exits["south"]
      elseif xdir == "e" then
        roomid  = exits["east"]
      elseif xdir == "w" then
        roomid  = exits["west"]
      elseif xdir == "u" then
        roomid  = exits["up"]
      elseif xdir == "d" then
        roomid  = exits["down"]
      else
        roomid=map:getRoom()
      end
    
      -- attempt to move a direction with no know exit
    
      if roomid == nil then
        roomid=map:getRoom()
      end
    end

    if roomid ~= nil then
      if getRoomArea(roomid) == -1 then
        unhideRoom(roomid)
      else
        -- already found
      end

      centerview(roomid)
    else
      centerview(1)
    end
    
    map:setRoom(roomid)
  else
    centerview(1) -- blank room number
  end
end

-- return a table built from mud exit string

function getExitTable(xmudstr)
  local exitsarray = {0,0,0,0,0,0}
  
  if string.find(xmudstr, "-N") ~= nil or string.find(xmudstr, "- N") ~= nil then
    exitsarray[1] = 1
  end

  if string.find(xmudstr, "-S") ~= nil or string.find(xmudstr, "- S") ~= nil then
    exitsarray[2] = 1
  end

  if string.find(xmudstr, "-E") ~= nil or string.find(xmudstr, "- E") ~= nil then
    exitsarray[3] = 1
  end

  if string.find(xmudstr, "-W") ~= nil or string.find(xmudstr, "- W") ~= nil then
    exitsarray[4] = 1
  end

  if string.find(xmudstr, "-U") ~= nil or string.find(xmudstr, "- U") ~= nil then
    exitsarray[5] = 1
  end

  if string.find(xmudstr, "-D") ~= nil or string.find(xmudstr, "- D") ~= nil then
    exitsarray[6] = 1  
  end

  return( exitsarray )
end

-- [Searching... Match found: Silverymoon, Gem of the North : At the End of Bowshot Ride : 48908]

function solveScan(xsuppress)
  if table.size(scanned) == 0 then
    --if xsuppress == nil then
    --  echo("&lt;red&gt;No scan results to attempt solving]\n")
    --end
    return(nil)
  end

  local scanresults = {}

  for k,v in pairs(scanned) do
    if type(v) == "table" and k ~= "currentroomexits" then
      if #scanresults == 0 then
        scanresults= v.filtered
      end
      
      scanresults = table.n_intersection(scanresults, v.filtered)

      -- no intersect
      if scanresults == false then
        scanresults = {}
      end
    end
  end

  if #scanresults == 1 then
    local match= scanresults[1]

    if xsuppress == nil then
      cecho("&lt;red&gt;Match found: &lt;blue&gt;" .. getRoomAreaName(getRoomArea(match)) .. " : " .. getRoomName(match) .. " : " .. match .. "&lt;red&gt;]\n")
    end

    return( match )
  end

  if xsuppress == nil then
    display(scanresults)
    cecho("&lt;red&gt;Solve scan failed. &lt;green&gt;Multiple (&lt;red&gt;" .. #scanresults .. "&lt;green&gt;) matches found]\n")
  end

  map:setRoom(nil)
  centerview(1)

  return(nil)
end

function filterScan(xkey)
  -- remove roomids from table if reversematch to current location is false

  if scanned[xkey].roomids ~= nil then
    scanned[xkey].filtered = {}

    for k,v in pairs(scanned[xkey].roomids) do
      local match= getRoomExits(v)[NyyLIB.reversedirs[xkey]]

      if match ~= nil then
        -- need to verify match identical to current room

        table.insert(scanned[xkey].filtered, match)
      end
    end

    scanned[xkey].roomids = nil
  end
end

-- map:setFutureRoom is the room number that will be occupied when the current movement queue is completed

function map:getFutureRoom()
  return ( self.futureRoom )
end

function map:setFutureRoom(xroom)
  self.futureRoom = xroom
end

function map:getExits()
  return ( self.exits )
end

function map:setExits(xexits)
  self.exits=xexits
end

function map:getRoomname()
  return ( self.roomname )
end

function map:setRoomname(xname)
  self.roomname = xname
end

function map:getRoom()
  return ( self.roomid )
end

function map:setRoom(xid)
  if xid ~= nil then
    if getRoomArea(xid) == -1 then
      unhideRoom(xid)
    end
  end

  self.roomid = xid

  if map:getFutureRoom() == nil or map:countMovement() == 0 then
    if xid ~= nil then
      echoDebug("&lt;blue&gt;[map:setRoom (setFutureRoom) : " .. xid .. "]\n")
      map:setFutureRoom( xid )
    end
  end

  raiseEvent("newRoomEvent", map:getRoom() )
end

function map:getZone(roomid)
  local areaID
  local areaname

  if roomid == nil then
    return( "" )
  end

  areaID = getRoomArea( roomid )

  if areaID ~= nil then
    if areaID == -1 then
      local zone=getRoomUserData(roomid, "zoneid")
      local zoneid=tonumber(zone)

      areaname = NyyLIB.areaTable[zoneid]
    else
      areaname=getRoomAreaName(areaID)
    end
  end

  return (areaname)
end

function map:toggle()
  if charData:get("map") == "on" then
    charData:set("map", "off")
    
    mapButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
    
    map:hide()
  else
    charData:set("map", "on")
    
    mapButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
    
    map:show()
  end
end

function map:hide()
  
  if mapAdjCon ~= nil then
    mapAdjCon:hide()
  end
  
  --if NyyLIB.mapwindow ~= nil then
  --  NyyLIB.mapwindow:show()
  --  NyyLIB.mapwindow:hide()
  --end
end

function map:show()
  
  if mapAdjCon ~= nil then
    mapAdjCon:show()
  end
  
  --if NyyLIB.mapwindow ~= nil then
  --  NyyLIB.mapwindow:hide()
  --  NyyLIB.mapwindow:show()
  --end
end

function map:countRooms()
  if self.roomcount == nil then
    self.roomcount=0

    for k,v in pairs(getRooms()) do
      self.roomcount=self.roomcount+1
    end
  end

  return(self.roomcount)
end

function map:loadMap()
  -- create mapper window if not yet present

  mudlet = mudlet or {}; mudlet.mapper_script = true

  if NyyLIB.mapwindow == nil then
  
    display("map created from map:loadMap()")
  
    mapAdjCon = mapAdjCon or Adjustable.Container:new({name="mapAdjCon" })
    mapAdjCon:disableAutoDock()
  
    NyyLIB.mapwindow = Geyser.Mapper:new({name="NyyMapper",x=0,y=0,width="100%",height="100%"}, mapAdjCon)
    
  end

  if setDefaultAreaVisible ~= nil then
    setDefaultAreaVisible(false)
  end

  -- top level map will be loaded if exists, otherwise the default
  local is_file = io.open(homepath("toril.map"))
  local loadok  

  if is_file ~= nil then
    loadok = loadMap(homepath("toril.map"))

    if loadok then
      cecho("&lt;red&gt;[Loaded map: " .. homepath("toril.map") .. "]\n")
    end
  else
    loadok = loadMap(mainpath("toril.map"))

    if not loadok then
        cecho("&lt;red&gt;[Failed map load: " .. mainpath("toril.map") .. "]\n")
    else
        cecho("&lt;red&gt;[Loaded map: " .. mainpath("toril.map") .. "]\n")

      -- initial map load - save file
      saveMap( "" )
    end
  end

  expandAlias("@find", false)
end

function map:setDoNotEnter(xroomid)

  if roomExists(xroomid) then
    setRoomUserData(xroomid, "DoNotEnter", "X")
  else
    echo("[Error: Attempt to set DNE in non-existent room: " .. xroomid .. "]\n")
  end
end

function map:getDoNotEnter(xroomid)
  local str=getRoomUserData(xroomid, "DoNotEnter")

  if str == "X" then
    return(true)
  end

  return(false)
end

-- iterate over the list of areas, matching them with substring match. 
-- if we get match a single area, then return it's ID, otherwise return
-- 'false' and a message that there are more than one area matches

function map:findAreaID(areaname)
  local nx
  local list = getAreaTable()
 
  local returnid, fullareaname

  if areaname == nil then
    cecho("&lt;red&gt;[Warning: map:findAreaId(areaname) - nil areaname]\n")
    return nil
  end

  for area, id in pairs(list) do
    if area == areaname then
      if returnid then 
      echo("[more then one area matches]\n")
      return nil
    end
      returnid = id; 
    end
  end

  return returnid
end

function map:findRoomArea(xname, xexits)
  local partmap = searchRoom(xname)
  local match = {}
  local filteredmatch = {}

  local matchedarea=nil

  for roomid, roomname in pairs(partmap) do
    if roomname == xname then
      table.insert(match, roomid)
    end
  end

  if #match == 0 then
    return(nil)
  end

  if #match == 1 then
    matchedarea= map:getZone( match[1] )
    return(matchedarea)
  end

  for k, v in pairs(match) do
    local roomexits = getRoomExits(v)
    local matchtable = {0,0,0,0,0,0}

    if roomexits["north"] then
      matchtable[1] = 1
    end

    if roomexits["south"] then
      matchtable[2] = 1
    end
  
    if roomexits["east"] then
      matchtable[3] = 1
    end

    if roomexits["west"] then
      matchtable[4] = 1
    end
  
    if roomexits["up"] then
      matchtable[5] = 1
    end
  
    if roomexits["down"] then
      matchtable[6] = 1
    end
  
    if table.concat(xexits) == table.concat(matchtable) then
      table.insert(filteredmatch, v)
    end
  end

  matchedarea= map:getZone( filteredmatch[1] )

  -- multiple rooms matches, but all in the same area

  for k,v in pairs(filteredmatch) do
    if map:getZone(v) ~= matchedarea then
      matchedarea=nil
    end
  end

  return(matchedarea)
end

function map:findRoomID(xname, xexits, xsuppress)
  local partmap = searchRoom(xname)
  local match = {}
  local filteredmatch = {}

  for roomid, roomname in pairs(partmap) do
    if roomname == xname then
      table.insert(match, roomid)
    end
  end

  if #match == 0 then
    map:setRoom(nil)
    
    if xsuppress == nil then
      cecho("&lt;red&gt;No matches found: &lt;blue&gt;" .. xname .. "&lt;red&gt;]\n")
    end
    return(nil)
  end

  if #match == 1 then
    if xsuppress == nil then
      cecho("&lt;red&gt;Match found: &lt;forest_green&gt;" .. getRoomAreaName(getRoomArea(match[1])) .. " : ".. xname .. " : " .. match[1] .. "&lt;red&gt;]\n")
    end

    return(match[1])
  end

  for k, v in pairs(match) do
    local roomexits = getRoomExits(v)
    local matchtable = {0,0,0,0,0,0}

    if roomexits["north"] then
      matchtable[1] = 1
    end

    if roomexits["south"] then
      matchtable[2] = 1
    end
  
    if roomexits["east"] then
      matchtable[3] = 1
    end

    if roomexits["west"] then
      matchtable[4] = 1
    end
  
    if roomexits["up"] then
      matchtable[5] = 1
    end
  
    if roomexits["down"] then
      matchtable[6] = 1
    end
  
    if table.concat(xexits) == table.concat(matchtable) then
      table.insert(filteredmatch, v)
    end
  end

  if #filteredmatch == 0 then
    if xsuppress == nil then
      cecho("&lt;red&gt;No matching exits found]\n")
    end
    return(nil)
  end

  if #filteredmatch == 1 then
    if xsuppress == nil then
      cecho("&lt;green&gt;Exits matched room#: " .. filteredmatch[1] .. " : " .. xname .. "&lt;red&gt;]\n")
    end
    return(filteredmatch[1])
  end

  if xsuppress == nil then
    cecho("&lt;green&gt;Multiple (&lt;red&gt;" .. #filteredmatch .. "&lt;green&gt;) matches found: &lt;blue&gt;" .. xname .. "]\n")

    -- send scan if multiple matches/scan has not been already sent
    if table.size(scanned) == 0 then
      mud:send("SCAN")
    end
  end

  return(nil)
end

function map:findRoomIDTable(xname, xexits, xsuppress)
  local partmap = searchRoom(xname)
  local match = {}
  local filteredmatch = {}

  for roomid, roomname in pairs(partmap) do
    if roomname == xname then
      table.insert(match, roomid)
    end
  end

  if #match == 0 then
    if xsuppress == nil then
      echo("No matches found: " .. xname .. "]\n")
    end
    return(nil)
  end

  if #match == 1 then
    if xsuppress == nil then
      cecho("&lt;red&gt;Match found: &lt;blue&gt;" .. xname .. " : " .. match[1] .. "&lt;red&gt;]\n")
    end
    return(match)
  end

  for k, v in pairs(match) do
    local roomexits = getRoomExits(v)
    local matchtable = {0,0,0,0,0,0}

    if roomexits["north"] then
      matchtable[1] = 1
    end

    if roomexits["south"] then
      matchtable[2] = 1
    end
  
    if roomexits["east"] then
      matchtable[3] = 1
    end

    if roomexits["west"] then
      matchtable[4] = 1
    end
  
    if roomexits["up"] then
      matchtable[5] = 1
    end
  
    if roomexits["down"] then
      matchtable[6] = 1
    end
  
    if table.concat(xexits) == table.concat(matchtable) then
      table.insert(filteredmatch, v)
    end
  end

  if #filteredmatch == 0 then
    if xsuppress == nil then
      cecho("&lt;red&gt;No matching exits found]\n")
    end
    return(nil)
  end

  return(filteredmatch)
end

function map:getCurrentZone()
  local areaID
  local areaname

  if map:getRoom() ~= nil then
    areaID = getRoomArea( map:getRoom() )
  end

  if areaID ~= nil then
    areaname=getRoomAreaName(areaID)
  end

  return (areaname)
end

function map:isRoomName(teststring)
  if teststring == nil then
    return
  end

  -- if first character not a capital letter can't be room name  

  if not string.find(teststring, "^[A-Z]") then
    return(false)
  end

  -- if final character is period, !, or ' can't be room name
  -- final character must be [a-z]

  -- if string.find(teststring, "[!.']$") then
  -- for now, allow for whitespace character at end
  if not string.find(teststring, "[a-z \)]$") then
    return(false)
  end

  -- if (x2) can't be room
  if string.find(teststring, "(x2)") then
    return(false)
  end
  
  -- Your rage subsides considerably as the blade on your a black longsword of destruction
  if string.find(teststring, "Your rage subsides") then
    return(false)
  end
  
  
  -- As the magic of Vomicopol's bracers overwhelm his body, they
  if string.find(teststring, "bracers overwhelm") then
    return(false)
  end


  -- 'All of a sudden, your a set of frozen ice shard greaves explode'

  if string.find(teststring, "All of a sudden") then
    return(false)
  end

  -- The mighty scepter of valhalla growls angrily, 'This is no time to be cautious! Press this weak

  if string.find(teststring, "The mighty scepter of") then
    return(false)
  end

  -- Bard song isn't roomname
  
  -- As your voice lifts in a sweet rendition of an ancient bardic verse, the nearby air
  -- erupts with myriad echoes.  A beautiful voice rises above the din, singing along

  if string.find(teststring, "As your voice") then
    return(false)
  end
  
  if string.find(teststring, "erupts with myriad") then
    return(false)
  end

  if string.find(teststring, "Usage:") then
    return(false)
  end

  if map:getRoom() ~= nil then
    if string.find(teststring, " $") then
      if not charData:get("maperror", true) then
        cecho(" &lt;red&gt;[Error: trailing whitespace: (&lt;green&gt;" .. teststring .. "&lt;red&gt;)]")
      end
    end
  end

  return(true)
end

function map:getDoorName(xroomid, xdir)
  local dirname={  ["n"]="north",
             ["s"]="south",
             ["u"]="up",
             ["d"]="down",
             ["e"]="east",
             ["w"]="west" }
  local exitNames
  local checkdir=xdir

  exitNames = getDoors(xroomid)

  if exitNames[xdir] then
    exitNames = getRoomUserData(xroomid, "exitNames")

    if exitNames ~= "" and exitNames ~= nil then
      exitNames = yajl.to_value(exitNames)
    else
      exitNames = {}
    end

    if dirname[xdir] ~= nil then
      checkdir=dirname[xdir]
    end

    if exitNames[checkdir] then
      return(exitNames[checkdir])
    end

    return("door")
  end

  return(nil)
end


function map:setDoorName(xroomid, xdir, xdoorname)

  if roomExists(xroomid) then
    local exitNames = getRoomUserData(xroomid, "exitNames")

    if exitNames == "" or exitNames == nil then
      exitNames = {}
    else
      exitNames = yajl.to_value(exitNames)
    end
      
    if xdir == nil then
      cecho("&lt;RED&gt;Import Error:\n")
      display(xroomid)
      display(xdir)
      display(xdoorname)
      return
    end

    exitNames[exitMap[xdir]] = xdoorname

    setRoomUserData(xroomid, "exitNames", yajl.to_string(exitNames))
  else
    echo("[Error: Attempt to set door in non-existent room: " .. xroomid .. " : " .. xdir .. " : " .. xdoorname .. "]\n")
  end
end

function map:lockMap()
local fullmap = getRooms()
local areatable = getAreaTable()

  
  -- erase labels
  
  for k,_ in pairs(getAreaTableSwap()) do 
    for l,_ in pairs(getMapLabels(k)) do 
      deleteMapLabel(k,l) 
    end
  end
 
  -- unassign all rooms
  for roomid, roomname in pairs(fullmap) do
    if getRoomArea(roomid) ~= -1 then
      resetRoomArea(roomid)
      echo("Unassigning " .. roomid .. "\n")
    end
    
    if roomLocked(roomid) == false then
      lockRoom( roomid, true)
      echo("Locking " .. roomid .. "\n")
    end
  end

  -- delete all areas
  for i,v in pairs(areatable) do
    deleteArea(v)
  end

  -- create great unknown
  map:addArea(6)
  
  setAreaName(6, "The Great Unknown")
  
  setRoomArea(1, map:findAreaID("The Great Unknown"))

  setRoomName(1, "Unmapped")
   
  -- need to check if already exists
  --expandAlias("emptyroom", false)

  echo("Map locked\n")
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>geyser replacements</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

--- Returns the Geyser object associated with the label name
-- @param label The name of the label to use

function Geyser.Label:getWindow(label)
   for i,v in pairs(Geyser.windowList) do
        if v.name == label then
            return v
        end
    
    -- added to search down 1 additional level

    for key,val in pairs(v.windowList) do
      if val.name == label then
        return val
      end
    end
  end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>checkMask</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The checkMask function returns true/false if a character is a member of a set of classes.

-- checkMask(xmask, xname)
--   xmask - name of the mask to use
-- xname - name to check, or nil (whoami)
-- Returns true if xname's class is a member of the set

-- Example: Adud is a warrior

-- if checkMask("rogue", "Adud") then
--    display("This won't happen because Adud isn't a rogue")
-- end

-- Not including a character name means the character logged in will be used

-- Example: Nyyrazzilyss (an illithid) is currently logged in

-- if checkMask("psi") then
--    display("Nyyrazzilyss is a psi")
-- end

  masks = {
    classes = { "War", "Blk", "Pal", "UNK", "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Hex", "Ran", "Sor" },
    noPsi = { "War", "Blk", "Pal", "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Hex", "Ran", "Sor" },
    nopriest = { "War", "Blk", "Pal", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran", "Hex", "Sor" },
    nocleric = { "War", "Blk", "Pal", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Hex", "Ran", "Sor" },
    psi = { "Psi" },
    enc = { "Enc" },
    war = { "War" },
    cle = { "Cle" },
    sha = { "Sha" },
    rog = { "Rog" },
    ill = { "Ill" },
    inv = { "Inv" },
    dru = { "Dru" },
    bar = { "Bar" },
    ctr = { "Ctr" },
    ran = { "Ran" },
    ele = { "Ele" },
    pal = { "Pal" },
    blk = { "Blk" },
    lic = { "Lic" },
    nec = { "Nec" },
    dir = { "Dir" },
    hex = { "Hex" },
    sor = { "Sor" },
    all = { "War", "Blk", "Pal", "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Hex", "Ran", "Sor" },
    self = { "Enc", "Sha" },
    rangerhex = { "Ran", "Hex"},
    petrescue = { "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Sor" },
    traintanks = {"War", "Pal", "Blk", "Ran", "Hex", "Bar", "Ctr"},
    warrior = {"War", "Pal", "Blk" }, -- temporarily added ranger, rogue
    fighter = {"War", "Pal", "Blk", "Ran", "Hex" },
    hitter = { "Rog", "Hex", "Ran", "Blk", "Pal" },
    hitterToRescue = { "Rog", "Hex", "Ran" },
    singer = {"Bar", "Ctr"},
    autobless = {"Bar", "Ctr"},
    autohide = {"Psi", "Rog", "Ran"},
    hitterSinger = { "War", "Rog", "Hex", "Ran", "Blk", "Pal", "Bar", "Ctr"},
    displace = { "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Hex", "Ran" },
    rightWindow = {"UNK", "War", "Blk", "Pal", "Bar", "Ctr", "Dir", "Hex", "Ran", "Rog"},
    caster = {"Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha", "Sor" },
    mage = {"Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Sor" },
    noMemCaster= {"Hex", "Sor", "Bar", "Ctr"},
    casterGlobe= {"Enc", "Nec", "Lic"},
    casterSinger = {"Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha", "Bar", "Ctr" },
    casterPsi = {"Psi", "Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha" },
    casterPsiSinger = {"Psi", "Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha", "Bar", "Ctr" },
    statHitter = {"War", "Pal", "Blk", "Ran", "Dir", "Bar", "Ctr", "Rog" },
    priest = {"Sha", "Dru", "Ctr", "Cle" },
    pray = {"Sha", "Dru", "Cle" },
    nonPriestCaster = { "ZZZ" },
    rogue = {"Rog", "Bar", "Ctr"},
    petRescue = { "Psi", "Cle", "Enc", "Dru", "Lic", "Sha", "Inv", "Ill", "Ele",   "Nec", "Bar", "Ctr", "Rog", "Ran", "Hex", "Sor" },
    haster = { "Enc", "Nec", "Ele", "Lic" },
    summonmount = { "Dir"},
    mountedCombat = { "Dir"},
    missile = { "Sha", "Ele", "Enc", "Nec", "Inv", "Lic", "Ill", "Dru" },
    hlarea = { "Cle", "Sha", "Ele", "Enc", "Nec", "Inv", "Lic", "Ill", "Dru" },
    ffire = { "Enc", "Ill", "Inv", "Dru", "Sha"},
    stoner = { "Sha", "Ele", "Enc" },
    venomer = { "Rog", "Blk" },
    dmgundead = { "Cle", "Nec", "Lic" },
    necros = { "Lic", "Nec" },
    powerCaster = { "Blk", "Pal", "Ran", "Sor"},
      }

function checkMask(xmask, xname)
  local classname

  if xname == nil then
    xname = whoami()
  end

  classname = whoclass(xname) or "UNK"

  if masks[xmask] == nil then
    echoDebug("&lt;red&gt;[Error: mask " .. xmask .. " does not exist]\n")
    return
  end

  if table.contains( masks[xmask], classname ) then
    return(true)
  end

  return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>charData script</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
charData = charData or {}

-- charData:init(xkey, xval, xtop)
-- xkey - the variable to initialize
-- xval - value of the variable
-- xtop - true - This variable is for all profiles, not a single character


  setvar = {
-- { "name", "class", {"val1", "val2", "val3"}, "default", "instructions" },
  { "sound", "", {"off", "limited", "on"}, "on", "play sounds"},
  { "tts", "", {"#"}, "0", "speak mud text"},
  { "map", "", {"on", "off"}, "on", "display map"},
  { "maperror", "", {"true", "false"}, "true", "suppress map room errors"},
  { "roomwindow", "", {"true", "false"}, "false", "display room window"},
  { "winGroup", "", {"true", "false"}, "true", "display group window"},
  { "winChat", "", {"true", "false"}, "true", "display chat window"},
  { "winMap", "", {"true", "false"}, "true", "display map window"},
  { "winMinimap", "", {"true", "false"}, "true", "display minimap window"},
  { "winIconbar", "", {"true", "false"}, "true", "display iconbar window"},
  { "swedish", "", {"true", "false"}, "false", "translate acc/etc to swedish"},
  { "style", "", {"true", "false"}, "true", "use Qt icon stylesheet"},
  { "hideequip", "", {"true", "false"}, "true", "hide left equip icon bar"},
  { "border", "", {"*"}, "default", "file, default, or colour"},
  { "numcolor", "*", {"*"}, "orange", "color of numbers on buttons"},
  { "numcolcool", "*", {"*"}, "red", "color of numbers on buttons in cooldown"},
  { "colbuttonoff", "*", {"*"}, "#ff815a", "color of button when off"},
  { "colbuttonon", "*", {"*"}, "white", "color of button when on"},
  { "font", "", {"*"}, "AvQest", "font to use for buttons"},
  { "statname", "*", {"*"}, "unset", ""},
  { "autoopen", "*", {"true", "false"}, "false", "auto-open doors",
        "\n&lt;green&gt;[Doors will be opened while moving and pathing.]\n",
        "\n&lt;red&gt;[Doors will not be opened.]\n",
    },
  { "autoportal", "*", {"true", "false"}, "false", "auto enter rifts/portals/etc",
        "\n&lt;green&gt;[Special exits will be entered if warrior+1 group members use it.]\n",
        "\n&lt;red&gt;[Special exits will not be used automatically.]\n",
    },
  { "movebuffer", "", {"#"}, "10", "maximum movements to send before buffering" },
  { "condensed", "", {"dragon", "combat", "spells", "items", "arrows", "misc", "duplicate", "debug", "spellout", "debug2", "echosend", "powersbar"}, "", "" },
  { "vnum", "", {"true", "false"}, "true", "display room vnum" },
  { "chatfontsize", "", {"auto", "#"}, "12", "fontsize to use for the chat window" },
  { "grpfontsize", "", {"auto", "#"}, "14", "fontsize to use for the group window" },
  { "reconnect", "*", {"false", "#"}, "false", "auto login this char number" },
  { "endspell", "*", {"vit", "dsp", "pwt", "fly", "grp", "pfu", "hst", "dop", "cbm"}, "vit", "" },
  { "gcmd", "*", {"true", "false"}, "false", "use gcmd instead of gsay"},
  { "group", "", { "true", "false" }, "true", "updated group display" },
  { "assocchar", "", { "*" }, "false", "connect to association chat, storage" },
  { "blurout", "", { "*" }, "[[ BLUR OUT ]]", "" },
  { "displaceout", "", { "*" }, "[[ DISPLACE OUT ]]", "" },
  { "globeout", "", { "*" }, "[[ GLOBE OUT ]]", "" },
  { "hasteout", "", { "*" }, "[[ HASTE OUT ]]", "" },
  { "scaleout", "", { "*" }, "[[ SCALE OUT ]]", "" },
  { "stoneout", "", { "*" }, "[[ STONE OUT ]]", "" },
  { "vitout", "", { "*" }, "[[ VIT OUT ]]", "" },
  { "barkout", "", { "*" }, "[[ BARK OUT ]]", ""},
  { "-", "-" },
  { "autoweapon", "*", { "auto", "Bow", "Dual", "TwoHand", "Shield", "None" }, "auto", "weapon setup"},
  { "autoproc", "*", {"true", "false"}, "false", "autoproc equipment" },
  { "container", "*", { "*" }, "", "set the name of your main container"},
  { "food", "noPsi", { "*" }, "", "food name to eat"},
  { "canteen", "noPsi", { "*" }, "", "name of water container"},
  { "autoloot", "*", {"off", "coins", "all"}, "off", "",
        "\n&lt;red&gt;[Looting is disabled.]\n",
        "\n&lt;red&gt;[Only coins will be looted.]\n",
        "\n&lt;red&gt;[Everything will be looted from corpses.]\n"
    },
  { "flee", "*", {"on", "off", "dragon", "lich"}, "on", "",
        "\n&lt;red&gt;[If you panic but can't get out, you'll flee again.]\n",
        "\n&lt;red&gt;[All flee triggers are turned off.]\n",
        "\n&lt;red&gt;[If a room is fled (for any reason), it will be returned to.]\n",
        "\n&lt;red&gt;[Staying in a room with a lich that touched you isn't going to happen.]\n"
     },
  { "autoassist", "*", { "true", "false" }, "true", "assist people in combat",
        "\n&lt;green&gt;[Any group member is combat will be assisted.]\n",
        "\n&lt;red&gt;[Assist commands will not be sent.]\n",
    },
  { "petrescue", "*", {"NONE", "ALL", "ME"}, "ME", "",
        "\n&lt;red&gt;[Commands will not be generated to rescue anyone]\n",
        "\n&lt;green&gt;[Order pets to rescue all non-warriors]\n",
        "\n&lt;green&gt;[Only rescue me]\n"
     },
  { "-", "-" },
  { "autocast", "caster", {"true", "false"}, "false", "cast/mem spells automatically", "SpellsButton"},
  { "pokehaste", "haster", {"true", "false"}, "false", "cast haste when poked" },
  { "autots", "enc", {"true", "false"}, "false", "cast time stop" },
  { "self", "self", {"true", "false"}, "false", "spellup includes self",
        "\n&lt;green&gt;[The caster will be blurred, scaled or stoned on spellup.]\n",
        "\n&lt;red&gt;[Spellups are not including me.]\n"
    },
  { "bard", "enc", {"true", "false"}, "false", "rogue spellups includes bards",
        "\n&lt;green&gt;[Bards will be treated as hitters.]\n",
        "\n&lt;red&gt;[Bards don't need spells.]\n"
    },
  { "autoscale", "enc", {"true", "false"}, "false", "dragonscale targets",
        "\n&lt;green&gt;[Casters will now be scaled.]\n",
        "\n&lt;red&gt;[Warriors only will be scaled.]\n"
    },
  { "autoblur", "enc", {"true", "false"}, "false", "blur targets",
        "\n&lt;green&gt;[Casters will now be blurred.]\n",
        "\n&lt;red&gt;[Warriors only will be blurred.]\n"
    },
  { "autohaste", "enc", {"true", "false"}, "false", "incomplete",
        "\n&lt;red&gt;[Incomplete: Hitters will be hasted.]\n",
        "\n&lt;red&gt;[Incomplete: Hitters don't need haste.]\n"
    },
  { "autoglobe", "casterGlobe", {"true", "false", "hitters"}, "false", "who to globe",
        "\n&lt;green&gt;[Hitters (including ogre warriors) will be globed.]\n",
        "\n&lt;red&gt;[Players don't need globe.]\n",
        "\n&lt;green&gt;[All hitters and warriors will be globed.]\n"
    },
  { "resize", "enc", {"off", "small", "large", "all"}, "all", "resize setting",
      "\n&lt;red&gt;[Resizing will no longer occur.]\n",
      "\n&lt;red&gt;[Resizing will now occur for small players only.]\n",
      "\n&lt;red&gt;[All medium sized casters will be enlarged.]\n",
      "\n&lt;red&gt;[Ogre warriors will now be enlarged, and small casters reduced.]\n"
    },
  { "vit", "priest", { "all", "hitter", "priest", "warrior", "nopriest", "nocleric", "mage" }, "all", "mask when casting vit" },
  { "autovit", "priest", {"true", "false"}, "false", "cast vit automatically",
      "\n&lt;green&gt;[Auto-vitality turned on.]\n",
      "\n&lt;red&gt;[Auto vitality turned off.]\n"
    },
  { "autogh", "sha", {"true", "false"}, "false", "cast group heal automatically",
      "\n&lt;green&gt;[Auto group-heal turned on.]\n",
      "\n&lt;red&gt;[Auto group-heal turned off.]\n"
    },
  { "autord", "sha", {"true", "false"}, "false", "cast raise dead automatically",
      "\n&lt;green&gt;[Auto Raise Dead turned on.]\n",
      "\n&lt;red&gt;[Auto Raise Dead turned off.]\n"
    },
  { "autofury", "sha", {"true", "false"}, "false", "cast ancestral fury automatically", 
      "\n&lt;green&gt;[Ancestral Fury turned on.]\n",
      "\n&lt;red&gt;[Ancestral Fury turned off.]\n"
    },
  { "autoashield", "sha", {"true", "false"}, "false", "cast ancestral shield automatically", 
      "\n&lt;green&gt;[Ancestral Shield turned on.]\n",
      "\n&lt;red&gt;[Ancestral Shield turned off.]\n"
    },
  { "autoheal", "cle", {"true", "false"}, "false", "cast fh/ha automatically"},
  { "auto_heal", "rangerhex", {"true", "false"}, "false", "cast heal spells automatically",
      "\n&lt;green&gt;[Healing spells will be cast during combat.]\n",
      "\n&lt;red&gt;[Healing spells will not be used.]\n"
    },
  { "turnundead", "dmgundead", {"true", "false"}, "false", "damage undead automatically",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "autopurify", "cle", {"true", "false"}, "true", "cast divine purification automatically"},
  { "autocb", "cle", {"true", "false"}, "true", "cast cure blind automatically"},
  { "autoquake", "priest", {"true", "false"}, "false", "cast quake as needed",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "autores", "cle", {"true", "false"}, "false", "res all consented pcorpses in room",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "autorealm", "cle", {"true", "false"}, "false", "keep everyone realmd",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "warmaul", "equip", { "aid", "restore", "off"}, "off", ""},
  { "gigbag", "singer", { "*" }, "", "name of container holding instruments" },
  { "forcerenew", "singer", {"true", "false"}, "false", "force renew despite full psp"},
  { "lute", "singer", { "*" }, "", "" },
  { "piccolo", "singer", { "*" }, "", "" },
  { "trumpet", "singer", { "*" }, "", "" },
  { "drum", "singer", { "*" }, "", "" },
  { "harp", "singer", { "*" }, "", "" },
  { "mandolin", "singer", { "*" }, "", "" },
  { "autobless", "singer", {"true", "false"}, "false", "cast harmonious/natures blessing"},
  { "bane", "equip", { "blind", "poison", "slow", "strike"}, "blind", ""},
  { "valhalla", "equip", { "defend", "berserk" }, "defend", ""},
  { "psicrystal", "psi", { "*" }, "", ""},
  { "wormhole", "psi", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Wormhole and Rift triggers turned on.]\n",
      "\n&lt;red&gt;[Wormhole and Rift triggers turned off.]\n"
     },
  { "disableworm", "psi", { "true", "false" }, "false", "" },
  { "autotower", "psi", { "true", "false" }, "false", "" },
  { "autosustain", "psi", { "true", "false" }, "false", "" },

  { "hexbh", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Baleful Hex is turned on.]\n",
        "\n&lt;red&gt;[Baleful Hex is turned off.]\n"
     },

  { "hexec", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Eldritch Chains is turned on.]\n",
        "\n&lt;red&gt;[Eldritch Chains is turned off.]\n"
     },

  { "hexawg", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Armor of Winters Grasp is turned on.]\n",
        "\n&lt;red&gt;[Armor of Winters Grasp is turned off.]\n"
     },

  { "hexaoh", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Armor of Hexes is turned on.]\n",
        "\n&lt;red&gt;[Armor of Hexes is turned off.]\n"
     },

  { "hexaov", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Armor of the Void is turned on.]\n",
        "\n&lt;red&gt;[Armor of the Void is turned off.]\n"
     },

  { "hexcof", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Cloak of Flies is turned on.]\n",
        "\n&lt;red&gt;[Cloak of Flies is turned off.]\n"
     },
  { "hexds", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Death Shroud is turned on.]\n",
        "\n&lt;red&gt;[Death Shroud is turned off.]\n"
     },

  { "hexhb", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hexblast is turned on.]\n",
        "\n&lt;red&gt;[Hexblast is turned off.]\n"
     },
  { "hexsd", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Smothering Darkness is turned on.]\n",
        "\n&lt;red&gt;[Smothering Darkness is turned off.]\n"
     },
  { "hexdf", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Darkworm Feast is turned on.]\n",
        "\n&lt;red&gt;[Darkworm Feast is turned off.]\n"
     },
  { "hexse", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Soul Eater is turned on.]\n",
        "\n&lt;red&gt;[Soul Eater is turned off.]\n"
     },
  { "hexmb", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Memory of Blades is turned on.]\n",
        "\n&lt;red&gt;[Memory of Blades is turned off.]\n"
     },
  { "hexhb", "hex", { "true", "false" }, "false", "",
        "\n&lt;red&gt;[Hexblast is turned on.]\n",
        "\n&lt;red&gt;[Hexblast is turned off.]\n"
     },
  { "hexsd", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Smothering Darkness is turned on.]\n",
        "\n&lt;red&gt;[Smothering Darkness is turned off.]\n"
     },
  { "hexdf", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Darkworm Feast is turned on.]\n",
        "\n&lt;red&gt;[Darkworm Feast is turned off.]\n"
     },
  { "hexsu", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Soulcutter is turned on.]\n",
        "\n&lt;red&gt;[Soulcutter is turned off.]\n"
     },
  { "hexhs", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hellstrike is turned on.]\n",
        "\n&lt;red&gt;[Hellstrike is turned off.]\n"
     },
  { "hexbf", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Black Frost is turned on.]\n",
        "\n&lt;red&gt;[Black Frost is turned off.]\n"
     },
  { "hexvf", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Vortex of Fire is turned on.]\n",
        "\n&lt;red&gt;[Vortex of Fire is turned off.]\n"
     },
  { "hexvs", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Void Star is turned on.]\n",
        "\n&lt;red&gt;[Void Star is turned off.]\n"
     },

  { "hexfb", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Frostblade is turned on.]\n",
        "\n&lt;red&gt;[Frostblade is turned off.]\n"
     },
  { "hexboa", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Blade of Annihilation is turned on.]\n",
        "\n&lt;red&gt;[Blade of Annihilation is turned off.]\n"
     },
  { "hexbzd", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Blazing Doom is turned on.]\n",
        "\n&lt;red&gt;[Blazing Doom is turned off.]\n"
     },
  { "hexrb", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Ruin Blade is turned on.]\n",
        "\n&lt;red&gt;[Ruin Blade is turned off.]\n"
     },
  { "hexib", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Infernal Brand is turned on.]\n",
        "\n&lt;red&gt;[Infernal Brand is turned off.]\n"
     },
  { "hexfz", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Fiendish Frenzy is turned on.]\n",
        "\n&lt;red&gt;[Fiending Frenzy is turned off.]\n"
     },

  { "hexss", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Starless Shield is turned on.]\n",
        "\n&lt;red&gt;[Starless Shield is turned off.]\n"
     },
  { "hexhh", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Horrific Howl is turned on.]\n",
        "\n&lt;red&gt;[Horrific Howl Shield is turned off.]\n"
     },
  { "hexhxv", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hex of Void Embrace is turned on.]\n",
        "\n&lt;red&gt;[Hex of Void Embrace is turned off.]\n"
     },
  { "hexhxa", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hex of Arcane Disruption is turned on.]\n",
        "\n&lt;red&gt;[Hex of Arcane Disruption is turned off.]\n"
     },

  { "hexhn", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hex of Null Resilience is turned on.]\n",
        "\n&lt;red&gt;[Hex of Null Resilience is turned off.]\n"
     },

  
  { "hexfa", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Furious Assault is turned on.]\n",
        "\n&lt;red&gt;[Furious Assault is turned off.]\n"
     },
  { "hexha", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hellforged Avatar is turned on.]\n",
        "\n&lt;red&gt;[Hellforged Avatar is turned off.]\n"
     },
  { "hexhxl", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hex of Lingering Doom is turned on.]\n",
        "\n&lt;red&gt;[Hex of Lingering Doom is turned off.]\n"
     },
  { "hexhxs", "hex", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hex of Shattered Defenses is turned on.]\n",
        "\n&lt;red&gt;[Hex of Shattered Defenses is turned off.]\n"
     },





  { "warbh", "war", { "true", "false" }, "false", "",
        "\n&lt;red&gt;[Auto-bash is turned on.]\n",
        "\n&lt;red&gt;[Auto-bash is turned off.]\n"
     },

  { "warbds", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Bodyslam is turned on.]\n",
        "\n&lt;red&gt;[Bodyslam is turned off.]\n"
     },

  { "warvip", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Vigilant Protector is turned on.]\n",
        "\n&lt;red&gt;[Vigilant Protector is turned off.]\n"
     },


  { "warcc", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Combat Challenge is turned on.]\n",
        "\n&lt;red&gt;[Combat Challenge is turned off.]\n"
     },
  { "warwu", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Warriors Ultimantum is turned on.]\n",
        "\n&lt;red&gt;[Warriors Ultimantum is turned off.]\n"
     },
  { "warcs", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Comeback Strike is turned on.]\n",
        "\n&lt;red&gt;[Comeback Strike is turned off.]\n"
     },
  { "warsb", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Shield Bash is turned on.]\n",
        "\n&lt;red&gt;[Shield Bash is turned off.]\n"
     },
  { "wards", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Defensive Strike is turned on.]\n",
        "\n&lt;red&gt;[Defensive Strike is turned off.]\n"
     },
  { "warbs", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Brutal Strike is turned on.]\n",
        "\n&lt;red&gt;[Brutal Strike is turned off.]\n"
     },
  { "warra", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Relentless Assault is turned on.]\n",
        "\n&lt;red&gt;[Relentless Assault is turned off.]\n"
     },
  { "warcv", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Cleave is turned on.]\n",
        "\n&lt;red&gt;[Cleave is turned off.]\n"
     },
  { "warss", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Spinning Sweep is turned on.]\n",
        "\n&lt;red&gt;[Spinning Sweep is turned off.]\n"
     },
  { "warsk", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Skull Crusher is turned on.]\n",
        "\n&lt;red&gt;[Skull Crusher is turned off.]\n"
     },
  { "warua", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Unyielding Avalanche is turned on.]\n",
        "\n&lt;red&gt;[Unyielding Avalanche is turned off.]\n"
     },
  { "warros", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Rain of Steel is turned on.]\n",
        "\n&lt;red&gt;[Rain of Steel is turned off.]\n"
     },

  { "warnop", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[No Opening is turned on.]\n",
        "\n&lt;red&gt;[No Opening is turned off.]\n"
     },
  { "wariw", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Iron Warrior is turned on.]\n",
        "\n&lt;red&gt;[Iron Warrior is turned off.]\n"
     },
  { "warut", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Unstoppable is turned on.]\n",
        "\n&lt;red&gt;[Unstoppable is turned off.]\n"
     },
  { "warhd", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Heroic Defense is turned on.]\n",
        "\n&lt;red&gt;[Heroic Defense is turned off.]\n"
     },
  { "warsod", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Storm of Destruction is turned on.]\n",
        "\n&lt;red&gt;[Storm of Destruction is turned off.]\n"
     },
  { "warub", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Unbreakable is turned on.]\n",
        "\n&lt;red&gt;[Unbreakable turned off.]\n"
     },
  { "wardsd", "war", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Diamond Shield Defense is turned on.]\n",
        "\n&lt;red&gt;[Diamond Shield Defense is turned off.]\n"
     },


  { "ranss", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Sweeping Strike is turned on.]\n",
        "\n&lt;red&gt;[Sweeping Strike is turned off.]\n"
     },
  { "ranev", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Eviscerate is turned on.]\n",
        "\n&lt;red&gt;[Eviscerate is turned off.]\n"
     },
  { "ranks", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Knockdown Shot is turned on.]\n",
        "\n&lt;red&gt;[Knockdown Shot is turned off.]\n"
     },
  { "rancn", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Concussive Shot is turned on.]\n",
        "\n&lt;red&gt;[Concussive Shot is turned off.]\n"
     },
  { "rants", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Twin Strike is turned on.]\n",
        "\n&lt;red&gt;[Twin Strike is turned off.]\n"
     },
  { "rantr", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Triple Shot is turned on.]\n",
        "\n&lt;red&gt;[Triple Shot is turned off.]\n"
     },
  { "ranbs", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Auto-bstorm is turned on.]\n",
        "\n&lt;red&gt;[Auto-bstorm is turned off.]\n"
     },
  { "ranha", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Hail of Arrows is turned on.]\n",
        "\n&lt;red&gt;[Hail of Arrows is turned off.]\n"
     },
  { "ranap", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Armor Splinter is turned on.]\n",
        "\n&lt;red&gt;[Armor Splinter is turned off.]\n"
     },
  { "ransp", "ran", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Splintering Shot is turned on.]\n",
        "\n&lt;red&gt;[Splintering Shot is turned off.]\n"
     },

  { "ranmsp", "ran", {"true", "false"}, "false", "cast misty path",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "ranhm", "ran", {"true", "false"}, "false", "mark enemy during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "ranclw", "ran", {"true", "false"}, "false", "use winds during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "ranclp", "ran", {"true", "false"}, "false", "use cloak of protection",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "ranclr", "ran", {"true", "false"}, "false", "use cloak of resilience",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
    
  { "ranclrpct", "ran", {"%"}, "100", "use cloak of resilience %" },
  { "ranclppct", "ran", {"%"}, "100", "use cloak of protection %" },
  { "rancllpct", "ran", {"%"}, "50", "use cloak of life %" },
  { "randrpct", "ran", {"%"}, "70", "use dawns renewal %" },

    
  { "ranbof", "ran", {"true", "false"}, "false", "use blades of fire during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "ranlita", "ran", {"true", "false"}, "false", "use lightning arrow during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },

  { "raneld", "ran", {"true", "false"}, "false", "use electric discharge during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "ranhot", "ran", {"true", "false"}, "false", "use hail of thorns during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "rangrf", "ran", {"true", "false"}, "false", "use greenfire during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "ranab", "ran", {"true", "false"}, "false", "use arctic barrage during combat",
      "\n&lt;green&gt;[@ will be used during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },



  { "palfa", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Furious Assault is turned on.]\n",
        "\n&lt;red&gt;[Furious Assault is turned off.]\n"
     },

  { "palguard", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Guard is turned on.]\n",
        "\n&lt;red&gt;[Guard is turned off.]\n"
     },

  { "palbs", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Bolstering Strike is turned on.]\n",
        "\n&lt;red&gt;[Bolstering Strike is turned off.]\n"
     },
  { "palrc", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Radiant Charge is turned on.]\n",
        "\n&lt;red&gt;[Radiant Charge is turned off.]\n"
     },
  { "palss", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Shielding Smite is turned on.]\n",
        "\n&lt;red&gt;[Shielding Smite is turned off.]\n"
     },
  { "pales", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Enervating Smite is turned on.]\n",
        "\n&lt;red&gt;[Enervating Smite is turned off.]\n"
     },
  { "palws", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Wrathful Smite is turned on.]\n",
        "\n&lt;red&gt;[Wrathful Smite is turned off.]\n"
     },



  { "palvs", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Valiant Strike is turned on.]\n",
        "\n&lt;red&gt;[Valiant Strike is turned off.]\n"
     },

  { "palts", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Thunderous Smite is turned on.]\n",
        "\n&lt;red&gt;[Thunderous Smite is turned off.]\n"
     },

  { "palbrs", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Brilliant Smite is turned on.]\n",
        "\n&lt;red&gt;[Brilliant Smite is turned off.]\n"
     },

  { "paltrs", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Terrifying Smite is turned on.]\n",
        "\n&lt;red&gt;[Terrifying Smite is turned off.]\n"
     },
  { "palwws", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Whirlwind Smite is turned on.]\n",
        "\n&lt;red&gt;[Whirlwind Smite is turned off.]\n"
     },


  { "palds", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Divine Smite is turned on.]\n",
        "\n&lt;red&gt;[Divine Smite is turned off.]\n"
     },
  { "pallh", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Paladin healing is turned on.]\n",
        "\n&lt;red&gt;[Paladin healing is turned off.]\n"
     },
  { "paldc", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Divine Challenge is turned on.]\n",
        "\n&lt;red&gt;[Divine Challenge is turned off.]\n"
     },
  { "paltn", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[True Nemesis is turned on.]\n",
        "\n&lt;red&gt;[True Nemesis is turned off.]\n"
     },
  { "palsf", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Shield of Faith is turned on.]\n",
        "\n&lt;red&gt;[Shield of Faith is turned off.]\n"
     },
  { "palal", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Aura of Life is turned on.]\n",
        "\n&lt;red&gt;[Aura of Life is turned off.]\n"
     },
  { "palsw", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Shield of Warding is turned on.]\n",
        "\n&lt;red&gt;[Shield of Warding is turned off.]\n"
     },
  { "palboj", "pal", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Brand of Judgement will be used during combat.]\n",
        "\n&lt;red&gt;[Brand of Judgement is turned off.]\n"
     },


  
  { "blkfa", "blk", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Furious Assault is turned on.]\n",
      "\n&lt;red&gt;[Furious Assault is turned off.]\n"
   },
  
  { "autodspells", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Damage Spells are turned on.]\n",
        "\n&lt;red&gt;[Damage Spells are turned off.]\n"
     },

  { "blksot", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Soul Touch is turned on.]\n",
        "\n&lt;red&gt;[Soul Touch is turned off.]\n"
     },
  { "blkbc", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Baleful Challenge is turned on.]\n",
        "\n&lt;red&gt;[Baleful Challenge is turned off.]\n"
     },
  { "blktn", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[True Nemesis is turned on.]\n",
        "\n&lt;red&gt;[True Nemesis is turned off.]\n"
     },



  { "blkad", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Aura of Death is turned on.]\n",
        "\n&lt;red&gt;[Aura of Death is turned off.]\n"
     },

  { "blkdrs", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Dread Smite will be used during combat.]\n",
        "\n&lt;red&gt;[Dread Smite is turned off.]\n"
     },

  { "blkdm", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Dark Majesty is turned on.]\n",
        "\n&lt;red&gt;[Dark Majesty is turned off.]\n"
     },
  { "blkds", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Dominating Smite is turned on.]\n",
        "\n&lt;red&gt;[Dominating Smite is turned off.]\n"
     },

  { "blkps", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Plundering Smite is turned on.]\n",
        "\n&lt;red&gt;[Plundering Smite is turned off.]\n"
     },

  { "blkrs", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Ruinous Smite is turned on.]\n",
        "\n&lt;red&gt;[Ruinous Smite is turned off.]\n"
     },

  { "blkfs", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Frenzying Smite is turned on.]\n",
        "\n&lt;red&gt;[Frenzying Smite is turned off.]\n"
     },
  { "blksp", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Sigil of Pain will be used during combat.]\n",
        "\n&lt;red&gt;[Sigil of Pain is turned off.]\n"
     },
   { "blksos", "blk", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Shroud of Shadow is turned on.]\n",
      "\n&lt;red&gt;[Shroud of Shadow is turned off.]\n"
   },
  { "blkvs", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Vengeance Strike will be used during combat.]\n",
        "\n&lt;red&gt;[Vengeance Strike is turned off.]\n"
      },
  { "blkss", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Shattering Smite will be used during combat.]\n",
        "\n&lt;red&gt;[Shattering Smite is turned off.]\n"
      },
  { "blkmd", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Mortal Dread will be used during combat.]\n",
        "\n&lt;red&gt;[Mortal Dread is turned off.]\n"
      },
  { "blksph", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Spirit Harrow will be used during combat.]\n",
        "\n&lt;red&gt;[Spirit Harrow is turned off.]\n"
      },
  { "blkuf", "blk", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Uncontrolled Fury will be used during combat.]\n",
        "\n&lt;red&gt;[Uncontrolled Fury is turned off.]\n"
      },

  { "sorcw", "sor", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Crackling Whip is turned on.]\n",
        "\n&lt;red&gt;[Crackling Whip is turned off.]\n"
     },
  { "sorao", "sor", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Acidic Orb is turned on.]\n",
        "\n&lt;red&gt;[Acidic Orb is turned off.]\n"
    },


  { "sorcb", "sor", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Chaos Bolt is turned on.]\n",
        "\n&lt;red&gt;[Chaos Bolt is turned off.]\n"
     },
  { "soreb", "sor", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Entropic Blast is turned on.]\n",
        "\n&lt;red&gt;[Entropic Blast is turned off.]\n"
    },
  { "sorps", "sor", { "true", "false" }, "false", "",
        "\n&lt;green&gt;[Prismatic Sphere is turned on.]\n",
        "\n&lt;red&gt;[Prismatic Sphere is turned off.]\n"
    },





  { "wuss", "*", { "*" }, "", "always rescue and spell wuss"},
  { "rescuetype", "fighter", { "off", "basic", "all" }, "basic", "",
      "\n&lt;red&gt;[Rescue is now turned off]\n",
      "\n&lt;green&gt;[All grouped non-warrior players will be rescued]\n",
      "\n&lt;green&gt;[All grouped players will be rescued]\n"
    },
  { "autotank", "fighter", { "true", "false" }, "false", "" },
  { "autocircle", "rog", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Auto-circle is turned on.]\n",
      "\n&lt;red&gt;[Auto-circle is turned off.]\n"
    },
  { "autohide", "autohide", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Autohide is turned on.]\n",
      "\n&lt;red&gt;[Autohide is turned off.]\n"
     },
  { "autotrip", "rog", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Auto-trip is turned on.]\n",
      "\n&lt;red&gt;[Auto-trip is turned off.]\n"
     },
  { "autoassassinate", "rog", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Auto-assassinate is turned on.]\n",
      "\n&lt;red&gt;[Auto-assassinate is turned off.]\n"
     },
  { "autopoison", "venomer", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Auto-poison is turned on.]\n",
      "\n&lt;red&gt;[Auto-poison is turned off.]\n"
    },
  { "autoarea", "missile", {"true", "false"}, "false", "cast 1-6th circle area combat spells",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
     },
  { "automissile", "missile", {"true", "false"}, "false", "cast 1-6th circle combat spells",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
     },
  { "autohlmissile", "missile", {"true", "false"}, "false", "cast 7th+ circle combat spells",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
     },
  { "autohlarea", "hlarea", {"true", "false"}, "false", "cast 7th circle+ area combat spells",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
     },
  { "autofm", "inv", {"true", "false"}, "false", "use force missiles in combat",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
     },
  { "autostorm", "inv", {"true", "false"}, "false", "use sandstorm in combat",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
     },
  { "autoharm", "priest", {"true", "false"}, "false", "cast harm spells"},
  { "autoffire", "ffire", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[@ will be cast during combat.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
     },
  { "autodisplace", "ill", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Displacement will be used.]\n",
      "\n&lt;red&gt;[Displacement will not be used.]\n"
  },
  { "autodoppel", "ill", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[Doppelganger will be used.]\n",
      "\n&lt;red&gt;[Doppelganger will not be used.]\n"
  },
  { "displacemask", "ill", { "true", "false" }, "false", "",  },
  { "autoblind", "ele", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
  },
  { "autoward", "ele", { "true", "false" }, "false", "",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
  },
  { "autostone", "stoner", { "off", "rogues", "tanks", "all" }, "off", "",
      "\n&lt;green&gt;[@ will be used on self.]\n",
      "\n&lt;green&gt;[@ will be used on self and rogues.]\n",
      "\n&lt;green&gt;[@ will be used on self and tanks.]\n",
      "\n&lt;green&gt;[@ will be used on all group members.]\n"
  },
  { "poisonbag", "venomer", { "*" }, "", "name of container holding poisons" },
  { "primaryp", "venomer", { "*" }, "", "poison for primary weapon"},
  { "secondaryp", "venomer", { "*" }, "", "poison for secondary weapon"},
  { "autopfu", "necros", {"true", "false"}, "false", "cast protection from undead",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "autowail", "necros", {"true", "false"}, "false", "use banshee wail",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },
  { "autovcurse", "necros", {"true", "false"}, "false", "use vampiric curse",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },

  { "autopact", "lic", {"true", "false"}, "false", "cast death pact",
      "\n&lt;green&gt;[@ will be used.]\n",
      "\n&lt;red&gt;[@ will not be used.]\n"
    },

 }

function charData:init(xkey, xval, xtop)
  if xtop ~= nil then
    if self[xkey] == nil then
      self[xkey]=xval
    end
  else
    if whoami() == nil then
      cecho("&lt;red&gt;[Error: whoami not set]\n")
      return
    end
  
    self[whoami()] = self[whoami()] or {}

    if self[whoami()][xkey] == nil then
      self[whoami()][xkey]=xval
    end
  end
end

-- TODO: change charData:set to update matching button

function charData:set(xkey, xval, xtop)
  if xtop ~= nil then
    self[xkey] = xval
  else
    if self[whoami()] == nil then
      cecho("\n&lt;red&gt;[Creating self." .. whoami() .. "]\n")
      self[whoami()] = {}
    end

    self[whoami()][xkey] = xval
  end
end

-- should return initial value if key doesn't exist

function charData:get(xkey, xtop)
  if xtop ~= nil then
    -- key is top level

    if self[xkey] ~= nil then
      return(self[xkey])
    end
  else
    -- key is indexed on charname

    if whoami() == nil then
      return(nil)
    end

    if self[whoami()][xkey] ~= nil then
      return(self[whoami()][xkey])
    end
  end

  -- doesn't exit, should return initial value from setvar table
  -- tables (i.e. condensed) always exist

  local nx

  for nx=1, #setvar, 1 do
    local key= setvar[nx][1]
    local value

    if key == xkey then
      value=setvar[nx][4]

      if value == "true" then
        value=true
      elseif value =="false" then
        value=false
      end

      return(value)
    end
  end
  
  if xkey == nil then
    echoDebug("\n&lt;red&gt;[nil xkey value]\n")
  else
    echoDebug("\n&lt;red&gt;[Warning: key " .. xkey .. " does not exist]\n")
  end

  return(nil)
end

function charData:save()
  table.save(homepath("chardata.dat"), self )
  cecho("\n&lt;red&gt;[Saved CharData table]\n")
end

function charData:load()
  local is_file = io.open(homepath("chardata.dat"))

  cecho("&lt;red&gt;[Loaded charData]\n")

  
  if is_file ~= nil then
    table.load(homepath("chardata.dat"), self)

    -- if old version, replace true/false with boolean
    for k1,v1 in pairs(self) do
      if v1 == "true" then
        charData:set(k1, true, true)
      end

      if v1 == "false" then
        charData:set(k1, false, true)
      end

      if type(self[k1]) == "table" then
        for k2,v2 in pairs(self[k1]) do
          if v2 == "true" then
            self[k1][k2] = true
          end

          if v2 == "false" then
            self[k1][k2] = false
          end
        end
      end
    end

    if self.spellouts ~= nil then
      self.blurout = self.spellouts[1][2]
      self.globeout = self.spellouts[2][2]
      self.hasteout = self.spellouts[3][2]
      self.scaleout = self.spellouts[4][2]
      self.vitout = self.spellouts[5][2]
      self.barkout = "[[ BARK OUT ]]"

      self.spellouts = nil
    end
  end

  self.border = self.border or "default"

  self.condensed= self.condensed or {}

  self.condensed["dragon"] = self.condensed["dragon"] or false
  self.condensed["combat"] = self.condensed["combat"] or false
  self.condensed["spells"] = self.condensed["spells"] or false
  self.condensed["items"] = self.condensed["items"] or false
  self.condensed["arrows"] = self.condensed["arrows"] or false
  self.condensed["misc"] = self.condensed["misc"] or false
  self.condensed["duplicate"] = self.condensed["duplicate"] or false
  self.condensed["debug"] = self.condensed["debug"] or false
  self.condensed["spellout"] = self.condensed["spellout"] or false
  self.condensed["echosend"] = self.condensed["echosend"] or false

  self.gags = self.gags or {}
  self.cgags = self.cgags or {}

  self.fwalk = self.fwalk or {}

  self.group = self.group or false

  self.potionc = self.potionc or "&lt;:medium_blue&gt;&lt;white&gt;"

  self.chatfontsize = self.chatfontsize or "auto"
  self.grpfontsize = self.grpfontsize or 14
  self.assocchar = self.assocchar or ""

  self.vnum = self.vnum or false
  
  return
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Button Format Header</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- these are buttons not defined in 'Spell Powers Header'

buttonText = 
            {  

damage_spells = {"Damage|Spells"},



mysizeDisplay= { "T", "S", "M", "L", "H"},

TiaCrescent = { "Crescent|Moon"},
TiaMask = { "Tentacle|Rings"},
TiaSleeves= { "Mystic|Sleeves"},
TiaSandals= {"Tiamat|Sandals"},
baatorian= {"Slaad"},
TiaStaff= {"Ancient|Staff"},
TiaClaws= {"Gelugon|Claws"},
TiaLoop= {"Fighter's|Loop"},
TiaManacle= {"Mesh|Manacle"},
TiaVolance= {"Band Of|Volance"},
TiaScale= {"Silvered|Scale"},
TiaBracers= {"Time|Bracers"},
TiaCincture= { "Cincture" },
TiaWarder= {"Warder|Cloak"},
VermSleeves= {"Vermillion|Sleeves"},
TiaValhalla= {"Valhalla|Scepter", "Valhalla|Berserk", "Valhalla|Defend"},
TiaStability= {"Boots Of|Stability"},
TiaOcular= {"Ocular|Disc"},
SuppleGirdle= {"Supple|Girdle"},
AshenStaff= {"Ashen|Soul"},
FrenziedGrin= {"Frenzied|Grin"},
DragonCult= {"Dragonclt|Robes"},
SpikedArmor= {"Crystal|Armor"},
TiaWarmaul= {"War|Maul"},
TiaBane= {"Bane"},


-- misc buttons

auto_heal = { "Auto|Heal" },

MemButton = { "Memorize", "Meditate", "Pray", "Stand" },


--pet_rescue = { "Pet|Rescue", "PetRescue|ME", "PetRescue|ALL"},


-- bard/battlechanter

barBless = {"Bless"},
StopMusic = {"Stop|Music"},
RegenSong = {"Regen"},
HealSong = {"Heal"},
HasteSong = {"Haste"},
SlowSong = {"Slow"},
HarmSong = {"Harm"},
RenewSong = {"Renew"},
ProtectSong = {"Protect"},
TravelSong = { "Travel"},
Accompany = {"Accompany"},



-- Warrior

rescue={"Rescue|Off", "Rescue|Basic", "Rescue|All"},


-- rogue
              
assassinate = {"Assassinate"},
trip = {"Trip"},
circle = {"Circle"},
poisonRogue = {"Poison"},
autohide = {"Auto|Hide"},
              
-- psi

ultrablast={"Ultra|Blast"},
deathfield={"Death|Field"},
battletrance={"Battle|Trance"},
tower={"Tower Of|Iron Will"},
combatmind={"Combat|Mind"},
psidarkness={"Auto|Hide"},
wormhole={"Worm|Hole"},
              

-- enchanter

encSelf= {"Self"},
encResize= { "Resize", "Resize|Small", "Resize|Large", "Resize|All" },

globe_of_invulnerability= { "Globe Of|Invul", "Globe|Hitters" },
stoneskin= {"Stoneskin", "Stoneskin|Rogues", "Stoneskin|Self", "Stoneskin|Tanks"},

time_stop= { "Time Stop" },

-- illusionist

massmorph= { "Mass|Morph" },

-- necro/lich

SoulShackleButton = {"Soul|Shackles"},

               }
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>sqlfunctions</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function sqlOpen()
  NyyLIB.env = assert (luasql.sqlite3())
  
  NyyLIB.conn = assert (NyyLIB.env:connect(mainpath("toril.db")))

  local recs, row

  -- cache chars table
  recs = assert(NyyLIB.conn:execute([[SELECT * FROM chars  ]]))

  row = recs:fetch({})

  while row do
    row= recs:fetch({})
  end

  recs:close()

  -- cache items table
  recs = assert(NyyLIB.conn:execute([[SELECT * FROM items]]))

  row = recs:fetch({})

  while row do
    row= recs:fetch({})
  end

  recs:close()
end

function sqlinwho(xname)
  local recs, row
  local profilename

  recs = assert(NyyLIB.conn:execute([[SELECT class_name, char_race, account_name FROM chars WHERE char_name = ']] .. xname .. [[']]))

  row = recs:fetch({})

  recs:close()
  
  if row == nil then
    return(false)
  else
    for k, v in pairs(NyyLIB.fullclasslist) do
      if v[1] == row[1]:trim()   then
        whoadd(xname, v[2], row[2], row[3])
        profilename = row[3]
        --echo("\n[Adding - " .. xname .. " " .. v[2] .. " " .. row[2] .. "]\n")
      end
    end

    return(profilename)
  end
end

function sqlprofilename(xname)
  local recs, row

  recs = assert(NyyLIB.conn:execute([[SELECT class_name, char_race, account_name FROM chars WHERE char_name = ']] .. xname .. [[']]))

  row = recs:fetch({})

  recs:close()
  
  if row == nil then
    --echo(" [Not found in database]\n")
    return(false)
  else
    return(row[3])
  end
end

function sqlclist(xname)
  local recs, row

  local retval = {}

  recs = assert(NyyLIB.conn:execute([[
        SELECT char_name, class_name, char_race, char_level, account_name FROM 
        chars WHERE vis = 't' AND (account_name = (SELECT account_name 
        FROM chars WHERE LOWER(char_name) = LOWER(']] .. xname .. [[') AND vis = 't') OR 
        LOWER(account_name) = LOWER(']] .. xname .. [[')) ORDER BY char_level DESC, 
        char_name ASC]]))

  row = recs:fetch({})

  while row do
    retval[#retval+1] = {row[4], row[2], row[1], row[3], row[5]}
    row= recs:fetch({})
  end

  recs:close()

  return(retval)
end

function sqlshortstats(xsqlstring)
  local recs, row
  local sqlitem
  local sqlstring
  local nx
  
  sqlitems = xsqlstring:split(",")

  for nx=1,#sqlitems,1 do
    sqlitems[nx] = sqlitems[nx]:trim()
  end

  local retval = {}

  --display(sqlitems)
  
  if sqlitems[1]:sub(1,1) == "-" then
    sqlitems[1] = sqlitems[1]:sub(2)  
  
    sqlstring = [[SELECT item_name, short_stats FROM items WHERE short_stats NOT LIKE '%]] .. sqlitems[1] .. [[%']]
  else
    sqlstring = [[SELECT item_name, short_stats FROM items WHERE short_stats LIKE '%]] .. sqlitems[1] .. [[%']]
  end

  if #sqlitems &gt; 1 then
    for nx=2,#sqlitems,1 do
      if sqlitems[nx]:sub(1,1) == "-" then
        sqlitems[nx] = sqlitems[nx]:sub(2)  
        sqlstring=sqlstring .. [[ AND short_stats NOT LIKE '%]] .. sqlitems[nx] .. [[%']]
      else
        sqlstring=sqlstring .. [[ AND short_stats LIKE '%]] .. sqlitems[nx] .. [[%']]
      end
    end
  end
 
  --display(sqlstring)

  recs = assert(NyyLIB.conn:execute(sqlstring))

  row = recs:fetch({})

  while row do
    retval[#retval+1] = row[2]
    row = recs:fetch({})
  end

  recs:close()
  
  return(retval)
end

function sqliditem(xitemname)
  local recs, row

  local retval = {}

  -- remove trailing (poisoned) from name  
  xitemname=string.gsub(xitemname, "%(poisoned%)", "")
  xitemname= xitemname:trim()

  xitemname=string.gsub(xitemname, "'", "''")

  recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_name LIKE '%]] .. xitemname .. [[%']]))

  row = recs:fetch({})

  while row do
    retval[#retval+1] = row[2]
    row = recs:fetch({})
  end

  recs:close()
  
  return(retval)
end

function sqlIsWeapon(xitemname)
  local recs, row

  local retval = {}

  xitemname=string.gsub(xitemname, "'", "''")

  recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE (item_type = 'weapon' or item_type = "ranged") AND item_name LIKE '%]] .. xitemname .. [[%']]))

  row = recs:fetch({})

  while row do
    retval[#retval+1] = row[2]
    row = recs:fetch({})
  end

  recs:close()
  
  return(retval)
end


function sqlIsBow(xitemname)
  local recs, row

  local retval = {}

  xitemname=string.gsub(xitemname, "'", "''")

  recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'ranged' AND item_name LIKE '%]] .. xitemname .. [[%']]))

  row = recs:fetch({})

  while row do
    retval[#retval+1] = row[2]
    row = recs:fetch({})
  end

  recs:close()
  
  return(retval)
end

function sqlIs2H(xitemname)
  -- return list of matching 2h weapons

  local recs, row

  local retval = {}

  xitemname=string.gsub(xitemname, "'", "''")

  recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items, item_flags WHERE item_type = 'weapon' AND
                                               item_name LIKE '%]] .. xitemname .. [[%']] ..
                                               [[ AND item_flags.item_id = items.item_id AND item_flags.flag_abbr = 'two_hand']] 
                                                      ))

  row = recs:fetch({})

  while row do
    retval[#retval+1] = row[2]
    row = recs:fetch({})
  end

  recs:close()
  
  return(retval)
end


function sqlindexitem(xitemname)
  local recs, row

  local retval = {}

  xitemname=string.gsub(xitemname, "'", "''")

  recs = assert(NyyLIB.conn:execute([[SELECT rowid, item_name FROM items WHERE item_name LIKE '%]] .. xitemname .. [[%']]))

  row = recs:fetch({})

  while row do
    display(row[1])
    display(row[2])
    retval[#retval+1] = row[2]
    row = recs:fetch({})
  end

  recs:close()
  
  return(retval)
end

function createconsumabledb()
  local recs, row

  NyyLIB.itemdb = NyyLIB.itemdb or {}

  recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'potion']]))

  row = recs:fetch({})

  while row do
    if string.find(row[2], "%(Potion%) ") ~= nil then
      local st, en, retval

      st, en, retval = string.find (row[2], "%(Potion%)([A-Za-z0-9: -]+)%*")

      NyyLIB.itemdb[row[1]]={"potion", retval:trim()}
    end

    row= recs:fetch({})
  end

  recs:close()

  recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'scroll']]))

  row = recs:fetch({})

  while row do
    if string.find(row[2], "%(Scroll%) ") ~= nil then
      local st, en, retval

      st, en, retval = string.find (row[2], "%(Scroll%)([A-Za-z0-9: -]+)%*")

      NyyLIB.itemdb[row[1]]={"scroll", retval:trim()}
    end

    row= recs:fetch({})
  end

  recs:close()

  --recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'wand']]))

  --row = recs:fetch({})

  --while row do
  --  if string.find(row[2], "%(Wand%) ") ~= nil then
  --    local st, en, retval

  --    st, en, retval = string.find (row[2], "%(Wand%)([A-Za-z0-9: -]+)%*")

  --    NyyLIB.itemdb[row[1]]={"wand", retval:trim()}
  --  end

  --  row= recs:fetch({})
  --end

  --recs:close()

  --recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'staff']]))

  --row = recs:fetch({})

  --while row do
  --  if string.find(row[2], "%(Staff%) ") ~= nil then
  --    local st, en, retval

  --    st, en, retval = string.find (row[2], "%(Staff%)([A-Za-z0-9: -]+)%*")

  --    NyyLIB.itemdb[row[1]]={"staff", retval:trim()}
  --  end

  --  row= recs:fetch({})
  --end

  --recs:close()


  recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'poison']]))

  row = recs:fetch({})

  while row do
    if string.find(row[2], "%(Poison%) ") ~= nil then
      local st, en, retval

      st, en, retval = string.find (row[2], "%(Poison%)([A-Za-z0-9: -]+)%*")

      NyyLIB.itemdb[row[1]]={"poison", retval:trim()}
    end

    row= recs:fetch({})
  end

  recs:close()


  cecho("&lt;red&gt;[Consumable database cached: Potions, Scrolls, Poisons]\n")
end


function sqlwhoclass(xname)
  display(NyyLIB.conn)

  recs = assert(NyyLIB.conn:execute([[SELECT class_name FROM chars WHERE char_name LIKE ']] .. xname .. [[']]))

  row = recs:fetch({})

  while row do
  
    echo ( row[1] .. "\n")
    row = recs:fetch({})
  end

  recs:close()

end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tiapoints</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


-- @([A-Za-z]+) - ([0-9]+)
-- \1=\2,

TiamatPoints={
Adriorn=0,
Aetius=200,
Afu=200,
Alak=0,
Alane=0,
Alimam=0,
Anashoa=475,
Andreww=150,
Annam=0,
Areh=200,
Arete=0,
Arrithes=0,
Ashades=0,
Azralek=100,
Babo=0,
Banducci=100,
Baram=375,
Beern=0,
Berrin=80,
Blaez=100,
Cobu=200,
Con=150,
Dagk=400,
Damet=0,
Delkor=400,
Delmair=100,
Deshana=435,
Diel=0,
Diggz=300,
Dixa=0,
Donny=300,
Drabyl=400,
Drahken=200,
Drake=465,
Draqus=75,
Drakkochian=100,
Druzix=0,
Duard=200,
Elscint=0,
Enth=100,
Etrangere=100,
Ezwar=300,
Fibble=0,
Fkteval=0,
Flib=100,
Flyngspaghetti=175,
Frensolith=500,
Gehadron=0,
Gene=0,
George=825,
Gerin=200,
Getaris=100,
Gindipple=0,
Gormal=0,
Graum=100,
Grundar=75,
Gruuggh=550,
Gubody=0,
Gyrx=0,
Hamwich=100,
Hefa=275,
Hibbidy=100,
Hue=425,
Hyla=0,
Iamtux=100,
Ice=100,
Ikhar=200,
Iledor=50,
Inames=200,
Isisa=0,
Jacob=0,
Jasix=0,
Jaul=100,
Jhira=265,
Jimak=200,
Jkersey=325,
Jlewis=100,
John=100,
Justmefjs=50,
Kaern=0,
Kajj=235,
Kalantha=200,
Kanenan=0,
Kathal=100,
Kayos=0,
Kelemon=0,
Kidus=0,
Kimi=200,
Klandan=35,
Klosh=100,
Koric=200,
Koxa=0,
Kramel=100,
Krimic=0,
Kugol=400,
Kuno=180,
Kwirl=100,
Lenen=0,
Lienna=375,
Lilithelle=400,
Lilmeshay=0,
Lopi=100,
Lusas=100,
Maxler=300,
Mayoung=100,
Mij=0,
Mikempty=0,
Misi=0,
Mrizzalazzrazzi=0,
Mrorange=625,
Mung=200,
Myrranth=200,
Naled=0,
Nerox=50,
Netonosel=250,
Nolumakil=0,
Ntwolfgang=0,
Nurpy=300,
Nyyrazzilyss=1325,
Oggsk=50,
Onut=0,
Osheara=0,
Oteb=0,
Ozzec=100,
Parsnip=400,
Pibbinivil=0,
Popinoples=350,
Qaz=300,
Quinn=100,
Raronsil=0,
Redgoat=200,
Rhazien=0,
Rirus=0,
Riwer=100,
Rorg=50,
Rouse=525,
Ruagh=0,
Saerian=100,
Saitcho=100,
Samiam=0,
Sasin=150,
Sekfarok=325,
Selshanar=0,
Shoshana=0,
Silena=100,
Silvenleif=0,
Sipes=1000,
Solah=100,
Ssezef=0,
Stephanie=500,
Stoutwoodarcanos=0,
Sulaco=100,
Susab=150,
Syrac=200,
Tafi=0,
Talomis=100,
Tanji=100,
Teresias=65,
Thegnome=100,
Tibek=100,
Tilsen=250,
Timok=0,
Todd=200,
Toraza=175,
Torlin=100,
Torsoul=300,
Travok=0,
Turg=100,
Turtle=200,
Turxx=0,
Tyndall=200,
Typographer=0,
Utheba=100,
Venlarin=75,
Verarb=400,
Violeti=300,
Vooku=1100,
Wired=100,
Wobb=0,
Xboomx=300,
Xilissisix=100,
Xuter=0,
Yadir=100,
Ykor=200,
Yog=100,
Yxageirr=175,
Zarel=100,
Zellas=300,
Zepharian=0,
Zerogod=0,
Zipalodok=100,
Zoe=200,
Zusuk=600
}


function getPoints(xprofile)
  if TiamatPoints[xprofile] ~= nil then
    return(TiamatPoints[xprofile])
  end

  return(0)
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>StatsScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function groupStatsDisplay(xcharname)
  local profilename=inwho(xcharname)
  local temp = whoclass(xcharname)

  
  if not charData:get("group", true) then
    return
  end

  if temp ~= nil then
    if temp ~= "UNK" then
      local hits = getHits(xcharname)
      local attacks = getAttacks(xcharname)

      local cntRescueFail=getStat(xcharname, "failedrescue")
      local cntRescueSuccess=getStat(xcharname, "successrescue")


--       cecho(string.format("%" .. (16-string.len(xcharname)) .. "s", " "))

        cecho(string.format("&lt;cyan&gt;%5.1f%% (%4d)", 
            (hits*100)/attacks,
            attacks))

      
      if cntRescueFail+cntRescueSuccess ~= 0 then
        cecho(string.format("&lt;cyan&gt;%5.1f%% (%4d)   ", 
              cntRescueSuccess*100/(cntRescueFail+cntRescueSuccess),
              cntRescueFail+cntRescueSuccess))
      end

      echo("\n")
    end
  else
    echo(" [ Unknown ]\n")
  end
end

function resetStats()
  cecho("\n&lt;red&gt;[Resetting stats counters.]\n")

  NyyLIB.stats = {}
end

function addStat(xcharname, xstatname)
  NyyLIB.stats = NyyLIB.stats or {}

  if xcharname == "Someone" or xcharname == nil then
    return
  end

  echoDebug(" &lt;red&gt;[ &lt;cyan&gt;addStat(" .. xcharname .. "," .. xstatname .. ") &lt;red&gt;]\n")

  if NyyLIB.stats[xcharname] == nil then
    NyyLIB.stats[xcharname] = {}
  end

  if NyyLIB.stats[xcharname][xstatname] == nil then
    NyyLIB.stats[xcharname][xstatname] = 0
  end

  NyyLIB.stats[xcharname][xstatname] = NyyLIB.stats[xcharname][xstatname] + 1
end

function getStat(xcharname, xstatname)
  if NyyLIB.stats[xcharname] == nil then
    -- echo("\n[" .. xstatname .. " on " .. xcharname .. " is nil stat]\n")
    NyyLIB.stats[xcharname]={}
  end

  if NyyLIB.stats[xcharname][xstatname] == nil then
    -- echo("\n[" .. xstatname .. " on " .. xcharname .. " is nil stat]\n")
    
    NyyLIB.stats[xcharname][xstatname]=0
  end

  return ( NyyLIB.stats[xcharname][xstatname] )
end

function getHits(xcharname)

  local c_offHit = getStat(xcharname, "offHit")
  local c_offParry = getStat(xcharname, "offParry")
  local c_offDodge = getStat(xcharname, "offDodge")
  local c_offdeflect = getStat(xcharname, "offDeflect")

  local c_offShieldBlock = getStat(xcharname, "offShieldBlock")  

  local c_offMiss = getStat(xcharname, "offMiss")

  local c_all=c_offHit+ c_offMiss + c_offParry + c_offdeflect + c_offDodge + c_offShieldBlock

  local c_adjhit=c_all-c_offMiss

  return(c_adjhit)
end

function getAttacks(xcharname)

  local c_offHit = getStat(xcharname, "offHit")
  local c_offParry = getStat(xcharname, "offParry")
  local c_offDodge = getStat(xcharname, "offDodge")
  local c_offdeflect = getStat(xcharname, "offDeflect")

  local c_offShieldBlock = getStat(xcharname, "offShieldBlock")  

  local c_offMiss = getStat(xcharname, "offMiss")

  local c_all=c_offHit+ c_offMiss + c_offParry + c_offdeflect + c_offDodge + c_offShieldBlock


  return(c_all)
end


function printDeaths()
  local deathcount={}
  local nx=0


  for k,v in pairs(NyyLIB.stats) do
    deathcount[k]= getStat(k, "death")

    --echo( string.format("%15s %d\n", k, getStat(k, "death") ) )
  end

  cecho ("&lt;blue&gt;gcc * &lt;red&gt;... DEATH Top 20 ...\n")

  for k,v in spairs(deathcount, function(t, a, b) return (t[a]&gt;t[b]) end) do
    nx=nx+1

    if nx &lt; 21 then
      cecho( string.format("&lt;blue&gt;gcc * &lt;green&gt;%-14s %d\n", k, getStat(k, "death") ) )
    end
  end

end

function printHeals(xmode)
  local gheals={}
  local gotfullheal={}
  local gothealingaura={}

  local prefix = "&lt;blue&gt;gcc "

  for k,v in pairs(NyyLIB.stats) do
    if getStat(k, "GroupHeal") ~= 0 then
      gheals[k] = {getStat(k, "GroupHeal"), getStat(k, "Vitality") }
      -- echo(k .. " Group Heal: " .. getStat(k, "GroupHeal") .. " Vitality: " .. getStat(k, "Vitality") .. "\n")
    end

    if getStat(k, "gotHealingAura") ~= 0 or getStat(k, "gotFullHeal") ~= 0  then
      gothealingaura[k] = getStat(k, "gotHealingAura")
      gotfullheal[k] = getStat(k, "gotFullHeal")
    end

    --if getStat(k, "Vitality") ~= 0 then
    --  echo(k .. " Vitality: " .. getStat(k, "Vitality") .. "\n")
    --end
  end

  cecho(prefix .. "* &lt;red&gt;............... Heal F-Heal G-Heal Aura Vit\n")

  if xmode == "3" then
    cecho( "&lt;blue&gt;gsay * &lt;red&gt;............... Heal F-Heal G-Heal Aura Vit")
  end

  if gheals ~= {} then
    for k,v in spairs(gheals, function(t, a, b) return (t[a][1]&gt;t[b][1]) end) do
      cecho ( string.format(prefix .. "* &lt;green&gt;%-15s              %3d        %2d\n", k, v[1], v[2]) )

      if xmode == "3" then
        cecho( string.format(prefix .. "* &lt;green&gt;%-15s  %3d        %3d\n", k, v[1], v[2]) )
      end  
    end
  end

  for k,v in pairs(NyyLIB.stats) do
    if whoclass(k) == "Cle" then
      cecho( string.format(prefix .. "* &lt;green&gt;%-15s        %2d           %2d  %2d\n", k, getStat(k, "castFullHeal"), getStat(k, "castHealingAura"), getStat(k, "Vitality") ) )
    end
  end

  cecho(prefix .. "* &lt;red&gt;...............\n")

  if xmode == "3" then
    cecho( prefix .. "* &lt;red&gt;...............")
  end

  for k,v in spairs(gotfullheal, function(t, a, b) return (t[a]&gt;t[b]) end) do
    if checkMask("warrior", k) then
      cecho( string.format(prefix .. "* &lt;green&gt;%-15s        %2d           %2d \n", k, v, getStat(k, "gotHealingAura") ) )
    end
  end

  echo("\n")

end

function printStats(xmode)
  local hitters=false

  local c_attackmiss=getStat(whoami(), "offMiss")
  local c_attackhit=getStat(whoami(), "offHit")

  local c_block=getStat(whoami(), "defShieldBlock")
  local c_dodge=getStat(whoami(), "defDodge")
  local c_graze=getStat(whoami(), "defGraze")
  local c_deflect=getStat(whoami(), "defWeaponDeflect")
  local c_glances=getStat(whoami(), "defShieldGlance")
  local c_svamp=getStat(whoami(), "shieldvamp")
  local c_parry=getStat(whoami(), "defParry")
  local c_pdeflect=getStat(whoami(), "defParryPartial")
  local c_crit=getStat(whoami(), "crithit")

  local c_hit=getStat(whoami(), "defHit")
  local c_miss=getStat(whoami(), "defMiss")

  local c_offdodge=getStat(whoami(), "offDodge") -- attacked mob, but dodged - count as hit

  local c_all=c_hit+ c_miss + c_parry + c_deflect + c_dodge + c_block
  local skillblocked = c_block + c_parry + c_deflect + c_dodge
  local partialblock=  c_pdeflect + c_graze + c_glances
  local v2allhit = c_hit + skillblocked
  local v2weapon = c_parry + c_deflect + c_pdeflect

  local c_adjhit=c_all-c_miss

  local ptar = getStat(whoami(), "planetar")

  local defstring = string.format("[Defense: Hit %2.1f%% (%d/%d), %2.1f%% (%d) direct, %2.1f%% (%d) dodge, %2.1f%% (%d) shield, %2.1f%% (%d) weapon]\n",
                        c_hit*100/c_all, c_hit, c_all,
                        (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances),
                        c_graze*100/c_hit, c_graze,
                        c_glances*100/c_hit, c_glances,
                        c_pdeflect*100/c_hit, c_pdeflect   ) 

  local prefix = "&lt;blue&gt;gcc &lt;green&gt;"
  
  
  for k,v in pairs(NyyLIB.stats) do
    if k ~= whoami() then
      if checkMask("statHitter", k) then
        hitters=true
      end
    else
      if xmode == nil or xmode == 2 then
        hitters=true
      end
    end
  end 

  --echo("\npeople groupList:ingroup only - () echo (1) gsay hitters (2) gsay hitters+me (3) gsay all\n")


  if hitters then
    if xmode == nil then
      cecho(prefix .. "* &lt;red&gt;................... Hit (Total)   Rescues\n")
    else
      if xmode == 3 then
        mud:send("gcmd * [gsay stats reset] [gsay stats display]")
      end
      --send("gsay * ......................   Hit (Total) Spells")
      mud:send("gcmd * ......................   Hit (Total)")
    end
  end

  --for k,v in pairs(NyyLIB.stats) do
  --  if getStat(k, "offHit") == 0 then
  --    addStat(k, "offHit")
  --  end

  --  if getStat(k, "offMiss") == 0 then
  --    addStat(k, "offMiss")
  --  end
  --end
  
  for k,v in spairs(NyyLIB.stats, function(t,a,b) return (getHits(b)*100/(getHits(b)+t[b]["offMiss"])) &lt;
                                    (getHits(a)*100/(getHits(a)+t[a]["offMiss"])) end) do


    local varstring

    if whoclass(k) ~= nil then 

      varstring =  string.format("[%3s] %-16s:%5.1f%% (%4d)",
              whoclass(k), k, 
              getHits(k)*100/(getHits(k)+getStat(k, "offMiss")), 
              getHits(k) + getStat(k, "offMiss") )


      --local cntSpellCast = getStat(k, "spellCast")

      --if cntSpellCast ~= 0 then
      --  varstring = varstring .. string.format(" %4d", cntSpellCast)
      --end

      local cntRescueFail=getStat(k, "failedrescue")
      local cntRescueSuccess=getStat(k, "successrescue")


      if xmode ~= 3 then
        if cntRescueFail + cntRescueSuccess ~= 0 then
          varstring = varstring ..  string.format(" %5.1f%% (%4d)", 
                  cntRescueSuccess*100/(cntRescueFail+cntRescueSuccess),  cntRescueFail+cntRescueSuccess)
        end
      end

      varstring = "* " .. varstring .. "\n"

      if checkMask("statHitter", k) then
        if k ~= whoami() then
          if xmode == 1 or xmode == 2 or xmode == 3 then
            if groupList:ingroup(k) then
              mud:send("gcmd ".. varstring)
            end
          end
        else
          if xmode == 2 or xmode == 3 then
            if groupList:ingroup(k) then
              mud:send("gcmd ".. varstring)
            end
          end
        end
      else
        if xmode == 3 then
          if groupList:ingroup(k) then
            mud:send("gcmd " .. varstring)
          end
        end
      end

      if xmode == nil then
        cecho(prefix .. varstring)
  --      send("acc " .. varstring)
      end
    end
  end

  -- print defense stats
  if xmode == nil then
    echo("\n")

    -- check is ac,spells-&gt;parry-&gt;block-&gt;dodge-&gt;partial parry-&gt;partial block-&gt;partial dodge

    cecho(string.format("%s* &lt;green&gt;Of %d attacks on %s, AC and spells caused %d (%4.1f%%) to miss completely. The remaining %d:\n", prefix, c_all, whoami(), c_miss, c_miss*100/c_all, c_adjhit ))
    
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were parried\n", prefix, c_parry, c_parry*100/c_adjhit ) )
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were deflected\n", prefix, c_deflect, c_deflect*100/c_adjhit ) )
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were shieldblocked\n", prefix, c_block, c_block*100/c_adjhit ) )
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were dodged\n", prefix, c_dodge, c_dodge*100/c_adjhit ) )
    
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were partially deflected\n", prefix, c_pdeflect, c_pdeflect*100/c_adjhit ) )
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were partially shieldblocked\n", prefix, c_glances, c_glances*100/c_adjhit ) )
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were partially dodged\n", prefix, c_graze, c_graze*100/c_adjhit ) )

    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) struck directly\n", prefix, 
      c_adjhit-skillblocked-partialblock, (c_adjhit-skillblocked-partialblock)*100/c_adjhit ) )
  
    cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) of shieldblocks were vamped\n", prefix, c_svamp, c_svamp*100/(c_block+c_glances) ) )
  end

  --mud:send("gsay Planetar heal procs: " .. ptar)

  echo("\n")

  printHeals()

  printDeaths()
end

function spairs(t, order)
    -- collect the keys
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end

    -- if order function given, sort by it by passing the table and keys a, b,
    -- otherwise just sort the keys 
    if order then
        table.sort(keys, function(a,b) return order(t, a, b) end)
    else
        table.sort(keys)
    end

    -- return the iterator function
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end

function v2print(xname)

local cntRescueFail=getStat(xname, "failedrescue")
local cntRescueSuccess=getStat(xname, "successrescue")

local c_attackmiss=getStat(xname, "offMiss")
local c_attackhit=getStat(xname, "offHit")

local c_block=getStat(xname, "defShieldBlock")
local c_dodge=getStat(xname, "defDodge")
local c_graze=getStat(xname, "defGraze")
local c_deflect=getStat(xname, "defWeaponDeflect")
local c_glances=getStat(xname, "defShieldGlance")
local c_svamp=getStat(xname, "shieldvamp")
local c_parry=getStat(xname, "defParry")
local c_pdeflect=getStat(xname, "defParryPartial")
local c_crit=getStat(xname, "crithit")

local c_hit=getStat(xname, "defHit")
local c_miss=getStat(xname, "defMiss")


local c_all=c_hit+c_miss + c_parry + c_deflect + c_dodge + c_block

local output = {}

local skillblocked = c_block + c_parry + c_deflect + c_dodge
local partialblock=  c_pdeflect + c_graze + c_glances


local v2allhit = c_hit + skillblocked
local v2weapon = c_parry + c_deflect + c_pdeflect

-- csv line

output[#output+1] = string.format("//%s,%s,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n", 
                      charData:get("statname"), whoami(), NyyLIB.str, NyyLIB.agibonus, NyyLIB.hitroll, NyyLIB.damroll,
                        cntRescueFail, cntRescueSuccess, c_attackmiss, c_attackhit,
                      c_block,c_dodge,c_graze,c_deflect,c_glances,c_svamp,c_parry,c_pdeflect, c_crit,c_hit,c_miss)

output[#output+1] = string.format("[Based on AC alone, %2.1f%% (%d) hit, %2.1f%% (%d) missed]\n",
              v2allhit*100/c_all, c_all,
              c_miss*100/c_all, c_miss)
              
output[#output+1] = string.format("[Of hits/potential hits (%d), %2.1f%% (%d) of them were dodged, %2.1f%% (%d) of them partially]\n",
                v2allhit,
                (c_dodge+c_graze)*100/v2allhit,
                 c_dodge+c_graze,
                c_graze*100/(c_dodge+c_graze),
                c_graze )

output[#output+1] = string.format("[Of available attacks (%d), %2.1f%% (%d) were shield blocked, %2.1f%% (%d) of them partially]\n",
                 v2allhit-c_dodge-c_graze,
                (c_block+c_glances)*100/(v2allhit-c_dodge-c_graze), c_block+c_glances,
                c_glances*100/(c_block+c_glances), c_glances)

output[#output+1] = string.format("[Of the remaining %d attacks, %2.1f%% (%d) were riposted, %2.1f%% (%d) of them partially]\n",
                 v2allhit-c_dodge-c_graze-c_block-c_glances,
                v2weapon*100/(v2allhit-c_dodge-c_graze-c_block-c_glances), v2weapon,
                c_pdeflect*100/(v2weapon), c_pdeflect   )

output[#output+1] = string.format("[%2.1f%% (%d) partially dodged, %2.1f%% (%d) glanced off shield, %2.1f%% (%d) partially deflected]\n",
                      c_graze*100/c_hit, c_graze,
                      c_glances*100/c_hit, c_glances,
                      c_pdeflect*100/c_hit, c_pdeflect)

output[#output+1] = string.format("[%2.1f%% (%d) attacks went through all defenses]\n", 
              (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances) )

output[#output+1] = string.format("[The final hit rate is %2.1f%% (%d)]\n",
                      c_hit*100/c_all,  c_hit )

output[#output+1] = string.format("[Defense: Hit %2.1f%% (%d/%d) : %2.1f%% (%d) direct, %2.1f%% (%d) dodge, %2.1f%% (%d) shield, %2.1f%% (%d) weapon]\n",
                        c_hit*100/c_all, c_hit, c_all,
                        (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances),
                        c_graze*100/c_hit, c_graze,
                        c_glances*100/c_hit, c_glances,
                        c_pdeflect*100/c_hit, c_pdeflect   )

output[#output+1] = string.format("[+HIT %d +DAM %d : Missed %2.1f%% (%d) Hit %2.1f%% (%d)]\n", 
                NyyLIB.hitroll, NyyLIB.damroll,
                c_attackmiss*100/(c_attackhit+c_attackmiss), c_attackmiss,
                c_attackhit*100/(c_attackhit+c_attackmiss), c_attackhit)


if cntRescueFail + cntRescueSuccess &gt; 0 then
  output[#output+1] = string.format("[%2.2f%% (%d) failed rescues, %2.2f%% (%d) success]\n", 
                      cntRescueFail*100 / (cntRescueFail+cntRescueSuccess), cntRescueFail, 
                      cntRescueSuccess*100 / (cntRescueFail+cntRescueSuccess), cntRescueSuccess)
end

local nx

echo("\n")

for nx=2, #output, 1 do
  echo(output[nx])
end

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>HelpScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function showHelp(xindex)
  local index, name
  local found=false
  
  for line in io.lines(mainpath("helpfile.dat")) do
    if string.find(line, ";;") ~= nil then
      if found == false then
        index,name = string.match(line, ";;([0-9]+),([a-zA-Z ]+)")
      else
        return
      end
    else
      if index == tostring(xindex) or name == xindex then
        found=true
        echo(line .. "\n")
      end
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MiscScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- anti timeout for autoroller

function autoroll(fname, xcommand)
  if xcommand == buttons.TIMEREXPIRE then
    mud:send("cha pow")
  end
end

-- anti timeout function

function timeout(fname, xcommand)
  if xcommand == buttons.TIMEREXPIRE then
    --display("AFK timeout")
    mud:send("TIME")
  end
end

-- copy entire contents from src to dst

function copyBuffer(srcBuffer, dstBuffer)
  local srcBufferSize = getLastLineNumber(srcBuffer)
  local nx
  
  if srcBufferSize &gt; 100 then
    cecho("&lt;red&gt;[ copyBuffer: srcBuffer &gt; 100 lines ]\n")
    return
  end

  -- buffer is 0 based, final line is blank from the previous newline
  
  for nx=0, srcBufferSize-1, 1 do
    moveCursor(srcBuffer, 0, nx)
    selectCurrentLine(srcBuffer)
    copy(srcBuffer)
    appendBuffer(dstBuffer)
  end
end

-- return true if in combat - incomplete

function inCombat()
  if prompt:get("enemy") ~= "" or prompt:get("tank") ~= "" then
    return(true)
  end

  return(false)
end

-- return true if hidden

function getHide()
  hidden = hidden or false

  return(hidden)
end

function setHide(xval)
  hidden = xval
end

-- echo debug messages to screen

function echoDebug(xline)
  if charData:get("condensed", true)["debug"] then
    cecho(xline)
  end
end

-- basic button script: button (spell) name, chardata entry, command button recieved

function shiftButton(xfname, xchardata, xcommand)
  if xcommand == buttons.UPDATE then
    updateButton(xfname)
    return
  end

  if xcommand ~= buttons.INIT then
    shiftSetting(xfname, xchardata)
  end

  local current=charData:get(xchardata)

  if type(current) == "boolean" then
    if charData:get(xchardata) then
      setLabelImage(xfname, xfname .. "-on.png")
    else
      setLabelImage(xfname, xfname .. "-off.png")
    end
  else
    if current == nil then
      return
    end
    
    setLabelImage(xfname, xfname .. "-" .. current .. ".png")
  end

  -- only call if a spell
  updateSpellCount(xfname)

  --display("X")
  --mud:send("\n")
end

-- basic button script: button (spell) name, chardata entry, command button recieved
-- this button does not place spell counts on it

function shiftSkillButton(xfname, xchardata, xcommand)
  if xcommand == buttons.UPDATE then
    return
  end

  if xchardata == nil then
    cecho("&lt;red&gt;[shiftSkillButton Error: " .. tostring(xfname) .. " xchardata is nil]\n")
    return
  end

  -- display( charData:get(xchardata) )

  if xcommand ~= buttons.INIT then
    shiftSetting(xfname, xchardata)
  end

  --display( charData:get(xchardata) )

  local current=charData:get(xchardata)

  if current == nil then
    cecho("&lt;red&gt;[Error: " .. tostring(xchardata) .. " is nil in table]\n")
    return
  end

  if type(current) == "boolean" then
    if charData:get(xchardata) then
      setLabelImage(xfname, xfname .. "-on.png")
    else
      setLabelImage(xfname, xfname .. "-off.png")
    end
  else
    setLabelImage(xfname, xfname .. "-" .. current .. ".png")
  end

  --updateSpellCount(xname)

  --mud:send("\n")
end

-- shiftSetting moves a setting to the right, and echoes any attached information

function shiftSetting(xname, xsetting)
  local setting = charData:get(xsetting)

  -- convert boolean to "true"/ "false"
  if setting == false then
    setting = "false"
  elseif setting == true then
    setting = "true"
  end

  for k,v in pairs(setvar) do
    if v[1] == xsetting then
      local element=table.index_of(v[3], setting) or 0

      element=element+1

      if element &gt; table.size(v[3]) then
        element=1
      end

      local tosetvalue= v[3][element]

      -- convert "true"/ "false" to boolean
      if tosetvalue == "true" then
        tosetvalue=true
      elseif tosetvalue == "false" then
        tosetvalue=false
      end

      charData:set(xsetting, tosetvalue )

      -- display message on screen
      local screenecho= v[6+element-1]

      if screenecho ~= nil then
        -- substitute xname in string for @ if value was passed 
        if xname ~= nil then
          screenecho = string.gsub(screenecho, "@", to_english(xname) )
        end

        cecho( screenecho )
      end
    end
  end
end

-- rtrim(xstring) - trim trailing spaces

function rtrim(xstring)
  local n = #xstring
  while n &gt; 0 and xstring:find("^%s", n) do n = n - 1 end
  return xstring:sub(1, n)
end

-- condenseLine(newline) - delete line if identical to previous and suffix with x#


function previousLine()
  local previousline = getLines(getLineNumber()-1, getLineNumber())[1]

  return(previousline)
end

function condenseLine(newline)
  local previousline = getLines(getLineNumber()-1, getLineNumber())[1]

  if newline == "" and previousline == "" then
    eraseLine()
  end

  if newline == "" then
    return
  end

  -- new line is prompt, previous line blank, and line prior is prompt
  if previousline == "" then
    if string.find(newline, "^&lt; .* &gt;") then
    
      if string.find(getLines(getLineNumber()-2, getLineNumber())[1], "&lt;") then
        -- delete empty line prior to current line   TODO - change to copy current line to previous + blank it
        moveCursor(0, getLineCount()-1)  
        eraseLine()

        condenseLine(rtrim(newline))
        return
      end
    end
  end

  if string.len(previousline) &gt; 10 and string.len(newline) &gt; 10 then
    if string.find(previousline, newline, 1, true) ~= nil then
      -- delete previous line
      moveCursor(0, getLineCount()-1)
      eraseLine()

      -- don't suffix counter on prompt lines
      if not string.find(previousline, "^&lt; .* &gt;") then
        -- if previous line had (x#) at the end, echo (x#+1)
        if string.findPattern(previousline, "(x[0-9]+)" ) ~= nil then
          cecho(" &lt;red&gt;(x" .. (tonumber(string.findPattern(string.findPattern(previousline, "%(x([0-9]+)%)" ), "[0-9]+" ))+1) .. ")")
        else
          cecho(" &lt;red&gt;(x2)")
        end
      end
    end
  end
end

function printSorted(xlist)
  local sortedlist=xlist

  table.sort(sortedlist)

  for nx=1, #sortedlist, 1 do
    cecho("&lt;green&gt;" .. sortedlist[nx])
  end
end

function homepath(xname)
  if xname == nil then
    cecho("\n&lt;red&gt;[Homepath Error: xname is nil]\n")
    return
  end

  local path = getMudletHomeDir() .. "\\" .. xname

  path=string.gsub(path, "\\", "/")  

  return(path)
end


function mainpath(xname)
  local pathname= string.gsub(NyyLIB.homedir .. xname, "\\", "/")

  local is_file = io.open(pathname)

  if is_file == nil then
    cecho("&lt;red&gt;[Error: file " .. pathname .. " not found]\n")
  else
    io.close(is_file)
  end

  return(pathname)
end

function soundpath(xname)
  local pathname= string.gsub(NyyLIB.homedir .. "sounds\\" .. xname, "\\", "/")

  local is_file = io.open(pathname)

  if is_file == nil then
    cecho("&lt;red&gt;[Error: file " .. pathname .. " not found]\n")
  else
    io.close(is_file)
  end

  return(pathname)
end


function iconpath(xname)
  local pathname= string.gsub(NyyLIB.homedir .. "buttons\\" .. xname, "\\", "/")

  local is_file = io.open(pathname)

  if is_file == nil then
    cecho("&lt;red&gt;[Error: file " .. pathname .. " not found]\n")
  else
    io.close(is_file)
  end

  return(pathname)
end

-- togBoolean will return the true/false reverse of the boolean provided

function togBoolean(xvar)
  if xvar then
    xvar=false
  else
    xvar=true
  end

  return(xvar)
end

function g(xitem)
  local container= charData:get("container")

  if container == "" then
    cecho("&lt;red&gt;[Container not set: @set container containername]\n")
  end

  return ( "get " .. xitem .. " " .. container )
end

function p(xitem)
  local container= charData:get("container")

  if container == "" then
    cecho("&lt;red&gt;[Container not set: @set container containername]\n")
  end

  return ( "put " .. xitem .. " " .. container )
end

function eraseLine()
  if not charData:get("condensed", true)["debug"] and not charData:get("condensed", true)["debug2"] then
    deleteLine()
  end
  
  if charData:get("condensed", true)["debug"] then
    cinsertText("&lt;red&gt;-")
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GroupClassScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

groupList = groupList or {}

previous = previous or {}

tankingList = tankingList or {}

-- return grouplist in a table

function groupList:get()
  return (self)
end

-- number of members in current grouplist

function groupList:size()
  return (#groupList)
end

-- delete all members in current grouplist

function groupList:reset()
  -- copy table before erasing
  previous=table.deepcopy(groupList)

  local nx

  for nx=1, groupList:size(), 1 do
    groupList[nx]=nil
  end
end

-- identify if anyone has been vitalized

function groupList:checkMaxHP()
  local nx

  --display(previous)

  for nx=1, #previous, 1 do
    local charname=previous[nx][1]
    local maxhp= tonumber(previous[nx][4])

    local newmaxhp= groupList:getMaxHP(charname)

    if newmaxhp ~= nil then
      if maxhp ~= 0 then
        if tonumber(newmaxhp) &gt; (maxhp+50) then
          if not buff:get("vitality", charname) then
            sendStatus(charname)
          end
        end
      end
    end
  end
end

-- return total number of mobs being tanked

function groupList:totalMobsTanked()
  local total=0
  
  for k,v in pairs(tankingList) do
    total = total + v
  end
  
  return(total)
end

-- reset tanking to 0

function groupList:resetTanking()
  tankingList = {}
end

-- add 1 to tank

function groupList:incTanking(xchar)
  if tankingList == nil then
    return
  end
  
  tankingList[xchar] = tankingList[xchar] or 0
  tankingList[xchar] = tankingList[xchar] + 1
end

-- who is tanking? is so, return who, how many

function groupList:whoTanking()
  if next(tankingList) == nil then
    return(false)
  end

  return(tankingList)
end

-- return how many mobs xchar is known to be tanking

function groupList:getTanking(xchar)
  tankingList[xchar] = tankingList[xchar] or 0

  return(tankingList[xchar])
end


-- check if xchar exists in current grouplist

function groupList:ingroup(xchar)
  local nx

  if xchar == "" then
    return(false)
  end

  if xchar ~= nil then
    xchar = string.title(xchar)
  end

  for nx=1, groupList:size(), 1 do
    if groupList[nx][1] == xchar then
      return(true)
    end
  end
  
  return(false)
end

-- set hp, maxhp for xchar in grouplist

function groupList:setHP(xchar, xhp, xmaxhp)
  local nx

  for nx=1, groupList:size(), 1 do
    if groupList[nx][1] == xchar then
      groupList[nx][3] = xhp
      groupList[nx][4] = xmaxhp
      return
    end
  end
end

-- return hp, maxhp for xchar in grouplist

function groupList:getHP(xchar)
  local nx

  for nx=1, groupList:size(), 1 do
    if groupList[nx][1] == xchar then
      return(groupList[nx][3])
    end
  end

  if xchar ~= "gray" and xchar ~= "spirit" then
    --cecho("\n&lt;red&gt;[Error: " .. xchar .. " does not exist in groupList]\n")
  end
end

function groupList:getMaxHP(xchar)
  local nx

  for nx=1, groupList:size(), 1 do
    if groupList[nx][1] == xchar then
      return(groupList[nx][4])
    end
  end

  if xchar ~= "gray" and xchar ~= "spirit" then
    --cecho("\n&lt;red&gt;[Error: " .. xchar .. " does not exist in groupList]\n")
  end
end


-- return list of all pc chars in grouplist, or matching mask

function groupList:pc(xmask)
  local temp={}, nx

  if xmask == nil then
    xmask="classes"
  end

  for nx=1, groupList:size(), 1 do
    local charname=groupList[nx][1]

    -- Don't add if Someone, 2.Someone, etc
    if not string.find( charname, "Someone") then
      if checkMask(xmask, charname) then
        table.insert(temp, charname)
      end
    end
  end

  return(temp)
end

-- add xchar to grouplist

function groupList:add(xchar, xcls, xhp, xmaxhp)
  --if xchar == "a gray slaad" then
  --  table.insert(self, 1, {xchar, xcls, xhp, xmaxhp})
  --  return;
  --end

  if xchar == "doppelganger" then
    return
  end

  -- change hell hound to wolf

  if xchar == "hound" then
    xchar= "wolf"
  end

  -- If name already exists in table, rename to 2. 3. etc

  for nx=1, #groupList, 1 do
    if groupList[nx][1] == xchar then
      local test=string.findPattern(xchar, "([0-9]+)[.]" )

      if test==nil then
        xchar = "2." .. xchar
      else
        xchar = tonumber(string.findPattern( string.findPattern(xchar, "([0-9]+)[.]" ), "[0-9]+" ) )+1 .. "." .. string.sub(xchar, 3)
      end
    end
  end

  
  if xcls == "A-P" then
    xcls="Blk"
  end
  
  local newc = table.index_of(NyyLIB.classes, xcls)
  
  if newc == nil then
    display("groupList:add nil class")
    display(xcls)
  end
  
  -- TODO: reorder insert to x, 2., 3.

  for nx=1, #groupList, 1 do
    --display(table.index_of(NyyLIB.classes, groupList[nx][2]))
    if newc == nil then
      --display("XXX")
    end
    if table.index_of(NyyLIB.classes, groupList[nx][2] ) &gt; newc then
      table.insert(groupList, nx, {xchar, xcls, xhp, xmaxhp})
      return(nil)
    end
  end

  table.insert(groupList, #groupList+1, {xchar, xcls, xhp, xmaxhp})

  --for nx=#groupList, 1, -1 do
  --  if table.index_of(NyyLIB.classes, groupList[nx][2] ) &lt; newc then
  --    table.insert(groupList, nx+1, {xchar, xcls, xhp, xmaxhp})
  --    return(nil)
  --  end
  --end

  --table.insert(groupList, 1, {xchar, xcls, xhp, xmaxhp})
end

-- modifed group display 

function groupList:display(xname, xhp, xmaxhp, xmv, xmaxmv, xpsp, xmaxpsp )
  local profilename=inwho(xname)

  local charClass = whoclass(xname)

  local color="&lt;green&gt;"

  if xhp ~= nil then
    color=colorNumber(xhp, xmaxhp)
  end

  if charClass ~= nil then
    if charData:get("group", true) then
      eraseLine()

      if xhp ~= nil then
        cecho ( string.format("\n%s%4d/%-4d", color, xhp, xmaxhp ) ) --hp
      else
        cecho ( "\n    /    " )
      end

      if profilename then
        cecho ( string.format("[%s] %s%-16s @%-15s", charClass, color, xname, profilename)) -- class, name, profilename
      else
        cecho ( string.format("[UNK] %s%-16s @%-15s", color, xname, "unknown")) -- name, profilename
      end

      if xmv ~= nil then
        cecho ( string.format("&lt;green&gt;%3d/%-3d ", xmv, xmaxmv) )
      else
        cecho ( color .. "   /    " )
      end

      if xpsp ~= nil then
        cecho ( string.format("&lt;green&gt;%4d/%-4d ", xpsp, xmaxpsp) )
      else
        cecho ( color .. "    /     " )
      end

    end

    if charClass ~= "UNK" then
      groupStatsDisplay(xname)
    end
  else
  -- pet
    if charData:get("group", true) then
      local linecheck = string.find(matches[1], xname)

      selectSection(linecheck-1, string.len(matches[1])-linecheck+1)
      copy()

      selectCurrentLine()
      replace("")

      if xhp ~= nil then
        cecho ( string.format("%s%4d/%-4d", color, xhp, xmaxhp ) ) --hp
      else
        cecho ( "    /    " )
      end

      echo ( "[UNK] " )

      paste()

      moveCursor(0, getLineCount())
      eraseLine()
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>BuffScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

buff = buff or {}

power = {
 armor=1200, 
 haste=324, 
 dragonscales=360,
 blur=202,  
 globe_of_invulnerability=324,
 displace=1200,
 time_stop=175,
 stoneskin=240,
 elemental_ward=180,
 vitality=480
}

function power:get(powername)
  return( power[powername] )
end

function power:set(xname, xdur)
  power[xname] = xdur
end

function buff:set(xname, xbuff, xdur)
  -- name is set to a titled string
  xname=string.title(xname)
  
  self[xname] = self[xname] or {}

  if xdur == -1 then
    self[xname][xbuff] = nil
  elseif xdur == nil then
    -- get from db based on xbuff
    self[xname][xbuff] = power:get(xbuff)
  else
    self[xname][xbuff] = xdur
  end
end


-- function buff:set(xname, xbuff, xdur)  : Add buff to character
-- function buff:get(xbuff, xname)     : Return time left on buff. whoami() substituted for xname if nil
-- function buff:del(xname, xbuff, xsuppress) : Remove an individual or all buffs from xchar
-- function decreasebuffs()              : internal - decrement all buffs by 1 second

function buff:get(xbuff, xname)
  
  
  if xname == nil then
    xname=whoami()
  end

  -- on login, whoami isn't yet known

  if xname == nil then
    return nil
  end

  -- change string to title
  xname = string.title(xname)

  if self[xname] ~= nil then
    if self[xname][xbuff] ~= nil then
      return(self[xname][xbuff])
    end
  end

  return nil
end

function buff:del(xname, xbuff, xsuppress)
  if xbuff == nil then
    self[xname]={}
    return
  end

  buff:set(xname, xbuff, -1)

  if xsuppress ~= nil then
    buffexpired(xname, xbuff)
  end
end

-- substitute underscore for spaces, make all lower case
function to_snake(xname)
  local newname

  newname=string.trim(xname)

  newname=string.lower(newname)

  newname=string.gsub(newname, " ", "_") -- replace space with underscore

  return(newname)
end

function to_english(xname)
  local newname

  if xname == nil or xname == "" then
    return("")
  end

  newname=string.title(xname)

  newname=string.gsub(newname, "_", " ")


  local cappedname=""

  -- change capitalization

  for k,v in pairs( string.split(newname, " ") ) do
    if #v &gt; 3 then
      cappedname = cappedname .. string.title(v) .. " "
    else
      cappedname = cappedname .. v .. " "
    end
  end

  return( string.trim(cappedname) )
end

function decreasebuffs()
  for key, value in pairs(buff) do 
    if type(value) == "table" then
      for k, v in pairs(value) do 
        buff[key][k] = v-1

        if (v-1) == 0 or v &lt; -10 then
          buffexpired(key, k)

          buff:del(key, k)
        end
      end
    end
  end
end

function buffexpired(xname, xbuff)
  if groupList:ingroup(xname) then
    if not charData:get("condensed", true)["spellout"] then
      cecho("\n&lt;red&gt;[" .. to_english(xbuff) .. " has expired on &lt;green&gt;" .. xname .. "&lt;red&gt;.]\n")
    end
  end

  if xbuff == "combatmind" and checkMask("psi") then
    dropcombatmind()
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIGroup</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function colorNumber(xhp, xmaxhp)
  local pct = 1
  local col="&lt;green&gt;"

  if xhp == nil then
    pct=100
  else
    if tonumber(xhp) then
      pct=(xhp*100)/xmaxhp
    end
  end

  if not tonumber(xmaxhp) then
    cecho("&lt;red&gt;[Prompt appears incorrect: Rent/Re-enter Toril]\n")
    display(xmaxhp)
  end

  pct=(xhp*100)/xmaxhp

  if pct &gt;= 100 then
    col = "&lt;green&gt;"
  elseif pct &lt; 100 and pct &gt; 91 then
    col = "&lt;DarkGoldenrod&gt;"
  elseif pct &lt;= 91 and pct &gt; 75 then
     col = "&lt;yellow&gt;"
  elseif pct &lt;= 75 and pct &gt; 50 then
     col = "&lt;magenta&gt;"
  elseif pct &lt;= 50 and pct &gt; 33 then
    col = "&lt;magenta&gt;"
  elseif pct &lt;= 33 and pct &gt; 15 then
     col = "&lt;OrangeRed&gt;"
  elseif pct &lt;= 15 and pct &gt; -500 then
    col = "&lt;red&gt;"
  end

  if xhp == "" then
      col = "&lt;green&gt;"
  end

  return(col)
end

function countlines(xstr)
  local n=0
  local len=string.len(xstr)

  for i in xstr:gmatch("\n") do n=n+1 end

  if xstr:sub(len,len) ~= "\n" then
    n=n+1 -- last char is not newline
  end

  if xstr == "" then
    n=0
  end

  return(n)
end


function genline(xchar, xcls, xhp, xmaxhp)
  
  local pct = 1
  local col=colorNumber(xhp, xmaxhp)
  local cls = ""  

  local buffdisplay = ""
  local var

  if xcls == "UNK" then
    cls = "&lt;red&gt;" .. xcls .. "&lt;green&gt;"
  else
      cls = xcls
  end

  -- scale/stone

  if buff:get("dragonscales", xchar) then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "dragonscales", "scl")
  else
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "stoneskin", "stn")
  end  

  -- blur

  buffdisplay = buffdisplay .. createBuffDisplay(xchar, "blur", "blr")

  -- globe/ward

  if buff:get("elemental_ward", xchar) then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "elemental_ward", "wrd")
  else
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "globe_of_invulnerability", "glb")
  end

  -- display final item on each group display line

  local endspell=charData:get("endspell")

  if endspell == "vit" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "vitality", "vit")
  elseif endspell == "cbm" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "combatmind", "cbm")
  elseif endspell == "dsp" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "displacement", "dsp")
  elseif endspell == "pwt" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "pass_without_trace", "pwt")
  elseif endspell == "fly" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "fly", "fly")
  elseif endspell == "grp" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "greater_realm_of_protecti", "grp")
  elseif endspell == "pfu" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "protection_from_undead", "pfu")
  elseif endspell == "hst" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "haste", "hst")
  elseif endspell == "dop" then
    buffdisplay = buffdisplay .. createBuffDisplay(xchar, "doppleganger", "dop")
  end

  -- various display formats

  local displayname= xchar
  local displaynamecol=col

  local petname=pet:getShortName(xchar)

  if petname then
    displayname=petname

    if pet:getInRoom(xchar) then
      displaynamecol="&lt;cyan&gt;"
    else
      displaynamecol="&lt;grey&gt;"
    end
  end

  if table.contains(NyyLIB.deadpeople, xchar) then
    -- This group member is dead 
    -- pets should never show here

    return ("&lt;navy&gt;" .. string.format("[%s]            %-16s                             ", xcls, displayname))
  else
    -- blind, paralyzed, or silenced

    if buff:get("blindness", xchar) or buff:get("blind", xchar) then
      return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "       [[ BLIND ]]          "))
    end

    if buff:get("major_paralysis", xchar) then
      return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "       [[ PARA ]]           "))
    end

    if buff:get("silence_person", xchar) then
      return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "       [[ SILENT ]]         "))
    end

    if buff:get("venom", xchar) then
      return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "       [[ VENOM ]]          "))
    end

    -- No major penalties on char

    if xhp == 0 then
      -- character is not in room

      return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, "----", "----", displaynamecol, displayname, buffdisplay))
    else
      -- default group line

      if xchar == whoami() and (groupList:size() ~= 1 or pet:size() &gt; 0 ) then
        return (col .. string.format("[%s] %4d/%-4d  &lt;cyan&gt;%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displayname, buffdisplay))
      else
        return (col .. string.format("[%s] %4d/%-4d  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, buffdisplay))
      end
    end
  end
end

function createBuffDisplay(xchar, xbuff, xdsp)
  local var = buff:get(xbuff, xchar)
  local time = bufftimedisplay(var)

  if var then  
    if string.starts(time, "0") then
      return ( "&lt;red&gt;" .. xdsp:upper() .. ":" .. time .. " ")
    else
      return ( "&lt;green&gt;" .. xdsp:upper() .. ":" .. time .. " ")
    end
  else
    return ( "&lt;grey&gt;" .. xdsp .. "    ")
  end
end

function RedrawGroupStatus()
  local bottomwin = ""
  
  local count=0
  local i=0

  local numchars = groupList:size() + pet:size()

  if groupRedraw ~= nil then
    return
  end

  -- loop through group list

  for k,char in pairs(groupList:pc()) do
    local cls=whoclass(char) or "UNK"

    local charline = genline( char, cls, groupList:getHP(char), groupList:getMaxHP(char) )

    i=i+1

    if i &gt; 1 and (i % 2) == 0 then    
      bottomwin = bottomwin .. "            "
    end

    bottomwin = bottomwin .. charline
      
    if i ~= numchars and (i % 2) == 0 then
      bottomwin = bottomwin .. "\n"
    end
  end

  -- loop through followers (pets) - should cyan highlight, title

  -- pet:getShortName(xname)


  for k,char in pairs( pet:getTable() ) do
    i=i+1

    local cls="UNK"

    local charline = genline( char, "UNK", pet:getHP(char) or 0, pet:getMaxHP(char) or 0 )

    if i &gt; 1 and (i % 2) == 0 then    
      bottomwin = bottomwin .. "            "
    end

    bottomwin = bottomwin .. charline

    if i ~= numchars and (i % 2) == 0 then
      bottomwin = bottomwin .. "\n"
    end
  end

  bottomGroupWindowLines=countlines(bottomwin)


  if bottomGroupWindowLines == 1 then
    bottomGroupWindowLines=2
  end

  resizeGroupWindow(force)
  force=nil

  local grw=charData:get("groupwindow")

  if grw == "bottom" or grw == "all" or grw == "split" then
    local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")

    clearWindow("gGroupStatusWindow")
    
    if charData:get("winGroup", true) then
      bottomWindow:show()
    else
      bottomWindow:hide()
    end

    -- display( parseLine(bottomwin) )

    bottomWindow:echo( parseLine(bottomwin) )
  end

end

-- this function is always the bottom window
function parseLine(xline)
  local fontsize = charData:get("grpfontsize", true)
  local WindowWidth, WindowHeight = getMainWindowSize()
  local retval=""

  -- calculate/set font size of lower window
  if groupList:size() &lt; 3 and charData:get("grpfontsize", true) == "auto" then
    --fontsize= maxfont(55, WindowWidth)
    fontsize= maxfont(40, WindowWidth)  

    --display(fontsize)

    if fontsize &gt; 14 then
      fontsize = 14
    end
  end

  for k,v in pairs( string.split(xline, "&lt;") ) do
    if v ~= "" then
      local tmp =   string.split(v, "&gt;")
    
      if tmp[2] ~= nil then
        retval = retval .. [[&lt;span style="color:]] .. tmp[1] .. [["&gt;]] .. 
           string.gsub(tmp[2], " ", "&amp;nbsp;")
           .. [[&lt;/span&gt;]]
      end
    end
  end


  retval = [[&lt;p style="font-size:]] .. fontsize .. [[px;font-style:normal;font-family: 'Bitstream Vera Sans Mono'"&gt;]] .. retval .. [[&lt;/font&gt;&lt;/p&gt;]]
  --retval = [[&lt;p style="font-size:]] .. fontsize .. [[px;font-style:normal;font-family: ']] .. charData:get("font", true) .. [['"&gt;]] .. retval .. [[&lt;/font&gt;&lt;/p&gt;]]
  retval = string.gsub(retval, "\n", "&lt;br&gt;")

  return(retval)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIButtons</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
buttons = buttons or {}

-- buttons.list = buttons.list or { [0]={}, [1]={} }

buttons.TIMEREXPIRE = 0

buttons.INIT = -1
buttons.CLICK = -2
buttons.UPDATE = -3
buttons.ENTER = -4
buttons.NESTCLICK = -5
buttons.HOVER = -6

function onEnter(xname,xid)
  currentIcon = {xname,xid}
end

function buttons:init()
  buttons.list = { [0]={}, [1]={} }
end

-- button name, position (1-20), minimum level to create, width (or nil), height (or nil)

-- Button will callback to self on click IF a function exists for it.
-- If no function exists, information is taken from the powerAliases[Classname] table
-- A spell button is populated with the highest known memorized spell matching the charData entry

-- xbar= itembar to use 0=bottom, 1=left side

function addbutton(xname, xbar, xid, xlevel, xwidth, xheight)
  local newbutton=nil

  local text1
  local text2
  local text3

  if xid == nil then
    cecho("\n&lt;red&gt;[Adding non-existant button: " .. xname .. "]\n")
    powerAliases:addButtons()
    return
  end

  local createname

  if xbar == 0 then
    createname = xbar .. "button" .. xid
    xwidth= xwidth or "4.8%"
    xheight = xheight or "2c"
  elseif xbar == 1 then
    createname= xbar .. "button" .. xid
    xwidth= xwidth or "95%"
    xheight = xheight or "8%"
  end

  if xid &gt; 20 then
    display(xname)
    display(xid)
  end

  --display(xname)
  --display(xlevel)
  assert( tonumber(xlevel), xlevel )

  if charData:get("level") &gt;= xlevel then
    local window
    
    if xbar == 0 then
      window=Geyser.Label:getWindow("gIconBarWindow")
    elseif xbar == 1 then
      window=Geyser.Label:getWindow("LeftPanel")
    end

    -- reuse button if previously created
    if buttons.list[xbar][xid] ~= nil then
      echoDebug("&lt;red&gt;Re-using button: " .. xname .. " " .. tostring(xbar) .. " " .. tostring(xid) .. "]\n")
      
      -- button overlay
      newbutton = buttons.list[xbar][xid][2]
    
      -- show base button
      buttons.list[xbar][xid][3]:show()
    else
      -- init button, it doesn't exist
      buttons.list[xbar][xid] = {}

      echoDebug("&lt;red&gt;Creating button: " .. xname .. " " .. tostring(xbar) .. " " .. tostring(xid) .. "]\n")

      local xp
      local yp
      local ys
      
      if xbar == 0 then
        xp=iconxp(xid)
        yp=0
        ys="100%"
      elseif xbar == 1 then
        xp=0
        yp=lefticonyp(xid)
        ys="8%"
      end
    
      if xid &gt; 15 then
        yp=0 -- right size icons, changed from 8
        --ys="2c"
        ys="100%"
      end
      
      
      local baseButton = Geyser.Label:new({name=createname .. "base", x=xp, y=yp, width=xwidth, height=ys}, window)
      
      
      buttons.list[xbar][xid][3] = baseButton
      
      buttons.list[xbar][xid][3]:setStyleSheet([[background-color : transparent]])
      
      buttons.list[xbar][xid][4] = Geyser.Label:new({name="textLabelButton" .. tostring(xbar) .. "." .. tostring(xid) .. "a", x=0, y=3, width="100%", height=20}, baseButton)
      buttons.list[xbar][xid][4]:setStyleSheet([[background-color : transparent]])

      buttons.list[xbar][xid][5] = Geyser.Label:new({name="textLabelButton" .. tostring(xbar) .. "." .. tostring(xid) .. "b", x=0, y=19, width="100%", height=20}, baseButton)
      buttons.list[xbar][xid][5]:setStyleSheet([[background-color : transparent]])

      buttons.list[xbar][xid][6] = Geyser.Label:new({name="textLabelButton" .. tostring(xbar) .. "." .. tostring(xid) .. "c", x=0, y=10, width="100%", height=20}, baseButton)
      buttons.list[xbar][xid][6]:setStyleSheet([[background-color : transparent]])
    
      newbutton = Geyser.Label:new({name=createname, x="1%", y="1%", width="98%", height="98%"}, baseButton)

      buttons.list[xbar][xid][2] = newbutton

      -- make label transparent
      newbutton:setStyleSheet([[background-color : transparent]])

      if xname == "dummy" then
        buttons.list[xbar][xid][1] = xname
        return
      end
    end

    newbutton:setFontSize(window.fontSize)
    newbutton:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;     &lt;br&gt;     &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])

    -- chose the correct callback function

    local isMeleeButton = powerAliases:isMeleePower(xname)
    local isInstacastButton = powerAliases:isInstacast(xname)
    local isPowersCast= powerAliases:isPowersCast(xname)

    if isMeleeButton or isInstacastButton or isPowersCast then
      echoDebug("isMeleeButton=true")
      newbutton:setClickCallback("meleePowersUpdate", xname, buttons.CLICK)
    elseif _G[xname] == nil then -- if no existing function use the generic spell button function
      echoDebug("Generic spellcast")
      newbutton:setClickCallback("updateSpellCount", xname, buttons.CLICK)
    else
      echoDebug("No callback")
      newbutton:setClickCallback(xname, xname, buttons.CLICK)
    end


    -- use tooltips only on bottom bar
    if xbar == 0 then
      newbutton:setToolTip(xname, "10")
    end
    
    newbutton:setOnLeave( "buttonLeave" )

    newbutton:show()
    
    buttons.list[xbar][xid][1] = xname
    buttons.list[xbar][xid][2] = newbutton

    initButton(xname)
  end

  return(newbutton)
end

function updateButton(xname, nest)
  local label

  if nest == nil then
    label=findlabel(xname)    
  else
    label=findlabel(nest)
  end

  if label ~= nil then
    label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. getSpellCount(xname) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
  end
end

function buttons:hide()
  local nx

  -- changed to hide base button, only hide to button 15
  for nx=1, 20, 1 do
    label=findlabel("0button" .. nx .. "base")

    if label ~= nil then
      label:hide()
    end
  end
end

function buttons:change(xchardata, xvalue, xbutton, xlevel)
  if xlevel == nil then
    xlevel=1
  end
  
  if charData:get("level") &gt;= xlevel then
    cecho("&lt;red&gt;[Setting " .. xchardata .. " to " .. tostring(xvalue) .. "]\n")
    charData:set(xchardata, xvalue)
  else
    charData:set(xchardata, nil)
  end

  buttons:sync()
end

function buttons:sync()
  local bar
  
  -- highlight buttons re: new charData
  for bar=0, #buttons.list, 1 do
    if table.size(buttons.list[bar]) ~= 0 then
      for i,v in pairs(buttons.list[bar] ) do
        initButton( v[1])
      end
    end
  end
end

function buttons:id(xname)
  local bar
  
  for bar=0, #buttons.list, 1 do
    if table.size(buttons.list[bar]) ~= 0 then
      for i,v in pairs(buttons.list[bar]) do
        if v[1] == xname then
          return bar, i -- location, id
        end
      end
    end
  end

  return(nil)
end

function toggleGroupwindow()
  local window=Geyser.Label:getWindow("gGroupStatusWindow")

  if charData:get("winGroup", true) then
    --hide group window
    
    charData:set("winGroup", false, true)
    window:show()
  
    groupButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
  else
    --show group window
    
    charData:set("winGroup", true, true)
    window:hide()
  
    groupButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
  end

  selectGroupWindows()
  resizeGroupWindow(true)
end

function toggleRightIconWindow()
  -- local window=Geyser.Label:getWindow("buttonpanel")
  local window=NyyLIB.buttonpanel

  if buttonPanel then
    buttonPanel=false
    window:hide()
  else
    buttonPanel=true
    window:show()
    window:raise()
    lowerWindow("buttonpanel")

    --NyyLIB.buttonpanellabel:raise()
  end
end



function toggleIconbar()
  local window=Geyser.Label:getWindow("gIconBarWindow")

  if charData:get("winIconbar", true) then
    -- hide icon bar
    charData:set("winIconbar", false, true)
    window:hide()
  
    iconbarButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
  
    cecho("&lt;red&gt;[Iconbar is OFF.]\n")
  else
    -- show icon bar
    charData:set("winIconbar", true, true)
    window:show()
  
    iconbarButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
  
    cecho("&lt;red&gt;[Iconbar is ON.]\n")
  end

  resizeGroupWindow(true)
end

function  showIconbar()
  local window=Geyser.Label:getWindow("gIconBarWindow")

  if charData:get("winIconbar", true) then
    iconbarButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
    
    window:show()
  else
    iconbarButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
    
    window:hide()    
  end
end

-- return true if label is not hidden

function isIconActive(xname)
  local label=findlabel(xname)

  if label == nil then
    return(false)
  end

  if label["hidden"] then
    return(false)
  else
    return(true)
  end
end

-- use correct label: either text, or .png

function setLabelImage(xname, ximage)
  local label=findlabel(xname)
  
  echoDebug("\n&lt;red&gt;[setLabelImage: " .. xname .. " " .. ximage .. "]\n")

  if label == nil then
    cecho("\n&lt;red&gt;Error: unable to locate label: " .. xname .. "\n")
    return
  end
  
  label:clear()

  -- format of returned label name should be # button #, (bar) (button number)
  
  local spellText= powerAliases:getLabelText(xname)
  
  -- is this in text array?
  
  if buttonText[xname] ~= nil or spellText ~= nil then
    local textArray
    
    if spellText ~= nil then
      textArray= string.split(spellText, "|")
    else
      textArray= string.split(buttonText[xname][1], "|")
    end
    
    local buttonBar, buttonNumber=buttons:id(xname)

    echoDebug("&lt;red&gt;[Bar: " .. tostring(buttonBar) .. " Number: " .. buttonNumber .. "]\n")

    local text1= buttons.list[buttonBar][buttonNumber][4]
    local text2= buttons.list[buttonBar][buttonNumber][5]
    local text3= buttons.list[buttonBar][buttonNumber][6]

    local fontColour=charData:get("colbuttonoff")
  
    -- located correct button text to use if multiple choices

    ximage = string.gsub(ximage, "^[A-Za-z_]+-", ""):lower()
    ximage = string.gsub(ximage, ".png", "")

    if spellText == nil then
      for k,v in pairs(buttonText[xname]) do
        if string.find(ximage, v:lower()) or string.find(v:lower(), ximage) then
          textArray= string.split(v, "|")
        end
      end
    end
    
    -- use button color 2 for specific buttons
    if table.contains( { "me", "on", "basic", "all", "large", "small", "hitters", "rogues", "tanks", "sizet", "sizes", "sizem", "sizel", "sizeh"}, ximage) then
      fontColour=charData:get("colbuttonon")
    end
    
    -- use grey for active
    
    if ximage == "active" then
      fontColour="grey"
    end
    
    label:setStyleSheet([[background-color : transparent]])
    
    if buttonNumber == nil or text1 == nil or text2 == nil then
      cecho(string.format("&lt;red&gt;[Error: setLabelImage xname %s ximage %s buttonNumber %s text1 %s text2 %s]\n", xname, ximage, tostring(buttonNumber),
                              tostring(text1), tostring(text2) ) )
      return
    end

    -- determine max font size
    -- function maxfont(xchars, xpixelwidth)
    
    local WindowWidth, WindowHeight = getMainWindowSize()
    local labelWidth = WindowWidth * .048

    -- 1276 x 687

    -- width: 92 font: 18
    -- width: 72 font: 13
    -- width  51 font: 11

    local fontSize = "18"
    
    if labelWidth &lt; 72 then
      fontSize= "13"
    end

    if labelWidth &lt; 62 then
      fontSize= "11"
    end

    if #textArray == 2 then
      if fontColour == charData:get("colbuttonon") then
        -- add bold
        text1:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[1] .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
        text2:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[2] .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
      else
        text1:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[1] .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
        text2:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[2] .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
      end

      text3:echo("")
    else
      text1:echo("")
      text2:echo("")

      if fontColour == charData:get("colbuttonon") then
        -- add bold
        
        text3:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. 
                  textArray[1] .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
      else
        text3:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. 
                  textArray[1] .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
      end
    end
    
    return
  end

  -- cecho("&lt;red&gt;[setLabelImage: " .. xname .. " " .. ximage .. "]\n")

  if label ~= nil then
    label:setStyleSheet([[    QLabel{ border-image: url(]]..iconpath(ximage)..[[);;background-color: transparent;}]])
    return(label)
  else
    cecho("\n&lt;red&gt;[Error: unable to locate label: " .. xname .. "]")
    return(nil)
  end
end

function findlabel(xname)
  local othername=xname
  local window=Geyser.Label:getWindow("gIconBarWindow")
  local leftwindow=Geyser.Label:getWindow("LeftPanel")

  -- icon bar hasn't been created
  if window == nil then -- or 1 == 1
    return(nil)
  end

  -- search for target name in existing buttons

  local bar
  
  for bar=0, #buttons.list, 1 do
    if table.size(buttons.list[bar]) ~= 0 then
      for i,v in pairs(buttons.list[bar]) do
        if v[1] == xname then
          othername = bar .. "button" .. i       
        end
      end
    end
  end

  -- Search top + 1 level of labels, lower icon bar

  for i,v in pairs(window.windowList) do
    if v.name == othername then
      return v
    end

    for key,val in pairs(v.windowList) do
      if val.name == othername then
        return val
      end
    end
  end

  -- search through left icon bar
  
  for i,v in pairs(leftwindow.windowList) do
    if v.name == othername .. "base" then
      return v
    end
  end

  if string.find(xname, "^[01]button([0-9])+$") == nil then
     --echoDebug("&lt;red&gt;[label not found " .. xname .. "]")
  end

  return(nil)
end

function buttonLeave()
  currentIcon=nil
end

function dummy()
  return
end

function createButtons()
  local nx=0
  
  for nx=1, 15, 1 do
    addbutton("dummy", 0, nx, 0)
  end
end


function findbutton(xid)
  local window=Geyser.Label:getWindow("gIconBarWindow")

  if xid == nil then
    cecho("\n&lt;red&gt;[findbutton: nil xid]\n")
  end

  -- search two levels
  
  for i,v in pairs(window.windowList) do
    if v.name == "0button" .. xid then
      return v
    end
  
    for key,val in pairs(v.windowList) do
      if val.name == "0button" .. xid then
        return val
      end
    end
  end

  return(nil)
end

function iconxp(xnum)
  if xnum &gt; 20 then
    xnum = 20
  end

  return( xnum/20*100 .. "%" )
end

function lefticonyp(xnum)
  if xnum &gt; 10 then
    xnum = 10
  end

  xnum=11-xnum

  return( xnum/10*100 .. "%" )
end

function iconyp(xnum)
  -- bottom row only
  return(8)
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- RightLabel - Righthand side image label that runs top to bottom
-- RightPanel - Righthand side container that holds other windows, just inside RightLabel

-- demonnic.chat.container is created inside RightPanel
-- tab box is 25px, created inside demonnic.chat.container

-- iconbar height is always 40 pixels
-- currenty top left corner of icon bar
-- Geyser.Label:getWindow("gIconBarWindow").y  will return in the format -78px

function resetgui()
  expandAlias("@resetgui", false)
end

function leftIcons()
  local WindowWidth, WindowHeight = getMainWindowSize()
  local lLabel=Geyser.Label:getWindow("LeftLabel")
  local exitLabel=Geyser.Label:getWindow("LeftExitLabel")

  if charData:get("hideequip", true) then
    setBorderLeft( 10 )

    exitLabel:show()

    lLabel:resize(5, nil)
  else
    setBorderLeft ( math.ceil(WindowWidth/20)+4 )

    exitLabel:hide()    

    lLabel:resize("5%", nil)
  end
end

function hideLeftIcons()

  local WindowWidth, WindowHeight = getMainWindowSize()

  if charData:get("hideequip", true) then
    local lLabel=Geyser.Label:getWindow("LeftLabel")
    local exitLabel=Geyser.Label:getWindow("LeftExitLabel")

    exitLabel:hide()

    lLabel:resize(5, nil)

    setBorderLeft( 10 )
  else
    setBorderLeft ( math.ceil(WindowWidth/20)+4 )
  end
end

function showLeftIcons()
  local lLabel=Geyser.Label:getWindow("LeftLabel")
  local exitLabel=Geyser.Label:getWindow("LeftExitLabel")
  local WindowWidth, WindowHeight = getMainWindowSize()

  if charData:get("hideequip", true) then
    exitLabel:show()
  else
    exitLabel:hide()
  end

  lLabel:resize("5%", nil)

  setBorderLeft ( math.ceil(WindowWidth/20)+4 )
end

function leftsideOnEnter()
  -- don't display if chat is fullscreen and currently adjustable container
  if chatAdjCon.width ~= "100%" or chatAdjCon.isUserWindow then
    showLeftIcons()
  end
end

function leftsideOnLeave()
  hideLeftIcons()
end

function createLeftsideContainers()
  local WindowWidth, WindowHeight = getMainWindowSize()

--  local label = Geyser.Label:new({name="LeftLabel", x="0%", y=0, width="5%", height=WindowHeight-200,})
--  Geyser.Container:new({name="LeftPanel", x="1%", y="2%", width="98%", height="90%",}, label)


-- if charData:get("level") == 50 then -- xp window = 32

--  local label = Geyser.Label:new({name="LeftLabel", x="0%", y=32, width="5%", height="100%",})
  local label = Geyser.Label:new({name="LeftLabel", x="0%", y=0, width="5%", height="100%",})
  Geyser.Container:new({name="LeftPanel", x="1%", y="2%", width="98%", height="75%",}, label)

  local exitlabel = Geyser.Label:new({name="LeftExitLabel", x="5%", y=0, width="10%", height="100%",})
  exitlabel:setStyleSheet([[background-color : transparent]]);

  label:setOnEnter( "leftsideOnEnter" )
  exitlabel:setOnEnter( "leftsideOnLeave" )

  leftsideOnLeave()
end

function createRightsideContainers()
  --local label = Geyser.Label:new({name="RightLabel", x="66%", y="0%", width="34%", height="100%",})
  --Geyser.Container:new({name="RightPanel", x="1%", y="2%", width="98%", height="90%",}, label)

  chatAdjCon = chatAdjCon or Adjustable.Container:new({name="chatAdjCon"})

  chatAdjCon:setTitle("Chat")
  
  if charData:get("chatAdjCon", true) then
    chatAdjCon:onDoubleClick()
  else
    if chatAdjCon.x == "10px" and chatAdjCon.y == "10px" then
      chatAdjCon:resize("36.1%", "30.9%")
      chatAdjCon:move("63.6%", "31.2%")
    end
  end

  rightLabel = Geyser.Label:new({name="RightLabel", x=0, y=0, width="100%", height="100%",}, chatAdjCon)
  
  Geyser.Container:new({name="RightPanel", x="1%", y="2%", width="98%", height="90%",}, rightLabel)
end

function setBorder()
  local window=Geyser.Label:getWindow("gIconBarWindow")
  local rLabel=rightLabel
  local lLabel=Geyser.Label:getWindow("LeftLabel")

  local border=charData:get("border", true)

  local is_file = io.open(border)

  if is_file ~= nil then
    io.close(is_file)
  end

  if border == "default" then

    if window ~= nil then
--      window:setStyleSheet([[border-image: url(]] .. mainpath("leftbar.png") .. [[)]])
      window:setStyleSheet([[border-image: url(]] .. mainpath("bottombar.png") .. [[)]])

      -- Geyser.Label:getWindow("gIconBarWindow"):setStyleSheet([[background-color: yellow]])
    end

    if rLabel ~= nil then
      --checkthis
      rLabel:setStyleSheet([[border-image: url(]] .. iconpath("frame-1.png") .. [[)]])
      rLabel:setStyleSheet([[border: 1px solid red; border-radius: 10px]])
    end

    if lLabel ~= nil then
--      lLabel:setStyleSheet([[border-image: url(]] .. iconpath("frame-1.png") .. [[)]])
      lLabel:setStyleSheet([[border-image: url(]] .. mainpath("leftbar.png") .. [[)]])
    end

    return
  end

  if border == "none" then
    if window ~= nil then
      window:setStyleSheet([[border-image: url("")]])
    end

    if rLabel ~= nil then
      rLabel:setStyleSheet([[border-image: url("")]])
    end

    if lLabel ~= nil then
      lLabel:setStyleSheet([[border-image: url("")]])
    end

    return
  end

  if is_file then
    if window ~= nil then
      window:setStyleSheet([[border-image: url(]] .. charData:get("border", true) .. [[)]])
    end

    if rLabel ~= nil then
      rLabel:setStyleSheet([[border-image: url(]] .. charData:get("border", true) .. [[)]])
    end

    if lLabel ~= nil then
      lLabel:setStyleSheet([[border-image: url(]] .. charData:get("border", true) .. [[)]])
    end
    
    return
  end

  -- it's a colour

  if window ~= nil then
    window:setStyleSheet([[background-color: ]] .. border )
  end

  if rLabel ~= nil then
    rLabel:setStyleSheet([[background-color: ]] .. border )
  end

  if lLabel ~= nil then
    lLabel:setStyleSheet([[background-color: ]] .. border )
  end
end

function GUIScripts( event, x, y )
  -- called on sysWindowResizeEvent
  -- warning: this will be called constantly

  if NyyLIB == nil or NyyLIB == {} then
    return
  end

  if   NyyLIB.initcompleted ~= true then
    return
  end

  if NyyLIB.homedir == nil then
    return
  end

  --display("X")

  local WindowWidth, WindowHeight = getMainWindowSize()

  if (NyyLIB.windowx == nil or NyyLIB.windowy == nil) or (NyyLIB.windowx ~= x or NyyLIB.windowy ~= y) then 
    -- main window size has changed

    NyyLIB.windowx = x
    NyyLIB.windowy = y

    if demonnic ~= nil then
      if demonnic.chat ~= nil then
        if demonnic.chat.config.fontSize == nil then
          demonnic.chat.config.fontSize=12
        end

        demonnic.chat:redo()
      end
    end

    resizeGroupWindow(true)
  
    -- redraw button text
    buttons:sync()
  end
end

-- return the maximum fontsize that can display xchars in space of xpixelwidth
-- added ychars, ypixelheight for minimum display (rows)

function maxfont(xchars, xpixelwidth, ychars, ypixelheight)
  local fontSize=5
  local fontWidth,fontHeight = calcFontSize(5)

  if xchars == 10 then
    --display(xpixelwidth)
  end

  -- fit to x width
  while xpixelwidth/fontWidth &gt; xchars do
    
    fontSize=fontSize+1
    fontWidth,fontHeight = calcFontSize(fontSize)

    if fontSize == 100 then break end --error?
  end
  fontSize=fontSize-1

  -- fit to y width if provided 

  if ychars ~= nil and ypixelheight ~= nil then
    while ypixelheight/fontHeight &lt; ychars do
      fontSize=fontSize-1
    
      fontWidth,fontHeight = calcFontSize(fontSize)
  
      if fontSize &lt; 6 then break end --error?
    end
  end

  return(fontSize)
end

function initgui()
  local WindowWidth, WindowHeight = getMainWindowSize()
  local wwidth,wheight = calcFontSize(11)
  local rPanel = Geyser.Label:getWindow("RightPanel")

  NyyLIB = NyyLIB or {}

  -- lower group status window

  if gGroupStatusWindow == nil then
    gGroupStatusWindow = Geyser.Label:new({name="gGroupStatusWindow", x="0%", y="-1c", width="100%", height="1c",})
  end

  setBackgroundColor("gGroupStatusWindow", 0,0,0,255)
  gGroupStatusWindow:setFontSize(11)

  -- icon bar (bottom)
  local window=Geyser.Label:getWindow("gIconBarWindow")

  if window == nil then
    window = Geyser.Label:new({name="gIconBarWindow", x="0%", y=-51, width="100%", height="40",})
    setBorder()

    window:show()
  
    -- create all possible buttons
    createButtons()
  end

  window:hide()

  window:setFontSize(8)

  buttons:hide()

  miniMap:create()
  roomWindow:create()
  
  -- non-specific buttons

  baseButtons()

  -- groupwindow

  initGroupWindow()

  timer:init()

  -- map window

  local currentmap =  charData:get("map")
  expandAlias("@map on", false)

  charData:set("map", currentmap)

  if charData:get("map") == "off" then
    expandAlias("@map off", false)
  end

  -- load window locations
  --loadWindowLayout()

  -- unsure why these needed to fix what's being displayed / bugfix that just works for unknown reason
  showIconbar()
  NyyLIB.buttonpanel:hide()
end

function initGroupWindow()
  selectGroupWindows()

  local groupWindowsType=charData:get("groupwindow")

  if table.contains( { "bottom", "split", "all" }, groupWindowsType) then
    showWindow("gGroupStatusWindow")
  end

  if groupWindowsType == "right" then
    window=Geyser.Label:getWindow("gIconBarWindow")

    window:move(nil,-40)
    NyyLIB.IconBarLabel:move(nil,-40)
  end

  bottomGroupWindowLines=0
end

-- This function displays the correct windows

function  selectGroupWindows()
  hideWindow("gGroupStatusWindow")
  clearWindow("gGroupStatusWindow")

  RedrawGroupStatus()
end

-- This function resizes the group windows if needed

function resizeGroupWindow(xforce)
  local iconBar=Geyser.Label:getWindow("gIconBarWindow")
  local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")
  local WindowWidth, WindowHeight = getMainWindowSize()
  local currenty  -- yp of iconBar

  bottomBorderPX = bottomBorderPX or 0

  if iconBar ~= nil then
    currenty = tonumber(string.match(iconBar.y, '[0-9]+'))
  else
    -- windows haven't been created yet
    return
  end

  if not bottomGroupWindowLines then
    return
  end

  local bottomWindowSize = heightBottomGroupWindow()

  -- move and resize the windows
  
  -- if icon bar hidden, currenty is top of bottomwindow
   
  --+40 likely wrong 
   
  if currenty ~= (bottomWindowSize+40) or xforce then
    local groupWindowsType=charData:get("groupwindow")

    -- move icon window up/or down .y is top 
    iconBar:move(nil,-(bottomWindowSize+40) )
    
    -- update currenty to the new iconbar position
    
    if charData:get("winIconbar", true) then
      currenty = tonumber(string.match(iconBar.y, '[0-9]+'))
    else
      currenty=bottomWindowSize
    end
    
    -- lower window
        
    bottomWindow:move(nil, "-" .. bottomGroupWindowLines .. "c")  
    bottomWindow:resize(nil, bottomGroupWindowLines .. "c")
    setBackgroundColor("gGroupStatusWindow", 0,0,0,255)

    -- resize left panel -  WindowHeight-(bottomWindowSize+40) (32 for xp window)

    local lLabel=Geyser.Label:getWindow("LeftLabel")

    -- move label if xp window is visible, resize
    if charData:get("level") == 50 then 
      lLabel:resize(nil, WindowHeight-(bottomWindowSize+40) )
      lLabel:move(nil,0)
    else
      lLabel:resize(nil, WindowHeight-(bottomWindowSize+40+32) )
      lLabel:move(nil,32)
    end

    demonnic.chat:redo()
  end

  -- set bottom border if window sizes have changed

  --display(currenty)
  
  if bottomBorderPX ~= currenty then
    --display(currenty)
    bottomBorderPX = currenty
    --setBorderBottom(bottomBorderPX)

    -- move gear button
    
    -- bottomBorderPX=edge, 96px height of button
    -- moved to top, commented out
    --NyyLIB.settingsbutton:move(nil, -bottomBorderPX-96-20) 
  
    -- move button panel
    --NyyLIB.buttonpanel:move(-(480+96+20), -bottomBorderPX-96-20)
  
    setBorderBottom(bottomBorderPX)
  end
end

-- credit to Akaya @ http://forums.mudlet.org/viewtopic.php?f=5&amp;t=4610&amp;start=10#p21770

function setStyle()
local background_color = "#26192f"
local border_color = "#b8731b"
local black_color = "#000000"

--    spacing: 10;
--   QToolButton:pressed {  background-color: red;}

 
setAppStyleSheet([[
  QMainWindow {
     background: ]]..background_color..[[;
  }

  QMainWindow::separator {
     background: ]]..background_color..[[;
  }

  QToolBar {
     background: ]]..background_color..[[;
  }

  QToolButton {
     background: ]]..background_color..[[;
     border-style: solid;
     border-width: 2px;
     border-color: ]]..border_color..[[;
     border-radius: 5px;
    font-family: BigNoodleTitling;
     color: white;
     margin: 2px;
     font-size: 12pt;
  }

  QToolButton:hover { background-color: grey;}
  QToolButton:focus { background-color: grey;}

  QMenuBar{ background-color: ]]..background_color..[[;}

  QMenuBar::item{ background-color: ]]..background_color..[[;}

  QDockWidget::title {
     background: ]]..border_color..[[;
  }

  QStatusBar {
     background: ]]..background_color..[[;
  }
  QScrollBar:vertical {
     background: ]]..background_color..[[;
     width: 15px;
     margin: 22px 0 22px 0;
  }
  QScrollBar::handle:vertical {
     background-color: ]]..background_color..[[;
     min-height: 20px;
     border-width: 2px;
     border-style: solid;
     border-color: ]]..border_color..[[;
     border-radius: 7px;
  }
  QScrollBar::add-line:vertical {
   background-color: ]]..background_color..[[;
   border-width: 2px;
   border-style: solid;
   border-color: ]]..border_color..[[;
   border-bottom-left-radius: 7px;
   border-bottom-right-radius: 7px;
        height: 15px;
        subcontrol-position: bottom;
        subcontrol-origin: margin;
  }
  QScrollBar::sub-line:vertical {
   background-color: ]]..background_color..[[;
   border-width: 2px;
   border-style: solid;
   border-color: ]]..border_color..[[;
   border-top-left-radius: 7px;
   border-top-right-radius: 7px;
        height: 15px;
        subcontrol-position: top;
        subcontrol-origin: margin;
  }
  QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
     background: white;
     width: 4px;
     height: 3px;
  }
  QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
     background: none;
  }
]])

  setBackgroundColor("gGroupStatusWindow", 0,0,0,255)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>TimerScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
timer = timer or {}
timer.values = timer.values or {}

-- Usage:
--
-- timer:init() - create master timer
-- timer:get(xname) - return current value or nil
-- timer:set(xname, xduration) -- set timer 'xname' to value 'xduration' (duration=nil removes timer)
-- timer:custom - if created, this script will be called every second after all timers are updated
--
-- If a function exists matching the name of the timer, it will be called every second with arguments (functionname, timervalue).
-- When time remaining reaches 0, the timer will then be removed.


function timer:init()
  -- disable v1 timer if present, create v2 timer

  if exists("MudTimer", "timer") == 1 then
    disableTimer("MudTimer")
  end

  if exists("MudTimer2", "timer") == 0 then
    permTimer("MudTimer2", "", 1, [[timer:script()]] )
  end


  enableTimer("MudTimer2")
end

function timer:set(xname, xduration)
  -- echoDebug("&lt;red&gt;\n[timer:set - " .. tostring(xname) .. " : " .. tostring(xduration) .. "]\n")
  
  if xname=="" then
    echo("timer set error " .. tostring(xduration))
  end
  
  if xname == nil then
    cecho("&lt;red&gt;\n[Error: timer:set xname is nil]\n")
  end
  
  self.values[xname] = xduration
end

function timer:get(xname)
  return (self.values[xname])
end

function timer:script()
  -- decrement all timers
  for k, v in pairs(timer.values) do
    timer.values[k] = timer.values[k]-1

    -- is this timer for a meleePower?
    
    local meleeTimer = powerAliases:isMeleePower(k)
    
    -- is this timer for a instacast SPELL power

    local meleeSpellTimer = powerAliases:isInstacast(k)

    -- Timer has reached 0 (expired)
    if timer.values[k] &lt; 0 and k ~= "" then
      timer.values[k] = nil  

      
      if meleeSpellTimer then -- todo: set to not be used
        --display("1expire " .. k)
        meleeSpellButton(k, 0)
      elseif meleeTimer then
        --display("2expire " .. k)
        meleePowersUpdate(k, 0)
      else
        if _G[k] ~= nil then
          -- call timer with 0 (expired)
          _G[k](k, 0)
        end
      end
    else
      -- have timer called every second with "fname, time" as argument
      
      if meleeTimer or meleeSpellTimer then
        --display("update " .. k .. " " .. timer.values[k])
        meleePowersUpdate(k, timer.values[k])
      else
        if _G[k] ~= nil then
          _G[k](k, timer.values[k])
        end
      end
    end
  end

  if timer.custom ~= nil then
    timer:custom()
  end
end

-- melee spell button : charData is wrong : TODO

function meleeSpellButton(fname, xcommand)
  -- if xcommand &gt; 0, function being called re: timer
  
  if fname == "cooldown" then
    return
  end
  
  --display(fname, xcommand)

  -- TODO: This is a bandaid. fname is cooldown, weapon change, spells and melee powers
  
  PopulateButtonCooldown(fname, xcommand)
end

function timer:custom()
  NyyLIB.ticktimer= NyyLIB.ticktimer-1

  local x, y = getMousePosition()
  local movement=false
  
  if x ~= mousex or y ~= mousey then
    -- mouse movement has occured
    movement=true
    
    mousex=x
    mousey=y
  end
  
  if NyyLIB == nil or Geyser.Label:getWindow("gIconBarWindow") == nil then
    return
  end

  if NyyLIB.ticktimer &lt; 1 then
    NyyLIB.ticktimer = 60
  end

  local label=findbutton("0.2")

  -- this displays the number in the bottom left corner
  if label ~= nil then
    -- clear current value
    setBackgroundColor(label.name, 0, 0, 0, 0)
    label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt; &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])  

    -- display assassinate timer, weaponchange

    local value=timer:get("weaponchange")

    if value == nil then
      value= timer:get("assassinatetimer")
    end

    if value ~= nil then
      label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;]] .. bufftimedisplay(value) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])  
    end

    -- TODO: global cooldown
  
    --local value=timer:get("cooldown")

    --if value ~= nil then
    --  label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;]] .. value .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])  
    --end

    -- display stun count
    local value=buff:get("stun")

    if value ~= nil then
      label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;]] .. value .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])  
    end
  end

  if NyyLIB.songtimer ~= nil and NyyLIB.songtimer ~= "" then
    if NyyLIB.songtimer &gt; 0 then
      NyyLIB.songtimer = NyyLIB.songtimer - 1

      label=findlabel("StopMusic")
        
      if label ~= nil then
        clearWindow("StopMusic")
        label:echo([[&lt;p style="font-size:25px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. NyyLIB.songtimer .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
      end
    end
  end

  if checkMask("enc") then
    if buff:get("time_stop") then
      PopulateTimestop()
    end
  end

  decreasebuffs()

  RedrawGroupStatus()
end

function timedisplay(seconds)

  local sec
  local min

  min=math.floor(seconds/60)

  sec=seconds-(min*60)

  return ( string.format("%d:%02d", min, sec))
end

function bufftimedisplay(seconds)

  local sec
  local min

  if seconds == nil then
    return("X")
  end

  min=math.floor(seconds/60)

  sec=seconds-(min*60)

  if min &gt; 0 then
    return( string.format("%2d", min) )
  end

  if sec &lt; 10 then
    return( string.format("%02d", sec) ) 
  end

  return ( string.format("%02d", sec) )
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PromptScripts</name>
					<packageName></packageName>
					<script>prompt = prompt or {}

function prompt:set(xkey, xvalue)
  self[xkey]=xvalue
end

function prompt:get(xkey)
  if self[xkey] == nil then
    return( "" )
  end
  
  return(self[xkey])
end

function prompt:isStringPrompt(teststring)
  if string.find(teststring, "^&lt; .* &gt;") then
    return(true)
  end

  return(false)
end

-- melee powers + spell powers
-- overlap from yuanti?
-- class powers with identical names ss=sandstorm, sweeping strike

function prompt:decodePowers(xstring)
  -- initial prompt on login
  --display(xstring)
  
  if whoclass() == nil then
    return
  end
  
  local toDecode = string.split(xstring, "|")
  
  for nx=1,#toDecode,1 do
    local testItem = toDecode[nx]
    
    if testItem ~= "" then
      local powersAlias = string.match(testItem, "([a-z]+) .*")
      local powersName=meleePowers:getName(powersAlias)
      
      local powersCooldown = string.match(testItem, "[a-z]+ (.*)")
      local powersRound = tonumber(powersCooldown) or 0
      
      --display(testItem)
      --display(powersAlias)
      --display(powersName)
      --display(powersCooldown)
      --display(powersRound)
      
      -- if timer exists set it to powersRound * 4 (seconds)
      if powersName ~= nil and powersName ~= "" then
        --display(powersName)
        if timer:get(powersName) then
          timer:set(powersName, powersRound*4)
        end
      end
    end
  end
end

function prompt:decodeSpellSlots(xstring)
  local toDecode = string.split(xstring, "|")

  --display(toDecode)

  for nx=1,#toDecode-1,1 do
    spell:setSlot(nx, tonumber(toDecode[nx]) )
  end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellQueue</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

spell = spell or {}
spell.spellcastqueue = spell.spellcastqueue or {}    -- queued spells
--spell.varsendqueue = spell.varsendqueue or {}  -- queued non-spell cmds

failedSpell = failedSpell or {}

mud = mud or {}

mud.varsendqueue = mud.varsendqueue or {}

function mud:sendCommands()
  local nx

  if mud.sending ~= nil then
    return
  end

  mud.sending = true

  if mud.varsendqueue ~= nil and mud.varsendqueue ~= {} then

    while #self.varsendqueue ~= 0 do
      local sendcommand = self.varsendqueue[1]

      table.remove(self.varsendqueue, 1)

      local assistcheck = string.match(sendcommand, "^assist (.*)")

      -- screen echo if command is order
      if string.match(sendcommand, "^ORDER (.*)") then
          cecho("\n&lt;yellow&gt;[ " .. sendcommand .. " ]\n")
      end 


      if assistcheck == nil then
        if sendcommand ~= "\n" then
          -- echoDebug("&lt;green&gt;[ Send: " .. sendcommand .. " ] ")
        end
        lastsent = sendcommand
        expandAlias(sendcommand, charData:get("condensed", true)["debug"])
      else
        if prompt:get("tank") == "" then
          echoDebug("&lt;green&gt;[Sending: " .. sendcommand .. "] ")
          lastsent = sendcommand
          expandAlias(sendcommand, charData:get("condensed", true)["debug"])
        else
          echoDebug("&lt;blue&gt;[Not sending assist]\n")
        end
      end
    end
  end

  mud.sending = nil
end

function mud:send(xcmd)
  mud.varsendqueue = mud.varsendqueue or {}

  echoDebug("&lt;red&gt;[function: mud:send (entry) " .. xcmd .. "]")

  -- don't queue duplicates commands?

  if table.contains(mud.varsendqueue, xcmd) == false then
    if xcmd ~= "\n" and table.size( mud.varsendqueue ) ~= 0 then
      echoDebug("\n&lt;red&gt;[ mud:send queue : " .. xcmd .. " ]")
    end

    table.insert(mud.varsendqueue, xcmd)
  else
    echoDebug("\n&lt;red&gt;[NOT Queuing: " .. xcmd .. "]")
  end

  -- send all queued commands if not casting or in fugue 

  if   spell:getCurrent() == nil or map:getRoom() == 93848 then
    -- send queue contents
    mud:sendCommands() 
  end
end

-- setCast is used to prevent multiple usage of some spells

function spell:setCast(xspell)
  if xspell ~= nil then
    self.spellsCast[xspell] = true
  else
    self.spellsCast = {}
  end
end

function spell:getCast()
  self.spellsCast = self.spellsCast or {}

  return ( self.spellsCast )
end


-- spell:attempt(tank, "dragonscales", "ds") then

function spell:attempt(xchar, xspell, xcommand) -- if xchar doesn't have xspell and spells available/memorized, cast it

  -- if failedSpell matches then return false

  --if xcommand .. " " .. xchar == failedSpell then
  --  echoDebug("&lt;red&gt;[failedSpell: " .. failedSpell .. "]\n")
  --  return(false)
  --end

  -- trim to 25 chars

  -- no target set for spell
  if not xchar then
    if getSpellCount(xspell) &gt; 0 then
      spell:cast(xcommand)
      return(true)
    end
    return(false)
  end

  
  -- don't cast spells on people outside room, dead
  -- TODO: may need to check for death pact
  
  if groupList:getHP(xchar) == 0 or table.contains(NyyLIB.deadpeople, xchar) then
    return
  end

  if not buff:get(string.sub(xspell, 1, 25), xchar) then

    -- dragonscales/stoneskin are exclusive
    if xspell == "dragonscales" and buff:get("stoneskin", xchar) then
      return(false)
    end

    if xspell == "stoneskin" and buff:get("dragonscales", xchar) then
      return(false)
    end

    if getSpellCount(xspell) &gt; 0 then
      if groupList:getHP(xchar) ~= 0 then
        spell:cast(xcommand .. " " .. xchar)
        return(true)  
      end
    end
  end

  return(false)
end

function spell:getMoving()
  self.moving = self.moving or false

  return ( self.moving )
end

function spell:setMoving(xstatus)

  if self.moving ~= xstatus and charData:get("autocast") then
    if xstatus then
      cecho("&lt;red&gt;\n\n[Spellcasting is temporarily paused.]\n\n")
    else
      cecho("&lt;red&gt;\n\n[No longer moving. Spellcasting has resumed]\n\n")
    end
    
    --cecho("&lt;red&gt;\n[spell:setMoving(xstatus) : " .. tostring(xstatus) .. "]\n")
  end

  if xstatus then
    automem = 0
    setEnemy("")
    assistSent=nil
  end

  self.moving = xstatus
end

function spell:getMem()
  self.memorize = self.memorize or false

  return ( self.memorize )
end

function spell:setMem(xstatus)

  if xstatus ~= self.memorize then
    echoDebug("&lt;green&gt;\n[spell:setMem(xstatus) : " .. tostring(xstatus) .. "]\n")
  end

  memsent = false

  self.memorize = xstatus
end

-- return who cast the spell that just completed

function spell:whocast()
  --Mizes completes his spell... (his|her|its)
  --You complete your spell...
  --You are surrounded in a brilliant aura of holy power.
  
  -- 1/24/2023 new message:
  -- You cast the spell 'Vitality'.
  -- Snurgt casts the spell 'Light'.
  
  --TODO: If echosend enabled need to check back further then 1 line
  
  local castline = getLines(getLineNumber()-1, getLineNumber())[1]
  local charname

  if string.find(castline, "You complete your spell...") ~= nil then
    return(whoami())
  end

  if string.find(castline, "You cast the spell") ~= nil then
    return(whoami())
  end

  charname = string.match(castline, "([A-Za-z]+) completes ") or 
             string.match(castline, "([A-Za-z]+) casts the spell ")
  
  return(charname)
end

function spell:setCurrent(xspell)
  self.casting=xspell
end

function spell:getCurrent()
  return(self.casting)
end

-- no spell is currently being cast
function spell:stop()
  spell:setCurrent(nil)
  echoDebug("\n&lt;blue&gt;[Setting spell.casting to nil]")
end


function spell:count()
  return( #self.spellcastqueue )
end


function spell:eraseQueue()
  self.spellcastqueue = {}
end


-- remove all queued spells matching pattern xspell - if xspell not set, clear entire spellqueue

function spell:clear(xspell, noAbort)
  
  -- this should be checked on function calls  
  if checkMask("psi") then
    return
  end
  
  if xspell == nil then

    -- abort spell if casting - need to fix for stun (don't send abort)
    if spell:getCurrent() ~= nil and not nomagic then
      -- The abort command is sent direct to mud, not queued

      if not noAbort then
        send("abort")
      end

      --if pet:status("ghost") then
      --  mud:send("ORDER ghost abort")
      --end      
    end

    spell:eraseQueue()

    spell:stop()

    cecho("\n&lt;blue&gt;[Spellqueue cleared.]\n")

    memsent = false

    mud:sendCommands()

    return
  end

  local ix=0

  if spell:count() ~= 0 then
    for ix=spell:count(), 1, -1 do
      if self.spellcastqueue[ix] == nil then
        cecho("\n&lt;red&gt;[Error: clear spell " .. xspell .. "]\n")
        display(ix)
      end

      if string.find(self.spellcastqueue[ix], "^" .. xspell) then
        table.remove(self.spellcastqueue, ix)
      end
    end
  end

  if string.find(spell:getCurrent() or "", "^" .. xspell) then
    echoDebug("&lt;red&gt;[Sending abort: " .. spell:getCurrent() or "" .. " : " .. xspell .. "]\n")

    -- The abort command is sent direct to mud, not queued

    if not noAbort then
      send("abort")
    end
  end
end


-- will char be able to cast or use power?

function spell:castOK()
  -- if escapedir set don't cast
  if NyyLIB.escapedir ~= nil then
    return(false)
  end

  -- can't cast if bashed/sitting
  if prompt:get("position") ~= "std" then
    return(false)
  end

  -- can't cast in fugue

  if map:getRoom() == 93848 then
    return(false)
  end

  -- stunned, can't cast

  if buff:get("stun") then
    return(false)
  end

  -- paralyzed, can't cast

  if buff:get("minor_paralysis") or buff:get("major_paralysis") then
    return(false)
  end

  -- if melee power used/no response, can't cast
  
  if meleePowerUsed then
    return(false)
  end
  
  -- if bash was sent, 10 second cooldown
  
  if timer:get("bash") then
    return
  end
  
  return(true)
end

function spell:cast(xspell)
  if xspell ~= nil then
    echoDebug("&lt;red&gt;[spell:cast : " .. tostring(xspell) .. "]\n")
  end

  if not spell:castOK() then
    return
  end

  if spell:getCurrent() == "group" or spell:getCurrent() == "look" then
    spell:eraseQueue()
  end

  if not spell:getCurrent() then
    mud:sendCommands()
  end

  -- don't cast spells when sending status or waiting on look

  if sendingStatus then
    return
  end
  
  -- don't cast spells when mem'ing or moving

  if spell:getMem() or memsent or spell:getMoving() then
    return
  end

  -- don't cast if trying to mem or look sent/not received
  if spell:getMem() or memsent or look:get() then
    return
  end

  -- don't queue spells if already casting
  if self.casting then
    if xspell == nil then
      echoDebug("&lt;red&gt;[Currently casting: " .. self.casting .. "]\n")
      return
    end

    return
  end

  if xspell ~= nil then
    -- remove spell from queue if already present
    for ix=spell:count(), 1, -1 do
      if string.find(self.spellcastqueue[ix], "^" .. xspell) then
        --echoDebug("&lt;red&gt;[Removing from spellcastqueue: " .. xspell .. "]\n")
        table.remove(self.spellcastqueue, ix)
      end
    end

    -- do not queue spell if casting that spell
    if spell:getCurrent() ~= xspell then
      self.spellcastqueue[spell:count()+1] = xspell
    end
  end

  if spell:getCurrent() == nil then
    mud:sendCommands()

    if spell:count() &gt; 0 then
      local tocast = self.spellcastqueue[1]

      -- if fh spell and &gt; 80% hp, remove from queue

      local fhchar = string.match(tocast, "^fh (.*)")

      if groupList:ingroup(fhchar) then
        local hp=tonumber(groupList:getHP(fhchar))
        local maxhp= tonumber(groupList:getMaxHP(fhchar))

        if hp &gt; .8 * maxhp then
          -- remove spell from queue, try casting next spell
          table.remove(self.spellcastqueue, 1)
          spell:cast()
          return
        end
      end

      spell:setCurrent(tocast)
      table.remove(self.spellcastqueue, 1)

      -- command is sent here. If first letter is capital, don't display send?
      
      local displayname = to_english(powerAliases:toSpell(self.casting:lower()))

      cecho("\n&lt;red&gt;[&lt;cyan&gt;SPELL: &lt;red&gt;" .. displayname .. "] &lt;yellow&gt;" .. self.casting )

      if self.casting == string.title(tostring(self.casting)) then
        -- this send is not queued
        send(self.casting, false)
      else
        -- this send is not queued
        send(self.casting, true)
      end
    end
  end
end

function spell:setNext(xcommand)
  -- move to top of queue, or add if non-existant

  -- don't cast spells when sending status

  if sendingStatus then
    return
  end

  -- if currently casting this spell return
  if self.casting ~= nil then
    if self.casting == xcommand then
      echoDebug("\n&lt;red&gt;[Not queuing, already casting: " .. self.casting .. "]\n")
      return
    end
  end

  -- this is supposed to remove from queue if already present

  if table.contains (self.spellcastqueue, xcommand) then
    table.remove(self.spellcastqueue, table.index_of(self.spellcastqueue, xcommand) )
  end

  -- only queue spells if not in fugue

  if map:getRoom() ~= 93848 then
    table.insert(self.spellcastqueue, 1, xcommand)
  else
    self.casting=nil
  end

  spell:cast()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>WhoScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- NyyLIB.WhoClass.wholist xname={xclass,xrace,xprofilename}

function fixwholist()
  -- internal, not called
  local removed=0
  local total=0

  for k,v in pairs(NyyLIB.WhoClass.wholist) do
    if #(sqlclist(k)) &gt; 0 then
      removed=removed+1
      NyyLIB.WhoClass.wholist[k]=nil
    end

    total=total+1
  end

  echo("Total " .. total .. "\n")
  echo("Removed " .. removed .. "\n")
end

function savewholist()
  table.save( homepath("wholist_v3"), NyyLIB.WhoClass.wholist)
end

function loadwholist()
  NyyLIB.WhoClass = NyyLIB.WhoClass or {}
  NyyLIB.WhoClass.wholist = NyyLIB.WhoClass.wholist or {}

  local is_file = io.open( homepath("wholist_v3") )
  
  if is_file == nil then
    echo("[Creating wholist]\n")

    table.load( mainpath("wholist_v3"), NyyLIB.WhoClass.wholist )
    savewholist()
  end

  table.load( homepath("wholist_v3"), NyyLIB.WhoClass.wholist)
end

-- inwho(xname) - returns false or profilename

function inwho(xname)
  local profilename

  if xname == nil or xname == "" then
    return(false)
  end

  if string.findPattern(xname, " ") ~= nil then
    return(false)
  end

  if xname == "Someone" then
    return(false)
  end

  if NyyLIB.WhoClass.wholist[xname] ~= nil then
    return(NyyLIB.WhoClass.wholist[xname][3])
  end

  profilename = sqlinwho(xname)

  if profilename ~= false then
    return(profilename)
  end

  return(false)
end

-- k charname, v {x,x,x}
function whoclist(xname)
  for k,v in pairs(NyyLIB.WhoClass.wholist) do
    if k == xname or v[3] == xname then
      if sqlprofilename(k) == false then
        cecho(string.format("&lt;green&gt;[-- %15s] %20s %-15s (@%s)\n", v[1], k, 
          string.format("(%s)", v[2]), v[3]))
      end
    end
  end
end

function whoadd(xname, xclass, xrace, xprofile)
  NyyLIB.WhoClass.wholist = NyyLIB.WhoClass.wholist or {}

  -- find correct class name 
  for k, v in pairs(NyyLIB.fullclasslist) do
    if v[1] == xclass then
      xclass=v[2]
    end
  end

  if NyyLIB.WhoClass.wholist[xname] == nil then
    if xprofile == nil then
      NyyLIB.WhoClass.wholist[xname] = {xclass, xrace, "unknown"}
    else
      NyyLIB.WhoClass.wholist[xname] = {xclass, xrace, xprofile}
    end
  else

    -- correct wrong class
    if NyyLIB.WhoClass.wholist[xname][1] ~= xclass then
      NyyLIB.WhoClass.wholist[xname][1]=xclass
    end
    -- use setProfile?
    --if xprofile ~= nil and xprofile ~= "unknown" then
    --  NyyLIB.WhoClass.wholist[xname][3] = xprofile
    --end
  end
end

function setProfile(xname, xprofile)
  NyyLIB.WhoClass.wholist[xname][3] = xprofile 
end

function getProfile(xname)
  if NyyLIB.WhoClass.wholist[xname] ~= nil then
    return ( NyyLIB.WhoClass.wholist[xname][3] )
  end

  return(nil)
end

function whoaccount(xname)
  for k,v in pairs(NyyLIB.WhoClass.wholist) do
    if v[3] == xname then
      return(k)  
    end
  end

  if NyyLIB.WhoClass.wholist[xname] ~= nil then
    return ( NyyLIB.WhoClass.wholist[xname][3] )
  end

  return(nil)
end

function whoclass(xname)
  -- if xname = nil then replace it with whoami()

  if xname == nil then
    xname = whoami()
  end

  if xname == "a gray slaad" then
    return("UNK")
  end

  local retval

  if xname ~= nil then
    if NyyLIB.WhoClass.wholist[xname] ~= nil then
      retval=NyyLIB.WhoClass.wholist[xname][1]
    end
  end
  
  if retval == "A-P" then
    retval = "Blk"
  end

  if retval == "Dir" then
    retval = "Hex"
  end


  if NyyLIB.WhoClass.wholist[xname] ~= nil then
    return (retval)
  end

  return(nil)  
end


function whorace(xname)
  if xname == nil then
    xname=whoami()
  end


  if xname == "a gray slaad" then
    return("UNK")
  end

  if NyyLIB.WhoClass.wholist[xname] ~= nil then
    return ( NyyLIB.WhoClass.wholist[xname][2] )
  end

  return(nil)  
end

function whoami()
  return(whoamiv)
end

function setwhoami(xchar)
  whoamiv = xchar
end

function whosize(xname)
  local nx

  if xname == nil then
    xname=whoami()
  end

  local race=whorace(xname)

  for nx=1, #NyyLIB.fullracelist, 1 do
    if NyyLIB.fullracelist[nx][1] == race then
      return(NyyLIB.fullracelist[nx][2])
    end
  end

  return(nil)  
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ConsentScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
consent = consent or {}

consent.chars = consent.chars or {}

function consent:get(xchar)
  xchar=xchar:upper()
  
  if self.chars[xchar] == nil then
    self.chars[xchar] = false
  end

  return ( self.chars[xchar] )
end

function consent:set(xchar, xval)
  xchar=xchar:upper()

  self.chars[xchar]=xval
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PowerAliases</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

powersTable= powersTable or {}
powerAliases= powerAliases or {}
-- { "banshee_wail", "bw", 46, "", ""}

-- TODO: check on powers table should be moved to function


function powersTable:tableExists()
  local charclass = whoclass()
  
  if powersTable[charclass] == nil or powersTable[charclass][subClass] == nil then
    echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
    return(false)
  end
  
  return(true)
end


-- return power alias for supplied name (if it exists), or nil

function powerAliases:getAlias(xname)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end
  
  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xname:lower() then
      return(powersTable[charclass][subClass][nx][1])
    end
  end

  return(nil)
end

-- return text for label

function powerAliases:getLabelText(xname)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xname:lower() then
      return(powersTable[charclass][subClass][nx][3])
    end
  end

  return(nil)
end

-- if (full name) a melee power

function powerAliases:isMeleePower(xpowername)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  -- return true if a melee power

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xpowername:lower() then
      return(powersTable[charclass][subClass][nx][8])
    end
  end

  return(false)
end



-- is this a caster-type spell = display spell count?

function powerAliases:isCasterSpell(xspellname)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  -- return true if a caster-type spell

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xspellname:lower() then
      if powersTable[charclass][subClass][nx][7] == 1 then
        return(true)
      end
    end
  end

  return(false)
end

function powerAliases:isInstacast(xspellname)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  -- return true if a instacast spell (no casting message)

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xspellname:lower() then
      if powersTable[charclass][subClass][nx][7] == 2 or powersTable[charclass][subClass][nx][7] == 3 then 
        return(true)
      end
    end
  end

  return(false)
end

function powerAliases:isPowersCast(xspellname)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  -- return true if a powers cast spell (with casting message)

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xspellname:lower() then
      if powersTable[charclass][subClass][nx][7] == 4 then 
        return(true)
      end
    end
  end

  return(false)
end

function powerAliases:noCooldown(xspellname)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  -- return true no cooldown for this spell

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xspellname:lower() then
      if powersTable[charclass][subClass][nx][7] == 2 then 
        return(true)
      end
    end
  end

  return(false)
end






-- return the charData entry associated with this spell

function powerAliases:getChardata(xspellname)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][2]:lower() == xspellname:lower() then
      return(powersTable[charclass][subClass][nx][4])
    end
  end

  return("")
end

function powerAliases:getFullname(xalias)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][1]:lower() == xalias:lower() then
      return(powersTable[charclass][subClass][nx][2])
    end
  end

  return("")
end

-- { "needle_swarm", "ns", 26, "automissile", ""},

function powerAliases:addButtons()
--  addbutton("beltyns_burning_blood", 6, 31) -- hlmissile
--  addbutton("rain_of_blood", 3, 46)
--  addbutton("magic_missile", 5, 1)
--  addbutton("ward_undead", 12, 26)

  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  -- loop through all spells, and add button if it matches listed keys

  for nx=1, #powersTable[charclass][subClass], 1 do
    local name=powersTable[charclass][subClass][nx][2]
    local level=powersTable[charclass][subClass][nx][6]
    local spellkey=powersTable[charclass][subClass][nx][4]

    if spellkey == "autohlmissile" then
      addbutton(name, 0, 3, level)
    end

    if spellkey == "autoarea" then
      addbutton(name, 0, 4, level)
    end

    if spellkey == "autovit" then
      addbutton(name, 0, 7, level)
    end

    if spellkey == "automissile" then
      addbutton(name, 0, 5, level)
    end

    if spellkey == "autohlarea" then
      addbutton(name, 0, 6, level)
    end

    if spellkey == "autostorm" then
      addbutton(name, 0, 7, level)
    end

    if spellkey == "autoheal" then
      addbutton(name, 0, 8, level)
    end

    if spellkey == "autoharm" then
      addbutton(name, 0, 9, level)
    end

    if spellkey == "turnundead" then
      addbutton(name, 0, 12, level)
    end

    if spellkey == "autoquake" then
      addbutton(name, 0, 13, level)
    end

    if spellkey == "autord" then
      addbutton(name, 0, 15, level)
    end
  end
end


function powerAliases:castDamage()
  local charclass = whoclass()

  local charDataEntries= {}

  -- abort if not in combat or other spells currently queued
  if not inCombat() or spell:count() &gt; 0 then
    return(false)
  end

  --display(spell:getCurrent())

  -- faerie fire
  if charData:get("autoffire") then
    if not (spell:getCast())["ff"] then
      if getSpellCount("faerie_fire") &gt; 0 then
        if table.size( spell:getCast() ) == 0 then
          spell:cast("c 'faerie fire'")
          return
        end
      end
    end
  end

  if charData:get("turnundead") then
    charDataEntries[#charDataEntries+1] = "turnundead"
  end

  if charData:get("autohlarea") then
    charDataEntries[#charDataEntries+1] = "autohlarea"
  end

  if charData:get("autohlmissile") then
    charDataEntries[#charDataEntries+1] = "autohlmissile"
  end

  if charData:get("autoarea") then
    charDataEntries[#charDataEntries+1] = "autoarea"
  end

  if charData:get("automissile") then
    charDataEntries[#charDataEntries+1] = "automissile"
  end

  if charData:get("autoharm") then
    charDataEntries[#charDataEntries+1] = "autoharm"
  end

  if charData:get("autowail") then
    charDataEntries[#charDataEntries+1] = "autowail"
  end


  -- loop through all spells, and cast the first spell that matches
  --display("z")
  for nx=#powersTable[charclass][subClass], 1 , -1 do
    if table.contains(charDataEntries, powersTable[charclass][subClass][nx][4]) then
      --display(powersTable[charclass][subClass][nx][4])
      if getSpellCount(powersTable[charclass][subClass][nx][2]) &gt; 0 then
        -- don't cast spells limited to 1/fight
        if not (spell:getCast())[powersTable[charclass][subClass][nx][2]] then
          -- uppercase means gagging screen echo of the command being sent
          --cecho("&lt;green&gt;\n[ powerAliases:castDamage() - " .. powerAliases[charclass][nx][2] .. " ]\n")
          spell:cast( string.upper(powersTable[charclass][subClass][nx][1]) )
          return(true)
        end
      end
    end
  end

  return(false)
end

function powerAliases:findChardataButton(xchardata)
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][4] == xchardata then
      local spellname=powersTable[charclass][subClass][nx][2]
      local buttonBar, buttonid = buttons:id(spellname)

      if buttonid ~= nil then
        return(buttonid)
      end
    end
  end

  -- no existing button
  return(nil)
end

-- display correct button for highest level memd spell

function powerAliases:updateButton(xchardata)
  local charclass = whoclass()

  if xchardata == "" then
    return
  end

  if not powersTable:tableExists() then return(nil) end

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][4] == nil then
      display(nx)
    end
    
    if powersTable[charclass][subClass][nx][4] == xchardata then
      local spellname=powersTable[charclass][subClass][nx][2]
      local spelllevel= tonumber( powersTable[charclass][subClass][nx][6] )      

      if getSpellCount(spellname) &gt; 0 then
        if not isIconActive(spellname) then
          -- TODO need to identify correct button number
          addbutton(spellname, 0, powerAliases:findChardataButton(xchardata), spelllevel)
        end

        return
      end
    end
  end        
end

-- return the power (without target)

function powerAliases:toPower(xcommand)
  local charclass = whoclass()

  -- non-powers spells
  if string.match(xcommand, "c[ast]* +'") ~= nil then
    return(nil)
  end

  if not powersTable:tableExists() then return(nil) end

  -- extract power if string includes a target
  local powername = string.match(xcommand, "^([a-z]+) .*")

  if powername == nil then
    powername = xcommand
  end

  return(powername)
end

-- return the (fixed) spellname associated with a power

-- TODO: This should be changed to return name, target

function powerAliases:toSpell(xcommand)
  local charclass = whoclass()

  -- non-powers spells
  if string.match(xcommand, "c[ast]* +'") ~= nil then
    local _, _, spellname = string.find(xcommand, "c[ast]* +' *(.*) *'.*")
    return( to_snake(spellname) )
  end

  if not powersTable:tableExists() then return(nil) end

  local powername = powerAliases:toPower(xcommand)

  for nx=#powersTable[charclass][subClass], 1, -1 do
    if powersTable[charclass][subClass][nx][1] == powername then
      return( powersTable[charclass][subClass][nx][2] )
    end
  end
    
  echoDebug("Missing spell " .. powername)
  return(nil)
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PetScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The wraith of a human noble is busy, but will execute your order as soon as possible.
-- The wraith of a human noble starts casting an offensive spell called 'abi dalzims horrid wilting'.

-- The wraith of a human noble starts casting an offensive spell.
-- The wraith of a human noble completes its spell...


pet = pet or {}
pet.followers = pet.followers or {}
pet.oldfollowers = pet.oldfollowers or {}
pet.used = pet.used or {}

-- pet:add(petname, fullname, xhp, xmaxhp, inroom) - add pet to table
-- pet:delete(petname) - remove pet from table
-- pet:status() - return true if currently have any tracked pets
-- pet:status(type) - return true if currently have any tracked pets of 'type'



function pet:setRoom(xpet, xroom)
  if xpet == nil then
    return
  end

  if self.followers[xpet] == nil then
    return
  end

  echoDebug("&lt;red&gt;[Setting " .. xpet .. " to " .. tostring(xroom) .. "]\n")
  self.followers[xpet][6] = xroom
end

function pet:getRoom(xpet)
  if self.followers[xpet] ~= nil then
    return( self.followers[xpet][6] )
  end

  return(nil)
end

function pet:getOldRoom(xpet)
  if self.oldfollowers[xpet] ~= nil then
    return( self.oldfollowers[xpet][6] )
  end

  return(nil)
end

function pet:size()
  return( #pet:getTable() )
end

-- return true if that pet is undead
function pet:isUndead(xpetname)
  if self.followers[xpetname] ~= nil then
    if table.contains(self.followers[xpetname][5], "undead") then
      return(true)
    end
  end

  return(false)
end

function pet:getHP(xpetname)
  if self.followers[xpetname] ~= nil then
    return( self.followers[xpetname][2] )
  end

  return(nil)
end

function pet:setHP(xpetname, xvalue)
  if self.followers[xpetname] ~= nil then
    self.followers[xpetname][2]= xvalue
  end

  return(nil)
end


function pet:getMaxHP(xpetname)
  if self.followers[xpetname] ~= nil then
    return( self.followers[xpetname][3] )
  end

  return(nil)
end


function pet:orderAllCast(xspell)
  mud:send("ORDER followers cast '" .. xspell .. "'")

  return
end


-- pet:setInRoom(petname, xvalue) - xvalue true/false, is the pet in the current room or not

function pet:setInRoom(petname, xvalue)
  if self.followers[petname] ~= nil then
    if xvalue then
      self.followers[petname][4] = true
    else
      self.followers[petname][4] = false
    end
  else
    echoDebug("&lt;red&gt;[pet:setInRoom - " .. petname .. " is not in table]\n")
  end
end

-- pet:getInRoom(petname) - returns true if petname is in the current room

function pet:getInRoom(petname)
  if self.followers[petname] ~= nil then
    if map:getRoom() ~= nil then
      if map:getRoom() == pet:getRoom(petname) then
        return(true)
      end
    end

    if self.followers[petname][4] == "+" then
      return(true)
    else
      return(false)
    end
  else
    if petname == nil or petname == false then
      return(false)
    end

    --display(petname)

    echoDebug("&lt;red&gt;[pet:getInRoom - " .. petname .. " is not in table]\n")
    return(false)
  end
end

-- return a table of all followers of type ghost, wraith, or shadow

function pet:getCasterTable()
  local petlist = {}

  petlist = table.n_union(pet:getTable("ghost"), pet:getTable("wraith"), pet:getTable("shadow") )

  -- remove any from list not in current room
  for nx=1, #petlist, 1 do
    if not pet:getInRoom( petlist[nx] ) then
      table.remove(petlist, nx)
    end
  end

  return(petlist)
end

-- pet:getTable(xname) return a table of followers of type xname or all pets if nil passed

function pet:getTable(xname)
  local petlist = {}
  local testname
  

  if xname ~= nil then
    testname=pet:generateName(xname)
  end

  for k,v in pairs(pet.used) do
    if testname ~= nil then
      if string.findPattern(k, testname) then
        petlist[#petlist+1]=k
      end
    else
      petlist[#petlist+1]=k
    end
  end

  return(petlist)
end

-- pet:isNamed(xnamelist) - passed a mud formatted name list, and determines if any of the names match script renamed format

function pet:isNamed(xnamelist)
  -- passed list of possible names

  local keywords= string.split(xnamelist, " ")

  -- return existing formatted petname
  for k,v in pairs(keywords) do
    if string.match(v, "(.*[0-9]+)") then
      return(v)
    end
  end

  -- no name matches found
  return(nil)
end

-- pet:getShortName(xname) - return the 8 letter petname segment

function pet:getShortName(xname)
  local prefix= string.sub(whoami():lower(), 1, 3)

  local capture

  -- return existing formatted petname

  capture = string.match(xname, prefix .. "([a-z]+)[0-9]+")

  return(capture) 
end


-- pet:generateName(xname) return first 3 letters of whoami, first 8 letters of petname passed

function pet:generateName(xname)
  if xname == "gray" then
    xname= "slaad"
  end

  return(string.sub(whoami():lower(), 1, 3) .. string.sub(xname,1,8))
end


-- pet:generateNumberName(xname) - generates a name based on 'xname', and assigns an unused number to it

function pet:generateNumberName(xname)
  -- find first available numbered pet to use

  local nx

  for nx=1,15,1 do
    local testname= pet:generateName(xname) .. tostring(nx)

    if not pet.used[testname] then
      return(testname)
    end
  end

  cecho("&lt;red&gt;[pet:generateNumber - All possible pet numbers used]\n")
  return(pet:generateName(xname) .. "16")
end


-- pet:rescue(xchar) - order 1.spectre (or all followers) to rescue xchar

function pet:rescue(xchar)
  if checkMask("fighter") then
    return
  end

  if charData:get("petrescue") == "NONE" or getHide() then
    return
  end

  if spell["casting"] ~= nil or NyyLIB.escapedir ~= nil then
    return
  end

  -- paralyzed, can't send orders

  if buff:get("minor_paralysis") or buff:get("major_paralysis") then
    return
  end

  if xchar ~= "" and pet:status() then
    local spectrename=pet:getTable("spectre")[1]

    if spectrename ~= nil then
      if not pet:getInRoom(spectrename) then
        spectrename=nil
      end
    end

    if spectrename ~= nil then
      mud:send("ORDER " .. spectrename .. " rescue " .. xchar)
    elseif #pet:getTable() == #pet:getTable("ghost") then
      -- can't rescue if only pets are ghost, wraith, shadow
    elseif #pet:getTable() == #pet:getTable("wraith") then
      -- can't rescue if only pets are ghost, wraith, shadow
    elseif #pet:getTable() == #pet:getTable("shadow") then
      -- can't rescue if only pets are ghost, wraith, shadow
    else
      mud:send("ORDER followers rescue " .. xchar)
    end
  end
end

-- returns pet name if fullname passed matches the name of a pet

function pet:member(xfullname)
  if xfullname == nil then
    cecho("\n&lt;red&gt;[pet:member - xfullname is nil]\n")
  end

  for k,v in pairs(self.followers) do
    if v[1]:lower() == xfullname:lower() then
      return(k)
    end
  end

  return(false)
end

function pet:add(petname, fullname, xhp, xmaxhp, inroom, xfullkeywords)
  self.followers[petname] = {fullname, xhp, xmaxhp, inroom, xfullkeywords}
end

function pet:delete(petname)
  if self.followers[petname] ~= nil then
    self.followers[petname] = nil
  end
end

-- return true/false if a pet of type petname exists

function pet:status(petname)
  if petname == nil then
    if table.size(self.followers) &gt; 0 then
      return(true)
    else
      return(false)
    end
  else
    if #(pet:getTable(petname)) ~= 0 then
      return(true)
    else
      return(false)
    end
  end
end

-- usename marks a name as state:1 (believed to be used, not confirmed)

function pet:useName(petname)
  self.used[petname] = 1
end

-- confirmname marks a name as state:2 (has been confirmed to be in use)

function pet:confirmName(petname)
  self.used[petname] = 2
end

-- cleannames clears all unused names after having tested/confirmed them 

function pet:cleanNames()
  for k,v in pairs(self.used) do
    if v == 1 then
      self.used[k]=nil
    end
  end
end

-- pet:reset - sets all used entries to 1 in preperation to be confirmed

function pet:reset()
  self.oldfollowers = self.followers
  self.followers = {}

  for k,v in pairs(self.used) do
    self.used[k]=1
  end
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SoundScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

noSound = noSound or false

function sound(xname, xvolume, xlimited)
  local soundmode=charData:get("sound", false)

  if soundmode == "off" or (soundmode == "limited" and not xlimited) then
    return
  end
  
  if xvolume == nil then
    xvolume=100
  end

  -- if noSound has been set, this sound is one-time silenced
  if not noSound then
    echoDebug("\n&lt;red&gt;[sound: " .. xname .. "]\n")
    playSoundFile( soundpath(xname), xvolume )
  end

  noSound=false
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>RescueScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
rescuelist = rescuelist or {}

function rescuelist:generate()
  self.list= {}

  for k,char in pairs(groupList:pc("petRescue")) do
    table.insert(self.list, char)
  end
end  

function rescuelist:get()
  return(self.list)
end

function rescue(fname, xcommand)
  shiftSkillButton("rescue", "rescuetype", xcommand)
end

-- send rescue will send a single rescue command to the mud

rescueSent=false

function sendRescue(xchar)
  if rescueSent == false then

    -- can't rescue if blind
    
    if buff:get("blind") or buff:get("blindness") then
      return
    end

    if xchar == "someone" or xchar == "Someone" then
      return
    end

    -- stand first if sitting
    if spell:getMem() == true then
      mud:send("ST")
    end


    cecho("\n&lt;red&gt;[ Rescue: " .. xchar .. " ]\n")
    mud:send("RESCUE " .. xchar)

    if xchar == "ghost" then
      send("RESCUE 2.ghost")
    end

    if xchar == "guard" then
      send("RESCUE 2.guard")
      send("RESCUE 3.guard")
      send("RESCUE 4.guard")
    end

    rescueSent = true
  end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EnemyScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The ghoul of an opulent merchant

-- a minion of Moander 

function idMob(xname)
  local mobnames=
        { "zombie", "ghoul", "skeleton", "wight", "shadow", "spectre", "ghast", "ghost", "spirit"}

  local enemytable = string.split(xname, " ")

  if string.find(xname, "shadow of") then
    return("shadow")
  end

  if string.find(xname, "elderly priest of Mielikki") then
    return("priest")
  end

  if string.find(xname, "Rhangaun, Leader of the Rune Council") then
    return("rhangaun")
  end

  if string.find(xname, "minion") then
    return("minion")
  end

  if string.find(xname, "doppelganger") then
    return("doppelganger")
  end

  if string.find(xname, "runelord") then
    return("runelord")
  end

  if string.find(xname, "tyrant") then
    return("beholder")
  end


  -- check for containing a matching name
  for nx=1, #mobnames, 1 do

    --if string.find("hell hound", mobnames[nx]) then
    --  return("wolf")
    --end

    if string.find(xname, mobnames[nx]) then
      return(mobnames[nx])
    end
  end

if xname == "a great Molydeus tanar'ri" then
  return( "molydeus" )
end

if enemytable[#enemytable] == "para-elemental" then
  return( "elemental" )
end

if enemytable[#enemytable] == "batle-mage" then
    return( enemytable[2] )
  end

  if enemytable[#enemytable] == "member" then
    return( enemytable[2] )
  end

  if enemytable[#enemytable] == "patrolman" then
    return( enemytable[3] )
  end

  -- return the final word in the string
  return( enemytable[#enemytable] )
end

function getEnemy()
  enemy = enemy or ""

  return(enemy)
end

function setEnemy(xval)
  if xval == nil then
    cecho("&lt;red&gt;[Error: setEnemy(nil)]\n")
    return
  end
  
  if getEnemy():lower() ~= xval:lower() then
    echoDebug("&lt;red&gt;\n[Setting enemy to: &lt;blue&gt;" .. tostring(xval) .. "&lt;red&gt;]\n")
  end

  enemy = xval
end

function sendCon(xname)
  --if conSent == nil then
  --  conSent=true

  --  mud:send("CON " .. xname )
  --end
  
  return
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellAlerts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function getQuake()
  bcastQuake = bcastQuake or false

  return(bcastQuake)
end

function setQuake(xval)
  bcastQuake = xval
end

function castQuake()
  if getQuake() then
    if getSpellCount("earthquake") &gt; 0 then
      spell:setNext("c 'earthquake'")
      setQuake(false)
      return(true)
    end
  end

  return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MountScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

mount = mount or {}

-- addbutton("SummonMount", 10, 15)

function mount:set(xname)
  self.mountname = xname

  if xname ~= nil and NyyLIB.initgui then
    if checkMask("summonmount") then
      addbutton("MountDismount", 0, 11, 15)
    end
  else
    if checkMask("summonmount") then
      addbutton("SummonMount", 0, 11, 15)
    end
  end
end

function mount:get()
  return( self.mountname )
end

function mount:setMounted(xval)
  self.mounted=xval

  dismounted=false

  if checkMask("dir") then
    if xval then
      addbutton("mounted_charge", 0, 3, 1)
    else
      initDir()
    end
  end
end

function mount:getMounted()
  if self.mounted == nil then
    self.mounted=false
  end

  return(self.mounted)
end

function mount:charge(xtarget)
  if not timer:get("mountedcharge") then
    if xtarget ~= nil then
      if checkMask("dir") then
        mud:send("mc " .. xtarget)
      else
        mud:send("charge " .. xtarget)
      end
    else
      if checkMask("dir") then
        mud:send("mc")
      else
        mud:send("charge")
      end
    end

    timer:set("mountedcharge", 8)

    return(true)
  end

  return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>singleSendScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The look:send() command will send a single look command to the mud.

look = look or {}

function look:send()
  if not look:get() or look:get() == "LOOKSTART" then
    toGagLook=true
    --gaglook=true

    mud:send("LOOK")
    look:set("LOOKSENT")
  end
end

function look:set(xstatus)
  self.status=xstatus
end

function look:get()
  if self.status == nil then
    return(false)
  end

  return(self.status)
end

-- The group:send() command will send a single group command to the mud.
-- All group responses from using this command are gagged

group = group or {}

-- gagGroup = true -&gt; gag group
-- gagGroup = nil  -&gt; don't gag

function group:send(xval)
  if xval == false then
    gagGroup=nil
    return
  end

  if gagGroup == nil then
    gagGroup=true
    mud:send("GROUP")
    group:set("GROUPSENT")

    --send the followers command after sending group if NOT rogue
    
    if not checkMask("rog") then
      sendFollowers()
    end
  end
end

function group:set(xstatus)
  -- cecho("&lt;cyan&gt;[group:set " .. tostring(xstatus) .. "]\n")
  self.status=xstatus
end

function group:get()
  if self.status == nil then
    return(false)
  end

  return(self.status)
end

-- The sendFollowers() command will send a single (gagged) followers command to the mud
-- Multiple calls to the command will not complete.

function sendFollowers(xval)
  -- don't send followers if hidden
  if xval == false or getHide() then
    followersSent=nil
    return
  end

  -- don't send followers if nil
  --if followers == nil then
  --  return
  --end

  -- don't send followers if rogue
  
  if checkMask("rog") then
    followersSent=nil
    return
  end

  -- don't send followers if meditating (psi)
  --if checkMask("psi") and spell:getMem() then
  --  followersSent=nil
  --  return
  --end

  if followersSent then
    echoDebug("\n&lt;blue&gt;[followers command already sent]")
  end

  if not nofollowers then
    if followersSent == nil then
      followersSent = true
      mud:send("FOLLOWERS")
    end
  end
end

-- The sendStatus(xcharname) command requests status for that char

function sendStatus(xcharname)

  sendingStatus = true

  if xcharname == nil then
    mud:send("STATUS")
  else
    echoDebug("&lt;red&gt;\n[Sending status: " .. xcharname .. "]\n")
    mud:send("STATUS " .. xcharname )
  end
end

function sendAssist(xchar)
  --if xchar ~= nil then
  --  cecho("&lt;green&gt;[sendASsist: " .. xchar .. "]\n")
  --end

  if NyyLIB.castertrain then
    return
  end

  -- paralyzed, can't assist

  if buff:get("minor_paralysis") or buff:get("major_paralysis") then
    return
  end
  
  -- can't assist if blind
    
  if buff:get("blind") or buff:get("blindness") then
    return
  end
  
  -- if hp not listed send group
  if groupList:getHP(xchar) == 0 then
    group:send()
  end

  if charData:get("autoassist") == false then
    return
  end

  -- already in combat: why assist again?
  if inCombat() then
    return
  end

  -- sm caster train is active : flee to mem?
  if isActive("SMTrainCaster", "trigger") ~= 0 then
    if not fightreturn then
      if prompt:get("position") == "sit" then
        mud:send("ST")
      end

      -- send flee
      fleeMem()
      return
    end
  end

  echoDebug("&lt;red&gt;[assist]")

  if checkMask("rog") then
    local enemytarget = getEnemy()

    -- invis target, don't have di
    if enemytarget == "Someone" or enemytarget == "someone" then
      return
    end

    if enemytarget == "nightmare" then
      return
    end

    if enemytarget ~= "" then
      if enemytarget == "mage" or enemytarget == "wight" then
        if not buff:get("globe_of_invulnerability") then
          return
        end
      end
    end
  end

  if assistSent == nil then
    assistSent = true

    -- currently sitting: send stand first TODO is this sending multiple times?

    if prompt:get("position") == "sit" then
      mud:send("ST")
    end

    sendPoison()

    if checkMask("rog") then
      local enemytarget = getEnemy()

      if enemytarget ~= "" then
        -- if wraith kill, not backstab

        if timer:get("wraithform") then
          mud:send("KILL " .. enemytarget)
          return
        end

        if sendAssassinate(enemytarget) then
          return
        end

        -- nonpowers backstab for practice
        local backstab


        if prompt:get("hp") &gt; 1000 then
          backstab = "backstab " .. enemytarget
        else
          backstab = "bs " .. enemytarget
        end

        cecho("\n&lt;red&gt;[" .. backstab .. "]\n")
        mud:send(backstab)
      end

      look:send()

      return
    end

    -- mount before assisting
    if mount:get() ~= nil and not mount:getMounted() then
      --send("mount " .. mount:get() )
      mud:send("mount")
    end

    -- if memorizing stand before sending assist
    if spell:getMem() or memsent then
      mud:send("ST")
    end

    if checkMask("ran") then
      local enemytarget = getEnemy()

      if enemytarget ~= "" then
          cecho("\n&lt;red&gt;[&lt;cyan&gt;KILL " .. enemytarget .. "&lt;red&gt;]\n")
          mud:send("KILL " .. enemytarget)
          look:send()
          return
      end
    end

    echoDebug("&lt;red&gt;[assist " .. xchar .. "]\n")

    mud:send("assist " .. xchar)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellTrackerScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- incSpellCount(xname)
-- decSpellCount(xname)
-- setSpellCount(xname, xvalue)
-- getSpellCount(xname)
-- resetSpellCount()

function resetSpellCount()
  cecho("&lt;red&gt;[Clearing memorized spells]\n")
  charData:set("spells", {})
end

function incSpellCount(xname)
  local count=charData:get("spells") or {}

  count[xname] = count[xname] or 0
  count[xname] = count[xname] + 1

  -- echoDebug("\n&lt;red&gt;[ incSpellCount: " .. xname .. " value: " .. getSpellCount(xname) .. " ]" )

  charData:set("spells", count)

  -- call script associated with memorized spell to update spellcount in gui

  updateSpellCount(xname)

  return
end

function decSpellCount(xname)
  local count=charData:get("spells") or {}

  count[xname] = count[xname] or 1
  count[xname] = count[xname] - 1

  -- echoDebug("\n&lt;red&gt;[ decSpellCount: " .. xname .. " value: " .. getSpellCount(xname) .. " ]" )

  charData:set("spells", count)

  -- call script associated with memorized spell to update spellcount in gui

  updateSpellCount(xname)

  return
end

function getSpellCount(xname)
  local count=charData:get("spells") or {}

  count[xname] = count[xname] or 0

  return( count[xname] )
end

function setSpellCount(xname, xvalue)
  local count=charData:get("spells") or {}

  count[xname] = xvalue

  charData:set("spells", count)

  -- call script associated with memorized spell to update spellcount in gui

  updateSpellCount(xname)

  return
end

function iCast()
  if string.find(getLines(getLineNumber()-1, getLineNumber())[1], "You complete your spell...") ~= nil then
    return true
  end

  -- spellcast message change
  if string.find(getLines(getLineNumber()-1, getLineNumber())[1], "You cast the spell") ~= nil then
    return true
  end

  return false
end

function initButton(xname)
  
  -- xname = sweeping_strike, TiaVolance, cloak_of_the_winds, etc
  
  if powerAliases:isMeleePower(xname) then
    shiftButton(xname, powerAliases:getChardata(xname), buttons.INIT)
    return
  else
    if _G[xname] == nil then
      if powerAliases:getChardata(xname) == "" then
        -- cecho("&lt;red&gt;[initButton: " .. xname .. " not set in powerAliases]\n")
        return
      end

      shiftButton(xname, powerAliases:getChardata(xname), buttons.INIT)
      return
    end
  end

  _G[xname](xname, buttons.INIT)
end

function updateSpellCount(xname, xcommand)
  local chardata= powerAliases:getChardata(xname)

  -- is this a melee powers spell?
  if not powerAliases:isCasterSpell(xname) then
    return
  end

  -- normal caster spell
  
  if chardata == "" then
    if _G[xname] == nil then
      echoDebug("&lt;red&gt;[updateSpellCount: xname " .. xname .. " has a nil function]\n")
    end

    if _G[xname] ~= nil then
      _G[xname](xname, buttons.UPDATE)
    end

    return
  else
    if xcommand ~= nil then
      shiftButton(xname, chardata, xname)
    else
      shiftButton(xname, chardata, buttons.UPDATE )
    end
  end

  powerAliases:updateButton(chardata)
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIRoomWindow</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
roomWindow = roomWindow or {}
roomWindow.oldCount = roomWindow.oldCount or 0

roomBuffer = roomBuffer or createBuffer("roomBuffer")

-- Resize and reposition the room window

function roomWindow:resize()
  if self:exists() then
    local var=getLastLineNumber("gRoomWindow")

    if var == roomWindow.oldCount then
      return
    end
    
    roomWindow.oldCount = var

    if var ~= nil and var ~= -1 then
      local WindowWidth, WindowHeight = getMainWindowSize()
      local wwidth,wheight = calcFontSize(9)

      -- TODO: font size will need to be related to screensize.

      local ys = wheight * var

      roomLabel:resize(nil, ys+ 2*wheight)
      roomLabel:move("60%", "12%")
    
      self.windowid:resize(nil, var .. "c")
      self.windowid:move(nil, wheight)
    end
  end
end

-- Update the room window from the buffer

function roomWindow:update()
  if self:exists() then
    if getLastLineNumber("roomBuffer") &gt; 0 then
      clearWindow("gRoomWindow")
      copyBuffer("roomBuffer", "gRoomWindow")
      clearWindow("roomBuffer")
    end
  end
end

function roomWindow:test()
  roomLabel:setClickCallback("testfunction", "zzz", buttons.CLICK)
end

function testfunction()
  display("click")
end

-- Create the room window

function roomWindow:create()
  if not self:exists() then
      roomLabel = Geyser.Label:new({name="gRoomWindowLabel", x="60%", y="15%", width="34%", height="15c",}) -- -92c, -80c
      roomLabel:setStyleSheet([[border-image: url(]] .. mainpath("roomborder.png") .. [[)]])

      self.windowid = Geyser.MiniConsole:new({name="gRoomWindow", x="5%", y="5%", width="90%", height="90%",}, roomLabel) -- -92c, -80c
  end

  self.windowid:setFontSize(9)

  if charData:get("roomwindow") == false then
    --self.windowid:hide()
    roomLabel:hide()
  end
end

-- Toggle the room window on/off

function roomWindow:toggle()
  if charData:get("roomwindow") then
    charData:set("roomwindow", false)
    cecho("&lt;red&gt;[Room capture display is OFF.]\n")
    roomLabel:hide()
    self.windowid:hide()
  else
    charData:set("roomwindow", true)
    cecho("&lt;red&gt;[Room capture display is ON.]\n")
    roomLabel:show()
    self.windowid:show()
  
    raiseWindow("gRoomWindowLabel")
    raiseWindow("gRoomWindow")
  end
end

-- Return true if the room window has been created

function roomWindow:exists()
  if self.windowid ~= nil then
    return(true)
  else
    return(false)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellSlots</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
spell = spell or {}

spell.slots = spell.slots or {}


function spell:setSlot(xslot, xvalue)
  spell.slots[xslot] = xvalue
end

function spell:getSlot(xslot)
  return ( spell.slots[xslot] or 0)
end

function spell:resetSlot()
  self.slots = {}
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EquipScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

equip = equip or {}

equip.weapontype = equip.weapontype or "none"

-- Shield, Dual, TwoHand, Bow, None

function equip:setWeapon(xweapon)

  local oldWeapon=self.weapontype
  
  --display(xweapon)
  
  -- If type (not weapon) passed, set to type
  if table.contains( {"Bow", "TwoHand", "Shield", "Dual", "None"}, xweapon ) then
    self.weapontype = xweapon
  else
    local checkBow = sqlIsBow(xweapon)
    local check2H = sqlIs2H(xweapon)
    local checkWeapon = sqlIsWeapon(xweapon)

  
    if #checkBow &gt; 0 then
      self.weapontype = "Bow"
    elseif #check2H &gt; 0 then
      self.weapontype = "TwoHand"
    elseif #checkWeapon &gt; 0 then
      if checkMask("ran") then
        self.weapontype = "Dual"
      else
        self.weapontype = "Shield"
      end
    else
      self.weapontype = "None"
    end
  end


  if self.weapontype ~= oldWeapon then
    timer:set("weaponchange", 20)
  end

  initClass()
end

function equip:getWeapon()
  return ( self.weapontype )
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MeleePowers</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function PopulateButtonCooldown(fname, xvalue)
  local label=findlabel(fname)

  local color=charData:get("numcolor")

  -- if buff then use numcolor
  -- if in cooldown use numcolcool

  if timer:get(fname) and not buff:get(fname) then
    color=charData:get("numcolcool")
  else
    -- if buff for button is currently up, use buff timer value, not cooldown
    local buffVal= buff:get(fname)
    
    if buffVal then
      xvalue=buffVal
    end
  end

  -- Make sure button is still active
  if label ~= nil then
    --display("PopulateButtonCooldown " .. fname .. " " .. xvalue)
    if xvalue  &gt; 0 then
      -- label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor", true) .. [["&gt;]] .. timedisplay(xvalue) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])    
      label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. color .. [["&gt;]] .. xvalue .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])    
    else
      label:echo([[&lt;p style="font-size:14px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;   &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
    end
  end
end

function meleePowers:use(xalias)
  local charDataName = string.lower(whoclass() .. xalias)
  local fullName = meleePowers:getName(xalias:lower())

  if xalias == "fa" then
    fullName = "furious_assault"
  end

  if fullName == nil then
    cecho("&lt;red&gt;[Error: meleePowers:use : fullName nil for xalias " .. tostring(xalias) .. "]\n")
    return(false)
  end

  if charData:get(charDataName) then
      if timer:get(fullName) == nil or timer:get(fullName) == 0 and not timer:get("cooldown") then
        useMeleePower(xalias)

        -- furious assault doesn't return a failed message on usage
        if xalias == "fa" or xalias == "FA" then
          setMeleeCooldown()
        end

        return(true)
      end
  end

  return(false)
end


-- { alias, fullname, buttonname, charData, buttonNumber, level, isCasterSpell, powertype }
-- powersTable["Blk"][""] =

function meleePowers:addButtons()
  local charclass = whoclass()

  if not powersTable:tableExists() then return(nil) end

  local weapon=equip:getWeapon()
  
  if powersTable[whoclass()][subClass] ~= nil then
    local weapon=equip:getWeapon()
    
    for nx=1, #powersTable[charclass][subClass], 1 do
      local fullName=powersTable[charclass][subClass][nx][2]
      local minLevel=powersTable[charclass][subClass][nx][6]
      local buttonNumber=powersTable[charclass][subClass][nx][5]
      local weaponType=powersTable[charclass][subClass][nx][8]
      local isCasterSpell=powerAliases:isCasterSpell(fullName)

      if not isCasterSpell then      
        if weaponType == weapon or weaponType == nil or weaponType == "All" then
          if buttonNumber ~= nil then
            addbutton(fullName, 0, buttonNumber, minLevel)
          end
        end
      end
    end
  end
end

function meleePowersUpdate(fname, xcommand)
  -- if xcommand &gt; 0, function being called re: timer
  local charDataEntry = meleePowers:getCharData(fname)
  
  
  if xcommand &gt;= 0 then
    PopulateButtonCooldown(fname, xcommand)
  end
  
  if xcommand == buttons.INIT then
    if charData:get(charDataEntry) then
      setLabelImage(fname, fname .. "-on.png")
    else
      setLabelImage(fname, fname .. "-off.png")
    end
    return
  end

  if xcommand == buttons.CLICK then
    shiftSkillButton(fname, charDataEntry, xcommand)
  end
end

-- alias to full name
function meleePowers:getName(xstring)
  return( powerAliases:getFullname(xstring) )
end

function meleePowers:getCharData(xstring)
  --xstring = fullname
  return ( powerAliases:getChardata(xstring) )
end

function setMeleeCooldown()
  -- lowered from 4 to 3
  timer:set("cooldown", 3)
end

-- useMeleePower: xpower, noCooldown
-- xpower is power name
-- if noCooldown is true none is used (warrior special skills)

function useMeleePower(xpower) -- useMeleePower(xpower, noCooldown)
  
  xpower = string.lower(xpower)
  local powername = string.split( string.lower(xpower), " ")[1]
  local fullName = powerAliases:getFullname(powername)

  -- instacast has noCooldown
  local noCooldown=powerAliases:noCooldown(fullName)

  -- melee powers don't work on parad mobs
  --if prompt:get("tank") == "" then
  --  return
  --end

  -- cecho("\n&lt;red&gt;[useMeleePower(xpower): " .. xpower .. " meleePowerUsed: " .. tostring(meleePowerUsed) .. "\n")

  if meleePowerUsed then
    return
  end
  
  -- all melee powers have a 1 second cooldown unless noCooldown is set
  if not noCooldown then
    if timer:get("cooldown") then
      return
    end
    
    meleePowerUsed=true

    setMeleeCooldown()
  end
  
  addStat(whoami(), fullName)

  --if getCurrentLine() ~= "" then
  --  echo("\n")
  --end
  
  if not noCooldown then
    cecho("\n&lt;red&gt;[&lt;cyan&gt;MELEE: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() )
  
    if not charData:get("condensed", true)["echosend"] and not charData:get("condensed", true)["debug"] then
      echo("\n")
    end
  else
    -- instacast message to display
    if checkMask("sor") then
      cecho("&lt;red&gt;[&lt;cyan&gt;SORCERER INSTACAST: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() )    
    elseif checkMask("hex") then
      cecho("\n&lt;red&gt;[&lt;cyan&gt;HEX INSTACAST: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() )
    else
      cecho("\n&lt;red&gt;[&lt;cyan&gt;WARRIOR SKILL: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() )
    end
  
    if not charData:get("condensed", true)["echosend"] and not charData:get("condensed", true)["debug"] then
      echo("\n")
    end
  end

  -- Prevent resending of the same command if a fail response is recieved from the mud
  timer:set(fullName, 8)

  mud:send( xpower:upper() )

  return(true)
end

-- call class specific procPrompt function on cooldown expiry if one exists and not casting
function cooldown(fname, xcommand)
  if xcommand &gt; buttons.TIMEREXPIRE then
    return
  end

  --cecho("&lt;green&gt;[meleePowerUsed = false]\n")
  --meleePowerUsed=false
  
  --if whoclass() ~= nil and not spell:getCurrent() and spell:castOK() and inCombat() then
  --  local cname="procPrompt" .. whoclass()

  --  if _G[cname] ~= nil then
  --    _G[cname]()
  --  end
  --end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GagScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function isGagged(xline)
  local gag = charData:get("gags", true)

  if gag ~= nil and xline ~= nil then
    for key,val in pairs(gag) do
      if string.find(xline:lower(), val, 1, true) then
        return(true)
      end
    end
  end
  
  return(false)
end

function isChatGagged(xline)
  local gag = charData:get("cgags", true)

  if gag ~= nil and xline ~= nil then
    for key,val in pairs(gag) do
      if string.find(xline:lower(), val, 1, true) then
        return(true)
      end
    end
  end
  
  return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>TextScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- return the current line in a table with hex encoded colours (in decimal)

-- formating: string, fg table {position, colour}

hextable = hextable or 
   {
  textLine = nil,
  colourTable = {}
    }

function nilFunction()
  return
end



-- colourString
-- this function should colour a string as it appeared in current line then return a hex encoded string or table? 

function getColourString(xstring)
  local table=getColourLine()
  local pos=string.find(table.textLine, xstring, 1, true) -- string.find is base 1

  local cr=0
  local cg=0
  local cb=0

  local retstring = ""
  
  if table==nil then
    return(false)
  end
  
  if pos==nil then
    return(false)
  end
  
  for nx=pos, pos+#xstring-1, 1 do
    if table.colourTable[nx][1] ~= cr or table.colourTable[nx][2] ~= cg or table.colourTable[nx][3] ~= cb then
      cr= table.colourTable[nx][1]
      cg= table.colourTable[nx][2]
      cb= table.colourTable[nx][3]

      retstring = retstring .. string.format("|c%02x%02x%02x", cr, cg, cb)
    end
  
    retstring = retstring .. string.sub(table.textLine, nx, nx)
  end

  return(retstring)
end


function getColourLine()
  local nx

  local r,g,b
  local lineCapture = {}
  
  local currentLine

  -- selectSection(from, how long) 0 based (0,1) = first character of line

  moveCursorEnd("main")
  hextable.textLine = getLines(getLineCount(), getLineCount()-1)[1]

  hextable.colourTable = {}

  for nx=0, #hextable.textLine-1, 1 do
    selectSection(nx, 1) -- selectSection is base 0
  
    r,g,b = getFgColor()
  
    hextable.colourTable[nx+1] = { r, g, b }
  end

  return(hextable)
end

function tableToHexColour(xtable)
  local retstring = ""
  
  local cr=0
  local cg=0
  local cb=0
  
  for nx=1,#xtable.textLine, 1 do
    if xtable.colourTable[nx][1] ~= cr or xtable.colourTable[nx][2] ~= cg or xtable.colourTable[nx][3] ~= cb then
      cr= xtable.colourTable[nx][1]
      cg= xtable.colourTable[nx][2]
      cb= xtable.colourTable[nx][3]

      retstring = retstring .. string.format("|c%02x%02x%02x", cr, cg, cb)
    end
  
    retstring = retstring .. string.sub(xtable.textLine, nx, nx)
  end

  --display(xtable)

  return(retstring)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>BackupScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function copyFile(ifile, ofile)
  local inp = assert(io.open(ifile, "rb"))
   local out = assert(io.open(ofile, "wb"))
    
   local data = inp:read("*all")
   out:write(data)
    
   assert(out:close())
  assert(inp:close())
end

function backupFile(filename)
  local is_file = io.open(homepath(filename))

  if is_file ~= nil then
    copyFile(homepath(filename), backupPath(filename))
    cecho("&lt;red&gt;[File: " .. homepath(filename) .. " copied to \n          " .. backupPath(filename) .. "]\n")
    io.close(is_file)
  else
    cecho("&lt;red&gt;[File: " .. homepath(filename) .. " does not exist]\n")
  end
end

function restoreFile(filename)
  local srcfile = backupPath(filename)

  local is_file = io.open(srcfile)

  if is_file ~= nil then
    copyFile(srcfile, homepath(filename))
    cecho("&lt;red&gt;[File: " .. srcfile .. " copied to \n          " .. homepath(filename) .. "]\n")
    io.close(is_file)
  else
    cecho("&lt;red&gt;[File: " .. srcfile .. " does not exist]\n")
  end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Bash</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- this script has all the bash functions

function setBashing(xval)
  if xval ~= vbashing then
    echoDebug("&lt;red&gt;[setBashing : " .. tostring(xval) .. "]\n")
    vbashing = xval
  end
end

function getBashing()
  if vbashing == nil then
    vbashing=false
  end

  return(vbashing)
end

function canBash()
  -- Does the character have the bash button specific to their class/weapon enabled?
  -- "Bow", "TwoHand", "Shield", "Dual", "None"
  
  local weapon=equip:getWeapon()
  
  if charData:get("blkss") and weapon == "TwoHand" then return(true) end
  if charData:get("blkds") and weapon == "Shield" then return(true) end

  if charData:get("palts") and weapon == "TwoHand" then return(true) end
  if charData:get("palrc") and weapon == "Shield" then return(true) end

  if charData:get("ranks") and weapon == "Bow" then return(true) end
  if charData:get("ranss") and weapon == "Dual" then return(true) end

  if charData:get("warss") and weapon == "TwoHand" then return(true) end
  if charData:get("warsb") and weapon == "Shield" then return(true) end

  if charData:get("hexsd") and weapon == "Shield" then return(true) end
  if charData:get("hexhs") and weapon == "TwoHand" then return(true) end
  
  return(false)
end

function sendBash(xtarget)
  if xtarget == nil then
    xtarget = ""
  else
    xtarget = " " .. xtarget
  end
    
  -- can't bash if stunned

  if buff:get("stun") then
    return(false)
  end

  if not getBashing() then

    -- mounted charge instead of bash when mounted
    if mount:getMounted() then
      if not mount:charge() then
        return(false)
      end
    else
      if dismounted == true then
        return(false)
      end

      if checkMask("war") then
        if not timer:get("cooldown") then
          -- use powers attack depending on wielded weapon

          if isIconActive("shield_bash") then
            if not timer:get("shield_bash") then
              useMeleePower("SB" .. xtarget)
              setBashing(true)
              return(true)
            else
              return(false)
            end
          end
        
          if isIconActive("spinning_sweep") then
            useMeleePower("SS" .. xtarget)
            setBashing(true)
          end
        else
          return
        end
      end


      if checkMask("blk") then
        if not timer:get("cooldown") then
          -- use powers attack depending on wielded weapon

          if isIconActive("dominating_smite") then
            if not timer:get("dominating_smite") then
              useMeleePower("DS" .. xtarget)
              setBashing(true)
              return
            else
              return
            end
          end
        
          if isIconActive("shattering_smite") then
            useMeleePower("SS" .. xtarget)
            setBashing(true)
          end
        else
          return
        end
      end

      if checkMask("pal") then
        if charData:get("palrc") then
          if timer:get("radiant_charge") == nil and not timer:get("cooldown") and isIconActive("bolstering_strike") then
            useMeleePower("rc")
            setBashing(true)
            return
          end
        end
                
        if isIconActive("valiant_strike") then
          if charData:get("palts") then
            if timer:get("thunderous_smite") == nil and not timer:get("cooldown") then
              useMeleePower("ts")
              setBashing(true)
              return
            end
          end
        end
      end

      if checkMask("hex") then
        if charData:get("hexhs") then
          if timer:get("hellstrike") == nil and not timer:get("cooldown") and isIconActive("hellstrike") then
            useMeleePower("hs")
            setBashing(true)
            return
          end
        end
                
        if isIconActive("smothering_darkness") then
          if charData:get("hexsd") then
            if timer:get("smothering_darkness") == nil and not timer:get("cooldown") then
              useMeleePower("sd")
              setBashing(true)
              return
            end
          end
        end
      end

      if checkMask("ran") then
        if not timer:get("cooldown") then
          -- use powers attack depending on wielded weapon

          if isIconActive("sweeping_strike") then
            if not timer:get("sweeping_strike") then
              useMeleePower("SS" .. xtarget)
              return
            else
              return
            end
          end
        
          if isIconActive("knockdown_shot") then
            useMeleePower("KS" .. xtarget)
          end
        else
          return
        end
      end
    end
  end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIMiniMap</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
miniMap = miniMap or {}
miniMap.oldCount = miniMap.oldCount or 0

-- Update the room window from the buffer
function miniMap:update()
  clearWindow("miniMap")
    
  copyBuffer("minimapBuffer", "miniMap")
    
  clearWindow("minimapBuffer")
end

function miniMap:test()
  minimapLabel:setClickCallback("testfunction", "zzz", buttons.CLICK)
end

function testfunction()
  display("click")
end

-- resize the minimap font
function miniMap:resizeFont()
  if self:exists() then
    local WindowWidth=miniMap.label:get_width()
    local WindowHeight=miniMap.label:get_height()

    local fontsize= maxfont(33, WindowWidth, 13, WindowHeight )  

    self.windowid:setFontSize(fontsize)

    miniMap:center()
  end
end

function miniMap:center()
  -- center inside container
  local WindowWidth=miniMap.label:get_width()
  local WindowHeight=miniMap.label:get_height()

  local mapWidth=self.windowid:get_width()
  local mapHeight= self.windowid:get_height()
    
  local newx= math.floor((WindowWidth - mapWidth)/2)
  local newy= math.floor((WindowHeight - mapHeight)/2)
  
  if newx &lt; 0 then newx = 0 end
  if newy &lt; 0 then newy = 0 end
    
  self.windowid:move( newx, newy )
end

-- Create the minimap window
function miniMap:create()
  local WindowWidth, WindowHeight = getMainWindowSize()
  local fontsize= maxfont(33, math.floor(.9 * .2 * WindowWidth) )  
    
  -- 13 height x 28 width
  
  if not self:exists() then

      minimapAdjCon = minimapAdjCon or Adjustable.Container:new({name="minimapAdjCon", width="28c", height="13c"})

      minimapAdjCon:setTitle("MiniMap")

      if charData:get("minimapAdjCon", true) then
        minimapAdjCon:onDoubleClick()
      else
        if minimapAdjCon.x == "10px" and minimapAdjCon.y == "10px" then
          minimapAdjCon:move("45.4%", 0)
          minimapAdjCon:resize("18.4%", "30.9%")
        end
      end

      miniMap.label = Geyser.Label:new({name="miniMapLabel", x=0, y=4, width="100%", height=" 100%",}, minimapAdjCon)
      miniMap.label:setStyleSheet([[border-image: url(]] .. iconpath("frame-1.png") .. [[)]])

      self.windowid = Geyser.MiniConsole:new({name="miniMap", x="5%", y="5%", width="33c", height="13c",}, miniMap.label) -- -92c, -80c
 
  end
  
  self.windowid:setFontSize(fontsize)
  miniMap:resizeFont()

  if charData:get("winMinimap") == false then
    minimapAdjCon:hide()
  end
end

-- Toggle the minimap window on/off
function miniMap:toggle()
  if charData:get("winMinimap") then
    --turn off minimap
    
    charData:set("winMinimap", false)
    disableTrigger("tog minimap")
    cecho("&lt;red&gt;[Minimap display is OFF.]\n")
    
    minimapAdjCon:hide()
    
    minimapButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
    
    --minimapLabel:hide()
    --self.windowid:hide()
  else
    --turn on minimap
    
    charData:set("winMinimap", true)
    enableTrigger("tog minimap")
    mud:send("tog minimap")
    cecho("&lt;red&gt;[Minimap display is ON.]\n")
    
    minimapAdjCon:show()
    
    minimapButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
  end
end

-- Return true if the minmap window has been created
function miniMap:exists()
  if self.windowid ~= nil then
    return(true)
  else
    return(false)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="no" isFolder="no">
					<name>tts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function speak(xstring)
  -- text to speech!
  -- "|c00ffff"
  
  local ttsVolume = tonumber(charData:get("tts", false))
  local tts=string.gsub(xstring, "|c[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]", "")

  -- volume 0 = off
  if ttsVolume == 0 then
    return
  end
          
  ttsSetVolume(ttsVolume/100)
          
  ttsQueue( tts )
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>chatWindow</name>
					<packageName></packageName>
					<script>chat = chat or {}

-- Toggle the minimap window on/off

function chat:toggle()
  if charData:get("winChat") then
    charData:set("winChat", false)

    cecho("&lt;red&gt;[Chat display is OFF.]\n")
    
    chatButtonCon:setStyleSheet("QLabel{background-color: rgba(0,0,0,0%)}")
    
    chatAdjCon:hide()
  else
    charData:set("winChat", true)

    cecho("&lt;red&gt;[Chat display is ON.]\n")
    
    chatButtonCon:setStyleSheet("QLabel{border: 2px solid red;}")
    
    chatAdjCon:show()  
  end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUISettingsButton</name>
					<packageName></packageName>
					<script>function heightBottomGroupWindow()
  local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")
  local WindowWidth, WindowHeight = getMainWindowSize()

  if not charData:get("winGroup", true) or not bottomGroupWindowLines then
    return(0)
  end

  -- calculate/set font size of lower window
  local fontSize
  
  if charData:get("grpfontsize", true) == "auto" then
  
    fontSize= maxfont(40, (WindowWidth/3-15))

    if fontSize &gt; 14 then
      fontSize = 14
    end  
  else
    fontSize= tonumber(charData:get("grpfontsize", true))
  end
  -- max font is 13

  local fontWidth,fontHeight = calcFontSize(fontSize)  
  bottomWindow:setFontSize(fontSize)

  return(fontHeight * bottomGroupWindowLines)
end

function ZZZresizeGroupWindow(xforce)
  local iconBar=Geyser.Label:getWindow("gIconBarWindow")
  local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")
  local WindowWidth, WindowHeight = getMainWindowSize()
  local currenty  -- holds the positive yp of the iconbar

  bottomBorderPX = bottomBorderPX or 0

  if not iconBar then
    return
  end
  
  local iconbaryp=40
  
  if not charData:get("winGroup", true) then
    iconbaryp=bottomWindowSize
  end
   
  if currenty ~= (bottomWindowSize+iconbaryp) then
    if charData:get("winGroup", true) then
      currenty = tonumber(string.match(iconBar.y, '[0-9]+'))
    else
      currenty=bottomWindowSize
    end
  end

  -- set bottom border if window sizes have changed
  
  if bottomBorderPX ~= currenty then
    --display(currenty)
    bottomBorderPX = currenty
    --setBorderBottom(bottomBorderPX)

    -- move gear button
    
    -- bottomBorderPX=edge, 96px height of button
    -- moved to top of screen (100?)
    --NyyLIB.settingsbutton:move(nil, -bottomBorderPX-96-20) 
    --NyyLIB.settingsbutton:move(nil, 100) 
  
    -- move button panel
    --NyyLIB.buttonpanel:move(-(480+96+20), -bottomBorderPX-96-20)
  
    setBorderBottom(bottomBorderPX)
  end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>forumsql</name>
					<packageName></packageName>
					<script>function forumsqlOpen()
  NyyLIB.fenv = assert (luasql.sqlite3())
  
  NyyLIB.fconn = assert (NyyLIB.fenv:connect(mainpath("Forum.db")))

  display(NyyLIB.fconn)
end

function listmessages()
  local recs, row
  
  recs = assert(NyyLIB.fconn:execute([[SELECT pid,topic,author,utime,content FROM posts]]))

  row = recs:fetch({})

  while row do
    local author=row[3]
    local utime=row[4]
    local topic=row[2]
    
    
    local posttime= os.date("%m/%d/%Y", row[4])
    
    echo( "Originally posted by " .. author .. " on " .. posttime  .. " as topic: " .. topic .. "\n")
           
    row= recs:fetch({})
  end

end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Events</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>DisconnectEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function DisconnectEvent()
  display("disconnectevent")
  if not timer:get("reconnectMud") then
    cecho("&lt;red&gt;[DisconnectEvent was just called]\n")

    if not charData:get("reconnect") then
      cecho("&lt;red&gt;[Reconnect is not enabled. Type &lt;green&gt;@set reconnect charnumber &lt;red&gt;to enable]")
    end

    if charData:get("reconnect") ~= false and charData:get("reconnect") ~= nil then
      cecho("&lt;red&gt;[Sending reconnect in 30 seconds]")
      timer:set("reconnectMud", 30)
    end
  end
end

-- timer to reconnect to on expiry

function reconnectMud(fname, v)
  --display(fname, v)
  if v == 0 then
    
    timer:set("reconnectMudTimeout", 10*60)
    reconnect()
  end
end

function reconnectMudTimeout(fname, v)
  --display(v)
  if v == buttons.TIMEREXPIRE then
    cecho("&lt;red&gt;[Reconnect timeout]\n")
    DisconnectEvent()
  end
end</script>
					<eventHandlerList>
						<string>sysDisconnectionEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>promptEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- This event will be called whenever the mud prompt has been received

mobs = mobs or {}

function promptEvent(event)
  --echo("Y")
  -- testing: hp gauge

  --if not hpBar then
  --  hpBar = Geyser.Gauge:new({  name="hpBar", x="54%", y="50%", width="10%", height="20px",})

  --  hpBar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #98f041, stop: 0.1 #8cf029, stop: 0.49 #66cc00, stop: 0.5 #52a300, stop: 1 #66cc00);
  --   border-top: 1px black solid;
  --    border-left: 1px black solid;
  --    border-bottom: 1px black solid;
  --    border-radius: 7;
  --    font-size:18px;
  --    padding: 3px;
  --  ]])

  --  hpBar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #cc3300, stop: 0.1 #cc6600, stop: 0.49 #ff0000, stop: 0.5 #993300, stop: 1 #993300);
  --    border-width: 1px;
  --    border-color: black;
  --    border-style: solid;
  --    border-radius: 7;
  --    font-size:18px;
  --    padding: 3px;
  --  ]])
  --end

  --if hpBar then
  --  hpBar:setValue( prompt:get("hp"), prompt:get("maxhp") )
  --end
  
  
  if not scriptInitialized then
    scriptInitialized=true
    firstPrompt()
  end

  -- if no-one is known tanking, and the prompt shows combat look at the room


  if groupList:whoTanking() == false and prompt:get("tank") ~= "" then
    groupList:incTanking(prompt:get("tank"))
    look:send()
  end

  -- send all queued commands if not casting or in fugue 

  if   spell:getCurrent() == nil or map:getRoom() == 93848 then
    mud:sendCommands() 
  end

  -- if in fugue remove buffs on self, return

  if map:getRoom() == 93848 then
    buff:del(whoami())
    return
  end

  -- nyylib.torescue should only be set after looking at room
  if NyyLIB.torescue ~= "" then
    pet:rescue(NyyLIB.torescue)
    NyyLIB.torescue=""
  end

  if inCombat() then
    assistSent = nil

    -- can't be hidden if in combat
    setHide(false)

    -- send con to update database if needed
    local roomid = map:getRoom()

    if roomid ~= nil then
      if mobs[roomid] == nil then
        sendCon(prompt:get("enemy"))
      end
    end

    -- if tank=me, slaad, ghost, wraith, wight order rescue
    if not petcommand then
      local tank=prompt:get("tank")
      if not (#pet:getTable() == 1) then
        if table.contains( {whoami(), "gray", "ghost", "wraith", "wight", "ghoul" }, tank ) then
          pet:rescue( tank )
          petcommand=true
        end
      end
    end
  end

  -- If engaged in combat AND a look command was not sent/unreceived, set not moving
  
  if inCombat() or type(groupList:whoTanking()) == "table" and not look:get() then
    automem=0

    if spell:getMoving() then
      echoDebug("&lt;red&gt;[Currently in combat]\n")
    end

    spell:setMem(false)
    spell:setMoving(false)
  end

  -- Disengage from nightmares (tiamat zone only)
  if prompt:get("enemy") == "nightmare" then
    if map:getCurrentZone() == "Tiamat - The Pillar of Skulls" then
      if prompt:get("position") ~= "std" then
        mud:send("STAND")
      end

      mud:send("disengage")
      return
    end
  end

  if prompt:get("enemy") == "ekahk" then
    mud:send("FLEE")
  end

  -- No further processing if currently moving or memsent or groupsent
  if spell:getMoving() or memsent or group:get() == "GROUPSENT" then
    --echo(group:get())
    return
  end

  -- send furious assault
  if whorace() == "Half-Orc" then
      if whoclass() ~= nil and not spell:getCurrent() and spell:castOK() and inCombat() then
      if meleePowers:use("fa") then
        timer:set("furious_assault", 90)
         meleePowerUsed=false
        return
      end
    end
  end


  -- call class specific prompt script if one exists and not currently casting, must be in combat
  
  --display(whoclass())
  --display(spell:getCurrent())
  --display(spell:castOK())
  --display(inCombat())
  
  
  if whoclass() ~= nil and not spell:getCurrent() and spell:castOK() and inCombat() then
    local cname="procPrompt" .. whoclass() .. subClass

    --display(cname)

    if _G[cname] ~= nil then
      _G[cname]()
    end
  end

  -- proc equipment if needed 
  procEquipment()

  -- Call class self heal function if not casting and it exists
  if whoclass() ~= nil and not spell:getCurrent() then
    local cname="proc" .. whoclass() .. subClass .. "Heal"

    if _G[cname] ~= nil then
      _G[cname]()
    end
  end

  -- Process cast/send queue 

  spell:cast()

  -- undead pet casting (shadow/wraith/ghost)
  -- don't order to cast if i'm bashed (sit/rcl)

  if charData:get("autocast") and not nomagic then
    if checkMask("necros") then
      if not (inCombat() and (prompt:get("position") == "rcl" or prompt:get("position") == "sit")) then
        undeadPetCast()
      end
    end
  end

  --echo("w")

  -- don't cast if trying to mem or look sent/not received or nomagic is set or group sent not received
  -- if group:get == "GROUPSTART' event is first prompt after group recieved
  if spell:getMem() or memsent or look:get() or nomagic or group:get() then
    --display(group:get())
    return
  end

  -- call class specific spell script if autocast enabled and no spell currently being cast, standing, not stunned

  --echo("x")
  if charData:get("autocast") and not spell:getCurrent() and not buff:get("stun") then
    if prompt:get("position") == "std" then
      local cname="Spells" .. whoclass() .. subClass

      if _G[cname] ~= nil then
        _G[cname]()
      end
    end
  end
  -- automem segment

  memsent = memsent or false

  if automem &gt; 1 and not roomCombat then
    if spell:count() ~= 0 or spell:getCurrent() ~= nil then
      return
    end
    if checkMask("casterPsi") or checkMask("nonPriestCaster") then
      if charData:get("autocast") then
        if charData:get("memcount") ~= 0 and not spell:getMem() and spell:getCurrent() == nil and not memsent and prompt:get("position") ~= "sit" then
          if not inCombat() then
            echoDebug("&lt;red&gt;[Initiating automem]\n")
            mud:send("mem")
            memsent = true
          end
        end
      end
    end
  end
end

function procRanHeal()
  local percent=prompt:get("hp%")

  -- exit if not in combat (no tank in prompt), or map has current room as fugue
  -- this should prevent (some) proc commands from being issued in fugue

  if prompt:get("tank") == "" or map:getRoom() == 93848 then
    return
  end

  -- ranger heal procs are used if auto_heal is enabled
  if charData:get("auto_heal") then
    -- cast cloak of life (cll) on &lt; 50% hp if not already

    if not buff:get("cloak_of_life") and spell:getSlot(5) &gt; 0 then
      if percent &lt; tonumber(charData:get("rancllpct")) and prompt:get("position") == "std" then
        spell:cast("CLL")
      end
    end

    -- cast dawns renewl (dr) on &lt; 70% hp

    if spell:getSlot(2) &gt; 0 then
      if percent &lt; tonumber(charData:get("randrpct")) and prompt:get("position") == "std" then
        spell:cast("DR")
      end
    end
  end
end

function procBlkHeal()
  local hp=prompt:get("hp")
  local maxhp=prompt:get("maxhp")
  local percent=prompt:get("hp%")

  -- exit if not in combat (no tank in prompt), or map has current room as fugue
  -- this should prevent (some) proc commands from being issued in fugue

  if prompt:get("tank") == "" or map:getRoom() == 93848 then
    return
  end

  -- blackguard heal procs are used if blksot is enabled
  if charData:get("blksot") then
      
      -- soul touch on &lt; 30% hp
      if percent &lt; 30 then
        if timer:get("soul_touch") == nil and not timer:get("cooldown") then
          useMeleePower("SOT")
          return
        end
      end

    -- cast aura of death (al) on &lt; 50% hp if not already

    if not buff:get("aura_of_death") and spell:getSlot(5) &gt; 0 then
      if percent &lt; 50 and prompt:get("position") == "std" then
        spell:cast("AD")
      end
    end

    -- cast shadow healing (sh) on &lt; 70% hp

    if spell:getSlot(2) &gt; 0 then
      if percent &lt; 70 and prompt:get("position") == "std" then
        if (maxhp - hp) &gt; 125 then
          spell:cast("SH")
        end
      end
    end
  end
end


function procPalHeal()
  local percent=prompt:get("hp%")

  -- exit if not in combat (no tank in prompt), or map has current room as fugue
  -- this should prevent (some) proc commands from being issued in fugue

  if prompt:get("tank") == "" or map:getRoom() == 93848 then
    return
  end

  -- paladin heal procs are used if pallh is enabled
  if charData:get("pallh") then
      
      -- lay hands on &lt; 30% hp
      if percent &lt; 30 then
        if timer:get("lay_on_hands") == nil and not timer:get("cooldown") then
          useMeleePower("lh")
          return
        end
      end

    -- cast aura of life (al) on &lt; 50% hp if not already

    if not buff:get("aura_of_life") and spell:getSlot(5) &gt; 0 then
      if percent &lt; 50 and prompt:get("position") == "std" then
        spell:cast("AL")
      end
    end

    -- cast healing light (hl) on &lt; 70% hp

    if spell:getSlot(2) &gt; 0 then
      if percent &lt; 70 and prompt:get("position") == "std" then
        spell:cast("HL")
      end
    end
  end
end


function procEquipment()
  local percent=prompt:get("hp%")


  if not charData:get("autoproc") then return end

  -- exit if not in combat (no tank in prompt), or map has current room as fugue
  -- this should prevent (some) proc commands from being issued in fugue

  if prompt:get("tank") == "" or map:getRoom() == 93848 then
    return
  end

  -- proc manacle on &lt; 70% hp if not already blurred

  if not buff:get("blur") then
    if percent &lt; 70 then
      if isIconActive("TiaManacle") and timer:get("TiaManacle") == nil then
        TiaManacle("TiaManacle", buttons.CLICK)
      end
    end
  end

  -- proc volance on &lt; 60% hp

  if percent &lt; 60 then
    if isIconActive("TiaVolance") and timer:get("TiaVolance") == nil then
      TiaVolance("TiaVolance", buttons.CLICK)
    end
  end

  -- proc warder on &lt; 30% hp

  if percent &lt; 30 then
    if isIconActive("TiaWarder") and timer:get("TiaWarder") == nil then
      TiaWarder("TiaWarder", buttons.CLICK)
    end
  end

  -- proc items on &lt; 25% hp

  if percent &lt; 25 then
    -- proc supple girdle
    if isIconActive("SuppleGirdle") and not mount:getMounted() and timer:get("SuppleGirdle") == nil then
      SuppleGirdle("SuppleGirdle", buttons.CLICK)
      return
    end

    -- proc tiamat sleeves
    if isIconActive("TiaSleeves") and timer:get("TiaSleeves") == nil then
      TiaSleeves("TiaSleeves", buttons.CLICK)
    end
  end
end
</script>
					<eventHandlerList>
						<string>promptEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>statusEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function statusEvent(event, xcharname)

end</script>
					<eventHandlerList>
						<string>statusEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>sysManualLocationSetEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function sysManualLocationSetEvent(xtmp)
  --display("X")
end</script>
					<eventHandlerList>
						<string>sysManualLocationSetEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>installEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- sysInstallPackage

-- this function will be called with mudlet 3.1+ on package installation

function installEvent()
  cecho("&lt;red&gt;[\n[New package install event called]\n")

  -- mudlet 3.1+ in use, restart not required
  --disableAlias("restart")

  --remove generic_mapper
  uninstallPackage("generic_mapper")

  initNyyLIB()
end</script>
					<eventHandlerList>
						<string>sysInstall</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>newRoomEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function newRoomEvent(event, xroom)
  -- this event is called from map:update after every new room is entered

  --Example: snap after entering a particular room
  --if xroom == 79574 then
  --  send("snap")
  --end

  alreadyEnteredPortal=nil

  if xroom ~= nil then
    spell:setMoving(true)
    spell:setMem(false)
    memsent = false

    meleePowerUsed=false

    -- pet command couldn't have been sent
    petcommand = nil

    -- nomagic is a variable to stop casting (beholder, etc)
    nomagic=nil

  end

  spell:setCast() -- reset

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>onNetworkOutput</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- This event is called immediatly prior to sending anything to the mud


function onNetworkOutput(__, xcommand)
  if commandSent ~= nil then
    -- command2 will be the second-last command sent.
    command2 = commandSent
  end
  
  commandSent=xcommand
  
  -- afk flag at 6min, timeout at 10min 2020/12/6 changed to 8.5*60
  timer:set("timeout", 8.5*60)
  
  -- Screen echo of sent command (for debugging purposes)
  if charData:get("condensed", true)["echosend"] or charData:get("condensed", true)["debug"] then
    if getCmdLine("main") == "" then -- "main"
      cecho("\n")
    end
    
    cecho("&lt;yellow&gt;[onNetworkOutput: " .. tostring(xcommand) .. "]\n")
  end
end</script>
					<eventHandlerList>
						<string>sysDataSendRequest</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>initNyyLIB</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

NyyLIB = NyyLIB or {}

automem = automem or 0
  
function initNyyLIB()
  
  echo("\n\n\n")

  cecho([[&lt;green&gt;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO]])
  cecho("&lt;green&gt;THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE")
  cecho("&lt;green&gt;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,")
  cecho("&lt;green&gt;TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN")
  cecho("&lt;green&gt;THE SOFTWARE.")

  echo("\n\n\n")

  cecho("&lt;red&gt;[Initializing NyyLIB...]\n")

  -- remove generic_mapper
  uninstallPackage("generic_mapper")
  
  -- disable autoroller if active
  disableTrigger("RollerTrigger")

  expandAlias("@version", false)

  NyyLIB.homedir = getMudletHomeDir() .. "\\" .. NyyLIB.version .. "\\"

  -- startup time
  startupTime = getEpoch()

  -- discord
  setDiscordState("Playing Torilmud")

  -- sets the main windows size to 5 million lines maximum
  setConsoleBufferSize("main", 5000000, 1000)
  
  -- copy fontfile
  -- The new fontfile doesn't work until mudlet has been restarted
  
  local srcPath=mainpath("AvQest.ttf")
  local dstPath= getMudletHomeDir() .. "\\..\\..\\fonts\\AvQest.ttf"

  --display( srcPath )
  --display( dstPath )

  local is_file = io.open( dstPath )
  --display( is_file )

  if not is_file then
    copyFile(srcPath, dstPath)
  end

  --local is_file = io.open( dstPath )
  --display( is_file )

  buttons:init()
  roomWindow.windowid=nil

  -- create buffers
  minimapBuffer = createBuffer("minimapBuffer")

  local WindowWidth, WindowHeight = getMainWindowSize()

  splashwindow = Geyser.Label:new({name="splash", x="10%", y="10%", width="50%", height="75%"})
  splashwindow:setStyleSheet([[border-image: url(]] .. mainpath("splash.png") .. [[)]])
  tempTimer(6, [[splashwindow:hide()]] )

  -- loading charData table
  charData:load()

  NyyLIB.leftbuttonarray = {}

  NyyLIB.deadpeople = NyyLIB.deadpeople or {}

  NyyLIB.initgui = false
  NyyLIB.ticktimer = 60

  if charData:get("style", true) then
    setStyle()
  end

  NyyLIB.classes = { "War", "UNK", "Blk", "Pal", "Cle", "Dru", "Sha", "Ctr", 
    "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Hex", "Ran", "Sor" }

  NyyLIB.fullclasslist = { {"Rogue", "Rog"},
                {"Cleric", "Cle"},
                {"Paladin", "Pal"},
                {"Shaman", "Sha"},
                {"Illusionist", "Ill"},
                {"Ranger", "Ran"},
                {"Lich", "Lic"},
                {"Blackguard", "Blk"},
                {"Necromancer", "Nec"},
                {"Battlechanter", "Ctr"},
                {"Invoker", "Inv"},
                {"Enchanter", "Enc"},
                {"Druid", "Dru"},
                {"Warrior", "War"},
                {"Elementalist", "Ele"},
                {"Hexblade", "Hex"},
                {"Bard", "Bar"},
                {"Psionicist", "Psi"},
                {"Sorcerer", "Sor"}
              }

  NyyLIB.fullracelist = { {"Human", "M"},
                  {"Barbarian", "M"},
                  {"Drow Elf", "M"},
                  {"Moon Elf", "M"},
                  {"Half-Elf", "M"},
                  {"Shield Dwarf", "M"},
                  {"Half-Orc", "M"},
                  {"Duergar", "M"},
                  {"Duergar Dwarf", "M"},
                  {"Gnome", "S"},
                  {"Halfling", "S"},
                  {"Ogre", "L"},
                  {"Troll", "M"},
                  {"Illithid", "M"},
                  {"Orc", "M"},
                  {"Yuan-Ti", "M"}
                }

  NyyLIB.reversedirs   =   {
                     n   = "s",
                     e   = "w",
                     s   = "n",
                     w   = "e",
                     u   = "d",
                     d   = "u",
              north = "south",
              east = "west",
              south = "north",
              west = "east",
              up = "down",
              down = "up"
                     }

  NyyLIB.fulldirs = {
                  n = "north",
                  e = "east",
                  s = "south",
                  w = "west",
                  u = "up",
                  d = "down"
                }


  NyyLIB.statuschar=""


  NyyLIB.damagelevels = { "Excellent", "Few Scratches", "Small Wounds", "Few Wounds", "nasty wounds", "Pretty Hurt", "Awful" }

  NyyLIB.torescue=""

  NyyLIB.psilag="none"

  loadwholist()

   sqlOpen()

  createconsumabledb()
  
  demonnicOnStart()

  setBorder()

  -- enable mapper

  mudlet = mudlet or {}; mudlet.mapper_script = true
  expandAlias("@map init", false)

  -- only load mapfile if loaded map is &lt; 35000 rooms i.e. not mudlet loaded mapfile

  if map:countRooms() &lt; 35000 then
    map:loadMap()
  end

  NyyLIB.initcompleted = true

  registerAnonymousEventHandler("AdjustableContainerReposition", "AdjustableContainerReposition")

  registerAnonymousEventHandler("sysWindowResizeEvent", "GUIScripts")
  registerAnonymousEventHandler("newRoomEvent", "newRoomEvent")

  expandAlias("@stats reset", false)

  -- load window locations
  loadWindowLayout()

  cecho ("&lt;red&gt;[NyyLIB initialized.]\n")
  --echo("Account name: ")

  disableTrigger("minimap display")  

  createGearButtons()
end

function initFullData()
  echoDebug("&lt;red&gt;[initFullData called]\n")

  disableTrigger("scribenext")
  
  charData:init(whoami(), {}, true)

  charData:init("memcount", 0)
  charData:init("groupwindow", "split")
  charData:init("iconbar", "bottom")

  charData:init("statname", "unset")

  if NyyLIB.initgui == false then
    if NyyLIB.mapwindow == nil then
      cecho("&lt;red&gt;[error: mapwindow is nil]\n")
    else
      map:hide()
    end

    if whoami() == nil then
      cecho("&lt;red&gt;[error: whoami() is nil]\n")
    end

    if whoclass(whoami()) == nil then
      cecho("&lt;red&gt;[error: whoclass(whoami) is nil]\n")
    end

    initgui()

    -- call class initialization script (buttons)

    initClass()

    -- call custom initaliziation script 'initCustom()' if it exists

    if _G["initCustom"] ~= nil then
      _G["initCustom"]()
    else
      echoDebug("\n&lt;red&gt;[Custom script initCustom() does not exist]\n")
    end

    NyyLIB.initgui = true
  
    --bugfix bandaid mudlet 4.8.0
    selectGroupWindows()
  end
end

-- class initialization script (buttons)

function initClass()
  -- disable all class aliases
  
  local nx=0

  for nx=1, table.size(NyyLIB.classes), 1 do
    disableAlias(NyyLIB.classes[nx] .. subClass)
  end
  disableAlias("Bard")
  
  -- enable my class aliases
  enableAlias(whoclass() .. subClass)
 
  if whoclass() == "Ctr" or whoclass() == "Bar" then
    enableAlias("Bard")
  end
 
   buttons:hide()
  
  baseButtons()
  
  local fnInit="init" .. whoclass() .. subClass

  if _G[fnInit] ~= nil then
    _G[fnInit]()
  else
    echoDebug("\n&lt;red&gt;[Class script " .. fnInit .. " does not exist]\n")
  end
end

function firstPrompt()
  -- Initialization trigger on reconnect to toril.

  
  --enable logging
  startLogging(false)
  startLogging(true)

  -- clear noreconnect flag
  noreconnect=nil

  -- Enable single letter aliases
  enableAlias("movement commands")
  --enableAlias("p")
  --enableAlias("g")
  enableAlias("l (look)")

  -- reset any previously queued spells / commands
  mud.varsendqueue={}
  spell:clear()

  NyyLIB.initgui=false

  -- erase current value of assassinate timer
  timer:set("assassinatetimer", nil)

  setHide(false)
  group:send(false)
  sendFollowers(false)

  if charData:get("winMinimap") then
    enableTrigger("tog minimap")
    mud:send("tog minimap", false)
  end

  mud:send("TOG newprompt", false)
  mud:send("PROMPT options newline", false)
  mud:send("TOG smartprompt", false)
  --mud:send("DISPLAY enemypos", false)
  --mud:send("DISPLAY position", false)
  --mud:send("DISPLAY slots", false)
  mud:send("CLASS sub", false)
  mud:send("ATT", false)
  mud:send("SC", false)
  mud:send("EQUIP", false)
  group:send()
  sendStatus()
  mud:send("EXP", true)
  mud:send("CONSENT", false)

  -- TODO: temp timer display combo
  tempTimer(5, [[if checkMask("hex") and prompt:get("combo") == "" then mud:send("display combo") end]])
  tempTimer(5, [[if checkMask("sor") and prompt:get("combo") == "" then mud:send("display combo") end]])

  local assocchar = charData:get("assocchar", true)

  if assocchar ~= "" then
    mud:send("assoc chat " .. assocchar, false )
    mud:send("storage access " .. assocchar, false )
  end


  tempTimer(1.5, [[look:send()]])

  tempTimer(4, [[expandAlias("@resettrain", false)]])

  -- set map room to nil

  map:setRoom(nil)

  centerview(1)
 end</script>
					<eventHandlerList>
						<string>sysLoadEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>saveNyyLIB</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function saveNyyLIB()
  local ver=getMudletVersion()

  --if ver["major"] == 3 then
  --  if ver["build"] == "" or ver["build"] == "-dev" then
  --    disableAlias("restart")
  --  end
  --end

  saveWindowLayout()
  
  charData:save()

  -- save to map folder
  saveMap( "" )

  expandAlias("@map save", false)

  savewholist()
end</script>
					<eventHandlerList>
						<string>sysExitEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>sysWindowMouseMoveEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function sysWindowMouseMoveEvent(var)
  display(var)
end</script>
					<eventHandlerList>
						<string>sysWindowMouseMoveEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>sysConnectionEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

function sysConnectionEvent()
  scriptInitialized=nil 

  --remove reconnect timer if present
  timer:set("reconnectMud", nil)


  --clear connect timeout flag
  timer:set("reconnectMudTimeout", nil)

  -- connect time
  connectTime = getEpoch()

  -- disable autoroller
  expandAlias("@roll", false) 
end</script>
					<eventHandlerList>
						<string>sysConnectionEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>katumiUpdate</name>
					<packageName></packageName>
					<script>function katumiUpdate(k, v)
  -- k is function name. v is filename
    
  if string.find(v, "toril.db") then
    cecho("&lt;green&gt;Katumi download completed.\n")

    copyFile(v, mainpath("toril.db"))

    cecho("&lt;green&gt;Connecting to updated database.\n")
 
    sqlOpen()

    -- delete the downloaded file
    os.remove(v)
  end
end</script>
					<eventHandlerList>
						<string>sysDownloadDone</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>AdjustableContainerReposition</name>
					<packageName></packageName>
					<script>-- event name: "AdjustableContainerReposition" passed values (name, width, height, x, y)

function AdjustableContainerReposition(name, k)
  --resize font in minimap
  miniMap:resizeFont()

  demonnic.chat:fixWrap()

  -- raise the settings (gear) windows
  
  if NyyLIB.settingsbutton then
    NyyLIB.settingsbutton:raise()
  end
  
  if NyyLIB.buttonpanellabel then
    NyyLIB.buttonpanellabel:raiseAll()
  end
end</script>
					<eventHandlerList>
						<string>AdjustableContainerReposition</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>mapUpdate</name>
					<packageName></packageName>
					<script>function mapUpdate(k, v)
  -- k is function name. v is filename
  
  --display(v)
    
  if v == "toril.map" then
    cecho("&lt;green&gt;Map download completed.\n")

    copyFile(v, mainpath(v))

    -- display( mainpath(v) )

    -- delete the downloaded file
    os.remove(v)
  end
end</script>
					<eventHandlerList>
						<string>sysDownloadDone</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Utilities</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>cMud Map Importer</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>CreateMapFromCmud</name>
						<packageName></packageName>
						<script> -------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
require "luasql.sqlite3"
cmi = {}
--kept as reminders
--[[dirnums = {[1]="north", [2]="northeast", [3]="northwest",[4]="east",
[5]="west",[6]="south",[7]="southeast",[8]="southwest",[9]="up",[10]="down"}
dir_list=["north","n","northeast","ne","east","e","se","southeast",
          "south","s","sw","southwest","west","w","nw","northwest",
          "up","u","down","d", "special", "special"]
dirtype_list=[0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9, 10, 10]]

cmi.cmudToMudletExit = {[0]=1,[1]=2,[2]=4,[3]=7,[4]=6,[5]=8, [6]=5, [7]=3, [8]=9, [9]=10}


function cmi:passwordLabel(xroomid, xpw)
 -- "10749 1 red black Northern Waterdeep Main City"

  local tmp=xroomid .. " 7 green black " .. xpw

  cmi:roomLabel(tmp)
end


-- room label the room I'm in
-- room label 342 this is a label in room 342
-- room label green this is a green label where I'm at
-- room label green black this is a green to black label where I'm at
-- room label 34 green black this is a green to black label at room 34
-- how it works: split input string into tokens by space, then determine
-- what to do by checking first few tokens, and finally call the local
-- function with the proper arguments
--taken from Vadi
--input is room number, fgcolor, bgcolor, message

function cmi:roomLabel(input)
  local tk = input:split(" ")
  local room, direction, fg, bg, message

  -- input always have to be something, so tk[1] at least always exists
  if tonumber(tk[1]) then
    room = tonumber(table.remove(tk, 1)) -- remove the number, so we're left with the direction, colors or msg
  end

  if tonumber(tk[1]) then
    direction = tonumber(table.remove(tk, 1)) -- remove the number, so we're left with the colors or msg
  end

  -- next: is this a foreground color?
  if tk[1] and color_table[tk[1]] then
    fg = table.remove(tk, 1)
  end

  -- next: is this a backround color?
  if tk[1] and color_table[tk[1]] then
    bg = table.remove(tk, 1)
  end

  -- the rest would be our message
  if tk[1] then
    message = table.concat(tk, " ")
  end

  -- if we haven't provided a room ID and we don't know where we are yet, we can't make a label
  if not room then
    echo("We don't know where we are to make a label here.") return
  end

  -- x,y,z = getRoomCoordinates(roomID) Returns the room coordinates of the given room ID.
  
  local x,y,z = getRoomCoordinates(room)
  local f1,f2,f3 = unpack(color_table[fg])
  local b1,b2,b3 = unpack(color_table[bg])

--  [1] = "north",
--  [2] = "northeast",
--  [3] = "northwest",
--  [4] = "east",
--  [5] = "west",
--  [6] = "south",
--  [7] = "southeast",
--  [8] = "southwest",
--  [9] = "up",
--  [10] = "down",
--  [11] = "in",
--  [12] = "out",

  local length = string.len(message)

  if direction == 1 then -- north
    y=y+4
    x=x-length/3.5
  end

  if direction == 4 then -- east
    y=y+1
    x=x+.5+1
  end

  if direction == 5 then -- west
    --y=y+.5
    y=y+1
    --x=x-(length/1.5)-.5-1
    x=x-(length)-.5-1
  end

  if direction == 6 then -- south
    y=y-2
    x=x-length/3.5
  end

  if direction == 7 then -- se password
    x=x+.25
    y=y+.25
  end

  -- finally: do it :)
  if (z) then
  -- fontsize: 15
  -- labelID = createMapLabel(areaID, text, posx, posy, posz, fgRed, fgGreen, fgBlue, bgRed, bgGreen, bgBlue, zoom, fontSize, showOnTop, noScaling)
    local lid = createMapLabel(getRoomArea(room), message, x, y, z, f1,f2,f3, b1,b2,b3, 15, 15, false, false)
  --echo(string.format("Created new label #%d '%s' in %s.", lid, message, getRoomAreaName(getRoomArea(room))))
  end
end

function cmi:decimalToRGB(num)

    -- download luabit from http://files.luaforge.net/releases/bit/bit/luabitv0.4
    -- copy bit.lua to mudlet install directory

        -- require("bit")
        local r,g,b
        r = bit.band(num,0x0000ff)
        g = bit.band(num, 0x00ff00)
        g = bit.brshift(g,8)
        b = bit.band(num, 0xff0000)
        b = bit.brshift(b,16)
        return {['r']=r,['g']=g,['b']=b}
end

function cmi:colorExists(decColor)
  local colors, r, g, b

  colors = cmi:decimalToRGB(tonumber(decColor))
  r = colors['r']
  g = colors['g']
  b = colors['b']

  for k,v in pairs(getCustomEnvColorTable()) do
    if v[1] == r and v[2] == g and v[3] == b then
      return(k)
    end
  end
end


function cmi:colorRooms(con)
        local recs, row, roomID, colors, r,g, b, cTable
        local envsUsed = {}
        local envIndex = 500

      echo("[Setting room colours]\n")

        recs = assert(con:execute([[SELECT ObjId, Color FROM ObjectTbl]]))
        row = recs:fetch({})
        while row do
                roomID = tonumber(row[1])
                colors = cmi:decimalToRGB(tonumber(row[2]))
                r = colors['r']
                b = colors['b']
                g = colors['g']
                if envsUsed[row[10]] then
                        cTable = envsUsed[row[2]]
                else
                        cTable = cmi:colorExists(row[2])
                        
                        if not cTable then
                          envsUsed[row[2]] = envIndex
                          cTable = envIndex
                          setCustomEnvColor(cTable, r,g,b,255)
                          envIndex=envIndex+1
                        end
                end
          
          if roomExists(roomID) then
                  setRoomEnv(roomID, cTable)
            --echo("Setting room color for " .. roomID .. "\n")
          end
                row = recs:fetch({})
        end
        recs:close()

    echo("[Room colouring completed]\n")
end

function cmi:addRooms(con, xcmudid, xtorilid)
        local recs, row, roomID, roomname, roomdesc, x, y, z, cost, zone, script


    if xcmudid ~= nil then
          recs = assert(con:execute([[SELECT ObjId, Name, Desc, X,Y,Z, Cost, ZoneID, Script FROM ObjectTbl where ZoneID=]] .. xcmudid))
    else
          recs = assert(con:execute([[SELECT ObjId, Name, Desc, X,Y,Z, Cost, ZoneID, Script FROM ObjectTbl]]))
    end

      -- recs = assert(con:execute([[SELECT ObjId, Name, Desc, X,Y,Z, Cost, ZoneID, Script FROM ObjectTbl]]))
        row = recs:fetch({})
        while row do
                roomID = tonumber(row[1])
                roomname = row[2]
                roomdesc = row[3]
                x = tonumber(row[4])
                y = tonumber(row[5])*-1 --need to reflect on y axis
                z = tonumber(row[6])

                x = math.floor(x/240) -- was 120
                y = math.floor(y/240) -- was 120

                cost = tonumber(row[7])
                zone = tonumber(row[8])
          --  zone=5
                script = row[9]
                if script then
                        script = string.gsub(script, "All[=]?", "", 1)
                end
                addRoom( roomID )
                if roomname then
                        setRoomName( roomID, roomname )
                else
                        echo("null roomname:"..roomID .. "\n")
                end
                
                -- temporarily removed from map file
                --if roomdesc then
                --        setRoomUserData(roomID, "description", roomdesc)
                --else
                --        echo("null roomdesc:"..roomID .. "\n")
                --end
                
                
                if script and script ~= "" then
                        setRoomUserData(roomID, "script", script)
                end
                setRoomCoordinates(roomID, x,y,z)
                setRoomWeight(roomID, cost)

          if cost == 2147483647 then
            -- do not enter room
            echo("[Set room " .. roomID .. " do not enter]\n")
            map:setDoNotEnter(roomID)
          end

                if zone == -1 or not zone then
                        zone = 0
                end

          if xtorilid ~= nil then
            setRoomUserData(roomID, "zoneid", xtorilid)
            resetRoomArea(roomID)   -- set room area to -1
            lockRoom(roomID, true) -- lock room
                else
            setRoomUserData(roomID, "zoneid", zone)
            setRoomArea( roomID, zone )
          end

                row = recs:fetch({})
        end
     -- centerview(roomID)
        recs:close()
end

function cmi:addAreas(con)
  local recs, row, zoneId, Name, row
  recs = assert(con:execute([[SELECT ZoneId, Name FROM ZoneTbl]]))
  row = recs:fetch({})
  while row do
    ZoneId = tonumber(row[1])
    Name = row[2]
      setAreaName(ZoneId, Name)
    row = recs:fetch({})
  end
  recs:close()
end

function cmi:listAreas()
  local recs, row, zoneId, Name, row


  cmudAreaTable={}

  cmi:checkConnection()
  echo("Selected map: " .. cmi.file .. "\n")

  recs = assert(cmi.con:execute([[SELECT ZoneId, Name FROM ZoneTbl]]))
  row = recs:fetch({})
  while row do
    ZoneId = tonumber(row[1])
    Name = row[2]

    cmudAreaTable[Name]=ZoneId

    echo("ID: " .. ZoneId .. " " .. Name .. "\n")

    row = recs:fetch({})
  end
  recs:close()
end


function cmi:addExits(con)
  local recs, row, FromID, ToID, dirtype, param, ExitKindID, name
  recs = assert(con:execute([[SELECT FromID, ToID, DirType, Param, ExitKindID, Name FROM ExitTbl]]))

-- NOTE - this adds all exits from mapfile, whether room has been added or not


--setDoor(roomID, exitCommand, doorStatus)
--Creates or deletes a door in a room. Doors are purely visual - they don't affect pathfinding. You can use the information to change to adjust your speedwalking path based on the door information in a room, though.

--roomID:
--Room ID to to create the door in.
--exitCommand:
--The cardinal direction for the door is in - it can be one of the following: e,s,w,n,ne,se,sw,ne. {Plans are afoot to add support for doors on the other normal exits: up,down,in,out and also on special exits though more work will be needed for them to be shown in the mapper.}
--doorStatus:
--The door status as a number - 0 means remove door, 1 means open door (will draw a green square on exit), 2 means closed door (yellow square) and 3 means locked door (red square).
--See also: getDoors()

-- make a door on the east exit of room 4234 that is currently open
--setDoor(4234, 'e', 1)
 
-- remove a door from room 923 that points north
--setDoor(923, 'n', 0)

  -- ExitKindID 0-normal exit 1-door 2-locked door


-- addSpecialExit(roomIDFrom, roomIDTo, command)
-- Creates a one-way from one room to another, that will use the given command for going through them.




  row = recs:fetch({})
  while row do
    FromID = tonumber(row[1])
    ToID = tonumber(row[2])
    dirtype = cmi.cmudToMudletExit[tonumber(row[3])]
    param = row[4]
    ExitKindID = row[5]
    name = row[6]

    -- if name has value then non-standard exit

    if roomExists(FromID) then
      if dirtype and dirtype ~= -1 then
        setExit(FromID, ToID, dirtype)
      else
        echo("dirtype failed room id " .. FromID .. "\n")
      end

      if name ~= "" and name ~= nil then
        addSpecialExit(FromID, ToID, name)
      end

      if param ~= "" and param ~= nil then
        map:setDoorName(FromID, dirtype, param)
      end

      if exitMap[dirtype] ~= nil then
        if ExitKindID == 1 then -- door
          echo("Door in " .. FromID .. " facing " .. exitMap[dirtype] .. "\n")
          setDoor(FromID, doorMap[dirtype], 2)
        elseif ExitKindID == 2 then -- locked door
          --echo("Locked door in " .. FromID .. " facing " .. exitMap[dirtype] .. "\n")
          
          -- make a door on the east exit of room 4234 that is currently open
          -- setDoor(4234, 'e', 1)
          
          setDoor(FromID, doorMap[dirtype], 3)
          
          -- need to lock exit
          -- lockExit(roomID, direction, lockIfTrue)
          -- lock the east exit of room 1201 so we never path through it
          --lockExit(1201, 4, true)
          
          lockExit(FromID, dirtype, true)          
        end
      else
        echo("nil exit match\n")
        display(FromID)
      end

    end

    row = recs:fetch({})
  end
  recs:close()
end

function cmi:labelCmudZones(con)
  local recs, row, exitrecs, toID, DirType, zonerecs, toZone, fromZone, fromID, zonerec, zoneFetch, zoneName, input
  recs = assert(con:execute([[SELECT ObjId, X,Y,Z, ZoneID, Script FROM ObjectTbl]]))
  row = recs:fetch({})
  while row do
    fromID = tonumber(row[1])
    fromZone = tonumber(row[5])
    exitrecs = assert(con:execute([[SELECT ToID, DirType FROM ExitTbl WHERE FromID = ]]..fromID))
    toID = exitrecs:fetch({})
  
    while toID do
      toZone=nil
      
      zonerecs = assert(con:execute([[SELECT ZoneID FROM ObjectTbl WHERE ObjId = ]]..tonumber(toID[1])))
      
      local zonerecord = zonerecs:fetch({})
      
      if zonerecord ~= nil then
        toZone = tonumber(zonerecord[1])
      end
      
      if toZone ~= fromZone and toZone ~= nil then
        zonerec = assert(con:execute([[SELECT ZoneId, Name FROM ZoneTbl WHERE ZoneId = ]]..toZone))
        zoneFetch = zonerec:fetch({})
        zoneName = zoneFetch[2]

        DirType = cmi.cmudToMudletExit[toID[2]]

        if DirType == nil then
          DirType=4
        end

         input = fromID.." " .. DirType .. " red black "..zoneName -- numeric direction to place label
        --display(input)
        setRoomUserData(fromID, "edge", input)
        -- cmi:roomLabel(input)
      end
      toID = exitrecs:fetch({})
    end
    row = recs:fetch({})
  end
    if zonerec then
        zonerec:close()
    end
  zonerecs:close()
  exitrecs:close()
  recs:close()
end

function cmi:addFavorites(con)
  local recs, row, objId, Name
  recs = assert(con:execute([[SELECT Name, ObjID FROM FavTbl]]))
  row = recs:fetch({})
  while row do
    Name = row[1]
    objId = tonumber(row[2])
    setRoomUserData(objId, "favorite", Name)
    row = recs:fetch({})
  end
  recs:close()
end

function cmi:getConnection()
  if cmi.con then
    cmi.con:close()
  end
  if cmi.env then
    cmi.env:close()
  end
  cmi.env = assert (luasql.sqlite3())
  
  -- connect to data source
  --cmi.file = invokeFileDialog(true, "Select your cMud Map")

  --cmi.file = "/tmp/TorilMud.dbm"
  --cmi.file = "/users/Chris/Google Drive/Toril/TorilMud.dbm"

  cmi.file= "/Users/Chris/Documents/GitHub/NyyLIB/TorilMud.dbm"

  cmi.con = assert (cmi.env:connect(cmi.file))
end

function cmi:checkConnection()
  if not cmi.env or not cmi.file or not cmi.con then
    cmi:getConnection()
  end
end

function cmi:onlyExits()
  cmi:checkConnection()
  -- create environment object
  echo("Selected map: " .. cmi.file .. "\n")

  echo("[Adding exits]\n")
  cmi:addExits(cmi.con)
end

function cmi:importArea(xcmudid, xtorilid)
  cmi:checkConnection()
  -- create environment object
  echo("Selected map: " .. cmi.file .. "\n")
  
  echo("[Adding rooms]\n")
  cmi:addRooms(cmi.con, xcmudid, xtorilid)

  --cmi:colorRooms(cmi.con)
--  echo("[Adding exits]\n")
--  cmi:addExits(cmi.con)
  --set area names
  --cmi:addAreas(cmi.con)

   --cmi:addFavorites(cmi.con)
  --cmi:labelCmudZones(cmi.con)
end

function cmi:colorAreas()
  cmi:checkConnection()
  -- create environment object
  echo("Selected map: " .. cmi.file .. "\n")
  
  cmi:colorRooms(cmi.con)
end

function cmi:importAll()
  cmi:checkConnection()
  -- create environment object
  echo("Selected map: " .. cmi.file .. "\n")
  
  -- x cmi:addRooms(cmi.con)
  cmi:colorRooms(cmi.con)
  -- x cmi:addExits(cmi.con)


  --set area names
  --cmi:addAreas(cmi.con)

   --cmi:addFavorites(cmi.con)
  --cmi:labelCmudZones(cmi.con)
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>ImportedCode</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>chef</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- Copyright (C) 2009 Florian Zeitz
-- Copyright (C) 2009 Matthew Wild
--
-- This project is MIT/X11 licensed. Please see the
-- COPYING file in the source package for more information.
--

local chef = {
  { th = "t" },

  { ow = "o"},
  {["([^%w])o"] = "%1oo",
  O = "Oo"},

  {au = "oo",
  u = "oo", U = "Oo"},
  {["([^o])o([^o])"] = "%1u%2"},
  {ir = "ur",

  an = "un", An = "Un", Au = "Oo"},

  {e = "i", E = "I"},

  { i = function () return select(math.random(2), "i", "ee"); end },

  {a = "e", A = "E"},

  {["e([^%w])"] = "e-a%1"},
  {f = "ff"},

  {v = "f", V = "F"},
  {w = "v", W = "V"} };

function swedish(english)
  local eng, url = english:match("(.*)(http://.*)$");
  if eng then english = eng; end

  for _,v in ipairs(chef) do
    for k,v in pairs(v) do
      english = english:gsub(k,v);
    end
  end
  english = english:gsub("the", "zee");
  english = english:gsub("The", "Zee");
  english = english:gsub("tion", "shun");
  --english = english:gsub("[.!?]$", "%1\nBork Bork Bork!");
  return tostring(english..((url and url) or ""));
end

function check_message(data)
  local origin, stanza = data.origin, data.stanza;

  local body, bodyindex;
  for k,v in ipairs(stanza) do
    if v.name == "body" then
      body, bodyindex = v, k;
    end
  end

  if not body then return; end
  body = body:get_text();

  if body and (body:find(trigger_string, 1, true) == 1) then
    module:log("debug", body:find(trigger_string, 1, true));
    stanza[bodyindex][1] = swedish(body:gsub("^" .. trigger_string, "", 1));
  end
end


</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>LuaBit v0.4</name>
					<packageName></packageName>
					<script>------------------------------------------------
--LuaBit v0.4
-------------------
--a bitwise operation lib for lua.

--http://luaforge.net/projects/bit/

--How to use:
-------------------
-- bit.bnot(n) -- bitwise not (~n)
-- bit.band(m, n) -- bitwise and (m &amp; n)
-- bit.bor(m, n) -- bitwise or (m | n)
-- bit.bxor(m, n) -- bitwise xor (m ^ n)
-- bit.brshift(n, bits) -- right shift (n &gt;&gt; bits)
-- bit.blshift(n, bits) -- left shift (n &lt;&lt; bits)
-- bit.blogic_rshift(n, bits) -- logic right shift(zero fill &gt;&gt;&gt;)
 
--Please note that bit.brshift and bit.blshift only support number within
--32 bits.

--2 utility functions are provided too:
-- bit.tobits(n) -- convert n into a bit table(which is a 1/0 sequence)
               -- high bits first
-- bit.tonumb(bit_tbl) -- convert a bit table into a number 
-------------------

--Under the MIT license.

--copyright(c) 2006~2007 hanzhao (abrash_han@hotmail.com)
--]]---------------


------------------------
-- bit lib implementions

function check_int(n)
 -- checking not float
 if(n - math.floor(n) &gt; 0) then
  error("trying to use bitwise operation on non-integer!")
 end
end

local function to_bits(n)
 check_int(n)
 if(n &lt; 0) then
  -- negative
  return to_bits(bit.bnot(math.abs(n)) + 1)
 end
 -- to bits table
 local tbl = {}
 local cnt = 1
 while (n &gt; 0) do
  local last = math.mod(n,2)
  if(last == 1) then
   tbl[cnt] = 1
  else
   tbl[cnt] = 0
  end
  n = (n-last)/2
  cnt = cnt + 1
 end

 return tbl
end

function tbl_to_number(tbl)
 local n = table.getn(tbl)

 local rslt = 0
 local power = 1
 for i = 1, n do
  rslt = rslt + tbl[i]*power
  power = power*2
 end
 
 return rslt
end

function expand(tbl_m, tbl_n)
 local big = {}
 local small = {}
 if(table.getn(tbl_m) &gt; table.getn(tbl_n)) then
  big = tbl_m
  small = tbl_n
 else
  big = tbl_n
  small = tbl_m
 end
 -- expand small
 for i = table.getn(small) + 1, table.getn(big) do
  small[i] = 0
 end

end

function bit_or(m, n)
 local tbl_m = to_bits(m)
 local tbl_n = to_bits(n)
 expand(tbl_m, tbl_n)

 local tbl = {}
 local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))
 for i = 1, rslt do
  if(tbl_m[i]== 0 and tbl_n[i] == 0) then
   tbl[i] = 0
  else
   tbl[i] = 1
  end
 end
 
 return tbl_to_number(tbl)
end

function bit_and(m, n)
 local tbl_m = to_bits(m)
 local tbl_n = to_bits(n)
 expand(tbl_m, tbl_n) 

 local tbl = {}
 local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))
 for i = 1, rslt do
  if(tbl_m[i]== 0 or tbl_n[i] == 0) then
   tbl[i] = 0
  else
   tbl[i] = 1
  end
 end

 return tbl_to_number(tbl)
end

function bit_not(n)
 
 local tbl = to_bits(n)
 local size = math.max(table.getn(tbl), 32)
 for i = 1, size do
  if(tbl[i] == 1) then 
   tbl[i] = 0
  else
   tbl[i] = 1
  end
 end
 return tbl_to_number(tbl)
end

function bit_xor(m, n)
 local tbl_m = to_bits(m)
 local tbl_n = to_bits(n)
 expand(tbl_m, tbl_n) 

 local tbl = {}
 local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))
 for i = 1, rslt do
  if(tbl_m[i] ~= tbl_n[i]) then
   tbl[i] = 1
  else
   tbl[i] = 0
  end
 end
 
 --table.foreach(tbl, print)

 return tbl_to_number(tbl)
end

function bit_rshift(n, bits)
 check_int(n)
 
 local high_bit = 0
 if(n &lt; 0) then
  -- negative
  n = bit_not(math.abs(n)) + 1
  high_bit = 2147483648 -- 0x80000000
 end

 for i=1, bits do
  n = n/2
  n = bit_or(math.floor(n), high_bit)
 end
 return math.floor(n)
end

-- logic rightshift assures zero filling shift
function bit_logic_rshift(n, bits)
 check_int(n)
 if(n &lt; 0) then
  -- negative
  n = bit_not(math.abs(n)) + 1
 end
 for i=1, bits do
  n = n/2
 end
 return math.floor(n)
end

function bit_lshift(n, bits)
 check_int(n)
 
 if(n &lt; 0) then
  -- negative
  n = bit_not(math.abs(n)) + 1
 end

 for i=1, bits do
  n = n*2
 end
 return bit_and(n, 4294967295) -- 0xFFFFFFFF
end

function bit_xor2(m, n)
 local rhs = bit_or(bit_not(m), bit_not(n))
 local lhs = bit_or(m, n)
 local rslt = bit_and(lhs, rhs)
 return rslt
end

--------------------
-- bit lib interface

bit = {
 -- bit operations
 bnot = bit_not,
 band = bit_and,
 bor  = bit_or,
 bxor = bit_xor,
 brshift = bit_rshift,
 blshift = bit_lshift,
 bxor2 = bit_xor2,
 blogic_rshift = bit_logic_rshift,

 -- utility func
 tobits = to_bits,
 tonumb = tbl_to_number,
}
</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Demonnic</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>Tabbed Chat</name>
						<packageName></packageName>
						<script>--Do not remove the following lines. Or change them.
demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.tabsToBlink = demonnic.chat.tabsToBlink or {}
demonnic.chat.config = demonnic.chat.config or {}
demonnic.chat.tabs = demonnic.chat.tabs or {}
demonnic.chat.windows = demonnic.chat.windows or {}
demonnic.chat.config.activeColors = demonnic.chat.config.activeColors or {}
demonnic.chat.config.inactiveColors = demonnic.chat.config.inactiveColors or {}</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>Configuration Options</name>
							<packageName></packageName>
							<script>--[[
This is where all of the configuration options can be set. 
Anything I've put in this script object can be changed, but please do pay attention to what you're doing.
If you change one of the values to something it shouldn't be, you could break it. 
]]

--This is where you tell it to use tabbed chat.
demonnic.chat.use = true

--[[
The timestamp option is set here.
Set to false if you do not want any timestamps displayed for chat.
If you do want it displayed, set to the string for the format you wish. 
see http://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for information
how to format the string
]]
demonnic.chat.config.timestamp = "hh:mm"

--[[ Should we use our own colors for the timestamp?
Set to true if you want to specify foreground and background colors
for the timestamp.
Set to false if you want the timestamps background and foreground
colors to match that of the mud output.
]]
demonnic.chat.config.timestampCustomColor = false
--[[
and what foreground color? You can either use one of the 'named' colors
(see http://wiki.mudlet.org/images/c/c3/ShowColors.png for available colors)
demonnic.chat.config.timestampFG = "slate_grey"

Or you can use a table of R,G,B values. 
demonnic.chat.config.timestampFG = {
  255,
    0,
    0,
}
then the foreground for the timestamp would be 255 read, 100 green, and 0 blue
]]
demonnic.chat.config.timestampFG = "red"

--and background? Same rules as for the foreground above
demonnic.chat.config.timestampBG = "blue"

--[[
This is where you say what corner of the screen you want the tabbed chat on
Valid settings are "topright", "topleft", "bottomright", "bottomleft"
]]--
demonnic.chat.config.location = "topright"

--[[
This is a table of channels you would like.
AKA the place you tell the script what tabs you want.
Each entry must be a string. The defaults should be a pretty effective guide.
]]

demonnic.chat.config.channels = {
  "ALL",
  "SAYS",
  "SKILL",
  "TELLS",
  "GSAY",
  "GCMD",
  "NHC",
  "GCC",
  "OOC",
  "ACC",
  "AUC"
}


--Set this to the name of the channel you want to have everything sent to. 
--Per the default, this would be the "All" channel. If you have a different name for it:
--
--demonnic.chat.config.Alltab = "Bucket"  
--
--And if you don't want it turned on at all:
--
--demonnic.chat.config.Alltab = false

demonnic.chat.config.Alltab = "ALL"



---------------------------------------------------------------------------------
--                                                                             --
--The infamous blinking stuff!!!                                               --
--                                                                             --
---------------------------------------------------------------------------------

--[[
Do you want tabs to blink when you get new messages, until you click on the tab?
True if yes, false if no.
]]
demonnic.chat.config.blink = true

--How long (in seconds) between blinks? For example, 1 would mean a 1 second pause in between blinks.
demonnic.chat.config.blinkTime = 3

--Blink if the bucket tab ("All" by default, but configured above) is in focus?
demonnic.chat.config.blinkFromAll = true




--Font size for the chat messages

demonnic.chat.config.fontSize = 12

--[[
Should we preserve the formatting of the text. 
Or should we set the background of it to match the window color?
Set this to false if you want the background for all chat to match the background of the window.
Useful if you change the background from black, and don't like the way the pasted chat makes blocks in it
]]

demonnic.chat.config.preserveBackground = false

--[[
Gag the chat lines in the main window?
defaults to false, set to true if you want to gag.
]]

demonnic.chat.config.gag = false

--[[
Number of lines of chat visible at once. 
Will determine how tall the window for the chats is.
]]

-- demonnic.chat.config.lines = 19

--[[
Number of characters to wrap the chatlines at.
This will also determine how wide the chat windows are.
]]

demonnic.chat.config.width = 64

--[[
Set the color for the active tab. R,G,B format.
The default here is a brightish green
]]

demonnic.chat.config.activeColors = {
  r = 0,
  g = 180,
  b = 0,
}

--[[
Set the color for the inactive tab. R,G,B format.
The default here is a drab grey
]]

demonnic.chat.config.inactiveColors = {
  r = 60,
  g = 60,
  b = 60,
}

--[[
Set the color for the chat window itself. R,G,B format.
Defaulted to the black of my twisted hardened soul. Or something.
]]

demonnic.chat.config.windowColors = {
  r = 0,
  g = 0,
  b = 0,
}

--[[
Set the color for the text on the active tab. Uses color names.
Set the default to purple. So the tab you're looking at, by default will be purple on bright green. 
Did I mention I'm a bit colorblind?
]]

demonnic.chat.config.activeTabText = "purple"

--[[
Set the color for the text on the inactive tabs. Uses color names.
Defaulted this to white. So the tabs you're not looking at will be white text on boring grey background.
]]

demonnic.chat.config.inactiveTabText = "white"

--[[
have to make sure a currentTab is set... 
so we'll use the one for the bucket, or the first one in the channels table
Or, you know... what it's currently set to, if it's already set.
]]
demonnic.chat.currentTab = demonnic.chat.currentTab or demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>Code</name>
							<packageName></packageName>
							<script>function setChatLabel(xwindow, xtext, xcolor)
  local fontSize=14

  local font = charData:get("font", true)

  if xcolor == nil then
    xcolor="white"
  end

  xwindow:setStyleSheet([[background-color : transparent]])

  if xcolor == charData:get("colbuttonon") then
    -- add bold
    xwindow:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. font .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. xcolor .. [["&gt;]] .. xtext .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
  else
    xwindow:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. font .. [['"&gt;&lt;center&gt;&lt;font color="]] .. xcolor .. [["&gt;]] .. xtext .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
  end
end

function demonnic.chat:redo()
	local WindowWidth, WindowHeight = getMainWindowSize()
	local wwidth,wheight = calcFontSize(demonnic.chat.config.fontSize)
	
	if charData:get("chatfontsize", true) == "auto" then
		demonnic.chat.config.fontSize= maxfont(60, (WindowWidth/3-15))
	
		if demonnic.chat.config.fontSize &gt; 12 then
			demonnic.chat.config.fontSize = 12
		end	
	else
		demonnic.chat.config.fontSize= tonumber(charData:get("chatfontsize", true))
	end

	wwidth,wheight = calcFontSize(demonnic.chat.config.fontSize)	

  --iterate the table of channels and redo wrap, fontsize
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
 	  demonnic.chat.windows[tab]:setWrap( (WindowWidth/3)/wwidth ) 
  	if tab ~= demonnic.chat.currentTab then
			setChatLabel(demonnic.chat.tabs[tab], tab, charData:get("colbuttonoff") )
		end
	end
end



function demonnicChatSwitch(chat)
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local newr = demonnic.chat.config.activeColors.r
  local newg = demonnic.chat.config.activeColors.g
  local newb = demonnic.chat.config.activeColors.b
  local oldchat = demonnic.chat.currentTab
  if demonnic.chat.currentTab ~= chat then

    --display(chat)
    
    setChatLabel(demonnic.chat.tabs[oldchat], oldchat, charData:get("colbuttonoff"))

    demonnic.chat.windows[oldchat]:show()
    demonnic.chat.windows[oldchat]:hide()
    demonnic.chat.tabs[oldchat]:setColor(r,g,b)
    -- demonnic.chat.tabs[oldchat]:echo(oldchat, demonnic.chat.config.inactiveTabText, "c")
    if demonnic.chat.config.blink and demonnic.chat.tabsToBlink[chat] then
      demonnic.chat.tabsToBlink[chat] = nil
    end
    if demonnic.chat.config.blink and chat == demonnic.chat.config.Alltab then
      demonnic.chat.tabsToBlink = {}
    end
  end
  demonnic.chat.tabs[chat]:setColor(newr,newg,newb)
  -- demonnic.chat.tabs[chat]:echo(chat, demonnic.chat.config.activeTabText, "c")
  demonnic.chat.windows[chat]:show()
  demonnic.chat.windows[chat]:raise()

  setChatLabel(demonnic.chat.tabs[chat], chat, charData:get("colbuttonon"))

  demonnic.chat.currentTab = chat  
end

function demonnic.chat:resetUI()
  demonnic.chat.container = Geyser.Container:new( {
    fontSize = demonnic.chat.config.fontSize,
   x="2%",    y="2%",    width="94%",   height="94%"  }, rightLabel )

  demonnic.chat.tabBox = Geyser.HBox:new({
    x=0, y=0, width = "100%", height = "25px", name = "DemonChatTabs", },demonnic.chat.container)
end

function demonnic.chat:create()
  --reset the UI
  demonnic.chat:resetUI()
  --Set some variables locally to increase readability
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local winr = demonnic.chat.config.windowColors.r
  local wing = demonnic.chat.config.windowColors.g
  local winb = demonnic.chat.config.windowColors.b

  --iterate the table of channels and create some windows and tabs
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.tabs[tab] = Geyser.Label:new({
      name=string.format("tab%s", tab),
    }, demonnic.chat.tabBox)


  -- demonnic.chat.tabs[tab]:setStyleSheet([[border-image: url(]] .. iconpath("gui".. tab  .. ".png") .. [[)]])
  setChatLabel(demonnic.chat.tabs[tab], tab, charData:get("colbuttonoff"))


    -- demonnic.chat.tabs[tab]:echo(tab, demonnic.chat.config.inactiveTabText, "c")
    demonnic.chat.tabs[tab]:setColor(r,g,b)
    demonnic.chat.tabs[tab]:setClickCallback("demonnicChatSwitch", tab)

    demonnic.chat.windows[tab] = Geyser.MiniConsole:new({
--      fontSize = demonnic.chat.config.fontSize,
      x = 0,
      y = 25,
      autoWrap = true,
      height = "100%-25px",
      width = "100%",
      name = string.format("win%s", tab),
    }, demonnic.chat.container)
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
    demonnic.chat.windows[tab]:setColor(winr,wing,winb)
    
  end
  
  local showme = demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
  demonnicChatSwitch(showme)
  --start the blink timers, if enabled
  if demonnic.chat.config.blink and not demonnic.chat.blinkTimerOn then
    demonnic.chat:blink()
  end
end


function demonnic.chat:fixWrap()
  -- this doesn't work
  
  for i,tab in ipairs(demonnic.chat.config.channels) do
    --demonnic.chat.windows[tab]:enableAutoWrap()
  end
end

function demonnic.chat:append(chat, xwho, xbody)
  local r = demonnic.chat.config.windowColors.r
  local g = demonnic.chat.config.windowColors.g
  local b = demonnic.chat.config.windowColors.b

  local ofr,ofg,ofb = getFgColor()
  local obr,obg,obb = getBgColor()
  if demonnic.chat.config.preserveBackground then
    setBgColor(r,g,b)
  end

  -- check if broken packet/line on same line as prompt

  local roomline = getLines(getLineCount(), getLineCount()-1)[1]

  -- don't echo chat gags
  
  if isChatGagged(xwho) or isChatGagged(xbody) then
    return
  end

  if roomline == nil then
    echo("[ERROR: nil roomline]\n")
  end

  --local linecheck = string.find(roomline, "^&lt; .* &gt; ")

  --if linecheck ~= nil then
  --  linecheck = string.find(roomline, "&gt; ")
  --end

  --if linecheck ~= nil then
    -- include part line without prompt
  --  selectSection(linecheck+1, string.len(roomline)-linecheck-1)
  --else
  -- include full line in capture window
  --  selectCurrentLine()
  --end

  selectCurrentLine()
  copy()

  -- don't echo gagged text

  if isGagged(captureWho) or isGagged(captureBody) or isGagged(roomline) then
    return
  end

  -- don't echo empty lines

  if getCurrentLine() == nil then
    return
  end

  if getCurrentLine() == "" then
    return
  end

  -- don't capture wormhole requests

  if   string.find(roomline, ".* tells you 'hole .*") or
      string.find(roomline, ".* tells you 'hol .*") or
      string.find(roomline, ".* tells you 'worm .*") or
      string.find(roomline, ".* tells you 'wormhole .*") or
      string.find(roomline, ".* tells you 'rift .*") then
        return
  end

  --display(xwho)

  -- append to subtab, allTab
  if chat == "GSAY" then
    -- supress adding to alltab
    -- if blue ansi change tab to gcmd?
    --display(xbody)
    
    if string.find(xbody, "|c00ffff") then
      demonnic.chat.windows[chat]:append(xwho, xbody, "GCMD")
    else
      demonnic.chat.windows[chat]:append(xwho, xbody, "GSAY")
    end
  else
     demonnic.chat.windows[chat]:append(xwho, xbody, chat)
   end
 
  if demonnic.chat.config.gag then 
    deleteLine() 
    tempLineTrigger(1,1, [[if isPrompt() then deleteLine() end]])
  end
 
  if demonnic.chat.config.blink and chat ~= demonnic.chat.currentTab then 
    if (demonnic.chat.config.Alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end


function demonnic.chat:blink()
  if demonnic.chat.blinkID then killTimer(demonnic.chat.blinkID) end
  if not demonnic.chat.config.blink then 
    demonnic.chat.blinkTimerOn = false
    return 
  end
  for tab,_ in pairs(demonnic.chat.tabsToBlink) do
    demonnic.chat.tabs[tab]:flash()
  end
  demonnic.chat.blinkID = tempTimer(demonnic.chat.config.blinkTime, function () demonnic.chat:blink() end)
end
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>demonnicOnStart</name>
							<packageName></packageName>
							<script>function demonnicOnStart()
  cecho("&lt;red&gt;[Initializing chat windows...]\n")

  local WindowWidth, WindowHeight = getMainWindowSize()

  NyyLIB = NyyLIB or {}

  createRightsideContainers()
  createLeftsideContainers()

  -- if demonnic.chat.use then
  demonnic.chat:create()
    -- end

  cecho("&lt;red&gt;[Chat containers created]\n")
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>echo functions</name>
							<packageName></packageName>
							<script>
function demonnic.chat:cecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  cecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    cecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:decho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  decho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    decho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:hecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  hecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    hecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:echo(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  echo(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    echo(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>geyser additions</name>
							<packageName></packageName>
							<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function Geyser.MiniConsole:clear()
   clearWindow(self.name)
end

function Geyser.MiniConsole:append(xwho, xbody, windowName)
  
  local allTab=false
  
  if demonnic.chat.config.Alltab then 
    allTab=string.format("win%s", demonnic.chat.config.Alltab)
  end

  if xwho ~= nil then
    local isLeader=false
    
    if NyyLIB.leader ~= nil then
      if string.find(xwho, NyyLIB.leader) or (NyyLIB.leader == whoami() and string.find(xwho, "You")) then
        isLeader=true
      end
    end
    
    -- remove |6c(@name/)(capture) "
    -- lua string.gsub("|aaaaaatest", "|%x%x%x%x%x%x", "")
    -- Auction: Vamot bid 50 platinum on item 96 a small oaken drum wrapped with dragonhide
    -- "Vamot bid 50 platinum on item 96 a small oaken drum wrapped with dragonhide"
    
    
    local zwho= string.gsub(xwho, "|%x%x%x%x%x%x%x", ""):trim()
    
    zwho = string.gmatch(zwho, "%w+")()

    if zwho == "You" then
      zwho=whoami()
    end
    
    --display(zwho)
    -- if there's a space inside zwho then substring the first word
    -- "You project 'test'"
    
    hechoLink(self.name, xwho, [[nilFunction()]], getTime(true, "ddd hh:mm AP") .. "/@" .. (inwho(zwho) or ""), true)
    
    if allTab then
      if windowName ~= "AUC" then
        hechoLink(allTab, xwho, [[nilFunction()]], getTime(true, "ddd hh:mm AP") .. "/@" .. (inwho(zwho) or ""), true)
      end
      speak(xwho)
    end
    
    -- duplicate echo to gcmd if gsay and group leader
    if (windowName == "GSAY" or windowName == "GCMD") and isLeader then
      hechoLink("winGCMD", xwho, [[nilFunction()]], getTime(true, "ddd hh:mm AP") .. "/@" .. (inwho(xwho) or ""), true)
    end
    
    -- show xbody if passed
    if xbody ~= nil then
      -- display body with url link if present
    
      local checkUrl = getUrl(xbody)
    
      if checkUrl then
        hechoLink(self.name, xbody, [[openUrl("]] .. checkUrl .. [[")]], checkUrl, true)

        if allTab then
          if windowName ~= "AUC" then
            hechoLink(allTab, xbody, [[openUrl("]] .. checkUrl .. [[")]], checkUrl, true)
          end
        end
      else
        -- replace single with double backslash
        xbody=string.gsub(xbody, "\\", "\\")  

        hecho(self.name, xbody)
        hecho("testLabel", xbody)
        
         
        --display(xbody) 
         
        if allTab then
          if windowName ~= "AUC" then
            hecho(allTab, xbody)
          end
          
          speak(xbody)
        end
      
        -- duplicate echo to gcmd if gsay and group leader TODO: check for cyan colour
        if (windowName == "GSAY" or windowName == "GCMD")and isLeader then
          hecho("winGCMD", xbody)
        end
      end
    end

    -- terminate line
    
    deselect()
    copy()
    appendBuffer(self.name)
  
    if allTab then
      --don't echo auctions to the alltab
      if windowName ~= "AUC" then
        appendBuffer(allTab)
      end
    end
  
    if (windowName == "GSAY" or windowName == "GCMD") and isLeader then
      -- line termination required for gcmd window also
      appendBuffer("winGCMD")
    end
  end
end

function Geyser.MiniConsole:setStyleSheet(style)
  appendBuffer(self.name)
end

-- rLabel:setStyleSheet([[border-image: url(]] .. iconpath("frame-1.png") .. [[)]])</script>
							<eventHandlerList />
						</Script>
						<Script isActive="no" isFolder="no">
							<name>copyString</name>
							<packageName></packageName>
							<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function clearScratchPad()
  if scratchPad ~= nil then
    clearWindow("scratchPad")
  end
end

function copyStringToScratchpad(xstring)
  local currentLine = getLines(getLineCount(), getLineCount()-1)[1]

  if scratchPad == nil then
    scratchPad=createBuffer("scratchPad")
  end

  display(currentLine)
  -- body of tell
  --moveCursorEnd()
  --selectSection(string.len(whotell)+11, string.len(matches[1])-string.len(whotell)-11)
  --copy()

  --moveCursor("scratchPad", 0, 0)
  --paste("scratchPad")

  -- who sent tell

  --selectSection(0, string.len(whotell)+1)
  --copy()

  --moveCursor("scratchPad", 0, 0)
  --paste("scratchPad")


  -- place built line on winALL

  --selectCurrentLine("scratchPad")
  --copy("scratchPad")

  --moveCursorEnd()

  --appendBuffer("winALL")
end</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
					<Script isActive="yes" isFolder="no">
						<name>EMCO</name>
						<packageName></packageName>
						<script>EMCO = EMCO or {}

--- Embeddable Multi Console Object.
-- This is essentially YATCO, but with some tweaks, updates, and it returns an object
-- similar to Geyser so that you can a.) have multiple of them and b.) easily embed it
-- into your existing UI as you would any other Geyser element.
--@classmod EMCO
--@author Damian Monogue &lt;demonnic@gmail.com&gt;
--@copyright 2020 Damian Monogue
--@license MIT, see LICENSE.lua
local EMCO = Geyser.Container:new({
  name = "TabbedConsoleClass",
  timestampExceptions = {},
  path = "|h/log/|E/|y/|m/|d/",
  fileName = "|N.|e"
})

-- patch Geyser.MiniConsole if it does not have its own display method defined
if Geyser.MiniConsole.display == Geyser.display then
  function Geyser.MiniConsole:display(...)
    local arg = {...}
    arg.n = table.maxn(arg)
    if arg.n &gt; 1 then
      for i = 1, arg.n do
        self:display(arg[i])
      end
    else
      self:echo((prettywrite(arg[1], '  ') or 'nil') .. '\n')
    end
  end
end

--local pathOfThisFile = (...):match("(.-)[^%.]+$")
--local ok, content = pcall(require, pathOfThisFile .. "loggingconsole")
--local LC
--if ok then
--  LC = content
--else
--  debugc("EMCO tried to require loggingconsole but could not because: " .. content)
--end

--- Creates a new Embeddable Multi Console Object.
-- &lt;br&gt;see https://github.com/demonnic/EMCO/wiki for information on valid constraints and defaults
-- @tparam table cons table of constraints which configures the EMCO.
-- &lt;table class="tg"&gt;
-- &lt;thead&gt;
--   &lt;tr&gt;
--     &lt;th&gt;option name&lt;/th&gt;
--     &lt;th&gt;description&lt;/th&gt;
--     &lt;th&gt;default&lt;/th&gt;
--   &lt;/tr&gt;
-- &lt;/thead&gt;
-- &lt;tbody&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;timestamp&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;display timestamps on the miniconsoles?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;blankLine&lt;/td&gt;
--     &lt;td class="tg-even"&gt;put a blank line between appends/echos?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;scrollbars&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;enable scrollbars for the miniconsoles?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;customTimestampColor&lt;/td&gt;
--     &lt;td class="tg-even"&gt;if showing timestamps, use a custom color?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;mapTab&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;should we attach the Mudlet Mapper to this EMCO?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;mapTabName&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Which tab should we attach the map to?
--                     &lt;br&gt;If mapTab is true and you do not set this, it will throw an error&lt;/td&gt;
--     &lt;td class="tg-even"&gt;&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;blinkFromAll&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;should tabs still blink, even if you're on the 'all' tab?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;preserveBackground&lt;/td&gt;
--     &lt;td class="tg-even"&gt;preserve the miniconsole background color during append()?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;gag&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;when running :append(), should we also gag the line?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;timestampFormat&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Format string for the timestamp. Uses getTime()&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"HH:mm:ss"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;timestampBGColor&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Custom BG color to use for timestamps. Any valid Geyser.Color works.&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;"blue"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;timestampFGColor&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Custom FG color to use for timestamps. Any valid Geyser.Color works&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"red"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;allTab&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Should we send everything to an 'all' tab?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;allTabName&lt;/td&gt;
--     &lt;td class="tg-even"&gt;And which tab should we use for the 'all' tab?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"All"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;blink&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Should we blink tabs that have been written to since you looked at them?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;blinkTime&lt;/td&gt;
--     &lt;td class="tg-even"&gt;How long to wait between blinks, in seconds?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;3&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;fontSize&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;What font size to use for the miniconsoles?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;9&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;font&lt;/td&gt;
--     &lt;td class="tg-even"&gt;What font to use for the miniconsoles?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;tabFont&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;What font to use for the tabs?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;activeTabCss&lt;/td&gt;
--     &lt;td class="tg-even"&gt;What css to use for the active tab?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;""&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;inactiveTabCSS&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;What css to use for the inactive tabs?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;""&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;activeTabFGColor&lt;/td&gt;
--     &lt;td class="tg-even"&gt;What color to use for the text on the active tab. Any Geyser.Color works.&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"purple"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;inactiveTabFGColor&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;What color to use for the text on the inactive tabs. Any Geyser.Color works.&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;"white"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;activeTabBGColor&lt;/td&gt;
--     &lt;td class="tg-even"&gt;What BG color to use for the active tab? Any Geyser.Color works. Overriden by activeTabCSS&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"&lt;0,180,0&gt;"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;inactiveTabBGColor&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;What BG color to use for the inactavie tabs? Any Geyser.Color works. Overridden by inactiveTabCSS&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;"&lt;60,60,60&gt;"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;consoleColor&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Default background color for the miniconsoles. Any Geyser.Color works&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"black"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;tabBoxCSS&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;tss for the entire tabBox (not individual tabs)&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;""&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;tabBoxColor&lt;/td&gt;
--     &lt;td class="tg-even"&gt;What color to use for the tabBox? Any Geyser.Color works. Overridden by tabBoxCSS&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"black"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;consoleContainerCSS&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;CSS to use for the container holding the miniconsoles&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;""&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;consoleContainerColor&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Color to use for the container holding the miniconsole. Any Geyser.Color works. Overridden by consoleContainerCSS&lt;/td&gt;
--     &lt;td class="tg-even"&gt;"black"&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;gap&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;How many pixels to place between the tabs and the miniconsoles?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;1&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;consoles&lt;/td&gt;
--     &lt;td class="tg-even"&gt;List of the tabs for this EMCO in table format&lt;/td&gt;
--     &lt;td class="tg-even"&gt;{ "All" }&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;allTabExclusions&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;List of the tabs which should never echo to the 'all' tab in table format&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;{}&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;tabHeight&lt;/td&gt;
--     &lt;td class="tg-even"&gt;How many pixels high should the tabs be?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;25&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;autoWrap&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Use autoWrap for the miniconsoles?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;true&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;wrapAt&lt;/td&gt;
--     &lt;td class="tg-even"&gt;How many characters to wrap it, if autoWrap is turned off?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;300&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;leftMargin&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Number of pixels to put between the left edge of the EMCO and the miniconsole?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;0&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;rightMargin&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Number of pixels to put between the right edge of the EMCO and the miniconsole?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;0&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;bottomMargin&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Number of pixels to put between the bottom edge of the EMCO and the miniconsole?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;0&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;topMargin&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Number of pixels to put between the top edge of the miniconsole container, and the miniconsole? This is in addition to gap&lt;/td&gt;
--     &lt;td class="tg-even"&gt;0&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;timestampExceptions&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Table of tabnames which should not get timestamps even if timestamps are turned on&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;{}&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;tabFontSize&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Font size for the tabs&lt;/td&gt;
--     &lt;td class="tg-even"&gt;8&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;tabBold&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Should the tab text be bold? Boolean value&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;tabItalics&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Should the tab text be italicized?&lt;/td&gt;
--     &lt;td class="tg-even"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;tabUnderline&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Should the tab text be underlined?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;tabAlignment&lt;/td&gt;
--     &lt;td class="tg-even"&gt;Valid alignments are 'c', 'center', 'l', 'left', 'r', 'right', or '' to not include the alignment as part of the echo (to allow the stylesheet to handle it)&lt;/td&gt;
--     &lt;td class="tg-even"&gt;'c'&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;commandLine&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;Should we enable commandlines for the miniconsoles?&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;false&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-even"&gt;cmdActions&lt;/td&gt;
--     &lt;td class="tg-even"&gt;A table with console names as keys, and values which are templates for the command to send. see the setCustomCommandline function for more&lt;/td&gt;
--     &lt;td class="tg-even"&gt;{}&lt;/td&gt;
--   &lt;/tr&gt;
--   &lt;tr&gt;
--     &lt;td class="tg-odd"&gt;backgroundImages&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;A table containing definitions for the background images. Each entry should have a key the same name as the tab it applies to, with entries "image" which is the path to the image file,&lt;br&gt;and "mode" which determines how it is displayed. "border" stretches, "center" center, "tile" tiles, and "style". See Mudletwikilink for details.&lt;/td&gt;
--     &lt;td class="tg-odd"&gt;{}&lt;/td&gt;
--   &lt;/tr&gt;
-- &lt;/tbody&gt;
-- &lt;/table&gt;
-- @tparam GeyserObject container The container to use as the parent for the EMCO
-- @return the newly created EMCO
function EMCO:new(cons, container)
  local funcName = "EMCO:new(cons, container)"
  cons = cons or {}
  cons.type = cons.type or "tabbedConsole"
  cons.consoles = cons.consoles or { "All" }
  if cons.mapTab then
    if not type(cons.mapTabName) == "string" then
      self:ce(funcName, [["mapTab" is true, thus constraint "mapTabName" and string expected, got ]] .. type(cons.mapTabName))
    elseif not table.contains(cons.consoles, cons.mapTabName) then
      self:ce(funcName, [["mapTabName" must be one of the consoles contained within constraint "consoles". Valid option for tha mapTab are: ]] .. table.concat(cons.consoles, ","))
    end
  end
  cons.allTabExclusions = cons.allTabExclusions or {}
  if not type(cons.allTabExclusions) == "table" then self:se(funcName, "allTabExclusions must be a table if it is provided") end
  local me = self.parent:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  -- set some defaults. Almost all the defaults we had for YATCO, plus a few new ones
  me.cmdActions = cons.cmdActions or {}
  if not type(me.cmdActions) == "table" then self:se(funcName, "cmdActions must be a table if it is provided") end
  me.backgroundImages = cons.backgroundImages or {}
  if not type(me.backgroundImages) == "table" then self:se(funcName, "backgroundImages must be a table if provided.") end
  if me:fuzzyBoolean(cons.timestamp) then
    me:enableTimestamp()
  else
    me:disableTimestamp()
  end
  if me:fuzzyBoolean(cons.customTimestampColor) then
    me:enableCustomTimestampColor()
  else
    me:disableCustomTimestampColor()
  end
  if me:fuzzyBoolean(cons.mapTab) then
    me.mapTab = true
  else
    me.mapTab = false
  end
  if me:fuzzyBoolean(cons.blinkFromAll) then
    me:enableBlinkFromAll()
  else
    me:disableBlinkFromAll()
  end
  if me:fuzzyBoolean(cons.preserveBackground) then
    me:enablePreserveBackground()
  else
    me:disablePreserveBackground()
  end
  if me:fuzzyBoolean(cons.gag)then
    me:enableGag()
  else
    me:disableGag()
  end
  me:setTimestampFormat(cons.timestampFormat or "HH:mm:ss")
  me:setTimestampBGColor(cons.timestampBGColor or "blue")
  me:setTimestampFGColor(cons.timestampFGColor or "red")
  if me:fuzzyBoolean(cons.allTab) then
    me:enableAllTab(cons.allTab)
  else
    me:disableAllTab()
  end
  if me:fuzzyBoolean(cons.blink) then
    me:enableBlink()
  else
    me:disableBlink()
  end
  if me:fuzzyBoolean(cons.blankLine) then
    me:enableBlankLine()
  else
    me:disableBlankLine()
  end
  if me:fuzzyBoolean(cons.scrollbars) then
    me.scrollbars = true
  else
    me.scrollbars = false
  end
  me.tabUnderline = me:fuzzyBoolean(cons.tabUnderline) and true or false
  me.tabBold = me:fuzzyBoolean(cons.tabBold) and true or false
  me.tabItalics = me:fuzzyBoolean(cons.tabItalics) and true or false
  me.tabFontSize = cons.tabFontSize or 8
  me.tabAlignment = cons.tabAlignment or "c"
  me.blinkTime = cons.blinkTime or 3
  me.fontSize = cons.fontSize or 9
  me.activeTabCSS = cons.activeTabCSS or ""
  me.inactiveTabCSS = cons.inactiveTabCSS or ""
  me.activeTabFGColor = cons.activeTabFGColor or "purple"
  me.inactiveTabFGColor = cons.inactiveTabFGColor or "white"
  me.activeTabBGColor = cons.activeTabBGColor or "&lt;0,180,0&gt;"
  me.inactiveTabBGColor = cons.inactiveTabBGColor or "&lt;60,60,60&gt;"
  me.consoleColor = cons.consoleColor or "black"
  me.tabBoxCSS = cons.tabBoxCSS or ""
  me.tabBoxColor = cons.tabBoxColor or "black"
  me.consoleContainerCSS = cons.consoleContainerCSS or ""
  me.consoleContainerColor = cons.consoleContainerColor or "black"
  me.commandLine = me:fuzzyBoolean(cons.commandLine) and true or false
  me.gap = cons.gap or 1
  me.consoles = cons.consoles
  me.tabHeight = cons.tabHeight or 25
  me.leftMargin = cons.leftMargin or 0
  me.rightMargin = cons.rightMargin or 0
  me.topMargin = cons.topMargin or 0
  me.bottomMargin = cons.bottomMargin or 0
  if cons.autoWrap == nil then
    me.autoWrap = true
  else
    me.autoWrap = cons.autoWrap
  end
  me.font = cons.font
  me.tabFont = cons.tabFont
  me.wrapAt = cons.wrapAt or 300
  me.currentTab = ""
  me.tabs = {}
  me.tabsToBlink = {}
  me.mc = {}
  self.blinkTimerID = tempTimer(me.blinkTime, function() me:doBlink() end, true)
  me:reset()
  if me.allTab then me:setAllTabName(me.allTabName or me.consoles[1]) end
  table.insert(EMCOHelper.items, me)
  return me
end

function EMCO:readYATCO()
  local config
  if demonnic and demonnic.chat and demonnic.chat.config then
    config = demonnic.chat.config
  else
    cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Could not find demonnic.chat.config, nothing to convert\n")
    return
  end
  local constraints = "EMCO:new({\n"
  constraints = string.format("%s  x = %d,\n", constraints, demonnic.chat.container.get_x())
  constraints = string.format("%s  y = %d,\n", constraints, demonnic.chat.container.get_y())
  constraints = string.format("%s  width = %d,\n", constraints, demonnic.chat.container.get_width())
  constraints = string.format("%s  height = %d,\n", constraints, demonnic.chat.container.get_height())
  if config.timestamp then
    constraints = string.format("%s  timestamp = true,\n  timestampFormat = \"%s\",\n", constraints, config.timestamp)
  else
    constraints = string.format("%s  timestamp = false,\n", constraints)
  end
  if config.timestampColor then
    constraints = string.format("%s  customTimestampColor = true,\n", constraints)
  else
    constraints = string.format("%s  customTimestampColor = false,\n", constraints)
  end
  if config.timestampFG then
    constraints = string.format("%s  timestampFGColor = \"%s\",\n", constraints, config.timestampFG)
  end
  if config.timestampBG then
    constraints = string.format("%s  timestampBGColor = \"%s\",\n", constraints, config.timestampBG)
  end
  if config.channels then
    local channels = "consoles = {\n"
    for _,channel in ipairs(config.channels) do
      if _ == #config.channels then
        channels = string.format("%s    \"%s\"", channels, channel)
      else
        channels = string.format("%s    \"%s\",\n", channels, channel)
      end
    end
    channels = string.format("%s\n  },\n", channels)
    constraints = string.format([[%s  %s]], constraints, channels)
  end
  if config.Alltab then
    constraints = string.format("%s  allTab = true,\n", constraints)
    constraints = string.format("%s  allTabName = \"%s\",\n", constraints, config.Alltab)
  else
    constraints = string.format("%s  allTab = false,\n", constraints)
  end
  if config.Maptab and config.Maptab ~= "" then
    constraints = string.format("%s  mapTab = true,\n", constraints)
    constraints = string.format("%s  mapTabName = \"%s\",\n", constraints, config.Maptab)
  else
    constraints = string.format("%s  mapTab = false,\n", constraints)
  end
  constraints = string.format("%s  blink = %s,\n", constraints, tostring(config.blink))
  constraints = string.format("%s  blinkFromAll = %s,\n", constraints, tostring(config.blinkFromAll))
  if config.fontSize then
    constraints = string.format("%s  fontSize = %d,\n", constraints, config.fontSize)
  end
  constraints = string.format("%s  preserveBackground = %s,\n", constraints, tostring(config.preserveBackground))
  constraints = string.format("%s  gag = %s,\n", constraints, tostring(config.gag))
  constraints = string.format("%s  activeTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.activeColors.r, config.activeColors.g, config.activeColors.b)
  constraints = string.format("%s  inactiveTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.inactiveColors.r, config.inactiveColors.g, config.inactiveColors.b)
  constraints = string.format("%s  consoleColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.windowColors.r, config.windowColors.g, config.windowColors.b)
  constraints = string.format("%s  activeTabFGColor = \"%s\",\n", constraints, config.activeTabText)
  constraints = string.format("%s  inactiveTabFGColor = \"%s\"", constraints, config.inactiveTabText)
  constraints = string.format("%s\n})", constraints)
  return constraints
end

--- Scans for the old YATCO configuration values and prints out a set of constraints to use.
-- with EMCO to achieve the same effect. Is just the invocation
function EMCO:miniConvertYATCO()
  local constraints = self:readYATCO()
  cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Here are the constraints to use with EMCO(x,y,width, and height have been converted to their absolute values):\n\n")
  echo(constraints .. "\n")
end

--- Echos to the main console a script object you can add which will fully convert YATCO to EMCO.
-- This replaces the demonnic.chat variable with a newly created EMCO object, so that the main
-- functions used to place information on the consoles (append(), cecho(), etc) should continue to
-- work in the user's triggers and events.
function EMCO:convertYATCO()
  local invocation = self:readYATCO()
  local header = [[
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Make a new script, then copy and paste the following output into it.
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Afterward, uninstall YATCO (you can leave YATCOConfig until you're sure everything is right) and restart Mudlet
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; If everything looks right, you can uninstall YATCOConfig. 


-- Copy everything below this line until the next line starting with --
demonnic = demonnic or {}
demonnic.chat = ]]
  cecho(string.format("%s%s\n--- End script\n", header, invocation))
end

function EMCO:checkTabPosition(position)
  if position == nil then
    return 0
  end
  return tonumber(position) or type(position)
end

function EMCO:checkTabName(tabName)
  if not tostring(tabName) then
    return "tabName as string expected, got" .. type(tabName)
  end
  tabName = tostring(tabName)
  if table.contains(self.consoles, tabName) then
    return "tabName must be unique, and we already have a tab named " .. tabName
  else
    return "clear"
  end
end

function EMCO.ae(funcName, message)
  error(string.format("%s: Argument Error: %s", funcName, message))
end

function EMCO:ce(funcName, message)
  error(string.format("%s:gg Constraint Error: %s", funcName, message))
end

--- Display the contents of one or more variables to an EMCO tab. like display() but targets the miniconsole
--@tparam string tabName the name of the tab you want to display to
--@param item The thing to display()
--@param[opt] item2 another thing to display()
--@param[optchain] item_n and so on and so on
function EMCO:display(tabName, ...)
  local funcName = "EMCO:display(tabName, item)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be a tab which exists in this EMCO. valid options are: " .. table.concat(self.consoles, ","))
  end
  self.mc[tabName]:display(...)
end

--- Remove a tab from the EMCO
--@tparam string tabName the name of the tab you want to remove from the EMCO
function EMCO:removeTab(tabName)
  local funcName = "EMCO:removeTab(tabName)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be a tab which exists in this EMCO. valid options are: " .. table.concat(self.consoles, ","))
  end
  table.remove(self.consoles, table.index_of(self.consoles, tabName))
  local window = self.mc[tabName]
  local tab = self.tabs[tabName]
  window:hide()
  tab:hide()
  self.tabBox:remove(tab)
  self.tabBox:organize()
  self.consoleContainer:remove(window)
  self.mc[tabName] = nil
  self.tabs[tabName] = nil
end

--- Adds a tab to the EMCO object
-- @tparam string tabName the name of the tab to add
-- @tparam[opt] number position position in the tab switcher to put this tab
function EMCO:addTab(tabName, position)
  local funcName = "EMCO:addTab(tabName, position)"
  position = self:checkTabPosition(position)
  if type(position) == "string" then self.ae(funcName, "position as number expected, got " .. position) end
  local tabCheck = self:checkTabName(tabName)
  if tabCheck ~= "clear" then self.ae(funcName, tabCheck) end
  if position == 0 then
    table.insert(self.consoles, tabName)
    self:createComponentsForTab(tabName)
  else
    table.insert(self.consoles, position, tabName)
    self:reset()
  end
end

--- Switches the active, visible tab of the EMCO to tabName
--@param tabName the name of the tab to show
function EMCO:switchTab(tabName)
  local oldTab = self.currentTab
  if oldTab ~= tabName and oldTab ~= "" then
    self.mc[oldTab]:hide()
    self.tabs[oldTab]:setStyleSheet(self.inactiveTabCSS)
    self.tabs[oldTab]:setColor(self.inactiveTabBGColor)
    self.tabs[oldTab]:echo(oldTab, self.inactiveTabFGColor)
    if self.blink then
      if self.allTab and tabName == self.allTabName then
        self.tabsToBlink = {}
      elseif self.tabsToBlink[tabName] then
        self.tabsToBlink[tabName] = nil
      end
    end
  end
  self.tabs[tabName]:setStyleSheet(self.activeTabCSS)
  self.tabs[tabName]:setColor(self.activeTabBGColor)
  self.tabs[tabName]:echo(tabName, self.activeTabFGColor)
  if oldTab and self.mc[oldTab] then
    self.mc[oldTab]:hide()
  end
  self.mc[tabName]:show()
  self.currentTab = tabName
end

function EMCO:createComponentsForTab(tabName)
  local tab = Geyser.Label:new({
    name = string.format("%sTab%s", self.name, tabName)
  }, self.tabBox)
  if self.tabFont then
    tab:setFont(self.tabFont)
  end
  tab:echo(tabName, self.inactiveTabFGColor)
  tab:setAlignment(self.tabAlignment)
  tab:setFontSize(self.tabFontSize)
  tab:setItalics(self.tabItalics)
  tab:setBold(self.tabBold)
  tab:setUnderline(self.tabUnderline)
  -- use the inactive CSS. It's "" if unset, which is ugly, but
  tab:setStyleSheet(self.inactiveTabCSS)
  -- set the BGColor if set. if the CSS is set it overrides the setColor, but if it's "" then the setColor actually covers that.
  -- and we set a default for the inactiveBGColor
  tab:setColor(self.inactiveTabBGColor)
  tab:setClickCallback("EMCOHelper.switchTab", nil, string.format("%s+%s",self.name, tabName))
  self.tabs[tabName] = tab
  local window
  local windowConstraints = {
    x = self.leftMargin,
    y = self.topMargin,
    height = string.format("-%dpx", self.bottomMargin),
    width = string.format("-%dpx", self.rightMargin),
    name = string.format("%sWindow%s", self.name, tabName),
    commandLine = self.commandLine,
    path = self:processTemplate(self.path, tabName),
    fileName = self:processTemplate(self.fileName, tabName)
  }
  local parent = self.consoleContainer
  local mapTab = self.mapTab and tabName == self.mapTabName
  if mapTab then
    window = Geyser.Mapper:new(windowConstraints, parent)
  else
    if LC then
      window = LC:new(windowConstraints, parent)
    else
      window = Geyser.MiniConsole:new(windowConstraints, parent)
    end
    if self.font then
      window:setFont(self.font)
    end
    window:setFontSize(self.fontSize)
    window:setColor(self.consoleColor)
    if self.autoWrap then
      window:enableAutoWrap()
    else
      window:setWrap(self.wrapAt)
    end
    if self.scrollbars then
      window:enableScrollBar()
    else
      window:disableScrollBar()
    end
  end
  self.mc[tabName] = window
  if not mapTab then
    self:setCmdAction(tabName)
  end
  window:hide()
  self:processImage(tabName)
end

--- Sets the background image for a tab's console. use EMCO:resetBackgroundImage(tabName) to remove an image.
--- @tparam string tabName the tab to change the background image for.
--- @tparam string imagePath the path to the image file to use.
--- @tparam string mode the mode to use. Will default to "center" if not provided.
function EMCO:setBackgroundImage(tabName, imagePath, mode)
  mode = mode or "center"
  local tabNameType = type(tabName)
  local imagePathType = type(imagePath)
  local modeType = type(mode)
  local funcName = "EMCO:setBackgroundImage(tabName, imagePath, mode)"
  if tabNameType ~= "string" or not table.contains(self.consoles, tabName) then self.ae(funcName, "tabName must be a string and an existing tab") end
  if imagePathType ~= "string" or not io.exists(imagePath) then self.ae(funcName, "imagePath must be a string and point to an existing image file") end
  if modeType ~= "string" or not table.contains({"border", "center", "tile", "style"}, mode) then self.ae(funcName, "mode must be one of 'border', 'center', 'tile', or 'style'") end
  local image = {
    image = imagePath,
    mode = mode
  }
  self.backgroundImages[tabName] = image
  self:processImage(tabName)
end

--- Resets the background image on a tab's console, returning it to the background color
--- @tparam string tabName the tab to change the background image for.
function EMCO:resetBackgroundImage(tabName)
  local tabNameType = type(tabName)
  local funcName = "EMCO:resetBackgroundImage(tabName)"
  if tabNameType ~= "string" or not table.contains(self.consoles, tabName) then self.ae(funcName, "tabName must be a string and an existing tab") end
  self.backgroundImages[tabName] = nil
  self:processImage(tabName)
end

--- Does the work of actually setting/resetting the background image on a tab
--- @tparam string tabName the name of the tab to process the image for.
--- @local
function EMCO:processImage(tabName)
  if self.mapTab and tabName == self.mapTabName then return end
  local image = self.backgroundImages[tabName]
  local window = self.mc[tabName]
  if image then
    if image.image and io.exists(image.image) then
      window:setBackgroundImage(image.image, image.mode)
    end
  else
    window:resetBackgroundImage()
  end
end

--- Replays the last numLines lines from the log for tabName
--@param tabName the name of the tab to replay
--@param numLines the number of lines to replay
function EMCO:replay(tabName, numLines)
  if not LC then return end
  if self.mapTab and tabName == self.mapTabName then return end
  numLines = numLines or 10
  self.mc[tabName]:replay(numLines)
end

--- Replays the last numLines in all miniconsoles
--@param numLimes
function EMCO:replayAll(numLines)
  if not LC then return end
  numLines = numLines or 10
  for _, tabName in ipairs(self.consoles) do
    self:replay(tabName, numLines)
  end
end

--- Formats the string through EMCO's template. |E is replaced with the EMCO's name. |N is replaced with the tab's name.
--@param str the string to replace tokens in
function EMCO:processTemplate(str, tabName)
  str = str:gsub("|E", self.name)
  str = str:gsub("|N", tabName or "")
  return str
end

--- Sets the path for the EMCO for logging
--@param path the template for the path. @see EMCO:new()
function EMCO:setPath(path)
  if not LC then return end
  path = path or self.path
  self.path = path
  path = self:processTemplate(path)
  for name,window in pairs(self.mc) do
    if not (self.mapTab and self.mapTabName == name) then
      window:setPath(path)
    end
  end
end

--- Sets the fileName for the EMCO for logging
--@param fileName the template for the path. @see EMCO:new()
function EMCO:setFileName(fileName)
  if not LC then return end
  fileName = fileName or self.fileName
  self.fileName = fileName
  fileName = self:processTemplate(fileName)
  for name,window in pairs(self.mc) do
    if not (self.mapTab and self.mapTabName == name) then
      window:setFileName(fileName)
    end
  end
end

--- Sets the command action for a tab's command line. Can either be a template string to send where '|t' is replaced by the text sent, or a funnction which takes the text
--- @tparam string tabName the name of the tab to set the command action on
--- @param template the template for the commandline to use, or the function to run when enter is hit.
--- @usage myEMCO:setCmdAction("CT", "ct |t") -- will send everything in the CT tab's command line to CT by doing "ct Hi there!" if you type "Hi there!" in CT's command line
--- @usage myEMCO:setCmdAction("CT", function(txt) send("ct " .. txt) end) -- functionally the same as the above
function EMCO:setCmdAction(tabName, template)
  template = template or self.cmdActions[tabName]
  if template == "" then template = nil end
  self.cmdActions[tabName] = template
  local window = self.mc[tabName]
  if template then
    if type(template) == "string" then
      window:setCmdAction(function(txt)
        txt = template:gsub("|t", txt)
        send(txt)
      end)
    elseif type(template) == "function" then
      window:setCmdAction(template)
    else
      debugc(string.format("EMCO:setCmdAction(tabName, template): template must be a string or function if provided. Leaving CmdAction for tab %s be. Template type was: %s", tabName, type(template)))
    end
  else
    window:resetCmdAction()
  end
end

--- Resets the command action for tabName's miniconsole, which makes it work like the normal commandline
--- @tparam string tabName the name of the tab to reset the cmdAction for
function EMCO:resetCmdAction(tabName)
  self.cmdActions[tabName] = nil
  self.mc[tabName]:resetCmdAction()
end

--- Gets the contents of tabName's cmdLine
--- @param tabName the name of the tab to get the commandline of
function EMCO:getCmdLine(tabName)
  return self.mc[tabName]:getCmdLine()
end

--- Prints to tabName's command line
--- @param tabName the tab whose command line you want to print to
--- @param txt the text to print to the command line
function EMCO:printCmd(tabName, txt)
  return self.mc[tabName]:printCmd(txt)
end


--- Clears tabName's command line
--- @tparam string tabName the tab whose command line you want to clear
function EMCO:clearCmd(tabName)
  return self.mc[tabName]:clearCmd()
end

--- Appends text to tabName's command line
--- @tparam string tabName the tab whose command line you want to append to
--- @tparam string txt the text to append to the command line
function EMCO:appendCmd(tabName, txt)
  return self.mc[tabName]:appendCmd(txt)
end

--- resets the object, redrawing everything
function EMCO:reset()
  self:createContainers()
  for _,tabName in ipairs(self.consoles) do
    self:createComponentsForTab(tabName)
  end
  local default
  if self.currentTab == "" then
    default = self.allTabName or self.consoles[1]
  else
    default = self.currentTab
  end
  self:switchTab(default)
end

function EMCO:createContainers()
  self.tabBoxLabel = Geyser.Label:new({
    x=0,
    y=0,
    width = "100%",
    height = tostring(tonumber(self.tabHeight) + 2) .. "px",
    name = self.name .. "TabBoxLabel"
  }, self)
  self.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "100%",
    name = self.name .. "TabBox"
  }, self.tabBoxLabel)
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)

  local heightPlusGap = tonumber(self.tabHeight) + tonumber(self.gap)
  self.consoleContainer = Geyser.Label:new({
    x = 0,
    y = tostring(heightPlusGap) .. "px",
    width = "100%",
    height = "-0px",
    name = self.name .. "ConsoleContainer"
  }, self)
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

function EMCO:stripTimeChars(str)
  return string.gsub(string.trim(str), '[hHmMszZaApPdy:. ]', '')
end

--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function EMCO:fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end

--- clears a specific tab
--- @tparam string tabName the name of the tab to clear
function EMCO:clear(tabName)
  local funcName = "EMCO:clear(tabName)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  if self.mapTab and self.mapTabName == tabName then
    self.ae(funcName, "Cannot clear the map tab")
  end
  self.mc[tabName]:clear()
end

--- clears all the tabs
function EMCO:clearAll()
  for _,tabName in ipairs(self.consoles) do
    if not self.mapTab or (tabName ~= self.mapTabName) then
      self:clear(tabName)
    end
  end
end

--- sets the font for all tabs
--- @tparam string font the font to use.
function EMCO:setTabFont(font)
  self.tabFont = font
  for _,tab in pairs(self.tabs) do
    tab:setFont(font)
  end
end

--- sets the font for a single tab. If you use setTabFont this will be overridden
--- @tparam string tabName the tab to change the font of
--- @tparam string font the font to use for that tab
function EMCO:setSingleTabFont(tabName, font)
  local funcName = "EMCO:setSingleTabFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  self.tabs[tabName]:setFont(font)
end

--- sets the font for all the miniconsoles
--- @tparam string font the name of the font to use
function EMCO:setFont(font)
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setFont(font): attempt to call setFont with font '" .. font .. "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.font = font
  for _,tabName in pairs(self.consoles) do
    if not self.mapTab or tabName ~= self.mapTabName then
      self.mc[tabName]:setFont(font)
    end
  end
end

--- sets the font for a specific miniconsole. If setFont is called this will be overridden
--- @tparam string tabName the name of window to set the font for
--- @tparam string font the name of the font to use
function EMCO:setSingleWindowFont(tabName, font)
  local funcName = "EMCO:setSingleWindowFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setSingleWindowFont(tabName, font): attempt to call setFont with font '" .. font .. "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.mc[tabName]:setFont(font)
end

--- sets the font size for all tabs
--- @tparam number fontSize the font size to use for the tabs
function EMCO:setTabFontSize(fontSize)
  self.tabFontSize = fontSize
  for _, tab in pairs(self.tabs) do
    tab:setFontSize(fontSize)
  end
end

--- Sets the alignment for all the tabs
-- @param alignment Valid alignments are 'c', 'center', 'l', 'left', 'r', 'right', or '' to not include the alignment as part of the echo
function EMCO:setTabAlignment(alignment)
  self.tabAlignment = alignment
  for _, tab in pairs(self.tabs) do
    tab:setAlignment(self.tabAlignment)
  end
end

--- enables underline on all tabs
function EMCO:enableTabUnderline()
  self.tabUnderline = true
  for _, tab in pairs(self.tabs) do
    tab:setUnderline(self.tabUnderline)
  end
end

--- disables underline on all tabs
function EMCO:disableTabUnderline()
  self.tabUnderline = false
  for _, tab in pairs(self.tabs) do
    tab:setUnderline(self.tabUnderline)
  end
end

--- enables italics on all tabs
function EMCO:enableTabItalics()
  self.tabItalics = true
  for _, tab in pairs(self.tabs) do
    tab:setItalics(self.tabItalics)
  end
end

--- enables italics on all tabs
function EMCO:disableTabItalics()
  self.tabItalics = false
  for _, tab in pairs(self.tabs) do
    tab:setItalics(self.tabItalics)
  end
end

--- enables bold on all tabs
function EMCO:enableTabBold()
  self.tabBold = true
  for _, tab in pairs(self.tabs) do
    tab:setBold(self.tabBold)
  end
end

--- disables bold on all tabs
function EMCO:disableTabBold()
  self.tabBold = false
  for _, tab in pairs(self.tabs) do
    tab:setBold(self.tabBold)
  end
end

--- enables custom colors for the timestamp, if displayed
function EMCO:enableCustomTimestampColor()
  self.customTimestampColor = true
end

--- disables custom colors for the timestamp, if displayed
function EMCO:disableCustomTimestampColor()
  self.customTimestampColor = false
end

--- enables the display of timestamps
function EMCO:enableTimestamp()
  self.timestamp = true
end

--- disables the display of timestamps
function EMCO:disableTimestamp()
  self.timestamp = false
end

--- Sets the formatting for the timestamp, if enabled
-- @tparam string format Format string which describes the display of the timestamp. See: https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime
function EMCO:setTimestampFormat(format)
  local funcName = "EMCO:setTimestampFormat(format)"
  local strippedFormat = self:stripTimeChars(format)
  if strippedFormat ~= "" then
    self.ae(funcName, "format contains invalid time format characters. Please see https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for formatting information")
  else
    self.timestampFormat = format
  end
end

--- Sets the background color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampBGColor(color)
  self.timestampBGColor = color
end
--- Sets the foreground color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampFGColor(color)
  self.timestampFGColor = color
end

--- Sets the 'all' tab name.
-- &lt;br&gt;This is the name of the tab itself
-- @tparam string allTabName name of the tab to use as the all tab. Must be a tab which exists in the object.
function EMCO:setAllTabName(allTabName)
  local funcName = "EMCO:setAllTabName(allTabName)"
  local allTabNameType = type(allTabName)
  if allTabNameType ~= "string" then self.ae(funcName, "allTabName expected as string, got" .. allTabNameType) end
  if not table.contains(self.consoles, allTabName) then self.ae(funcName, "allTabName must be the name of one of the console tabs. Valid options are: " .. table.concat(self.containers, ",")) end
  self.allTabName = allTabName
end

--- Enables use of the 'all' tab
function EMCO:enableAllTab()
  self.allTab = true
end

--- Disables use of the 'all' tab
function EMCO:disableAllTab()
  self.allTab = false
end

--- Enables tying the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;mapTabName must be set, or this will error. Forces a redraw of the entire object
function EMCO:enableMapTab()
  local funcName = "EMCO:enableMapTab()"
  if not self.mapTabName then
    error(funcName .. ": cannot enable the map tab, mapTabName not set. try running :setMapTabName(mapTabName) first with the name of the tab you want to bind the map to")
  end
  self.mapTab = true
  self:reset()
end

--- disables binding the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;CAUTION: this may have unexpected behaviour, as you can only open one Mapper console per profile
-- so you can't really unbind it. Binding of the Mudlet Mapper is best decided at instantiation.
function EMCO:disableMapTab()
  self.mapTab = false
end

--- sets the name of the tab to bind the Mudlet Map.
-- &lt;br&gt;Forces a redraw of the object
-- &lt;br&gt;CAUTION: Mudlet only allows one Map object to be open at one time, so if you are going to attach the map to an object
-- you should probably do it at instantiation.
-- @tparam string mapTabName name of the tab to connect the Mudlet Map to.
function EMCO:setMapTabName(mapTabName)
  local funcName = "EMCO:setMapTabName(mapTabName)"
  local mapTabNameType = type(mapTabName)
  if mapTabNameType ~= "string" then
    self.ae(funcName, "mapTabName as string expected, got" .. mapTabNameType)
  end
  if not table.contains(self.consoles, mapTabName) and mapTabName ~= "" then
    self.ae(funcName, "mapTabName must be one of the existing console tabs. Current tabs are: " .. table.concat(self.consoles, ","))
  end
  self.mapTabName = mapTabName
end

--- Enables tab blinking even if you're on the 'all' tab
function EMCO:enableBlinkFromAll()
  self.enableBlinkFromAll = true
end

--- Disables tab blinking when you're on the 'all' tab
function EMCO:disableBlinkFromAll()
  self.enableBlinkFromAll = false
end

--- Enables gagging of the line passed in to :append(tabName)
function EMCO:enableGag()
  self.gag = true
end

--- Disables gagging of the line passed in to :append(tabName)
function EMCO:disableGag()
  self.gag = false
end

--- Enables tab blinking when new information comes in to an inactive tab
function EMCO:enableBlink()
  self.blink = true
end

--- Disables tab blinking when new information comes in to an inactive tab
function EMCO:disableBlink()
  self.blink = false
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:enablePreserveBackground()
  self.preserveBackground = true
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:disablePreserveBackground()
  self.preserveBackground = false
end

--- Sets how long in seconds to wait between blinks
-- @tparam number blinkTime time in seconds to wait between blinks
function EMCO:setBlinkTime(blinkTime)
  local funcName = "EMCO:setBlinkTime(blinkTime)"
  local blinkTimeNumber = tonumber(blinkTime)
  if not blinkTimeNumber then
    self.ae(funcName, "blinkTime as number expected, got ".. type(blinkTime))
  else
    self.blinkTime = blinkTimeNumber
    if self.blinkTimerID then
      killTimer(self.blinkTimerID)
    end
    self.blinkTimerID = tempTimer(blinkTimeNumber, function() self:blink() end, true)
  end
end

function EMCO:doBlink()
  if self.hidden or self.auto_hidden or not self.blink then
    return
  end
  for tab,_ in pairs(self.tabsToBlink) do
    self.tabs[tab]:flash()
  end
end

--- Sets the font size of the attached consoles
-- @tparam number fontSize font size for attached consoles
function EMCO:setFontSize(fontSize)
  local funcName = "EMCO:setFontSize(fontSize)"
  local fontSizeNumber = tonumber(fontSize)
  local fontSizeType = type(fontSize)
  if not fontSizeNumber then
    self.ae(funcName, "fontSize as number expected, got " .. fontSizeType)
  else
    self.fontSize = fontSizeNumber
    for _,tabName in ipairs(self.consoles) do
      if self.mapTab and tabName == self.mapTabName then
        -- skip this one
      else
        local window = self.mc[tabName]
        window:setFontSize(fontSizeNumber)
      end
    end
  end
end

function EMCO:adjustTabNames()
  for _,console in ipairs(self.consoles) do
    if console == self.currentTab then
      self.tabs[console]:echo(console, self.activTabFGColor, 'c')
    else
      self.tabs[console]:echo(console, self.inactiveTabFGColor, 'c')
    end
  end
end

function EMCO:adjustTabBackgrounds()
  for _, console in ipairs(self.consoles) do
    local tab = self.tabs[console]
    if console == self.currentTab then
      tab:setStyleSheet(self.activeTabCSS)
      tab:setColor(self.activeBGColor)
    else
      tab:setStyleSheet(self.inactiveTabCSS)
      tab:setColor(self.inactiveBGColor)
    end
  end
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabFGColor(color)
  self.activeTabFGColor = color
  self:adjustTabNames()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabFGColor(color)
  self.inactiveTabFGColor = color
  self:adjustTabNames()
end

--- Sets the BG color for the active tab.
-- &lt;br&gt;NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabBGColor(color)
  self.activeTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the inactive tab.
-- &lt;br&gt;NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabBGColor(color)
  self.inactiveTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the consoles attached to this object
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleColor(color)
  self.consoleColor = color
  self:adjustConsoleColors()
end

function EMCO:adjustConsoleColors()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:setColor(self.consoleColor)
    end
  end
end

--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function EMCO:setTabBoxCSS(css)
  local funcName = "EMCHO:setTabBoxCSS(css)"
  local cssType = type(css)
  if cssType ~= "string" then
    self.ae(funcName, "css as string expected, got " .. cssType)
  else
    self.tabBoxCSS = css
    self:adjustTabBoxBackground()
  end
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTabBoxColor(color)
  self.tabBoxColor = color
  self:adjustTabBoxBackground()
end

function EMCO:adjustTabBoxBackground()
    self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
    self.tabBoxLabel:setColor(self.tabBoxColor)
end

--- Sets the color for the container which holds the consoles attached to this object.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleContainerColor(color)
  self.consoleContainerColor = color
  self:adjustConsoleContainerBackground()
end

--- Sets the CSS to use for the container which holds the consoles attached to this object
-- @tparam string css CSS to use for the container
function EMCO:setConsoleContainerCSS(css)
  self.consoleContainerCSS = css
  self:adjustConsoleContainerBackground()
end

function EMCO:adjustConsoleContainerBackground()
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function EMCO:setGap(gap)
  local gapNumber = tonumber(gap)
  local funcName = "EMCO:setGap(gap)"
  local gapType = type(gap)
  if not gapNumber then
    self.ae(funcName, "gap expected as number, got " .. gapType)
  else
    self.gap = gapNumber
    self:reset()
  end
end

--- Sets the height of the tabs in pixels
-- @tparam number tabHeight the height of the tabs for the object, in pixels
function EMCO:setTabHeight(tabHeight)
  local tabHeightNumber = tonumber(tabHeight)
  local funcName = "EMCO:setTabHeight(tabHeight)"
  local tabHeightType = type(tabHeight)
  if not tabHeightNumber then
    self.ae(funcName, "tabHeight as number expected, got ".. tabHeightType)
  else
    self.tabHeight = tabHeightNumber
    self:reset()
  end
end

--- Enables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To enable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:enableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:enableAutoWrap()
  self.autoWrap = true
  for _,console in ipairs(self.consoles) do
    if self.mapTab and console == self.mapTabName then
      -- skip the map
    else
      self.mc[console]:enableAutoWrap()
    end
  end
end

--- Disables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To disable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:disableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:disableAutoWrap()
  self.autoWrap = false
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:disableAutoWrap()
    end
  end
end

--- Sets the number of characters to wordwrap the attached consoles at.
-- &lt;br&gt;it is generally recommended to make use of autoWrap unless you need
-- a specific width for some reason
function EMCO:setWrap(wrapAt)
  local funcName = "EMCO:setWrap(wrapAt)"
  local wrapAtNumber = tonumber(wrapAt)
  local wrapAtType = type(wrapAt)
  if not wrapAtNumber then
    self.ae(funcName, "wrapAt as number expect, got " .. wrapAtType)
  else
    self.wrapAt = wrapAtNumber
    for _,console in ipairs(self.consoles) do
      if self.mapTab and self.mapTabName == console then
        -- skip the Map
      else
        self.mc[console]:setWrap(wrapAtNumber)
      end
    end
  end
end

--- Appends the current line from the MUD to a tab.
-- &lt;br&gt;depending on this object's configuration, may gag the line
-- &lt;br&gt;depending on this object's configuration, may gag the next prompt
-- @tparam string tabName The name of the tab to append the line to
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:append(tabName, excludeAll)
  local funcName = "EMCO:append(tabName, excludeAll)"
  local tabNameType = type(tabName)
  local validTab = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    self.ae(funcName, "tabName as string expected, got ".. tabNameType)
  elseif not validTab then
    self.ae(funcName, "tabName must be a tab which is contained in this object. Valid tabnames are: " .. table.concat(self.consoles, ","))
  end
  self:xEcho(tabName, nil, 'a', excludeAll)
end

function EMCO:checkEchoArgs(funcName, tabName, message, excludeAll)
  local tabNameType = type(tabName)
  local messageType = type(message)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local ae = self.ae
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif messageType ~= "string" then
    ae(funcName, "message as string expected, got " .. messageType)
  elseif not validTabName then
    ae(funcName, "tabName must be the name of a tab attached to this object. Valid names are: " .. table.concat(self.consoles, ","))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

function EMCO:xEcho(tabName, message, xtype, excludeAll)
  if self.mapTab and self.mapTabName == tabName then
    error("You cannot send text to the Map tab")
  end
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.mc[self.allTabName] or false
  local ofr,ofg,ofb,obr,obg,obb
  if xtype == "a" then
    selectCurrentLine()
    ofr,ofg,ofb = getFgColor()
    obr,obg,obb = getBgColor()
    if self.preserveBackground then
      local r,g,b = Geyser.Color.parse(self.consoleColor)
      setBgColor(r,g,b)
    end
    copy()
    if self.preserveBackground then
      setBgColor(obr, obg, obb)
    end
    deselect()
    resetFormat()
  else
    ofr,ofg,ofb = Geyser.Color.parse("white")
    obr,obg,obb = Geyser.Color.parse(self.consoleColor)
  end
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    if not table.contains(self.timestampExceptions, tabName) then
      console:decho(fullTimestamp)
    end
    if allTab and tabName ~= self.allTabName and not table.contains(self.timestampExceptions, self.allTabName) then
      allTab:decho(fullTimestamp)
    end
  end
  if self.blink and tabName ~= self.currentTab then
    if not (self.allTabName == self.currentTab and not self.blinkFromAll) then
      self.tabsToBlink[tabName] = true
    end
  end
  if xtype == "a" then
    console:appendBuffer()
    if allTab then
      allTab:appendBuffer()
    end
    if self.gag then
      deleteLine()
      if self.gagPrompt then
        tempPromptTrigger(function() deleteLine() end, 1)
      end
    end
  else
    console[xtype](console, message)
    if allTab then allTab[xtype](allTab, message) end
  end
  if self.blankLine then
    console:echo("\n")
    if allTab then allTab:echo("\n") end
  end
end

--- cecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to cecho to
-- @tparam string message the message to cecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cecho(tabName, message, excludeAll)
  local funcName = "EMCO:cecho(tabName, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'cecho', excludeAll)
end

--- decho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to decho to
-- @tparam string message the message to decho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:decho(tabName, message, excludeAll)
  local funcName = "EMCO:decho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'decho', excludeAll)
end

--- hecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to hecho to
-- @tparam string message the message to hecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hecho(tabName, message, excludeAll)
  local funcName = "EMCO:hecho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'hecho', excludeAll)
end

--- echo to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to echo to
-- @tparam string message the message to echo to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echo(tabName, message, excludeAll)
  local funcName = "EMCO:echo(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'echo', excludeAll)
end

-- internal function used for type checking echoLink/Popup arguments
function EMCO:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, popup)
  local expectedType = popup and "table" or "string"
  local textType = type(text)
  local commandsType = type(commands)
  local hintsType = type(hints)
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local sf = string.format
  local ae = self.ae
  if textType ~= "string" then
    ae(funcName, "text as string expected, got " .. textType)
  elseif commandsType ~= expectedType then
    ae(funcName, sf("commands as %s expected, got %s", expectedType, commandsType))
  elseif hintsType ~= expectedType then
    ae(funcName, sf("hints as %s expected, got %s", expectedType, hintsType))
  elseif tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, sf("tabName must be a tab which exists, tab %s could not be found", tabName))
  elseif self.mapTab and tabName == self.mapTabName then
    ae(funcName, sf("You cannot echo to the map tab, and %s is configured as the mapTabName", tabName))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "Optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

-- internal function used for handling echoLink/popup
function EMCO:xLink(tabName, linkType, text, commands, hints, useCurrentFormat, excludeAll)
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.mc[self.allTabName] or false
  local arguments = {text, commands, hints, useCurrentFormat}
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      local ofr,ofg,ofb = Geyser.Color.parse("white")
      local obr,obg,obb = Geyser.Color.parse(self.consoleColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    if not table.contains(self.timestampExceptions, tabName) then
      console:decho(fullTimestamp)
    end
    if allTab and tabName ~= self.allTabName and not table.contains(self.timestampExceptions, self.allTabName) then
      allTab:decho(fullTimestamp)
    end
  end
  console[linkType](console, unpack(arguments))
  if allTab then allTab[linkType](allTab, unpack(arguments)) end
end

--- cechoLink to a tab
-- @tparam string tabName the name of the tab to cechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:cechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "cechoLink", text, command, hint, true, excludeAll)
end

--- dechoLink to a tab
-- @tparam string tabName the name of the tab to dechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:dechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "dechoLink", text, command, hint, true, excludeAll)
end

--- hechoLink to a tab
-- @tparam string tabName the name of the tab to hechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:hechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "hechoLink", text, command, hint, true, excludeAll)
end

--- echoLink to a tab
-- @tparam string tabName the name of the tab to echoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoLink(tabName, text, command, hint, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoLink(tabName, text, command, hint, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "echoLink", text, command, hint, useCurrentFormat, excludeAll)
end

--- cechoPopup to a tab
-- @tparam string tabName the name of the tab to cechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:cechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "cechoPopup", text, commands, hints, true, excludeAll)
end

--- dechoPopup to a tab
-- @tparam string tabName the name of the tab to dechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:dechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "dechoPopup", text, commands, hints, true, excludeAll)
end

--- hechoPopup to a tab
-- @tparam string tabName the name of the tab to hechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:hechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "hechoPopup", text, commands, hints, true, excludeAll)
end

--- echoPopup to a tab
-- @tparam string tabName the name of the tab to echoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "echoPopup", text, commands, hints, useCurrentFormat, excludeAll)
end

--- adds a tab to the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to add to the exclusion list
function EMCO:addAllTabExclusion(tabName)
  local funcName = "EMCO:addAllTabExclusion(tabName)"
  self:validTabNameOrError(tabName, funcName)
  if not table.contains(self.allTabExclusions, tabName) then table.insert(self.allTabExclusions, tabName) end
end

--- removess a tab from the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to remove from the exclusion list
function EMCO:removeAllTabExclusion(tabName)
  local funcName = "EMCO:removeAllTabExclusion(tabName)"
  self:validTabNameOrError(tabName, funcName)
  local index = table.index_of(self.allTabExclusions, tabName)
  if index then table.remove(self.allTabExclusions, index) end
end

function EMCO:validTabNameOrError(tabName, funcName)
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
end

function EMCO:addTimestampException(tabName)
  local funcName = "EMCO:addTimestampException(tabName)"
  self:validTabNameOrError(tabName, funcName)
  if not table.contains(self.timestampExceptions, tabName) then table.insert(self.timestampExceptions, tabName) end
end

function EMCO:removeTimestampException(tabName)
  local funcName = "EMCO:removeTimestampTabException(tabName)"
  self:validTabNameOrError(tabName, funcName)
  local index = table.index_of(self.timestampExceptions, tabName)
  if index then table.remove(self.timestampExceptions, index) end
end

--- Enable placing a blank line between all messages.
function EMCO:enableBlankLine()
  self.blankLine = true
end

--- Enable placing a blank line between all messages.
function EMCO:disableBlankLine()
  self.blankLine = false
end

--- Enable scrollbars for the miniconsoles
function EMCO:enableScrollbars()
  self.scrollbars = true
  self:adjustScrollbars()
end

--- Disable scrollbars for the miniconsoles
function EMCO:disableScrollbars()
  self.scrollbars = false
  self:adjustScrollbars()
end

function EMCO:adjustScrollbars()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip the Map tab
    else
      if self.scrollbars then
        self.mc[console]:enableScrollBar()
      else
        self.mc[console]:disableScrollBar()
      end
    end
  end
end

EMCOHelper = EMCOHelper or {}
EMCOHelper.items = EMCOHelper.items or {}
function EMCOHelper:switchTab(designator)
  local args = string.split(designator, "+")
  local emcoName = args[1]
  local tabName = args[2]
  for _,emco in ipairs(EMCOHelper.items) do
    if emco.name == emcoName then
      emco:switchTab(tabName)
      return
    end
  end
end

--- Save an EMCO's configuration for reloading later. Filename is based on the EMCO's name property.
function EMCO:save()
  local configtable = {
    timeStamp = self.timeStamp,
    blankLine = self.blankLine,
    scrollbars = self.scrollbars,
    customTimestampColor = self.customTimestampColor,
    mapTab = self.mapTab,
    mapTabName = self.mapTabName,
    blinkFromAll = self.blinkFromAll,
    preserveBackground = self.preserveBackground,
    gag = self.gag,
    timestampFormat = self.timestampFormat,
    timestampBGColor = self.timestampBGColor,
    allTab = self.allTab,
    allTabName = self.allTabName,
    blink = self.blink,
    blinkTime = self.blinkTime,
    fontSize = self.fontSize,
    font = self.font,
    tabFont = self.tabFont,
    activeTabCSS = self.activeTabCSS,
    inactiveTabCSS = self.inactiveTabCSS,
    activeTabFGColor = self.activeTabFGColor,
    activeTabBGColor = self.activeTabBGColor,
    inactiveTabFGColor = self.inactiveTabFGColor,
    inactiveTabBGColor = self.inactiveTabBGColor,
    consoleColor = self.consoleColor,
    tabBoxCSS = self.tabBoxCSS,
    tabBoxColor = self.tabBoxColor,
    consoleContainerCSS = self.consoleContainerCSS,
    consoleContainerColor = self.consoleContainerColor,
    gap = self.gap,
    consoles = self.consoles,
    allTabExclusions = self.allTabExclusions,
    timestampExceptions = self.timestampExceptions,
    tabHeight = self.tabHeight,
    autoWrap = self.autoWrap,
    wrapAt = self.wrapAt,
    leftMargin = self.leftMargin,
    rightMargin = self.rightMargin,
    bottomMargin = self.bottomMargin,
    topMargin = self.topMargin,
    x = self.x,
    y = self.y,
    height = self.height,
    width = self.width,
    tabFontSize = self.tabFontSize,
    tabBold = self.tabBold,
    tabItalics = self.tabItalics,
    tabUnderline = self.tabUnderline,
    tabAlignment = self.tabAlignment,
  }
  local dirname = getMudletHomeDir().."/EMCO/"
  local filename = dirname .. self.name .. ".lua"
  if not(io.exists(dirname)) then lfs.mkdir(dirname) end
  table.save(filename, configtable)
end

--- Load and apply a saved config for this EMCO
function EMCO:load()
  local dirname = getMudletHomeDir().."/EMCO/"
  local filename = dirname .. self.name .. ".lua"
  local configTable = {}
  if io.exists(filename) then
    table.load(filename, configTable)
  else
    debugc(string.format("Attempted to load config for EMCO named %s but the file could not be found. Filename: %s", self.name, filename))
  end
  self.timeStamp = configTable.timeStamp
  self.blankLine = configTable.blankLine
  self.scrollbars = configTable.scrollbars
  self.customTimestampColor = configTable.customTimestampColor
  self.mapTab = configTable.mapTab
  self.mapTabName = configTable.mapTabName
  self.blinkFromAll = configTable.blinkFromAll
  self.preserveBackground = configTable.preserveBackground
  self.gag = configTable.gag
  self.timestampFormat = configTable.timestampFormat
  self.timestampBGColor = configTable.timestampBGColor
  self.allTab = configTable.allTab
  self.allTabName = configTable.allTabName
  self.blink = configTable.blink
  self.blinkTime = configTable.blinkTime
  self.activeTabCSS = configTable.activeTabCSS
  self.inactiveTabCSS = configTable.inactiveTabCSS
  self.activeTabFGColor = configTable.activeTabFGColor
  self.activeTabBGColor = configTable.activeTabBGColor
  self.inactiveTabFGColor = configTable.inactiveTabFGColor
  self.inactiveTabBGColor = configTable.inactiveTabBGColor
  self.consoleColor = configTable.consoleColor
  self.tabBoxCSS = configTable.tabBoxCSS
  self.tabBoxColor = configTable.tabBoxColor
  self.consoleContainerCSS = configTable.consoleContainerCSS
  self.consoleContainerColor = configTable.consoleContainerColor
  self.gap = configTable.gap
  self.consoles = configTable.consoles
  self.allTabExclusions = configTable.allTabExclusions
  self.timestampExceptions = configTable.timestampExceptions
  self.tabHeight = configTable.tabHeight
  self.wrapAt = configTable.wrapAt
  self.leftMargin = configTable.leftMargin
  self.rightMargin = configTable.rightMargin
  self.bottomMargin = configTable.bottomMargin
  self.topMargin = configTable.topMargin
  self.tabFontSize = configTable.tabFontSize
  self.tabBold = configTable.tabBold
  self.tabItalics = configTable.tabItalics
  self.tabUnderline = configTable.tabUnderline
  self.tabAlignment = configTable.tabAlignment
  self:move(configTable.x, configTable.y)
  self:resize(configTable.width, configTable.height)
  self:reset()
  if configTable.fontSize then self:setFontSize(configTable.fontSize) end
  if configTable.font then self:setFont(configTable.font) end
  if configTable.tabFont then self:setTabFont(configTable.tabFont) end
  if configTable.autoWrap then self:enableAutoWrap() else self:disableAutoWrap() end
end

EMCO.parent = Geyser.Container

return EMCO</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>EMCOtest</name>
						<packageName></packageName>
						<script>MDKExample = MDKExample or {}

function MDKExample.exampleEMCO()
  --local EMCO = require("@PKGNAME@.EMCO")
  MDKExample.UW = Geyser.UserWindow:new({name = "TestWindow"})
  local stylesheet = [[background-color: rgb(0,180,0,255); border-width: 1px; border-style: solid; border-color: gold; border-radius: 10px;]]
  local istylesheet = [[background-color: rgb(60,60,60,255); border-width: 1px; border-style: solid; border-color: gold; border-radius: 10px;]]
  MDKExample.EMCO = EMCO:new({
    name = "MDKExampleEMCO",
    x = "0",
    y = "0",
    width = "100%",
    height = "100%",
    allTab = true,
    allTabName = "All",
    gap = 2,
    consoleColor = "black",
    consoles = {
      "Guild",
      "All",
      "Local",
      "Map",
    },
    mapTabName = "Map",
    mapTab = true,
    activeTabCSS = stylesheet,
    inactiveTabCSS = istylesheet,
    preserveBackground = true
  }, MDKExample.UW)
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>extract url</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- all characters allowed to be inside URL according to RFC 3986 but without
-- comma, semicolon, apostrophe, equal, brackets and parentheses
-- (as they are used frequently as URL separators)

--the below code was sourced from https://stackoverflow.com/questions/23590304/finding-a-url-in-a-string-lua-pattern

local text_with_URLs = [[
   &lt;a href="http://www.lua.org:80/manual/5.2/contents.html"&gt;L.ua 5.2&lt;/a&gt;
   [url=127.0.0.1:8080]forum link[/url]
   intranet links: http://test, http://retracker.local/announce
   [markdown link](https://74.125.143.101/search?q=Who+are+the+Lua+People%3F)
   long subdomain chain: very.long.name.of.my.site.co.uk
   auth link: ftp://user:pwd@site.com/path - not recognized yet :(
]]

local domains = [[.ac.ad.ae.aero.af.ag.ai.al.am.an.ao.aq.ar.arpa.as.asia.at.au
   .aw.ax.az.ba.bb.bd.be.bf.bg.bh.bi.biz.bj.bm.bn.bo.br.bs.bt.bv.bw.by.bz.ca
   .cat.cc.cd.cf.cg.ch.ci.ck.cl.cm.cn.co.com.coop.cr.cs.cu.cv.cx.cy.cz.dd.de
   .dj.dk.dm.do.dz.ec.edu.ee.eg.eh.er.es.et.eu.fi.firm.fj.fk.fm.fo.fr.fx.ga
   .gb.gd.ge.gf.gh.gi.gl.gm.gn.gov.gp.gq.gr.gs.gt.gu.gw.gy.hk.hm.hn.hr.ht.hu
   .id.ie.il.im.in.info.int.io.iq.ir.is.it.je.jm.jo.jobs.jp.ke.kg.kh.ki.km.kn
   .kp.kr.kw.ky.kz.la.lb.lc.li.lk.lr.ls.lt.lu.lv.ly.ma.mc.md.me.mg.mh.mil.mk
   .ml.mm.mn.mo.mobi.mp.mq.mr.ms.mt.mu.museum.mv.mw.mx.my.mz.na.name.nato.nc
   .ne.net.nf.ng.ni.nl.no.nom.np.nr.nt.nu.nz.om.org.pa.pe.pf.pg.ph.pk.pl.pm
   .pn.post.pr.pro.ps.pt.pw.py.qa.re.ro.ru.rw.sa.sb.sc.sd.se.sg.sh.si.sj.sk
   .sl.sm.sn.so.sr.ss.st.store.su.sv.sy.sz.tc.td.tel.tf.tg.th.tj.tk.tl.tm.tn
   .to.tp.tr.travel.tt.tv.tw.tz.ua.ug.uk.um.us.uy.va.vc.ve.vg.vi.vn.vu.web.wf
   .ws.xxx.ye.yt.yu.za.zm.zr.zw]]
local tlds = {}
for tld in domains:gmatch'%w+' do
   tlds[tld] = true
end
local function max4(a,b,c,d) return math.max(a+0, b+0, c+0, d+0) end
local protocols = {[''] = 0, ['http://'] = 0, ['https://'] = 0, ['ftp://'] = 0}
local finished = {}

function getUrl(xstring)
  
  -- remove any colour codes in string
  xstring = string.gsub(xstring, "|c%d%d%d%d%d%d", "")
  
  for pos_start, url, prot, subd, tld, colon, port, slash, path in
    xstring:gmatch'()(([%w_.~!*:@&amp;+$/?%%#-]-)(%w[-.%w]*%.)(%w+)(:?)(%d*)(/?)([%w_.~!*:@&amp;+$/?%%#=-]*))'
  do
     if protocols[prot:lower()] == (1 - #slash) * #path and not subd:find'%W%W'
      and (colon == '' or port ~= '' and port + 0 &lt; 65536)
      and (tlds[tld:lower()] or tld:find'^%d+$' and subd:find'^%d+%.%d+%.%d+%.$'
      and max4(tld, subd:match'^(%d+)%.(%d+)%.(%d+)%.$') &lt; 256)
     then
      finished[pos_start] = true
      return(url)
     end
  end

  for pos_start, url, prot, dom, colon, port, slash, path in
     xstring:gmatch'()((%f[%w]%a+://)(%w[-.%w]*)(:?)(%d*)(/?)([%w_.~!*:@&amp;+$/?%%#=-]*))'
  do
   if not finished[pos_start] and not (dom..'.'):find'%W%W'
      and protocols[prot:lower()] == (1 - #slash) * #path
      and (colon == '' or port ~= '' and port + 0 &lt; 65536)
   then
      return(url)
   end
  end
  
  return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>NewGear</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

-- Thanks @Raiwen!

NewGear = NewGear or {}

NewGear.items = {}
  
NewGear.spreadsheet = {
  Bahamut = {
    {"a silver ring with mirrored finish", "finger", "75 hp, -4 svsp, Priest only", "Powers: Csan, all attackers stop attacking you, 3 min cd"},
    {"a heavy flail of meteoric iron", "wield", "3d6, 3% cr, 2x cb, sonic/sonic burst/keen/thundering/force 100%, 5 hit 5 sf heal", "Powers: Proc curse on every hit"},
    {"platinum scalemail of the faithful", "body", "30 hp, sf 5 healing, 5% pierce, good war/priest only", "Powers: cshroud, 3 dam -5 sv spell, 3 min buff, 12 min cd"},
    {"a crown of the death dragon", "head", "30 hp, 6 dam, 5% elements, !good, warrior only", "Powers: Aotdd, increases threat"},
    {"a woven mithril mantle of the Battlerager", "about", "ac 21, 4 dam, -5 svbr, 5% blud/fire/cold, !evil, warrior/priest only", "Powers: Battlerage command, berserk, +2/+2"},
    {"the blood-soaked bastion of defense", "shield", "ac 25, 25 hp, -5 svsp, Warrior only", "Powers: Bog, 5 hp vamp per melee hit, 10% damage reduction"},
    {"the hollowed claw of a balor demon", "finger", "ac4 4 dam, !good thief only", "Powers: Wings of the Balor, fly"},
    {"an adamantium cloak of elvenkind", "about", "ac 15 2% unarmed 4 dam 50 mv, !evil, thief only", "Powers: Camo"},
    {"a rune etched dragonscale of incarnadine hue", "eyes", "ac8 5% fire 3dam 4 maxagi, !cleric/mage , Di/sense", ""},
    {"a belt of black dragon scales", "waist", "ac 10 5% cold 25 hp 5 sf necro mage only", ""},
    {"the crystallized tear of an astral deva", "ear", "20 hp, -5 svsp, mage only", "Powers: Remove silence/major para/stuff"},
    {"a staff of radiance", "weapon", "4d4 3 cr 2 cb, keen, brilliant, 30 hp 5 hitroll, proc radiant pattern mage only", "Powers: 75 hp 10 hitroll for 3 min, 12 min cd"},
    {"a icy white dragon mask", "face", "ac 10 10% cold 20 hp 8 sf spirit, priest only", ""},
    {"a stygian black dragon mask", "face", "ac 10 5% slash 10% acid 12 hp 6 maxagi, warrior only", ""},
    {"a vibrant green dragon mask", "face", "ac 10 10% poison 20 hp 8 sf nature, priest only", ""},
    {"a brilliant blue dragon mask", "face", "ac 10 10% elect 20 hp 8 sf heal, priest only", ""},
    {"a fiery red dragon mask", "face", "ac 10 10% fire 4 dam 8 maxstr, rogue only", ""},
    {"a ring of wizardry", "finger", "80 hp, 10 AC, proc mem, mage only", ""},
    {"a star-metal chainmail hood of boundless thought", "head", "AC 12 50 hp/mana", "Powers: proc mana in combat"},
    {"a strand of nine pearls", "neck", "ac 10 20 hp 15 maxwis priest only", "Powers: proc mem"},
    {"a celestial longbow of carved yew wood", "ranged", "4d6 3% cr 3x cb 100% holy/holy burst, 6/6", "", {"magic", "bless", "float", "two_hand"}},
    {"a crimson-edged obsidian blade", "weapon", "6d6 6% cr 5cb keen/vampiric/unholy/axiomatic 6/6", "Powers: proc blind", {"magic", "two_hand"}},
    {"a golden-edged moonstone blade", "weapon", "6d6 6% cr 5cb keen/holy/anarchic/brilliant", "Powers: proc heal", {"magic", "two_hand"}},
    {"snow-white boots of speed", "feet", "ac12 20hp -6 ss perm haste, priest/bchanter only", ""},
    {"the paws of the cheetah", "feet", "ac 8 3/3 warrior/thief only", "Powers: haste for 54 seconds, 60s cd, eats up power cd"},
    {"a dragontooth of Lareth", "weapon", "4d4 9% cr 2 cb flaming/flaming burst/keen 100%, 5/5", "Powers: fear, -84 str, I forget the last one"},
    {"a dragonhide component bag", "component bag", "ac 5 5 agi", ""},
    {"a dragonhide ammo belt", "bandolier", "ac 5 1 dam", ""},
    {"a fine silk haversack stitched with platinum thread", "component bag", "ac 5 25 mv", ""},
    {"a crown of the north wind", "head", "ac 10 5% prot elements 40 hp 7 hitroll priest/warrior only !evil", "Powers: break procs, powers: minor para, fear, slow, flee, sleep"},
    {"a bracelet of brainstealer scales", "wrist", "Illithid only, ac 10 5% prot elements, 25 hp, 50 mana", "Powers: eats a sub 500 hp pet for mana I think"},
    {"a belt of mercury dragon scales", "waist", "ac 15 5% poison 25 hp 5 maxagi priest/mage only", "Powers: power invis, cd 15s"},
    {"a thrumming deep crystal on an adamantine chain", "ear", "20 hp, 5 maxagi, !female !male", "Powers: 20 normal all stats, 2 min duration, 12 min cd"},
    {"a torque of aquatic dragon scales", "neck", "ac 10 5% acid 20 hp 5 sf illu mage only", ""},
    {"some sleeves of gold dragon scales", "arms", "ac 10 5% poison, 20 hp 5 sf elem, mage only", ""},
    {"a bracelet of silver dragon scales", "wrist", "ac 10 5% elect 20 hp 5 sf ench, mage only", ""},
    {"some boots of brass dragon scales", "feet", "ac 10 5% fire 20 hp 5 sf focus, mage only", ""},
    {"an orb of green dragonkind", "shield", "ac15 35hp 8sf_ill", ""},
    {"an orb of white dragonkind", "shield", "ac15 35hp 8sf_ele 10%pfc power:dogow mage-only", ""},
    {"a laminated harp strung with sirine hair", "instrument", "5% breaths 35 hp", ""},
    {"a mithril flute with silver inlays", "instrument", "35hp 50mana bard/bchanter-only", ""},
    {"a vial of Bahamut's cleansing", "potion", "L59 divine purification, dispel magic, remove curse", ""},
    {"a vial of feculent pustulence", "drink", "large unholy water container", ""},
    {"a badge of the Bronze Knights", "badge", "1 mana", ""}


  },
  Ashstone = {
    {"an iron vambrace studded with bloodstones", "arms", "ac10 15hp -5bre pff farsee pr-evil pr-good, anyone can wear except good aligned", "", {}, "(Q)"},
    {"a sharpened rapier studded with rubies", "weapon", "dam:4 Hit:2 * (Weapon) Crit:9% Multi:2x (Class: Martial, Type: Rapier) * MAGIC !Cleric !Mage * Flaming 100% 100% 0 0 - Flaming Burst 100% 100% 0 0 - Keen 100% 100% 0 0", "", {}, "(Q)"},
  },
  Baphomet = {
    {"a spiked iron choker 2", "waist", "ac9 2 hit 2 dam 4% unarmed resist", ""},
    {"a helm of Clangeddin''s might", "head", "ac15 20hp 5maxcon", ""},
    {"a dismal ring of the under-realms", "finger", "dismal is 65hp4maxagi !warrior", ""},
    {"a white-gold ring of the heirlooms", "finger", "ac6 10maxstr, nobits", ""},
    {"glowing geometrical designs tattooed on the hands", "hands", "ac7 5%spells 5%pff 4sf_ill 5maxint", ""},
  }
}

function NewGear:getNextId()
  recs = assert(NyyLIB.conn:execute([[select max(item_id) as maxid from items]]))
  row = recs:fetch({})
  id = 0
  while row do
    id = row[1] + 1
    row = recs:fetch({})
  end
  recs:close()
  return id
end

function NewGear:reset()
  for zone, litem in pairs(NewGear.spreadsheet) do
    for _, tbl in ipairs(litem) do
      NewGear:delete(tbl[1])
    end
  end
end

function NewGear:findByItem(item)
  return NewGear:findByName(item.item_name)
end

function NewGear:findByName(gear)
  local sql = string.format(
    [[select item_id from items where item_name = '%s']],
    NyyLIB.conn:escape(gear)
  )
  -- display(sql)
  local recs = assert(
    NyyLIB.conn:execute(sql)
  )
  local ids = {}
  local row = recs:fetch({})
  while row do
    table.insert(ids, row[1])
     row = recs:fetch({})
  end
  recs:close()
  return ids
end

function NewGear:existsItem(item)
  return NewGear:exists(item.item_name)
end

function NewGear:exists(gear)
  local ids = NewGear:findByName(gear)
  return #ids &gt; 0
end

function NewGear:deleteById(item_id)
  local sql = string.format([[DELETE FROM items where item_id = %d]], item_id)
  --display(sql)
  local res = assert(NyyLIB.conn:execute(sql))
  --display(res)
  sql = string.format([[DELETE FROM item_flags where item_id = %d]], item_id)
  --display(sql)
  res = assert(NyyLIB.conn:execute(sql))
  --display(res)
end

function NewGear:delete(gear)
  local ids = NewGear:findByName(gear)
  if #ids == 0 then
    return false -- Nothing to delete
  end
  if #ids &gt; 1 then
    cecho(string.format(
      [[&lt;red&gt;[TOO MANY IDS] "%s": {%s}\n]],
      gear, table.concat(ids, ", ")
    ))
    return false -- Too many IDs returned
  end
  NewGear:deleteById(ids[1])
  return true
end

function NewGear:insert(item)
  new_id = NewGear:getNextId()
  sql = string.format([[INSERT INTO items
VALUES (%d, '%s', '%s',
 %d, %d, '%s',
 '%s', '%s', '%s',
 '%s', '%s', '%s',
 '%s')]],
      new_id, NyyLIB.conn:escape(item.item_name), item.keywords,
      item.weight, item.c_value, item.item_type,
      item.from_zone, item.from_mob, NyyLIB.conn:escape(item.short_stats),
      NyyLIB.conn:escape(item.long_stats), 
      NyyLIB.conn:escape(item.full_stats), item.comments,
      item.last_id)
  --display(sql)
  res = assert(NyyLIB.conn:execute(sql))
  --display(res)
  for _, iflag in ipairs(item.flags) do
    sql = string.format([[INSERT INTO item_flags
VALUES (%d, '%s')]],
      new_id, iflag)
    --display(sql)
    res = assert(NyyLIB.conn:execute(sql))
    --display(res)
  end
end

function NewGear:init()
  local gearItems = {}

  for zone, ilist in pairs(NewGear.spreadsheet) do
    for _, tbl in ipairs(ilist) do
      display(tbl)
      local fl = tbl[5]
      local R = tbl[6]
      if fl == nil then
        fl = {}
      end
      if R == nil then
        R = " (R)"
      else
        if R ~= "" then
          R = " " .. R
        end
      end
      -- remove this variable to have it debug via display()
      local IGNORE=[[
      display(
        {
          tbl1 = tbl[1],
          tbl2 = tbl[2],
          tbl3 = tbl[3],
          tbl4 = tbl[4],
          zone = zone,
          R = R
        }
      )
      ]]
      local it = {
        item_id = -1,
        item_name = tbl[1],
        keywords = "",
        weight = 1,
        c_value = 77700,
        item_type = tbl[2],
        from_zone = zone,
        from_mob = '',
        short_stats = string.format("%s (%s) %s * %s * Flags? * Wt:? Val:? * Zone: %s%s * Last ID: 2019-08-27", tbl[1], tbl[2], tbl[3], tbl[4], zone, R),
        long_stats = "",
        full_stats = '',
        comments = '',
        last_id = '2019-08-27',
        flags = fl,
      }
      table.insert(gearItems, it)
    end
  end
  
  for _,item in ipairs(gearItems) do
    if not NewGear:existsItem(item) then
      display(item.item_name)
      NewGear:insert(item)
    end
  end
  
end
</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>convertToUserWindow</name>
					<packageName>convertToUserWindow</packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>convertAdj.Init</name>
						<packageName></packageName>
						<script>-- convert Adjustable.Containers to UserWindows and back
-- v0.1
-- Note: saving if UserWindow won't bring back as UserWindow if reloading
-- by Edru 7th October 2020

-- Adjustable.Container.userwindow is the associated userwindow object
-- Adjustable.Container.isUserWindow boolean

convertAdj = convertAdj or {}
function Adjustable.Container:onDoubleClick()
  self.isUserWindow = self.isUserWindow or false
  
  -- doubleclick on an adj window to convert to userwindow
  if self.isUserWindow then
    -- Move userWindow -&gt; Adjustable
    
    registerAnonymousEventHandler("sysWindowMousePressEvent", "convertAdj.sendToPosition", true)
    
    -- assign the container that was clicked on
    convertAdj.container = self
    self.userwindow:hide_impl()
    
    
    self.isUserWindow= false
    charData:set(self.name, false, true)
    
  else
    -- Move Adjustablewindow -&gt; userWindow
    
    -- create the new userwindow. The name is adj container name + "userWindow"
    self.userwindow = self.userwindow or Geyser.UserWindow:new({name = self.name.."userWindow"})
    self.userwindow:disableAutoDock()
    self.userwindow:show()
    self.userwindow:setTitle(self.titleText)
    self.userwindow:move(self:get_x(), self:get_y())
    self.userwindow:resize(self:get_width(), self:get_height())
    self:changeContainer(self.userwindow)
    self:move(0,0)
    self:resize("100%", "100%")
    self:lockContainer("standard")
    self.isUserWindow= true
    charData:set(self.name, true, true)  
  end
end

function convertAdj.Init()
  
  -- this function is called with events sysLoadEvent and sysInstall
  
  -- :doAll occurs with all existing adjustable containers
  Adjustable.Container:doAll(function(self) self.adjLabel:setDoubleClickCallback(function(event) self:onDoubleClick() end)end)
  
  -- the original new/save functions
  local newWrapper = Adjustable.Container.new
  local saveWrapper = Adjustable.Container.save
  
  -- wrapper for the :new constructor
  function Adjustable.Container:new(cons, container)
    local me = newWrapper(self, cons, container)
    me.adjLabel:setDoubleClickCallback(function(event) me:onDoubleClick() end)
    return me
  end
  
  -- wrapper for the :save constructor
  function Adjustable.Container:save(slot, dir)
    if self.isUserWindow then
      local tempWindowName = self.windowname
      self.windowname = "main"
      self:setAbsolute(true, true)
      self:unlockContainer()
      saveWrapper(self, slot, dir)
      self:lockContainer()
      self.windowname = tempWindowName
      self:setPercent(true, true)
    else
      saveWrapper(self, slot, dir)
    end
    return true
  end
  
end

-- this is called with "sysWindowMousePressEvent" after click in window / user-&gt;adj
-- it converts the userwindow back to an adjustable window and places it top left where clicked
-- event, button are unused information
function convertAdj.sendToPosition(event, button, x, y, windowname)
    -- this is assigned prior to creating the event. It's the container that was clicked on
    local self = convertAdj.container
    
    -- function called directly / not by raised event
    if self == nil then return end
    
    local newContainer = Geyser
    if windowname ~= "main" then
        newContainer = Geyser.windowList[windowname.."Container"].windowList[windowname]
        display(windowname)
    end
    self:resize(self:get_width(), self:get_height())
    self:move(x, y)
    self:changeContainer(Geyser)
    self:setPercent(true, true)
    self:unlockContainer()
    self:show()
    convertAdj.container = nil
end</script>
						<eventHandlerList>
							<string>sysLoadEvent</string>
							<string>sysInstall</string>
						</eventHandlerList>
					</Script>
				</ScriptGroup>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>NyyLIB</name>
			<packageName>NyyLIB011dev</packageName>
			<script></script>
			<command></command>
			<keyCode>103</keyCode>
			<keyModifier>2949176</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>north</name>
				<packageName></packageName>
				<script>mud:send("n")</script>
				<command></command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>south</name>
				<packageName></packageName>
				<script>mud:send("s")</script>
				<command></command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>east</name>
				<packageName></packageName>
				<script>mud:send("e")</script>
				<command></command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>west</name>
				<packageName></packageName>
				<script>mud:send("w")</script>
				<command></command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>down</name>
				<packageName></packageName>
				<script>mud:send("d")</script>
				<command></command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>up</name>
				<packageName></packageName>
				<script>mud:send("u")</script>
				<command></command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>test</name>
				<packageName></packageName>
				<script>display("X")</script>
				<command></command>
				<keyCode>16777235</keyCode>
				<keyModifier>0</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>scan</name>
				<packageName></packageName>
				<script>mud:send("SCAN")</script>
				<command></command>
				<keyCode>43</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
