<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="2.0.4.015">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>LuminariGUI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>LuminariGUI</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>YATCOConfig</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName>YATCOConfig</packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Tell</name>
					<script>-- Tell Trigger: Captures private messages between players
-- Regex patterns:
-- 1. ^(\w+) tells you, '(.*)' - Captures incoming tells: player name and message
-- 2. You tell - Captures outgoing tell confirmations
demonnic.chat:append("Tell")
if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>39</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) tells you, '(.*)'</string>
						<string>You tell </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Congrats</name>
					<script>-- Congrats Trigger: Captures congratulations channel messages
-- Regex patterns:
-- 1. ^(\w+) congrats, '(.*)' - Captures congrats messages: player name and content
-- 2. You congrat, ' - Captures outgoing congrats confirmations
demonnic.chat:append("Congrats")
if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) congrats, '(.*)</string>
						<string>You congrat, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chat</name>
					<script>demonnic.chat:append("Chat")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>39</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) chats, '(.*)</string>
						<string>You chat, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Say</name>
					<script>demonnic.chat:append("Say")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You say, '</string>
						<string>You shout, '</string>
						<string>You holler, '</string>
						<string>You whisper to</string>
						<string>You ask</string>
						<string>You say out-of-character, '</string>
						<string>^(\w+) says, '</string>
						<string>^(\w+) shouts, '</string>
						<string>^(\w+) hollers, '</string>
						<string>whispers to you, '</string>
						<string>asks you, '</string>
						<string>^(\w+) says out-of-character, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Auction</name>
					<script>demonnic.chat:append("Auction")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) auctalks, '(.*)</string>
						<string>You auctalk, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Group</name>
					<script>demonnic.chat:append("Group")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[Group]</string>
						<string>You group-say, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Wiznet</name>
					<script>demonnic.chat:append("Wiz")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[wiznet]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GUI</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture Wilderness Map</name>
					<script>deleteLine()
clearUserWindow("map.minimap")

map.container:hide()
GUI.asciiMapContainer:show()

maplineTrig = tempLineTrigger(1,23,[[onMapLine()]])  -- Edit the max lines to how many your MAP display shows.
padding = map.calcMinimapPadding()

-- Map Line Processing Handler
-- Processes individual lines of ASCII map data and handles map display completion
-- Enhanced with comprehensive error handling for robust map processing
function onMapLine()
  -- Validate that we have a valid line to process
  if not line or line == "" then
    print("Warning: Empty or invalid map line received")
    return
  end
  -- Check for map completion marker
  local isLastLine = string.findPattern(line, "&lt;/WILDERNESS_MAP&gt;")
  if isLastLine then
    deleteLine()
    -- Safely cleanup trigger with validation
    if maplineTrig and exists(maplineTrig, "trigger") ~= 0 then
      killTrigger(maplineTrig)
    end
    maplineTrig = nil
    return
  end
  -- Process map line with error handling
  pcall(function()
    selectCurrentLine()
    copy()
    if map.minimap and map.minimap.echo then
      for i = 1, padding do
        map.minimap:echo(" ")
      end
      map.adjustMinimapFontSize()
      appendBuffer("map.minimap")
    else
      print("Warning: map.minimap not available for line processing")
    end
    deleteLine()
  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&lt;WILDERNESS_MAP&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture Room Map</name>
					<script>deleteLine()
clearUserWindow("map.minimap")

if GUI.buttonWindow.mudletOrAscii == "ASCII" then
  map.container:hide()
  GUI.asciiMapContainer:show()
elseif GUI.buttonWindow.mudletOrAscii == "Mudlet" then
  map.container:show()
  GUI.asciiMapContainer:hide()
end
map.minimap:echo("\n")
maplineTrig = tempLineTrigger(1,11,[[onRoomMapLine()]])  -- Edit the max lines to how many your MAP display shows.
padding = map.calcAsciimapPadding()

-- Room Map Line Processing Handler
-- Processes individual lines of room-specific ASCII map data
-- Enhanced with comprehensive error handling for robust map processing
function onRoomMapLine()
  -- Validate that we have a valid line to process
  if not line or line == "" then
    print("Warning: Empty or invalid room map line received")
    return
  end
  -- Check for room map completion marker
  local isLastLine = string.findPattern(line, "&lt;/ROOM_MAP&gt;")
  if isLastLine then
    deleteLine()
    -- Safely cleanup trigger with validation
    if maplineTrig and exists(maplineTrig, "trigger") ~= 0 then
      killTrigger(maplineTrig)
    end
    maplineTrig = nil
    return
  end
  -- Process room map line with error handling
  pcall(function()
    selectCurrentLine()
    copy()
    if map.minimap and map.minimap.echo then
      map.minimap:echo(" ")
      map.adjustAsciimapFontSize()
      appendBuffer("map.minimap")
    else
      print("Warning: map.minimap not available for room map line processing")
    end
    deleteLine()
  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&lt;ROOM_MAP&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Gag blank lines</name>
					<script>deleteLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Cast Console</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Started Cast</name>
						<script>GUI.castConsole_startCast(matches[2], matches[3])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Casting\: (.+) (\*+)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Cast Complete</name>
						<script>GUI.castConsole_completeCast()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You complete your spell...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Cast Aborted</name>
						<script>GUI.castConsole_abortedCast()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You abort your spell.</string>
							<string>Your spell is aborted!</string>
							<string>You are unable to find the target for your spell!</string>
							<string>You are unable to find the object for your spell!</string>
							<string>You are unable to continue your spell in your current position!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Cast Canceled</name>
						<script>GUI.castConsole_canceledCast()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are unable to continue casting!</string>
							<string>You are too nauseated to continue casting!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>LuminariGUI</name>
			<script></script>
			<command></command>
			<packageName>LuminariGUI</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Toggles</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Gag Chat</name>
					<script>--[[Toggling this will determine if the line and follow up
    prompt are removed from the main buffer for chat.]]
GUI.gagChatToggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^gag chat$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Show Self</name>
					<script>--Toggles whether or not you are shown in the group tab.
GUI.showSelfToggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^show self$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Horizontal Scroll</name>
					<script>--Toggles horizontal scroll bar on main window
GUI.horizontalScrollToggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^hscroll$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>YATCO</name>
				<script></script>
				<command></command>
				<packageName>YATCO</packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Demonnic</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>Shared</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Reset chasing</name>
							<script>demonnic.chaser:reset()</script>
							<command></command>
							<packageName></packageName>
							<regex>^chaseres$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Fix GUI Events</name>
							<script>-- =============================================================================
-- FIX GUI COMMAND
-- This command uses the centralized initialization system to refresh all
-- GUI components. It's the user-facing command for manual refresh.
-- =============================================================================
if GUI and GUI.initializeOrRefresh then
    GUI.initializeOrRefresh("fix gui command")
else
    cecho("\n&lt;yellow&gt;GUI system not fully loaded. Please close and reopen your profile, then try again.")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^fix gui$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Debug</name>
							<script>if matches[2] then
  demonnic:listCategories()
else
  demonnic:toggleDebug()
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^debug(?: (list))?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>debug categories</name>
							<script>if matches[2] then
  demonnic:watchCategory( matches[2] )
else
  demonnic:listCategories()
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^debugc(?: (.*))?$</regex>
						</Alias>
					</AliasGroup>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>Tabbed Chat</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Toggle blinking (temporary change)</name>
							<script>if demonnic.chat.config.blink then
  demonnic.chat.config.blink = false
  demonnic.chat.tabsToBlink = {}
  demonnic:echo("Blinking temporarily turned &lt;red&gt;off&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to false in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
else
  demonnic.chat.config.blink = true
  demonnic.chat:blink()
  demonnic:echo("Blinking temporarily turned &lt;red&gt;on&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to true in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^dblink$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dsound</name>
							<script>-- Toggle chat sound notifications
if demonnic and demonnic.chat and demonnic.chat.config then
    demonnic.chat.config.soundEnabled = not demonnic.chat.config.soundEnabled
    
    if demonnic.chat.config.soundEnabled then
        cecho("\n&lt;green&gt;Chat sound notifications ENABLED&lt;reset&gt;\n")
        -- Play a test sound
        local soundPath = getMudletHomeDir() .. "/LuminariGUI/" .. demonnic.chat.config.soundFile
        local file = io.open(soundPath, "r")
        if file then
            file:close()
            playSoundFile(soundPath, demonnic.chat.config.soundVolume)
        else
            -- Try user's home directory as fallback
            soundPath = getMudletHomeDir() .. "/" .. demonnic.chat.config.soundFile
            file = io.open(soundPath, "r")
            if file then
                file:close()
                playSoundFile(soundPath, demonnic.chat.config.soundVolume)
            else
                -- Try system beep as final fallback
                playSoundFile("")  -- Empty string triggers system beep in Mudlet
            end
        end
    else
        cecho("\n&lt;red&gt;Chat sound notifications DISABLED&lt;reset&gt;\n")
    end
    
    -- Save to GUI.toggles for persistence
    if GUI and GUI.toggles then
        GUI.toggles.chatSound = demonnic.chat.config.soundEnabled
        table.save(getMudletHomeDir() .. "/GUI.toggles.lua", GUI.toggles)
    end
else
    cecho("\n&lt;red&gt;Chat system not initialized. Type 'fix chat' to reinitialize.&lt;reset&gt;\n")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^dsound$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>set chat sound</name>
							<script>local args = matches[2]:split(" ")
local command = args[1]
local value = args[2]

if command == "on" or command == "off" then
    -- Enable/disable sounds
    demonnic.chat.config.soundEnabled = (command == "on")
    GUI.toggles.chatSound = demonnic.chat.config.soundEnabled
    table.save(getMudletHomeDir() .. "/GUI.toggles.lua", GUI.toggles)
    cecho(string.format("\n&lt;yellow&gt;Chat sounds %s&lt;reset&gt;\n", command:upper()))
    
elseif command == "volume" and value then
    -- Set volume (0-100)
    local vol = tonumber(value)
    if vol and vol >= 0 and vol &lt;= 100 then
        demonnic.chat.config.soundVolume = vol
        cecho(string.format("\n&lt;yellow&gt;Chat sound volume set to %d&lt;reset&gt;\n", vol))
    else
        cecho("\n&lt;red&gt;Volume must be between 0 and 100&lt;reset&gt;\n")
    end
    
elseif command == "file" and value then
    -- Set sound file
    demonnic.chat.config.soundFile = value
    cecho(string.format("\n&lt;yellow&gt;Chat sound file set to: %s&lt;reset&gt;\n", value))
    
elseif command == "cooldown" and value then
    -- Set cooldown between sounds
    local cd = tonumber(value)
    if cd and cd >= 0 then
        demonnic.chat.config.soundCooldown = cd
        cecho(string.format("\n&lt;yellow&gt;Chat sound cooldown set to %d seconds&lt;reset&gt;\n", cd))
    else
        cecho("\n&lt;red&gt;Cooldown must be 0 or positive number&lt;reset&gt;\n")
    end
    
elseif command == "test" then
    -- Test the sound
    local soundPath = getMudletHomeDir() .. "/LuminariGUI/" .. demonnic.chat.config.soundFile
    local file = io.open(soundPath, "r")
    if file then
        file:close()
        playSoundFile(soundPath, demonnic.chat.config.soundVolume)
        cecho("\n&lt;green&gt;Playing test sound...&lt;reset&gt;\n")
    else
        -- Try user's home directory as fallback
        soundPath = getMudletHomeDir() .. "/" .. demonnic.chat.config.soundFile
        file = io.open(soundPath, "r")
        if file then
            file:close()
            playSoundFile(soundPath, demonnic.chat.config.soundVolume)
            cecho("\n&lt;green&gt;Playing test sound from user directory...&lt;reset&gt;\n")
        else
            playSoundFile("")  -- Empty string triggers system beep in Mudlet
            cecho("\n&lt;yellow&gt;Sound file not found, playing default beep&lt;reset&gt;\n")
        end
    end
    
else
    -- Show help
    cecho("\n&lt;cyan&gt;Chat Sound Commands:&lt;reset&gt;\n")
    cecho("  &lt;white&gt;set chat sound on/off&lt;reset&gt; - Enable or disable sounds for ALL channels\n")
    cecho("  &lt;white&gt;set chat sound volume &lt;0-100&gt;&lt;reset&gt; - Set volume level\n")
    cecho("  &lt;white&gt;set chat sound file &lt;filename&gt;&lt;reset&gt; - Set sound file\n")
    cecho("  &lt;white&gt;set chat sound cooldown &lt;seconds&gt;&lt;reset&gt; - Set cooldown between sounds\n")
    cecho("  &lt;white&gt;set chat sound test&lt;reset&gt; - Test the current sound\n")
    cecho("\n&lt;yellow&gt;Current settings:&lt;reset&gt;\n")
    cecho(string.format("  Enabled: %s (plays for ALL channels)\n", demonnic.chat.config.soundEnabled and "YES" or "NO"))
    cecho(string.format("  Volume: %d\n", demonnic.chat.config.soundVolume))
    cecho(string.format("  File: %s\n", demonnic.chat.config.soundFile))
    cecho(string.format("  Cooldown: %d seconds\n", demonnic.chat.config.soundCooldown))
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^set chat sound(?:\s+(.*))?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fixChat</name>
							<script>-- =============================================================================
-- FIX CHAT COMMAND
-- This command uses the centralized initialization system with focus on chat.
-- It ensures the chat system is properly initialized and visible.
-- =============================================================================
GUI.initializeOrRefresh("fix chat command")

-- Additional chat-specific actions
if GUI.chatContainer then
  GUI.chatContainer:raise()
  if demonnic.chat and demonnic.chat.container then
    demonnic.chat:showAllTabs()
  end
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^fix chat$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Toggle Chat System</name>
							<script>-- Toggle between YATCO and EMCO chat systems
if LuminariGUI and LuminariGUI.toggleChatSystem then
  LuminariGUI.toggleChatSystem()
  
  -- Save preference
  local configFile = getMudletHomeDir() .. "/LuminariGUI_chatSystem.txt"
  local f = io.open(configFile, "w")
  if f then
    f:write(LuminariGUI.chatSystem)
    f:close()
  end
else
  cecho("&lt;red&gt;Chat system toggle not available. Please restart your profile if you see this error.\n")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^toggle chat system$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>EMCO Debug Status</name>
							<script>-- Show EMCO debug status
cecho("&lt;yellow&gt;=== EMCO Debug Status ===&lt;reset&gt;\n")
cecho(string.format("Chat System: &lt;cyan&gt;%s&lt;reset&gt;\n", LuminariGUI.chatSystem or "YATCO"))
cecho(string.format("EMCO Debug: &lt;cyan&gt;%s&lt;reset&gt;\n", EMCO_DEBUG and "ON" or "OFF"))
cecho(string.format("Verbose Debug: &lt;cyan&gt;%s&lt;reset&gt;\n", EMCO_DEBUG_VERBOSE and "ON" or "OFF"))

-- Check module status
cecho("\n&lt;yellow&gt;Module Status:&lt;reset&gt;\n")
local modules = {"demontools", "LoggingConsole", "EMCO", "EMCO_Compatibility_Layer"}
for _, mod in ipairs(modules) do
  local loaded = package.loaded[mod] ~= nil
  local global = _G[mod] ~= nil
  cecho(string.format("  %s: loaded=&lt;cyan&gt;%s&lt;reset&gt; global=&lt;cyan&gt;%s&lt;reset&gt;\n", 
    mod, loaded and "YES" or "NO", global and "YES" or "NO"))
end

-- Check demonnic.chat status
if demonnic and demonnic.chat then
  cecho("\n&lt;yellow&gt;demonnic.chat Status:&lt;reset&gt;\n")
  cecho(string.format("  Type: &lt;cyan&gt;%s&lt;reset&gt;\n", type(demonnic.chat)))
  cecho(string.format("  use: &lt;cyan&gt;%s&lt;reset&gt;\n", tostring(demonnic.chat.use)))
  cecho(string.format("  currentTab: &lt;cyan&gt;%s&lt;reset&gt;\n", tostring(demonnic.chat.currentTab)))
  if demonnic.chat.config then
    cecho(string.format("  config.gag: &lt;cyan&gt;%s&lt;reset&gt;\n", tostring(demonnic.chat.config.gag)))
    cecho(string.format("  config.soundEnabled: &lt;cyan&gt;%s&lt;reset&gt;\n", tostring(demonnic.chat.config.soundEnabled)))
  end
else
  cecho("\n&lt;red&gt;demonnic.chat not found!&lt;reset&gt;\n")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^debug emco status$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>EMCO Debug Toggle</name>
							<script>-- Toggle EMCO debug mode
if EMCO_DEBUG then
  EMCO_DEBUG = false
  EMCO_DEBUG_VERBOSE = false
  cecho("&lt;yellow&gt;EMCO debugging disabled&lt;reset&gt;\n")
else
  EMCO_DEBUG = true
  cecho("&lt;yellow&gt;EMCO debugging enabled (use 'debug emco verbose' for verbose mode)&lt;reset&gt;\n")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^debug emco$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>EMCO Debug Verbose</name>
							<script>-- Toggle EMCO verbose debug mode
EMCO_DEBUG = true
EMCO_DEBUG_VERBOSE = not EMCO_DEBUG_VERBOSE
cecho(string.format("&lt;yellow&gt;EMCO verbose debugging %s&lt;reset&gt;\n", 
  EMCO_DEBUG_VERBOSE and "enabled" or "disabled"))</script>
							<command></command>
							<packageName></packageName>
							<regex>^debug emco verbose$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>EMCO Test</name>
							<script>-- Test EMCO functionality
cecho("&lt;yellow&gt;=== Testing EMCO Functionality ===&lt;reset&gt;\n")

-- Test 1: Check if chat system exists
if not demonnic or not demonnic.chat then
  cecho("&lt;red&gt;FAIL: demonnic.chat not found&lt;reset&gt;\n")
  return
end
cecho("&lt;green&gt;PASS: demonnic.chat exists&lt;reset&gt;\n")

-- Test 2: Try to append to a tab
local testTab = "All"
cecho(string.format("\nTesting append to '%s' tab...\n", testTab))
local success, err = pcall(function()
  selectString("This is a test message for EMCO", 1)
  demonnic.chat:append(testTab)
end)

if success then
  cecho("&lt;green&gt;PASS: Append operation succeeded&lt;reset&gt;\n")
else
  cecho(string.format("&lt;red&gt;FAIL: Append operation failed: %s&lt;reset&gt;\n", err))
end

-- Test 3: Check tab visibility
if demonnic.chat.showAllTabs then
  cecho("\nTesting showAllTabs...\n")
  local success2, err2 = pcall(demonnic.chat.showAllTabs, demonnic.chat)
  if success2 then
    cecho("&lt;green&gt;PASS: showAllTabs succeeded&lt;reset&gt;\n")
  else
    cecho(string.format("&lt;red&gt;FAIL: showAllTabs failed: %s&lt;reset&gt;\n", err2))
  end
end

cecho("\n&lt;yellow&gt;=== Test Complete ===&lt;reset&gt;\n")</script>
							<command></command>
							<packageName></packageName>
							<regex>^debug emco test$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
			</AliasGroup>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>LuminariGUI</name>
			<packageName>LuminariGUI</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>MSDPMapper</name>
				<packageName>Generic Mapper</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>MSDPMapper</name>
					<packageName></packageName>
					<script>
map = map or {}
map.room_info = map.room_info or {}
map.prev_info = map.prev_info or {}
map.aliases = map.aliases or {}
map.enabled = false
map.minimap_font_size = 8
map.minimap_width = 21
map.minimap_height = 21


local defaults = {
    -- using Geyser to handle the mapper in this, since this is a totally new script
    mapper = {x = "75%", y = "0%", width = "25%", height = "50%"}
}

local terrain_types = {
    -- used to make rooms of different terrain types have different colors
    -- add a new entry for each terrain type, and set the color with RGB values
    -- each id value must be unique, terrain types not listed here will use mapper default color
    ["Inside"]         	= {id = 1, r = 130, g = 130, b = 130},
		["City"]           	= {id = 2, r = 200, g = 200, b = 200},
		["Field"] 					= {id = 3, r = 0, g = 170, b = 0},
		["Forest"] 					= {id = 4, r = 0, g = 122, b = 0},
		["Hills"] 					= {id = 5, r = 122, g = 69, b = 0},
		["Low Mountains"] 	= {id = 6, r = 100, g = 100, b = 100},
		["Water (Swim)"] 		= {id = 7, r = 0, g = 0, b = 255},
		["Water (No Swim)"] = {id = 8, r = 0, g = 0, b = 130},
		["In Flight"] 			= {id = 9, r = 200, g = 200, b = 255},
		["Underwater"] 			= {id = 10, r = 43, g = 43, b = 124},
		["Zone Entrance"] 	= {id = 211, r = 255, g = 0, b = 0},
		["Road North-South"] = {id = 12, r = 119, g = 101, b = 86},
		["Road East-West"] 	= {id = 13, r = 119, g = 101, b = 86},
		["Road Intersection"] = {id = 14, r = 119, g = 101, b = 86},
		["Desert"] 					= {id = 15, r = 234, g = 219, b = 124},
		["Ocean"] 					= {id = 16, r = 0, g = 90, b = 90},
		["Marshland"] 			= {id = 17, r = 81, g = 47, b = 109},
		["High Mountains"] 	= {id = 18, r = 255, g = 255, b = 255},
		["Outer Planes"] 		= {id = 19, r = 168, g = 42, b = 138},
		["Underdark - Wild"] = {id = 20, r = 131, g = 110, b = 145},
		["Underdark - City"] = {id = 21, r = 183, g = 178, b = 186},
		["Underdark - Inside"] = {id = 22, r = 132, g = 132, b = 132},
		["Underdark - Water (Swim)"] = {id = 23, r = 70, g = 139, b = 175},
		["Underdark - Water (No Swim)"] = {id = 24, r = 34, g = 68, b = 86},
		["Underdark - In Flight"] = {id = 25, r = 158, g = 178, b = 188},
		["Lava"] 						= {id = 26, r = 255, g = 119, b = 0},
		["Dirt Road North-South"] = {id = 27, r = 142, g = 85, b = 0},
		["Dirt Road East-West"] = {id = 28, r = 142, g = 85, b = 0},
		["Dirt Road Intersection"] = {id = 29, r = 142, g = 85, b = 0},
		["Cave"] 						= {id = 30, r = 80, g = 80, b = 80},
		["Jungle"] 					= {id = 31, r = 21, g = 132, b = 101},
		["Tundra"] 					= {id = 32, r = 224, g = 224, b = 224},
		["Taiga"] 					= {id = 33, r = 103, g = 137, b = 104},
		["Beach"] 					= {id = 34, r = 239, g = 235, b = 0},
}

-- list of possible movement directions and appropriate coordinate changes
local move_vectors = {
    north = {0,1,0}, south = {0,-1,0}, east = {1,0,0}, west = {-1,0,0},
    northwest = {-1,1,0}, northeast = {1,1,0}, southwest = {-1,-1,0}, southeast = {1,-1,0},
    up = {0,0,1}, down = {0,0,-1}
}

-- used to convert short dirs for full dirs
local exits = {
    n = "north", s = "south", w = "west", e = "east",
    nw = "northwest", ne = "northeast", sw = "southwest", se = "southeast",
    u = "up", d = "down"
}

local exitmap = {
    north = 1,      northeast = 2,      northwest = 3,      east = 4,
    west = 5,       south = 6,          southeast = 7,      southwest = 8,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    [1] = "north",  [2] = "northeast",  [3] = "northwest",  [4] = "east",
    [5] = "west",   [6] = "south",      [7] = "southeast",  [8] = "southwest",
    [9] = "up",     [10] = "down",      [11] = "in",        [12] = "out",
}
	
for k, v in pairs(exitmap) do
	
end	

local function make_room()
    local info = map.room_info
    local coords = {0,0,0}
    addRoom(info.VNUM)
    local areas = getAreaTable()
    local areaID = areas[info.AREA]
    if not areaID then
        areaID = addAreaName(info.AREA)
    else
        coords = {getRoomCoordinates(map.prev_info.VNUM)}								
        local shift = {0,0,0}
        for k,v in pairs(map.prev_info.EXITS) do
            if v == info.VNUM and move_vectors[k] then
                shift = move_vectors[k]								
                break
            end
        end
				
        for n = 1,3 do
            coords[n] = coords[n] + shift[n]
        end
											
        -- map stretching
        local overlap = getRoomsByPosition(areaID,coords[1],coords[2],coords[3])				
				
        if not table.is_empty(overlap) then
            local rooms = getAreaRooms(areaID)
            local rcoords		
            for _,id in ipairs(rooms) do
                local x, y, z = getRoomCoordinates(id)
								rcoords = {x, y, z}
                for n = 1,3 do
                    if shift[n] ~= 0 and (rcoords[n] - coords[n]) * shift[n] &gt;= 0 then
                        rcoords[n] = rcoords[n] + shift[n]
                    end
                end
                setRoomCoordinates(id,rcoords[1],rcoords[2],rcoords[3])
            end
        end
    end
		setRoomArea(info.VNUM, areaID)
    setRoomCoordinates(info.VNUM, coords[1], coords[2], coords[3])
    if terrain_types[info.TERRAIN] then
        setRoomEnv(info.VNUM, terrain_types[info.TERRAIN].id + 16)
    end
    -- Set the room name from MSDP data
    if info.NAME then
        setRoomName(info.VNUM, info.NAME)
    end
		if map.prev_info then -- Check if you moved into here from another room.
			local prev_exits = getRoomExits(map.prev_info.VNUM)
			for dir, id in pairs(map.prev_info.EXITS) do
				if prev_exits[dir] == nil then
			    if not setExit(map.prev_info.VNUM, id, exitmap[dir]) then       
            setExitStub(map.prev_info.VNUM, exitmap[dir], true)
          end
				end
			end
		end
    for dir, id in pairs(info.EXITS) do
        -- need to see how special exits are represented to handle those properly here				
        if not setExit(info.VNUM, id, exitmap[dir]) then       
            setExitStub(info.VNUM, exitmap[dir], true)
        end
    end
end

local function shift_room(dir)
    local ID = map.room_info.VNUM
    local x,y,z = getRoomCoordinates(ID)
    local x1,y1,z1 = move_vectors[dir]
    x = x + x1
    y = y + y1
    z = z + z1
    setRoomCoordinates(ID,x,y,z)
    updateMap()
end

local function handle_move()
	if map.enabled == true and map.room_info.ENVIRONMENT ~= "Wilderness" then
    if not getRoomName(map.room_info.VNUM) then
        make_room()
    else		
			if terrain_types[map.room_info.TERRAIN] then
        setRoomEnv(map.room_info.VNUM, terrain_types[map.room_info.TERRAIN].id + 16)
    	end 	  
      local stubs = getExitStubs1(map.room_info.VNUM)				
			if stubs then		
       	for _, n in ipairs(stubs) do
          local dir = exitmap[n]				
	        local id = map.room_info.EXITS[dir]
	        -- need to see how special exits are represented to handle those properly here
	        if getRoomName(id) then	        
					  setExit(map.room_info.VNUM, id, exitmap[dir])
	        end
  	    end
			end
    end
	end
  centerview(map.room_info.VNUM)
end

local function make_aliases()

-- Aliases
    -- Let the user shift a room around via command line
    table.insert(map.aliases,tempAlias([[^shift (\w+)$]],[[raiseEvent("shiftRoom",matches[2])]]))
		table.insert(map.aliases,tempAlias([[^mc on$]],[[raiseEvent("startMapping")]]))
		table.insert(map.aliases,tempAlias([[^mc off$]],[[raiseEvent("stopMapping")]]))
		
    map.aliases = map.aliases or {}
    local id
    local tbl = {
        ["Start Mapping Alias"] = {[[^start mapping$]], [[map.start_mapping()]]},
        ["Stop Mapping Alias"] = {[[^stop mapping$]], [[map.stop_mapping()]]},
				["Shift Room Alias"] = {[[^shift (\w+)$]],[[raiseEvent("shiftRoom",matches[2])]]},				
        
				--["Save Map Alias"] = {[[^save map$]], [[saveMap(getMudletHomeDir() .. "/map.dat")]]},
        --["Load Map Alias"] = {[[^load map(?: (local))?$]], [[map.load_map(matches[2])]]},
        --["Export Map Area Alias"] = {[[^export area (.*)]],[[map.export_area(matches[2])]]},
        --["Import Map Area Alias"] = {[[^import area (.*)]],[[map.import_area(matches[2])]]},

        --["Set Room Area Alias"] = {[[^set area (.*)$]], [[map.set_area(matches[2])]]},
        --["Set Map Mode Alias"] = {[[^map mode (\w+)$]],[[map.set_mode(matches[2])]]},
        
        --["Merge Rooms Alias"] = {[[^merge rooms$]], [[map.merge_rooms()]]},
        --["Add Door Alias"] = {[[^add door (\w+)(?: (none|open|closed|locked)(?: (yes|no))?)?$]],[[map.set_door(matches[2],matches[3],matches[4])]]},
        --["Add Portal Alias"] = {[[^add portal (.*)$]],[[map.set_portal(matches[2])]]},
        --["Set Room Exit Alias"] = {[[^set exit (.+) (\d+)]],[[map.set_exit(matches[2],matches[3])]]},
        --["Clear Moves Alias"] = {[[^clear moves$]], [[map.clear_moves()]]},

        --["Find Me Alias"] = {[[^find me$]], [[map.find_me()]]},
        --["Find Path Alias"] = {[[find path ([^;]+)(?:\s*;\s*(.+))?]],[[map.find_path(matches[2],matches[3])]]},
        --["Set Recall Alias"] = {[[^set recall$]],[[map.set_recall()]]},
        --["Set Character Alias"] = {[[^set character (.*)$]],[[map.character = matches[2]]},
    }
    for k,v in pairs(tbl) do
        if map.aliases[k] and exists(map.aliases[k],"alias") ~= 0 then
            killAlias(map.aliases[k])
        end
        id = tempAlias(v[1],v[2])
        map.aliases[k] = id
    end
end

--function map.set_door(dir,status,one_way)
--    -- adds a door on a given exit
--    if map.enabled then
--        if not map.room_info then error("Make Door: No room found.") end
--        dir = exitmap[dir] or dir
--        if not stubmap[dir] then error("Make Door: Invalid direction.") end
--        status = (status ~= "" and status) or "closed"
--        one_way = (one_way ~= "" and one_way) or "no"
--        if not table.contains({"yes","no"},one_way) then error("Make Door: Invalid one-way status, must be yes or no.") end

--        local exits = getRoomExits(currentRoom)
--        local target_room = exits[dir]
--        if target_room then
--            exits = getRoomExits(target_room)
--        end
--        if one_way == "no" and (target_room and exits[reverse_dirs[dir]] == currentRoom) then
--            add_door(target_room,reverse_dirs[dir],status)
--        end
--        add_door(currentRoom,dir,status)
--				print("Door added.")
--    end
--end

function map.load_map(use_local)
    local path = getMudletHomeDir() .. "/map.dat"		
    if use_local then
        loadMap(path)
        print("Map reloaded from local copy.")
    else
        local address = 'http://www.luminarimud.com/download/map.dat'
        downloading = true
        downloadFile(path,address)
        print("Downloading Map File.")
    end
end

function map.adjustMinimapFontSize()
  local w = map.minimap.get_width()
  local h = map.minimap.get_height()
  local font_size = 8
  repeat
    font_size = font_size + 1
    local width, height = calcFontSize(font_size)
    width = width * map.minimap_width
    height = height * map.minimap_height
  until (w &lt; width) or (h &lt; height)
	map.minimap_font_size = font_size - 1
  setMiniConsoleFontSize("map.minimap", map.minimap_font_size)
end

function map.adjustAsciimapFontSize()
  local w = map.minimap.get_width()
  local h = map.minimap.get_height()
  local font_size = 8
  repeat
    font_size = font_size + 1
    local width, height = calcFontSize(font_size)
    width = width * 20
    height = height * 11
  until (w &lt; width) or (h &lt; height)
	map.minimap_font_size = font_size - 1
  setMiniConsoleFontSize("map.minimap", map.minimap_font_size)
end

function map.calcMinimapPadding()
	local width = calcFontSize(map.minimap_font_size)
	local characters = map.minimap.get_width() / width
	return (characters - map.minimap_width) / 4
end

function map.calcAsciimapPadding()
	local width = calcFontSize(map.minimap_font_size)
	local characters = map.minimap.get_width() / width
	return (characters - 19) / 4
end

local function config()        
    -- setting terrain colors
    for k,v in pairs(terrain_types) do
        setCustomEnvColor(v.id + 16, v.r, v.g, v.b, 255)
    end
    -- making mapper window
    local info = defaults.mapper
    
    -- Create map as Adjustable Container
    map.container = GUI.AdjustableContainers.create("Map", "map", {
      x = info.x,
      y = info.y,
      width = info.width,
      height = info.height,
      name = "LuminariGUI_Map",
      titleText = "Map",
      adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
      buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
      tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
      titleTxtColor = "green",
      padding = 9,
      lockStyle = "border",
      autoSave = true,
      autoLoad = true,
      attached = "tr",  -- Top-right attachment
      defaultDir = GUI.AdjustableContainers.saveDir,
      noClose = true
    })
    
    -- Create separate Adjustable Container for ASCII map
    GUI.asciiMapContainer = GUI.AdjustableContainers.create("ASCIIMap", "ascii_map", {
      x = info.x,
      y = info.y,
      width = info.width,
      height = info.height,
      name = "LuminariGUI_ASCIIMap",
      titleText = "ASCII Map",
      adjLabelstyle = info.adjLabelstyle or "background-color: rgba(0,0,0,0%); border: 4px solid #444444;",
      raiseOnClick = false,
      savePosition = true,
      titleTxtColor = "green",
      padding = 9,
      lockStyle = "border",
      autoSave = true,
      autoLoad = true,
      attached = "tr",  -- Top-right attachment
      defaultDir = GUI.AdjustableContainers.saveDir,
      noClose = true
    })
    
    -- Create ASCII minimap MiniConsole inside the new container
		map.minimap = Geyser.MiniConsole:new({
  		name="map.minimap",
  		x=9, y= 25,
  		width="-18", height="-34",
		}, GUI.asciiMapContainer)
		
		map.minimap:setColor("black")
		
		-- Keep reference for backward compatibility
		map.minimapcontainer = GUI.asciiMapContainer
		
		-- Hide ASCII map by default (Mudlet map shows first)
		GUI.asciiMapContainer:hide()
    
    -- Create mapper window within the adjustable container
    if not map.container then
      print("ERROR: Map container not created - cannot initialize mapper")
      return
    end
    
		map.mapwindow = Geyser.Mapper:new({
      name = "map.mapwindow", 
      x = 0, 
      y = 0, 
      width = "100%", 
      height = "100%"
    }, map.container)
    
    if not map.mapwindow then
      print("ERROR: Failed to create Geyser.Mapper instance")
      return
    end
    
    -- Single initialization timer to ensure proper rendering
    tempTimer(0.2, function()
      if map.mapwindow then
        map.mapwindow:show()
        map.mapwindow:resize()
        -- Force a second resize to handle any rendering issues
        map.mapwindow:resize()
      else
        print("ERROR: Failed to initialize map window")
      end
    end)
    
    -- Show the map container
    if map.container then
      map.container:show()
      -- No need to manipulate z-order here - let Adjustable Container handle it
    end
		
		map.adjustMinimapFontSize()
		make_aliases()		
		
		map.get_default_map()
end

function map.get_default_map()
	-- If the user has no map, download the default map from the server!
	local areas = getAreaTable()
	local path = getMudletHomeDir() .. "/map.dat"
	 
	
	if (areas["Mosswood"] == nil) then
		local address = 'http://www.luminarimud.com/download/map.dat'
    downloading = true
    downloadFile(path,address)
    print("Downloading Map File.")
	end
end

function map.start_mapping()
  map.enabled=true
	print("Mapping enabled.")
end

function map.stop_mapping()
	map.enabled=false
	print("Mapping disabled.")
end

function map.eventHandler(event,...)     
    if event == "msdp.ROOM" then
        map.prev_info = map.room_info
        map.room_info = table.update({},msdp.ROOM)
				-- Check if we have moved between regular and wilderness areas

				if map.prev_info.ENVIRONMENT == "Wilderness" and map.room_info.ENVIRONMENT == "Room" then
					 -- re-enable the mapper!
					 if GUI.asciiMapContainer then GUI.asciiMapContainer:hide() end
					 if map.container then 
					   map.container:show()
					   -- Delay mapper refresh to ensure container is visible
					   tempTimer(0.1, function()
					     if map.mapwindow then
					       map.mapwindow:show()
					       map.mapwindow:resize()
					     end
					   end)
					 end
				elseif map.prev_info.ENVIRONMENT == "Room" and map.room_info.ENVIRONMENT == "Wilderness" then
					 -- disable the mapper!
					 if map.container then map.container:hide() end
					 if GUI.asciiMapContainer then GUI.asciiMapContainer:show() end
				end
        handle_move()
    elseif event == "shiftRoom" then
        local dir = exits[arg[1]] or arg[1]
        if not table.contains(exits, dir) then
            echo("Error: Invalid direction '" .. dir .. "'.")
        else
            shift_room(dir)
        end
		elseif event == "sysDownloadDone" and downloading then
        loadMap(getMudletHomeDir() .. "/map.dat")
        downloading = false
        print("Map File Loaded.")				
    elseif event == "sysConnectionEvent" then
        config()			 
		end
		
end

function map.onProtocolEnabled(_, protocol)
  if protocol == "MSDP" then
    print("MSDP enabled!")
		sendMSDP("REPORT", "ROOM")
		config()	
  end
end

registerAnonymousEventHandler("msdp.ROOM","map.eventHandler")
registerAnonymousEventHandler("shiftRoom","map.eventHandler")
registerAnonymousEventHandler("sysConnectionEvent", "map.eventHandler")
registerAnonymousEventHandler("sysProtocolEnabled", "map.onProtocolEnabled")
registerAnonymousEventHandler("sysDownloadDone", "map.eventHandler")</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>GUI</name>
				<packageName>Template</packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>CSSman</name>
					<packageName>CSSman</packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>CSSMan</name>
						<packageName></packageName>
						<script>-- CSSMan by Vadi. Public domain.

CSSMan = {}
CSSMan.__index = CSSMan

function CSSMan.new(stylesheet)
  local obj  = { stylesheet = {} }
  setmetatable(obj,CSSMan)
  local trim = string.trim

  assert(type(stylesheet) == "string", "CSSMan.new: no stylesheet provided. A possible error is that you might have used CSSMan.new, not CSSMan:new")

  for line in stylesheet:gmatch("[^\r\n]+") do
    local attribute, value = line:match("^(.-):(.-);$")
    if attribute and value then
      attribute, value = trim(attribute), trim(value)
      obj.stylesheet[attribute] = value
    end
  end

  return obj
end

function CSSMan:set(key, value)
  self.stylesheet[key] = value
end

function CSSMan:get(key)
  return self.stylesheet[key]
end

function CSSMan:getCSS(key)
  local lines, concat = {}, table.concat
  for k,v in pairs(self.stylesheet) do lines[#lines+1] = concat({k,": ", v, ";"}) end
  return concat(lines, "\n")
end

function CSSMan:gettable()
  return self.stylesheet
end

function CSSMan:settable(tbl)
  assert(type(tbl) == "table", "CSSMan:settable: table expected, got "..type(tbl))

  self.stylesheet = tbl
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>GUI</name>
					<packageName></packageName>
					<script>-- =============================================================================
-- LUMINARIGUI INITIALIZATION DOCUMENTATION
-- =============================================================================
-- The LuminariGUI uses a CENTRALIZED INITIALIZATION SYSTEM to ensure all
-- components are properly initialized and refreshed at the right times.
--
-- MAIN INITIALIZATION FUNCTION: GUI.initializeOrRefresh(context)
-- Located at line ~3079 in this file
--
-- This function handles ALL initialization and refresh operations for:
-- - Initial package load
-- - Connection/reconnection
-- - MSDP protocol activation
-- - Manual refresh commands (fix gui, fix chat)
-- - Runtime component refresh
--
-- ENTRY POINTS (all use GUI.initializeOrRefresh):
-- 1. sysLoadEvent - Package loaded
-- 2. sysInstall - Package installed  
-- 3. sysConnectionEvent - Connected to game
-- 4. sysProtocolEnabled - MSDP activated
-- 5. "fix gui" command - Manual refresh
-- 6. "fix chat" command - Chat-focused refresh
--
-- TO ADD NEW INITIALIZATION:
-- 1. Add your initialization code to GUI.init() function
-- 2. Add your refresh code to GUI.initializeOrRefresh() function
-- 3. DO NOT create separate initialization handlers
-- 4. DO NOT duplicate refresh code in commands
--
-- COMPONENTS MANAGED:
-- - Event handler registration (GUI.registerEventHandlers)
-- - All Adjustable Containers (chat, gauges, map, etc.)
-- - MSDP data refresh (health, movement, room, etc.)
-- - Mapper initialization and refresh
-- - Chat system initialization
-- - Container z-order management
-- =============================================================================

GUI = GUI or {}
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Toggles</name>
						<packageName></packageName>
						<script>--Toggle the gagging of chat from main buffer.
function GUI.gagChatToggle()
  if GUI.toggles.gagChat == false then
	  GUI.toggles.gagChat = true
		cecho("\n&lt;b&gt;&lt;white&gt;[CHAT]&lt;/b&gt; &lt;green&gt;Now gagging chat from main buffer.&lt;reset&gt;")
	elseif GUI.toggles.gagChat == true then
	  GUI.toggles.gagChat = false
		cecho("\n&lt;b&gt;&lt;white&gt;[CHAT]&lt;/b&gt; &lt;red&gt;No longer gagging chat from main buffer.&lt;reset&gt;")
	else
	  GUI.toggles = {
		       gagChat = true,
	  includeInGroup = true,
	  horizontalScroll = false,
	  chatSound = false,
		}
		table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
	end
end

--Toggles whether or not you are shown in the group tab.
function GUI.showSelfToggle()
  if GUI.toggles.includeInGroup == false then
	  GUI.toggles.includeInGroup = true
		GUI.updateGroup()
		cecho("\n&lt;b&gt;&lt;cyan&gt;[GROUP]&lt;/b&gt; &lt;green&gt;Now showing self in group display.&lt;reset&gt;")
	elseif GUI.toggles.includeInGroup == true then
	  GUI.toggles.includeInGroup = false
		GUI.updateGroup()
		cecho("\n&lt;b&gt;&lt;cyan&gt;[GROUP]&lt;/b&gt; &lt;red&gt;No longer showing self in group display.&lt;reset&gt;")
	else
	  GUI.toggles = {
		       gagChat = true,
	  includeInGroup = true,
	  horizontalScroll = false,
	  chatSound = false,
		}
		table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
		cecho("\n&lt;b&gt;&lt;cyan&gt;[GROUP]&lt;/b&gt; &lt;green&gt;Now showing self in group display.&lt;reset&gt;")
	end
end

--Toggle horizontal scroll bar on main window
function GUI.horizontalScrollToggle()
  if GUI.toggles.horizontalScroll == false then
    GUI.toggles.horizontalScroll = true
    -- Disable word wrap and enable horizontal scrollbar
    setWindowWrap("main", 999)
    if enableHorizontalScrollBar then
      enableHorizontalScrollBar("main")
    end
    cecho("\n&lt;white&gt;Horizontal scrolling enabled on main window.")
  elseif GUI.toggles.horizontalScroll == true then
    GUI.toggles.horizontalScroll = false
    -- Re-enable word wrap and disable horizontal scrollbar
    setWindowWrap("main", 100)
    if disableHorizontalScrollBar then
      disableHorizontalScrollBar("main")
    end
    cecho("\n&lt;white&gt;Horizontal scrolling disabled on main window (word wrap enabled).")
  else
    GUI.toggles = {
           gagChat = true,
      includeInGroup = true,
      horizontalScroll = false,
    }
    table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
    -- Re-enable word wrap and disable horizontal scrollbar
    setWindowWrap("main", 100)
    if disableHorizontalScrollBar then
      disableHorizontalScrollBar("main")
    end
    cecho("\n&lt;white&gt;Horizontal scrolling disabled on main window (word wrap enabled).")
  end
  
  -- Save the toggle state
  GUI.saveToggles()
end

function GUI.loadToggles()
--Check for saved .lua. Create if not.
  GUI.toggles = {}
  if not io.exists(getMudletHomeDir().."/GUI.toggles.lua") then
	  GUI.toggles = {
		       gagChat = true,
	  includeInGroup = true,
	  horizontalScroll = false,
	  chatSound = false,
		}
		table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
	else
		table.load(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
  end
  
  -- Sync chat sound setting with demonnic.chat.config
  if GUI.toggles.chatSound and demonnic and demonnic.chat and demonnic.chat.config then
    demonnic.chat.config.soundEnabled = true
  end
end

--Save Toggle Preferences
function GUI.saveToggles()
  table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
end

--Apply horizontal scroll setting to main window
function GUI.applyHorizontalScrollSetting()
  local enabled = GUI.toggles.horizontalScroll or false
  
  if enabled then
    -- Disable word wrap and enable horizontal scrollbar
    setWindowWrap("main", 999)
    if enableHorizontalScrollBar then
      enableHorizontalScrollBar("main")
    end
  else
    -- Re-enable word wrap and disable horizontal scrollbar
    setWindowWrap("main", 100)
    if disableHorizontalScrollBar then
      disableHorizontalScrollBar("main")
    end
  end
end

-- Basic resource cleanup function
function GUI.cleanup()
  -- Clean up any temporary triggers
  if maplineTrig and exists(maplineTrig, "trigger") ~= 0 then
    killTrigger(maplineTrig)
    maplineTrig = nil
  end
  -- Save current toggle preferences
  GUI.saveToggles()
end

registerAnonymousEventHandler("sysLoadEvent", "GUI.loadToggles")
registerAnonymousEventHandler("sysExitEvent", "GUI.saveToggles")
registerAnonymousEventHandler("sysExitEvent", "GUI.cleanup")

-- Apply horizontal scroll settings after chat system loads
registerAnonymousEventHandler("sysLoadEvent", function()
  tempTimer(2, function()
    GUI.applyHorizontalScrollSetting()
    -- Also sync chat sound setting after chat system loads
    if GUI.toggles.chatSound and demonnic and demonnic.chat and demonnic.chat.config then
      demonnic.chat.config.soundEnabled = true
    end
  end)
end)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Create Background</name>
						<packageName></packageName>
						<script>function GUI.init_background()
  GUI.BackgroundCSS = CSSMan.new([[
  background-color: rgba(38, 25, 47, 0.9);
  border: 1px solid rgba(184, 115, 27, 0.5);
  border-radius: 5px;
  padding: 5px;
  box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
]])
  -- Left
  GUI.Left = Geyser.Label:new({name = "GUI.Left", x = 0, y = 0, width = "25%", height = "100%"})
  GUI.Left:setStyleSheet(GUI.BackgroundCSS:getCSS())
  GUI.Left:hide() -- Hidden: No longer needed with Adjustable Containers
  --Right
	GUI.Right =
    Geyser.Label:new({name = "GUI.Right", x = "-25%", y = "-50%", width = "25%", height = "50%"})
  GUI.Right:setStyleSheet(GUI.BackgroundCSS:getCSS())
  GUI.Right:hide() -- Hidden: No longer needed with Adjustable Containers
	--Top
	--[[
	GUI.Top = Geyser.Label:new({name = "GUI.Top", x = "25%", y = 0, width = "50%", height = "25%"})
  GUI.Top:setStyleSheet(GUI.BackgroundCSS:getCSS())
	]]
	--Bottom
	GUI.Bottom = Geyser.Label:new({name = "GUI.Bottom", x = "25%", y = "-25%", width = "50%", height = "25%"})
  GUI.Bottom:setStyleSheet(GUI.BackgroundCSS:getCSS())
  GUI.Bottom:hide() -- Hidden: No longer needed with Adjustable Containers
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Set Borders</name>
						<packageName></packageName>
						<script>function GUI.set_borders()
  local w, h = getMainWindowSize()
  setBorderLeft(0)  -- Changed from w/4 to 0 - main window now starts at left edge
  setBorderTop(0)
  setBorderBottom(h / 4)
  setBorderRight(w / 2)  -- Changed from w/4 to w/2 - main window ends at 50%
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Boxes</name>
						<packageName></packageName>
						<script>function GUI.init_boxes()

  GUI.BoxCSS =
    CSSMan.new(
      [[    
	background-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/ui_texture.jpg);
	background-color: rgba(38, 25, 47, 0.8);
	border: 1px solid rgba(184, 115, 27, 0.5);
	border-radius: 5px;
	padding: 5px;
	box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
	font-family: Tahoma, Geneva, sans-serif;
]]
    )
  --GUI.Box1 = Geyser.Label:new({
  --  name = "GUI.Box1",
  --  x = 0, y = 0,
  --  width = "100%",
  --  height = "50%",
  --},GUI.Right)
  --GUI.Box1:setStyleSheet(GUI.BoxCSS:getCSS())
  --GUI.Box1:echo("&lt;center&gt;GUI.Box1")
	
	--Box2
  GUI.Box2 =
    Geyser.Label:new({name = "GUI.Box2", x = 0, y = 0, width = "100%", height = "100%", color = "black"}, GUI.Bottom)
  GUI.Box2:setStyleSheet(GUI.BoxCSS:getCSS())
  GUI.Box2:hide() -- Hidden: No longer needed with Adjustable Containers
  -- GUI.Box2:echo("&lt;center&gt;GUI.Box2") -- Removed: No longer needed with Adjustable Containers
  -- Create chat container using Adjustable.Container
  GUI.chatContainer = GUI.AdjustableContainers.create("Chat", "chat", {
    x = "0%",
    y = "75%", 
    width = "50%",
    height = "25%",
    name = "LuminariGUI_Chat",
    titleText = "Chat",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    titleTxtColor = "green",
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "b",  -- Bottom attachment
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  
  -- Create inner wrapper for YATCO to account for title bar and padding
  GUI.chatContainerInner = Geyser.Container:new({
    name = "GUI.chatContainerInner",
    x = 9,        -- Respect padding
    y = 25,       -- Below title bar  
    width = "-18", -- Account for padding on both sides
    height = "-34" -- Account for title bar + bottom padding
  }, GUI.chatContainer)
  
  -- Show the chat container
  if GUI.chatContainer then
    GUI.chatContainer:show()
    print(" Chat container created successfully")
  else
    print(" Failed to create chat container")
  end

  --Box3 - Now created as Adjustable Container
  -- Create as Adjustable Container for button panel
  GUI.buttonPanelContainer = GUI.AdjustableContainers.create("ButtonPanel", "button_panel", {
    x = "50%",
    y = "0%",
    width = "25%",
    height = "15%",
    name = "LuminariGUI_ButtonPanel",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    titleText = "Controls",
    titleTxtColor = "green",
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "tr",  -- Top-right attachment
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  
  -- Store reference to old Box3 for compatibility
  GUI.Box3 = GUI.buttonPanelContainer
  GUI.Box3CSS = CSSMan.new(GUI.BoxCSS:getCSS())
  GUI.Box3CSS:set("border-width", "0px")

  --Box4 - Now created as Adjustable Container in GUI.tabbedInfoWindow.init()
  -- Placeholder will be set when tabbedInfoWindow initializes

  --Box5 - Now created as Adjustable Container in GUI.init_boxes()
  -- Create as Adjustable Container for room info and map legend
  GUI.roomInfoContainer = GUI.AdjustableContainers.create("RoomInfo", "room_info", {
    x = "75%",
    y = "50%",
    width = "25%",
    height = "39%",
    name = "LuminariGUI_RoomInfo",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    titleText = "Room Info / Legend",
    titleTxtColor = "green",
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "tr",  -- Top-right attachment
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  
  -- Store reference to old Box5 for compatibility
  GUI.Box5 = GUI.roomInfoContainer
  GUI.Box5CSS = CSSMan.new(GUI.BoxCSS:getCSS())
  GUI.Box5CSS:set("border-width", "0px")
 
 --Commenting out Box 6 echo until skill Icons are finished. 
	GUI.Box6 =
    Geyser.Label:new(
      {name = "GUI.Box6", x = "0%", y = "65%", width = "100%", height = "35%"}, GUI.Right
    )
  GUI.Box6CSS = CSSMan.new(GUI.BoxCSS:getCSS())
  GUI.Box6CSS:set("border-width", "0px")
  GUI.Box6:setStyleSheet(GUI.Box6CSS:getCSS())
  GUI.Box6:hide() -- Hidden: No longer needed with Adjustable Containers
  --GUI.Box6:echo("&lt;center&gt;Skill Icons")

  -- Create status gauges container using Adjustable.Container
  GUI.Box7 = GUI.AdjustableContainers.create("StatusGauges", "gauges", {
    titleText = "Status",
    titleTxtColor = "green",
    x = "50%",
    y = "75%",
    width = "25%",
    height = "25%",
    noClose = true
  })
  
  -- Show the status gauges container
  if GUI.Box7 then
    GUI.Box7:show()
    print(" Status gauges container created successfully")
  else
    print(" Failed to create status gauges container")
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Gauges</name>
						<packageName></packageName>
						<script>function GUI.init_gauges()
  GUI.Footer =
    Geyser.HBox:new(
      {name = "GUI.Footer", x = 0, y = 10, width = "100%", height = "75%"}, GUI.Bottom
    )
  GUI.Status =
    Geyser.HBox:new(
      {name = "GUI.Status", x = 9, y = 18, width = "-18", height = "-18", margin = 5}, GUI.Box7
    )
  -- Action icons moved to separate Adjustable Container
  GUI.GaugeBar =
    Geyser.VBox:new(
      {
        name = "GUI.GaugeBar",
        x = 0,
        y = 0,
        height = "100%",
        width = "100%", -- Full width now that action icons are separate
        h_policy = Geyser.Fixed,
        v_policy = Geyser.Fixed,
      },
      GUI.Status
    )
  --GUI.LeftColumn = Geyser.VBox:new({
  --  name = "GUI.LeftColumn",
  --},GUI.Footer)
  --GUI.RightColumn = Geyser.VBox:new({
  --  name = "GUI.RightColumn",
  --},GUI.Footer)
  GUI.GaugeBackCSS =
    CSSMan.new(
      [[
  background-color: rgba(0,0,0,0.3);
  border-style: solid;
  border-color: rgba(184, 115, 27, 0.8);
  border-width: 2px;
  border-radius: 10px;
  margin: 5px;
  width: 100%;
  font-family: BitstreamVeraSans;
  font-weight: bold;
  font-size: 14px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 2px rgba(184, 115, 27, 0.3);
  padding: 2px;
]]
    )
  GUI.GaugeFrontCSS =
    CSSMan.new(
      [[
  background-color: rgba(0,0,0,0);
  border-style: solid;
  border-color: rgba(255,255,255,0.4);
  border-width: 1px;
  border-radius: 8px;
  margin: 5px;
  width: 100%;
  font-family: BitstreamVeraSans;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
  box-shadow: 0 0 5px rgba(255,255,255,0.3), inset 0 1px 3px rgba(255,255,255,0.2);
]]
    )
  GUI.Health =
    Geyser.Gauge:new({name = "GUI.Health", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#FF6B6B")
  GUI.GaugeBackCSS:set("background-color", "#8B0000")
  GUI.Health.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.Health.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.Health:setValue(100, 100)
  GUI.Health.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;HEALTH: 100/100&lt;/b&gt;&lt;/span&gt;]])
  -- GUI.Experience =
  --   Geyser.Gauge:new({name = "GUI.Experience", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  -- GUI.GaugeFrontCSS:set("background-color", "#9370DB")
  -- GUI.GaugeBackCSS:set("background-color", "#4B0082")
  -- GUI.Experience.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  -- GUI.Experience.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  -- GUI.Experience:setValue(math.random(100), 100)
  -- GUI.Experience.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;EXPERIENCE&lt;/b&gt;&lt;/span&gt;]])
  GUI.PSP =
    Geyser.Gauge:new({name = "GUI.PSP", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#40E0D0")
  GUI.GaugeBackCSS:set("background-color", "#008B8B")
  GUI.PSP.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.PSP.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.PSP:setValue(100, 100)
  GUI.PSP.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;PSP: 100/100&lt;/b&gt;&lt;/span&gt;]])
  GUI.Moves =
    Geyser.Gauge:new({name = "GUI.Moves", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#FFD700")
  GUI.GaugeBackCSS:set("background-color", "#B8860B")
  GUI.Moves.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.Moves.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.Moves:setValue(100, 100)
  GUI.Moves.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;MOVES: 100/100&lt;/b&gt;&lt;/span&gt;]])
  GUI.Enemy =
    Geyser.Gauge:new({name = "GUI.Enemy", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#9370DB")
  GUI.GaugeBackCSS:set("background-color", "#4B0082")
  GUI.Enemy.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.Enemy.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.Enemy:setValue(0, 100)
  GUI.Enemy.front:echo([[&lt;b&gt;ENEMY: 0/0&lt;/b&gt;]])
  GUI.Enemy:hide() -- Hide until there's an actual enemy
  GUI.AffectedByIconsBox =
    Geyser.HBox:new(
      {
        name = "GUI.AffectedByIconsBox",
        x = 0,
        y = 0,
        height = "32%",
        width = "100%",
        h_policy = Geyser.Dynamic,
        v_policy = Geyser.Dynamic,
      },
      GUI.GaugeBar
    )
end

function GUI.init_action_icons()
  -- Create Adjustable Container for action icons
  GUI.actionIconsContainer = GUI.AdjustableContainers.create("ActionIcons", "action_icons", {
    x = "75%",
    y = "89%",
    width = "8%",
    height = "11%",
    name = "LuminariGUI_ActionIcons",
    titleText = "Actions",
    attached = "tr",  -- Top-right attachment
    autoSave = true,
    autoLoad = true,
    lockStyle = "border",
    padding = 9,
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    titleTxtColor = "green",
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  GUI.ActionIconsBox = GUI.actionIconsContainer  -- Backward compatibility
  
  -- Create the HBox inside the container
  GUI.actionIconsHBox = Geyser.HBox:new({
    name = "GUI.actionIconsHBox",
    x = 9,
    y = 25,
    height = "-34",
    width = "-18"
  }, GUI.actionIconsContainer)
  
  -- Initialize action icon CSS
  GUI.ActionIconCSS = CSSMan.new([[
	margin: 0px;
	vertical-align: top;
	border: 1px solid rgba(184, 115, 27, 0.5);
	border-radius: 3px;
	box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
]])
  
  -- Create standard action icon
  GUI.StandardActionIcon = Geyser.Label:new({
    name = "GUI.StandardActionIcon",
    width = 32,
    height = 32,
    h_policy = Geyser.Fixed,
    v_policy = Geyser.Fixed,
  }, GUI.actionIconsHBox)
  GUI.StandardActionIcon:setStyleSheet([[
    QLabel { 
      border-image: url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-standard.png"); 
      margin: 0px; 
      vertical-align: top; 
    }
  ]])
  GUI.StandardActionIcon:setToolTip("Standard Action", "10")
  
  -- Create move action icon
  GUI.MoveActionIcon = Geyser.Label:new({
    name = "GUI.MoveActionIcon",
    width = 32,
    height = 32,
    h_policy = Geyser.Fixed,
    v_policy = Geyser.Fixed,
  }, GUI.actionIconsHBox)
  GUI.MoveActionIcon:setStyleSheet([[
    QLabel { 
      border-image: url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-move.png"); 
      margin: 0px; 
      vertical-align: top; 
    }
  ]])
  GUI.MoveActionIcon:setToolTip("Move Action", "10")
  
  -- Create swift action icon
  GUI.SwiftActionIcon = Geyser.Label:new({
    name = "GUI.SwiftActionIcon",
    width = 32,
    height = 32,
    h_policy = Geyser.Fixed,
    v_policy = Geyser.Fixed,
  }, GUI.actionIconsHBox)
  GUI.SwiftActionIcon:setStyleSheet([[
    QLabel { 
      border-image: url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-swift.png"); 
      margin: 0px; 
      vertical-align: top; 
    }
  ]])
  GUI.SwiftActionIcon:setToolTip("Swift Action", "10")
  
  -- Show the container
  GUI.actionIconsContainer:show()
end

--GUI.Endurance = Geyser.Gauge:new({
--  name = "GUI.Endurance",
--},GUI.RightColumn)
--GUI.Endurance.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
--GUI.GaugeFrontCSS:set("background-color","yellow")
--GUI.Endurance.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
--GUI.Endurance:setValue(math.random(100),100)
--GUI.Endurance.front:echo("GUI.Endurance")
--GUI.Endurance.front:echo([[&lt;span style = "color: black"&gt;GUI.Endurance&lt;/span&gt;]])
--GUI.Willpower = Geyser.Gauge:new({
--  name = "GUI.Willpower",
--},GUI.RightColumn)
--GUI.Willpower.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
--GUI.GaugeFrontCSS:set("background-color","purple")
--GUI.Willpower.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
--GUI.Willpower:setValue(math.random(100),100)
--GUI.Willpower.front:echo("GUI.Willpower")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Cast Console</name>
						<packageName></packageName>
						<script>function GUI.init_castConsole()
  -- Convert Cast Console to Adjustable Container
  GUI.castConsoleContainer = GUI.AdjustableContainers.create("CastConsole", "cast_console", {
    x = "50%",
    y = "60%",
    width = "25%",
    height = "15%",
    padding = 9,
    name = "LuminariGUI_CastConsole",
    titleText = "Cast Console",
    titleTxtColor = "green",
    attached = "br",  -- Bottom-right attachment
    adjLabelstyle = "background-color: rgba(0,0,0,0%); border: 9px groove #444444;",
    locked = false,
    lockStyle = "standard",
    noClose = true
  })
  
  -- Create internal MiniConsole for spell casting display
  -- Position below title bar (approximately 20-25 pixels) and respect padding
  GUI.castConsole = Geyser.MiniConsole:new({
    name = "GUI.castConsole",
    x = 10,  -- Slight offset from left to respect container padding
    y = 25,  -- Position below title bar
    width = -20,  -- Use negative value to respect padding on both sides
    height = -35,  -- Use negative value to account for title bar and bottom padding
    color = "black"
  }, GUI.castConsoleContainer)
  
  -- Set font size to match main window
  setMiniConsoleFontSize("GUI.castConsole", getFontSize("main"))
  
  -- Ensure proper z-order
  GUI.castConsoleContainer:raise()
end


function GUI.castConsole_startCast(spellName, spellLength)
  GUI.currentlyCasting = spellName
	GUI.castingNow = true
  clearUserWindow("GUI.castConsole")
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..spellName:title().."&lt;/b&gt; &lt;white&gt;- &lt;cyan&gt;&lt;b&gt;"..spellLength.."&lt;/b&gt;")
	if GUI.castConsoleTimer then
	  killTimer(GUI.castConsoleTimer)
	end
end

function GUI.castConsole_completeCast()
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..GUI.currentlyCasting:title().."&lt;/b&gt; &lt;white&gt;- &lt;b&gt;&lt;green&gt; CAST COMPLETE&lt;/b&gt;")
	GUI.castConsoleTimer = tempTimer(10, [[clearUserWindow("GUI.castConsole")]])
end

function GUI.castConsole_abortedCast()
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..GUI.currentlyCasting:title().."&lt;/b&gt; &lt;white&gt;- &lt;b&gt;&lt;red&gt; ABORTED&lt;/b&gt;")
	GUI.castingNow = false
	GUI.castConsoleTimer = tempTimer(10, [[clearUserWindow("GUI.castConsole")]])
end


function GUI.castConsole_canceledCast()
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..GUI.currentlyCasting:title().."&lt;/b&gt; &lt;white&gt;- &lt;b&gt;&lt;red&gt; CANCELED&lt;/b&gt;")
	GUI.castingNow = false
	GUI.castConsoleTimer = tempTimer(10, [[clearUserWindow("GUI.castConsole")]])
end

</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Header Icons</name>
						<packageName></packageName>
						<script>function GUI.init_header_icons()
  GUI.Header =
    Geyser.HBox:new({name = "GUI.Header", x = 0, y = 0, width = "100%", height = "100%"}, GUI.Top)
  GUI.IconCSS =
    CSSMan.new(
      [[
  background-color: rgba(0,0,0,100);
  border-style: solid;
  border-width: 1px;
  border-color: white;
  border-radius: 5px;
  margin: 5px;
  qproperty-wordWrap: true;
]]
    )
  --[[
for i=1,12 do
  GUI["Icon"..i] = Geyser.Label:new({
    name = "GUI.Icon"..i,
  },GUI.Header)
  GUI["Icon"..i]:setStyleSheet(GUI.IconCSS:getCSS())
  GUI["Icon"..i]:echo("&lt;center&gt;GUI. Icon"..i)
end
]]
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>TabbedInfoWindow</name>
						<packageName></packageName>
						<script>GUI.tabbedInfoWindow =
  GUI.tabbedInfoWindow or
  {
    tabs = {"Player", "Affects", "Group"},
    color1 = "rgba(0,0,0,0)",
    color2 = "rgba(0,0,0,0)",
    width = "100%",
    height = "100%",
    current = "Player",
  }

-- createFrame function removed - frame images are incompatible with adjustable containers

function GUI.tabbedInfoWindow.click(tab)
  GUI.tabbedInfoWindow[GUI.tabbedInfoWindow.current]:hide()
  GUI.tabbedInfoWindow[GUI.tabbedInfoWindow.current .. "tab"]:echo(
    GUI.tabbedInfoWindow.current, "white", "c"
  )
  GUI.tabbedInfoWindow.current = tab
  GUI.tabbedInfoWindow[GUI.tabbedInfoWindow.current]:show()
  GUI.tabbedInfoWindow[tab .. "tab"]:echo(tab, "yellow", "c")
end

function GUI.tabbedInfoWindow.init()
  GUI.tabbedInfoWindowTabCSS =
    CSSMan.new(
      [[font-family: Tahoma, Geneva, sans-serif; 
			border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
			border: 1px solid rgba(184, 115, 27, 0.8);
			border-radius: 3px;
			padding: 3px;
		]]
    )
  
  -- Create Adjustable Container for tabbed info window
  local containerConfig = {
    x = "50%",  -- Column 2 position
    y = "15%",  -- Below Controls
    width = "25%",
    height = "45%",  -- Adjusted to fit: 15% to 60%
    name = "character_stats",
    titleText = "Character Stats",
    titleTxtColor = "green",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "tr",  -- Changed from "tl" to "tr" - now attaches to top-right since it's on right side
    defaultDir = GUI.AdjustableContainers.saveDir
  }
  
  -- Add noClose to containerConfig
  containerConfig.noClose = true
  
  -- Create adjustable container
  GUI.tabbedInfoWindowContainer = GUI.AdjustableContainers.create("TabbedInfo", "tabbed_info", containerConfig)
  
  -- Store reference to old Box4 for compatibility
  GUI.Box4 = GUI.tabbedInfoWindowContainer
  
  -- Create inner container for backwards compatibility
  GUI.tabbedInfoWindow.container =
    Geyser.Container:new(
      {
        name = "GUI.tabbedInfoWindow.back",
        x = 9,
        y = 25,
        width = "-18",
        height = "-34",
      },
      GUI.tabbedInfoWindowContainer
    )
  GUI.tabbedInfoWindow.header =
    Geyser.HBox:new(
      {name = "GUI.tabbedInfoWindow.header", x = 0, y = 0, width = "100%", height = "8%"},
      GUI.tabbedInfoWindow.container
    )
  GUI.tabbedInfoWindow.footer =
    Geyser.Label:new(
      {name = "GUI.tabbedInfoWindow.footer", x = 0, y = "8%", width = "100%", height = "92%"},
      GUI.tabbedInfoWindow.container
    )
  GUI.tabbedInfoWindow.footer:setStyleSheet([[font-family: Tahoma, Geneva, sans-serif;
]])
  GUI.tabbedInfoWindow.center =
    Geyser.Label:new(
      {name = "GUI.tabbedInfoWindow.center", x = 0, y = 0, width = "100%", height = "100%"},
      GUI.tabbedInfoWindow.footer
    )
  GUI.tabbedInfoWindow.center:setStyleSheet(
    [[
  background-color: ]] ..
    GUI.tabbedInfoWindow.color2 ..
    [[
	font-family: Tahoma, Geneva, sans-serif;
	]]
  )
  for k, v in pairs(GUI.tabbedInfoWindow.tabs) do
    GUI.tabbedInfoWindow[v .. "tab"] =
      Geyser.Label:new({name = "GUI.tabbedInfoWindow." .. v .. "tab"}, GUI.tabbedInfoWindow.header)
    GUI.tabbedInfoWindow[v .. "tab"]:setStyleSheet(GUI.tabbedInfoWindowTabCSS:getCSS())
    GUI.tabbedInfoWindow[v .. "tab"]:echo("&lt;center&gt;" .. v)
    GUI.tabbedInfoWindow[v .. "tab"]:setClickCallback("GUI.tabbedInfoWindow.click", v)
    GUI.tabbedInfoWindow[v] =
      Geyser.Label:new(
        {name = "GUI.tabbedInfoWindow." .. v, x = 0, y = 0, width = "100%", height = "100%"},
        GUI.tabbedInfoWindow.footer
      )
    GUI.tabbedInfoWindow[v]:setStyleSheet(
      [[
    background-color: ]] ..
      GUI.tabbedInfoWindow.color1 ..
      [[;    
	  font-family: Tahoma, Geneva, sans-serif;
	]]
    )
    GUI.tabbedInfoWindow[v .. "center"] =
      Geyser.Label:new(
        {
          name = "GUI.tabbedInfoWindow." .. v .. "center",
          x = 0,
          y = 0,
          width = "100%",
          height = "100%",
        },
        GUI.tabbedInfoWindow[v]
      )
    GUI.tabbedInfoWindow[v .. "center"]:setStyleSheet(
      [[
    background-color: ]] ..
      GUI.tabbedInfoWindow.color2 ..
      [[;
		border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/ui_texture.jpg) 0 0 0 0 stretch stretch;
		font-family: Tahoma, Geneva, sans-serif;
  ]]
    )
    GUI.tabbedInfoWindow[v]:hide()
    GUI.tabbedInfoWindow.current = v
  end
  -- Init to player tab
  GUI.tabbedInfoWindow.click("Player")
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Affects</name>
						<packageName></packageName>
						<script>-- Affects
-- -------
-- There are several types of affects in Luminari - Affected By (Status), Spell-Like Affects, Resistances and Damage Reduction
-- 'Affected By' also includes 'Modes' which change the character's behavior in some way, for example 'Flurry-of-Blows' or
-- 'Rapid-Shot'.  Modes are displayed in the box with the health bars, as this is important information even if you are not
-- Interested in the other types of affects.
--
-- Spell-like affects can create 'Affected By' status flags.
--
-- All other affects are displayed in the 'Affects' tab in the upper left.
--
-- Container: GUI.tabbedInfoWindow["Affectscenter"]
--

-- Initialize tables
GUI.AffectIcons = GUI.AffectIcons or {}
GUI.SLAffects = GUI.SLAffects or {}
GUI.SLAffects.Labels = GUI.SLAffects.Labels or {}
GUI.Affects = GUI.Affects or {}
GUI.Affects.Rows = GUI.Affects.Rows or {}
GUI.Affects.Modes = GUI.Affects.Modes or {}

function GUI.Affects.init()
  -- Initialize all the labels and such	
  -- Don't overwrite GUI.Affects itself - preserve the init function!
  GUI.Affects.Labels = {}
  GUI.Affects.Modes = {}
  GUI.Affects.Modes.Labels = {}
  GUI.Affects.Rows = {}
  -- CSS
  GUI.Affects.IconCSS = CSSMan.new([[
	  margin: 0px;	
  ]])
  GUI.Affects.Modes.IconCSS = CSSMan.new([[
	  margin: 0px;
  ]])  
  -- Calculate how many labels will fit into the container
  GUI.Affects.icon_width = 48
  GUI.Affects.icon_height = 48
  GUI.Affects.Modes.icon_width = 48
  GUI.Affects.Modes.icon_height = 48
  GUI.Affects.num_icons_row =
    (GUI.tabbedInfoWindow["Affectscenter"]:get_width()) / GUI.Affects.icon_width
  GUI.Affects.num_rows = 3 -- This is so we have room below for the other affect types.	
    --(GUI.tabbedInfoWindow["Affectscenter"]:get_height()) / GUI.Affects.icon_height
  
	-- Create the VBox
  GUI.Affects.container =
    Geyser.VBox:new(
      {
        name = "GUI.Affects.container",
        x = 0,
        y = 0,
        width = "100%",
        height = GUI.Affects.num_rows * GUI.Affects.icon_height,
        h_policy = Geyser.Fixed,
        v_policy = Geyser.Fixed,
      },
      GUI.tabbedInfoWindow["Affectscenter"]
    )
	-- Create the Affect Labels
  for i = 1, GUI.Affects.num_rows do
    --GUI.Affects.icon_width * GUI.Affects.num_icons_row,
    GUI.Affects.Rows[i] = {}
    GUI.Affects.Rows[i].Labels = {}
    GUI.Affects.Rows[i].container =
      Geyser.HBox:new(
        {
          name = "GUI.Affects.Row" .. i,
          x = 0,
          y = 0,
          height = GUI.Affects.icon_height,
          width = "100%",
          h_policy = Geyser.Fixed,
          v_policy = Geyser.Fixed,
        },
        GUI.Affects.container
      )
    for j = 1, GUI.Affects.num_icons_row do
      GUI.Affects.Rows[i].Labels[j] =
        Geyser.Label:new(
          {
            name = "GUI.Affects.Label" .. tostring(i) .. '_' .. tostring(j),
            width = GUI.Affects.icon_width,
            height = GUI.Affects.icon_height,
            h_policy = Geyser.Fixed,
            v_policy = Geyser.Fixed,
          },
          GUI.Affects.Rows[i].container
        )
      GUI.Affects.Rows[i].Labels[j]:setStyleSheet(GUI.Affects.IconCSS:getCSS())
      GUI.Affects.Rows[i].Labels[j]:setColor(0, 0, 0, 0)
    end
    GUI.Affects.current_row = 1
    GUI.Affects.current_column = 1
  end
  -- Initialize Modes - These will display along with the health bars.
  GUI.Affects.Modes.num_icons_row =
    GUI.AffectedByIconsBox:get_width() / GUI.Affects.Modes.icon_width
  GUI.Affects.Modes.ModeList =
    {
      ["Mode-RapidShot"] = true,
      ["Flurry-of-Blows"] = true,
      ["Sneaking"] = true,
      ["Hiding"] = true,
      ["Mode-PowerAttack"] = true,
      ["Mode-Expertise"] = true,
      ["Mode-Total-Defense"] = true,
      ["Spot-Mode"] = true,
      ["Listen-Mode"] = true,
      ["Mode-Spellbattle"] = true,
      ["Counterspell"] = true,
      ["Defensive-Casting"] = true,
      ["Charging"] = true,
      ["WildShape"] = true,
    }
  -- Create the Mode Labels
  for i = 1, GUI.Affects.Modes.num_icons_row do
    GUI.Affects.Modes.Labels[i] =
      Geyser.Label:new(
        {
          name = "GUI.AffectIcon" .. tostring(i),
          width = GUI.Affects.Modes.icon_width,
          height = GUI.Affects.Modes.icon_height,
          h_policy = Geyser.Dynamic,
          v_policy = Geyser.Dynamic,
        },
        GUI.AffectedByIconsBox
      )
    GUI.Affects.Modes.Labels[i]:setStyleSheet(GUI.Affects.Modes.IconCSS:getCSS())
  end
	GUI.tabbedInfoWindow["Affects"]:hide()
	
	-- Initialize the area for the Spell Like Affects - GUI.Affects.SLAffects
	GUI.SLAffects.row_height = 20
	-- Calculate how many rows we can have:
	GUI.SLAffects.num_rows = (GUI.tabbedInfoWindow["Affectscenter"]:get_height() - (GUI.Affects.icon_height*GUI.Affects.num_rows)) / GUI.SLAffects.row_height
	-- Set up the VBox
	GUI.SLAffects.container = 
	Geyser.VBox:new(
      {
        name = "GUI.SLAffects.container",
        x = 0,
        y = GUI.Affects.icon_height*GUI.Affects.num_rows,
        width = "100%",
        height = GUI.tabbedInfoWindow["Affectscenter"].get_height() - (GUI.Affects.icon_height*GUI.Affects.num_rows),        
        v_policy = Geyser.Fixed,
      },
      GUI.tabbedInfoWindow["Affectscenter"]
  )

	for i = 1, GUI.SLAffects.num_rows do
		GUI.SLAffects.Labels[i] = 
			Geyser.Label:new(
				{
					name = "GUI.SLAffect" .. tostring(i),
					width = "100%",
					height = GUI.SLAffects.row_height,
					h_policy = Geyser.Fixed,
				}, GUI.SLAffects.container
			)
		GUI.SLAffects.Labels[i]:setStyleSheet([[
        background-color: rgba(0,0,0,0%);
      ]])
    GUI.SLAffects.Labels[i]:hide()
	end 
end

function GUI.updateSLAffects()
	if msdp.AFFECTS and msdp.AFFECTS.SPELL_LIKE_AFFECTS and #msdp.AFFECTS.SPELL_LIKE_AFFECTS &gt; 0 then
		-- We have spell like affects to process!		
		for i = 1, GUI.SLAffects.num_rows do
			GUI.SLAffects.Labels[i]:echo("")
			GUI.SLAffects.Labels[i]:hide()
			if i &lt;= #msdp.AFFECTS.SPELL_LIKE_AFFECTS then
			  if (msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].LOCATION == "Damage-Reduction") then
					affect_string = string.format("&lt;pre&gt;[ %s ] %s %s (%s)&lt;/pre&gt;", msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].DURATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].NAME, 
					msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].LOCATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].TYPE)
				else
				  affect_string = string.format("&lt;pre&gt;[ %s ] %s %s to %s (%s)&lt;/pre&gt;", msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].DURATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].NAME, 
					msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].MODIFIER, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].LOCATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].TYPE)
				end
				GUI.SLAffects.Labels[i]:echo(affect_string)
				GUI.SLAffects.Labels[i]:show()
			end
		end		 
	end
end

function GUI.updateAffectIcons()
  -- Also update spell-like affects display
  GUI.updateSLAffects()
  
  if msdp.AFFECTS and msdp.AFFECTS.AFFECTED_BY and #msdp.AFFECTS.AFFECTED_BY &gt; 0 then
    -- We have a status to process!  Do MODES first.
    affected_by = msdp.AFFECTS.AFFECTED_BY
    for k, _ in ipairs(GUI.Affects.Modes.Labels) do
      GUI.Affects.Modes.Labels[k]:hide()
    end
    for k, _ in ipairs(GUI.Affects.Rows) do
      for l, _ in ipairs(GUI.Affects.Rows[k].Labels) do
        GUI.Affects.Rows[k].Labels[l]:hide()
      end
    end
    GUI.Affects.Modes.current_icon = 1
    GUI.Affects.current_row = 1
    GUI.Affects.current_column = 1
    for i = 1, #affected_by do
      -- Is this a Mode?
      if
        (
          (GUI.Affects.Modes.current_icon &lt;= GUI.Affects.Modes.num_icons_row) and
          (GUI.Affects.Modes.ModeList[affected_by[i].NAME] == true)
        )
      then
        -- Create the Icon!				
        GUI.Affects.Modes.Labels[GUI.Affects.Modes.current_icon]:setStyleSheet([[
          QLabel { 
            border-image: url("]] ..
            getMudletHomeDir():gsub("\\", "/") ..
            [[/LuminariGUI/images/affected_by/]] ..
            affected_by[i].NAME ..
            [[.png"); 
            margin: 0px; 
          }
        ]])
        -- Add tooltip for mode icons
        GUI.Affects.Modes.Labels[GUI.Affects.Modes.current_icon]:setToolTip(affected_by[i].NAME:gsub("_", " "), "10")
        GUI.Affects.Modes.Labels[GUI.Affects.Modes.current_icon]:show()
        GUI.Affects.Modes.current_icon = GUI.Affects.Modes.current_icon + 1
      else
        -- This is just an Affected By status flag
        if
          (
            (GUI.Affects.current_column &lt;= GUI.Affects.num_icons_row) and
            (GUI.Affects.current_row &lt;= GUI.Affects.num_rows)
          )
        then
          -- Create the Icon!				
          GUI.Affects.Rows[GUI.Affects.current_row].Labels[GUI.Affects.current_column]:setStyleSheet([[
            QLabel { 
              border-image: url("]] ..
              getMudletHomeDir():gsub("\\", "/") ..
              [[/LuminariGUI/images/affected_by/]] ..
              affected_by[i].NAME ..
              [[.png"); 
              margin: 0px; 
            }
          ]])
          -- Add tooltip for status effect icons
          GUI.Affects.Rows[GUI.Affects.current_row].Labels[GUI.Affects.current_column]:setToolTip(affected_by[i].NAME:gsub("_", " "), "10")
          GUI.Affects.Rows[GUI.Affects.current_row].Labels[GUI.Affects.current_column]:show()
          GUI.Affects.current_column = GUI.Affects.current_column + 1
          if GUI.Affects.current_column &gt; GUI.Affects.num_icons_row then
            GUI.Affects.current_column = 1
            GUI.Affects.current_row = GUI.Affects.current_row + 1
          end
        end
      end
    end
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Group</name>
						<packageName></packageName>
						<script>function GUI.init_group()
  GUI.GroupConsole =
    Geyser.MiniConsole:new(
      {name = "GUI.GroupConsole", x = 0, y = 0, width = "100%", height = "100%"},
      GUI.tabbedInfoWindow["Groupcenter"]
    )
  GUI.GroupConsole:setColor({r=0, b=0, g=0, a=0})
	GUI.tabbedInfoWindow["Group"]:hide()
end

function GUI.updateGroup()
  GUI.group_data = {}
  -- Remove the player from the group data if toggled off.
  local j = 1
  local status_msg
  for i = 1, #msdp.GROUP do
    if GUI.toggles.includeInGroup == false and msdp.GROUP[i].NAME ~= msdp.CHARACTER_NAME then
      while GUI.group_data[j] ~= nil do
        j = j + 1
      end
      GUI.group_data[j] = {}
      GUI.group_data[j].IS_LEADER = msdp.GROUP[i].IS_LEADER
      GUI.group_data[j].NAME = msdp.GROUP[i].NAME
      GUI.group_data[j].HEALTH = msdp.GROUP[i].HEALTH
      GUI.group_data[j].HEALTH_MAX = msdp.GROUP[i].HEALTH_MAX
      GUI.group_data[j].MOVEMENT = msdp.GROUP[i].MOVEMENT
      GUI.group_data[j].MOVEMENT_MAX = msdp.GROUP[i].MOVEMENT_MAX
      GUI.group_data[j].LEVEL = msdp.GROUP[i].LEVEL
      GUI.group_data[j].CLASS_STRING = msdp.GROUP[i].CLASS_STRING
  -- Add the player from the group data if toggled on.
		elseif GUI.toggles.includeInGroup == true then
      while GUI.group_data[j] ~= nil do
        j = j + 1
      end
      GUI.group_data[j] = {}
      GUI.group_data[j].IS_LEADER = msdp.GROUP[i].IS_LEADER
      GUI.group_data[j].NAME = msdp.GROUP[i].NAME
      GUI.group_data[j].HEALTH = msdp.GROUP[i].HEALTH
      GUI.group_data[j].HEALTH_MAX = msdp.GROUP[i].HEALTH_MAX
      GUI.group_data[j].MOVEMENT = msdp.GROUP[i].MOVEMENT
      GUI.group_data[j].MOVEMENT_MAX = msdp.GROUP[i].MOVEMENT_MAX
      GUI.group_data[j].LEVEL = msdp.GROUP[i].LEVEL
      GUI.group_data[j].CLASS_STRING = msdp.GROUP[i].CLASS_STRING	
    end -- if/elseif
  end -- for
	clearUserWindow("GUI.GroupConsole")
  num_grouped = #GUI.group_data
  for i = 1, num_grouped do
    -- Build the group member data and send it.
    --	+----------------------------------+
    --  | [level] Name                     |
    --  | hp: 90%  |=================    | |
    --  | Crown (leader), Shield (Tank)    |
    --  +----------------------------------+		
    if GUI.group_data[i].IS_LEADER == "1" then
      status_msg = "&lt;green&gt;LEADER"
    else
      status_msg = ""
    end
    local pct_health
    local health = tonumber(GUI.group_data[i].HEALTH)
    local max_health = tonumber(GUI.group_data[i].HEALTH_MAX)
    if health &gt; 0 then
      pct_health = (health / max_health) * 100
    else
      pct_health = 0
    end
    if pct_health &gt; 60 then
      hp_color = "&lt;green&gt;"
    elseif pct_health &gt; 15 then
        hp_color = "&lt;yellow&gt;"
      else
        hp_color = "&lt;red&gt;"
      end
			
			-- Format leader indicator
			local leader_icon = ""
			if GUI.group_data[i].IS_LEADER == "1" then
			  leader_icon = "&lt;gold&gt; "  -- Crown symbol for leader
			else
			  leader_icon = "  "
			end
			
			-- Format name with class abbreviation
			local class_abbr = GUI.group_data[i].CLASS_STRING or ""
			if #class_abbr > 3 then
			  class_abbr = string.sub(class_abbr, 1, 3):upper()
			end
			
			-- Enhanced member display with better formatting
			local member = string.format("%s&lt;cyan&gt;[&lt;b&gt;%2s&lt;/b&gt;] &lt;white&gt;&lt;b&gt;%-20s&lt;/b&gt; &lt;light_gray&gt;%-3s\n", 
			                            leader_icon,
			                            GUI.group_data[i].LEVEL,
			                            GUI.group_data[i].NAME,
			                            class_abbr)
			                            
			-- Health bar visualization
			local health_pct = math.floor(pct_health)
			local bar_length = 20
			local filled = math.floor((health_pct / 100) * bar_length)
			local empty = bar_length - filled
			
			member = member .. string.format("   &lt;light_gray&gt;HP: %s%3d%%&lt;light_gray&gt; [%s%s&lt;light_gray&gt;%s&lt;light_gray&gt;] &lt;dim_gray&gt;%s/%s\n",
			                                hp_color,
			                                health_pct,
			                                hp_color,
			                                string.rep("=", filled),
			                                string.rep("-", empty),
			                                GUI.group_data[i].HEALTH,
			                                GUI.group_data[i].HEALTH_MAX)
			                                
			-- Movement display
			local move_pct = tonumber(GUI.group_data[i].MOVEMENT) / tonumber(GUI.group_data[i].MOVEMENT_MAX) * 100
			local move_color = move_pct > 50 and "&lt;cyan&gt;" or (move_pct > 20 and "&lt;yellow&gt;" or "&lt;red&gt;")
			member = member .. string.format("   &lt;light_gray&gt;MV: %s%3d%%&lt;light_gray&gt; &lt;dim_gray&gt;(%s/%s)\n",
			                                move_color,
			                                math.floor(move_pct),
			                                GUI.group_data[i].MOVEMENT,
			                                GUI.group_data[i].MOVEMENT_MAX)
			
			-- Add separator between members
			if i &lt; num_grouped then
			  member = member .. "&lt;dim_gray&gt;   \n"
			end
			
      GUI.GroupConsole:cecho(member)
    end
  end


</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Player</name>
						<packageName></packageName>
						<script>function GUI.init_player()
  -- Check if tabbedInfoWindow is initialized
  if not GUI.tabbedInfoWindow or not GUI.tabbedInfoWindow["Playercenter"] then
    print("[GUI] Player tab not initialized yet")
    return
  end
  
  -- Add alignment to existing stylesheet without overwriting background and other styles
  local existingStyle = [[
    background-color: ]] .. GUI.tabbedInfoWindow.color2 .. [[;
    border-image: url(]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/ui_texture.jpg) 0 0 0 0 stretch stretch;
    font-family: Tahoma, Geneva, sans-serif;
    qproperty-alignment: 'AlignLeft | AlignTop';
  ]]
  
  GUI.tabbedInfoWindow["Playercenter"]:setStyleSheet(existingStyle)
end

function GUI.updatePlayer()
  -- Check if tabbedInfoWindow is initialized
  if not GUI.tabbedInfoWindow or not GUI.tabbedInfoWindow["Playercenter"] then
    print("[GUI] Player tab not ready for update")
    return
  end
  
  -- Build the player info display with proper null checks and enhanced styling
  local playerInfo = [[&lt;div style="padding: 5px;"&gt;]]
  
  -- Character name and level (larger, bold)
  playerInfo = playerInfo .. [[&lt;p style="font-size:18px;font-weight:bold;color:#FFD700;font-family:'Bitstream Vera Sans Mono';margin:0;text-shadow:1px 1px 2px #000;"&gt;]]
  playerInfo = playerInfo .. (msdp.CHARACTER_NAME or "Unknown") .. [[&lt;/p&gt;]]
  
  -- Level and Class
  playerInfo = playerInfo .. [[&lt;p style="font-size:16px;color:#C0C0C0;font-family:'Bitstream Vera Sans Mono';margin:2px 0;"&gt;Level &lt;span style="color:#00FF00;font-weight:bold;"&gt;]]
  playerInfo = playerInfo .. (msdp.LEVEL or "?") .. [[&lt;/span&gt; ]]
  playerInfo = playerInfo .. [[&lt;span style="color:#4169E1;font-weight:bold;"&gt;]] .. (msdp.CLASS or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
  
  -- Race
  playerInfo = playerInfo .. [[&lt;p style="font-size:14px;color:#DDA0DD;font-family:'Bitstream Vera Sans Mono';margin:2px 0;"&gt;]]
  playerInfo = playerInfo .. (msdp.RACE or "Unknown") .. [[&lt;/p&gt;]]
  
  -- Stats section with color coding
  playerInfo = playerInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:8px 0;"&gt;]]
  playerInfo = playerInfo .. [[&lt;p style="font-size:15px;color:#FFD700;font-weight:bold;font-family:'Bitstream Vera Sans Mono';margin:5px 0;"&gt;Attributes&lt;/p&gt;]]
  
  -- Stats in two columns with proper spacing
  playerInfo = playerInfo .. [[&lt;table style="width:100%;font-size:14px;font-family:'Bitstream Vera Sans Mono';border-spacing:15px 0;"&gt;]]
  playerInfo = playerInfo .. [[&lt;tr&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#FF6B6B;padding-right:20px;width:50%;"&gt;STR: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.STR or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#4169E1;padding-left:10px;width:50%;"&gt;INT: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.INT or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;/tr&gt;&lt;tr&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#90EE90;padding-right:20px;"&gt;DEX: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.DEX or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#87CEEB;padding-left:10px;"&gt;WIS: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.WIS or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;/tr&gt;&lt;tr&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#FFA500;padding-right:20px;"&gt;CON: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.CON or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#DDA0DD;padding-left:10px;"&gt;CHA: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.CHA or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;/tr&gt;&lt;/table&gt;]]
  
  -- AC and Gold
  playerInfo = playerInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:8px 0;"&gt;]]
  playerInfo = playerInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;&lt;span style="color:#C0C0C0;"&gt;AC:&lt;/span&gt; &lt;span style="color:#00CED1;font-weight:bold;font-size:16px;"&gt;]] .. (msdp.AC or "?") .. [[&lt;/span&gt;&lt;/p&gt;]]
  playerInfo = playerInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;&lt;span style="color:#C0C0C0;"&gt;Gold:&lt;/span&gt; &lt;span style="color:#FFD700;font-weight:bold;font-size:16px;"&gt;]] .. (msdp.MONEY or "0") .. [[&lt;/span&gt;&lt;/p&gt;]]
  
  playerInfo = playerInfo .. [[&lt;/div&gt;]]
  
  -- Update the display
  GUI.tabbedInfoWindow["Playercenter"]:echo(playerInfo)
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Buttons</name>
						<packageName></packageName>
						<script>GUI.buttonWindow =
  GUI.buttonWindow or
  {
    button = {"Legend", "Mudlet", "ASCII"},
    color1 = "rgba(0,0,0,0)",
    color2 = "rgba(0,0,0,0)",
    width = "100%",
    height = "100%",
		roomOrLegend = "Room",
		mudletOrAscii = "Mudlet",
		--# of chars wide text needs to be
		legendWidth = 50,
		--# of lines needed to display text
		legendHeight = 11,
  }

--Determine font size for Legend
function GUI.buttonWindow.adjustLegendFont()
  local w = GUI.buttonWindow.Legend.get_width()
  local h = GUI.buttonWindow.Legend.get_height()
  local font_size = 8
  repeat
    font_size = font_size + 1
    local width, height = calcFontSize(font_size)
    width = width * GUI.buttonWindow.legendWidth
    height = height * GUI.buttonWindow.legendHeight
  until (w &lt; width) or (h &lt; height)
	GUI.buttonWindow.Legend_font_size = font_size - 1
  setMiniConsoleFontSize("GUI.buttonWindow.Legend", GUI.buttonWindow.Legend_font_size)
end

--Button callback for Legend
function GUI.buttonWindow.legendClick()	
  --Toggle For Room Info/Legend
	if GUI.buttonWindow.roomOrLegend == "Room" then
		GUI.buttonWindow.roomInfo:hide()
    GUI.buttonWindow.Legend:show()
		GUI.buttonWindow.roomOrLegend = "Legend"
		GUI.updateRoom()
		GUI.buttonWindow.Legendbutton:echo("Legend/Room", "yellow", "c")
	elseif GUI.buttonWindow.roomOrLegend == "Legend" then
		GUI.updateLegend()
		GUI.buttonWindow.roomInfo:show()
    GUI.buttonWindow.Legend:hide()
		GUI.buttonWindow.roomOrLegend = "Room"
		GUI.buttonWindow.Legendbutton:echo("Legend/Room", "white", "c")
	end
end

--Button callback for Mudlet map.
function GUI.buttonWindow.mudletClick()
    -- Ensure containers exist before toggling
    if not map.container or not GUI.asciiMapContainer then
      print("ERROR: Map containers not initialized")
      return
    end
    
    GUI.asciiMapContainer:hide()
    map.container:show()
	  GUI.buttonWindow.mudletOrAscii = "Mudlet"
		GUI.buttonWindow.Mudletbutton:echo("Mudlet", "yellow", "c")
		GUI.buttonWindow.ASCIIbutton:echo("ASCII", "white", "c")
		
		-- Ensure mapper is visible and properly refreshed with a small delay
		tempTimer(0.1, function()
		  if map.mapwindow then
		    map.mapwindow:show()
		    map.mapwindow:resize()
		  end
		end)
end

--Button callback for ASCII map.
function GUI.buttonWindow.asciiClick()
    -- Ensure containers exist before toggling
    if not map.container or not GUI.asciiMapContainer then
      print("ERROR: Map containers not initialized")
      return
    end
    
    map.container:hide()
    GUI.asciiMapContainer:show()
		GUI.buttonWindow.mudletOrAscii = "ASCII"
		GUI.buttonWindow.ASCIIbutton:echo("ASCII", "yellow", "c")
		GUI.buttonWindow.Mudletbutton:echo("Mudlet", "white", "c")
		GUI.asciiMapContainer:raise()
end

--Button Init
function GUI.buttonWindow.init()
  GUI.buttonWindowCSS =
    CSSMan.new(
      [[font-family: Tahoma, Geneva, sans-serif; 
			border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
			border: 1px solid rgba(184, 115, 27, 0.6);
			border-radius: 4px;
			padding: 4px;
			font-weight: bold;
			color: white;
		]]
    )
  
  -- Add hover and pressed effects CSS
  GUI.buttonWindowHoverCSS =
    CSSMan.new(
      [[font-family: Tahoma, Geneva, sans-serif; 
			border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
			border: 1px solid rgba(184, 115, 27, 1.0);
			border-radius: 4px;
			padding: 4px;
			font-weight: bold;
			color: white;
			background-color: rgba(255, 255, 255, 0.1);
			box-shadow: 0px 0px 4px rgba(184, 115, 27, 0.6);
		]]
    )
		
--Entire Box3 Container for Buttons
  GUI.buttonWindow.container =
    Geyser.Container:new(
      {
        name = "GUI.buttonWindow.container",
        x = 9,
        y = 25,
        width = "-18",
        height = "-34",
      },
      GUI.buttonPanelContainer
    )

--Room Info
  GUI.buttonWindow.roomInfo = 
	Geyser.Label:new(
		{
		  name = "GUI.buttonWindow.roomInfo",
			x = 9,
			y = 25,
			width = "-18",
			height = "-34",
			},
			GUI.roomInfoContainer
		)

--Map Legend
  GUI.buttonWindow.Legend = 
	Geyser.MiniConsole:new(
		{
		  name = "GUI.buttonWindow.Legend",
			x = 9,
			y = 25,
			width = "-18",
			height = "-34",
			color = "black",
			},
			GUI.roomInfoContainer
		)
		GUI.buttonWindow.adjustLegendFont()
		
--Button Container
  GUI.buttonWindow.buttonContainer =
    Geyser.HBox:new(
      {name = "GUI.buttonWindow.buttonContainer", x = 0, y = 0, width = "100%", height = "100%"},
      GUI.buttonWindow.container
    )

--Draw Buttons
  for k, v in pairs(GUI.buttonWindow.button) do
    GUI.buttonWindow[v .. "button"] =
      Geyser.Label:new({name = "GUI.buttonWindow." .. v .. "button"}, GUI.buttonWindow.buttonContainer)
    GUI.buttonWindow[v .. "button"]:setStyleSheet(GUI.buttonWindowCSS:getCSS())
    GUI.buttonWindow[v .. "button"]:echo("&lt;center&gt;" .. (v == "Legend" and "Legend/Room" or v))
  end

--Legend Call Back
  GUI.buttonWindow.Legendbutton:setClickCallback("GUI.buttonWindow.legendClick")		
--Mudlet/ASCII Callback
  GUI.buttonWindow.Mudletbutton:setClickCallback("GUI.buttonWindow.mudletClick")	
  GUI.buttonWindow.ASCIIbutton:setClickCallback("GUI.buttonWindow.asciiClick")	
	
--Show Room Info on Startup
	GUI.buttonWindow.roomInfo:show()
  GUI.buttonWindow.Legend:hide()
	
--Populating Legend
	GUI.updateLegend()

--[[Will error line 33 if we call mudletClick callback
  so handling echo this way since Mudlet loads its map
  by default. ]]
	GUI.buttonWindow.Mudletbutton:echo("Mudlet", "yellow", "c")
	GUI.buttonWindow.ASCIIbutton:echo("ASCII", "white", "c")
	
end </script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Room Info/Legend</name>
						<packageName></packageName>
						<script>
function GUI.updateRoom()
  local roomInfo = [[&lt;div style="padding: 5px;"&gt;]]
  
  if msdp.ROOM.ENVIRONMENT == "Wilderness" then
    -- Wilderness display
    roomInfo = roomInfo .. [[&lt;p style="font-size:16px;font-weight:bold;color:#90EE90;font-family:'Bitstream Vera Sans Mono';margin:0;text-shadow:1px 1px 2px #000;"&gt;]]
    roomInfo = roomInfo .. [[&lt;center&gt; WILDERNESS &lt;/center&gt;&lt;/p&gt;]]
    
    roomInfo = roomInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:5px 0;"&gt;]]
    
    -- Coordinates
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Coords:&lt;/span&gt; &lt;span style="color:#00CED1;font-weight:bold;"&gt;(]]
    roomInfo = roomInfo .. (msdp.ROOM.COORDS.X or "?") .. ", " .. (msdp.ROOM.COORDS.Y or "?")
    roomInfo = roomInfo .. [[)&lt;/span&gt;&lt;/p&gt;]]
    
    -- Terrain
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Terrain:&lt;/span&gt; &lt;span style="color:#FFA500;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.TERRAIN or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
    
  else
    -- Regular room display
    -- Room name
    roomInfo = roomInfo .. [[&lt;p style="font-size:16px;font-weight:bold;color:#FFD700;font-family:'Bitstream Vera Sans Mono';margin:0;text-align:center;text-shadow:1px 1px 2px #000;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.NAME or "Unknown") .. [[&lt;/p&gt;]]
    
    roomInfo = roomInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:5px 0;"&gt;]]
    
    -- Room VNUM
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Room #:&lt;/span&gt; &lt;span style="color:#87CEEB;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.VNUM or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
    
    -- Terrain
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Terrain:&lt;/span&gt; &lt;span style="color:#FFA500;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.TERRAIN or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
    
    -- Area
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Area:&lt;/span&gt; &lt;span style="color:#DDA0DD;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.AREA or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
  end
  
  roomInfo = roomInfo .. [[&lt;/div&gt;]]
  GUI.buttonWindow.roomInfo:echo(roomInfo)
end
		
--Whattt to be replaced with MSDP or GMCP once coded in


function GUI.updateLegend()
  clearUserWindow("GUI.buttonWindow.Legend")
	GUI.buttonWindow.Legend:decho("\n &lt;102,0,0&gt; + &lt;255,255,255&gt; Up           &lt;0,102,102&gt;[&lt;0,255,255&gt;^&lt;0,102,102&gt;] &lt;255,255,255&gt;Air           &lt;0,102,102&gt;[&lt;255,0,255&gt;Y&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Wild")
	GUI.buttonWindow.Legend:decho("\n &lt;102,0,0&gt; - &lt;255,255,255&gt; Down         &lt;0,102,102&gt;[&lt;0,0,102&gt;U&lt;0,102,102&gt;] &lt;255,255,255&gt;Underwater    &lt;0,102,102&gt;[&lt;102,0,102&gt;C&lt;0,102,102&gt;] &lt;255,255,255&gt;UD City")
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;255,255,255&gt;&amp;&lt;0,102,102&gt;] &lt;255,255,255&gt;You          &lt;0,102,102&gt;[&lt;255,0,0&gt;X&lt;0,102,102&gt;] &lt;255,255,255&gt;Zone Entry    &lt;0,102,102&gt;[&lt;102,0,102&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Inside")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;192,192,192&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Inside       &lt;0,102,102&gt;[&lt;51,51,51&gt;|&lt;0,102,102&gt;] &lt;255,255,255&gt;Road N-S      &lt;0,102,102&gt;[&lt;102,0,102&gt;~&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Water") 
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;102,102,102&gt;C&lt;0,102,102&gt;] &lt;255,255,255&gt;City         &lt;0,102,102&gt;[&lt;51,51,51&gt;-&lt;0,102,102&gt;] &lt;255,255,255&gt;Road E-W      &lt;0,102,102&gt;[&lt;255,0,255&gt;=&lt;0,102,102&gt;] &lt;255,255,255&gt;UD D Water")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,102,0&gt;,&lt;0,102,102&gt;] &lt;255,255,255&gt;Field        &lt;0,102,102&gt;[&lt;51,51,51&gt;+&lt;0,102,102&gt;] &lt;255,255,255&gt;Intersect     &lt;0,102,102&gt;[&lt;102,0,102&gt;^&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Air")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,255,0&gt;Y&lt;0,102,102&gt;] &lt;255,255,255&gt;Forest       &lt;0,102,102&gt;[&lt;255,255,0&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Desert        &lt;0,102,102&gt;[&lt;255,0,0&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Lava")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;102,102,0&gt;^&lt;0,102,102&gt;] &lt;255,255,255&gt;Hills        &lt;0,102,102&gt;[&lt;0,0,255&gt;o&lt;0,102,102&gt;] &lt;255,255,255&gt;Ocean         &lt;0,102,102&gt;[&lt;102,102,0&gt;|&lt;0,102,102&gt;] &lt;255,255,255&gt;D Rd N-S")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;102,0,0&gt;m&lt;0,102,102&gt;] &lt;255,255,255&gt;Mountain     &lt;0,102,102&gt;[&lt;255,0,255&gt;,&lt;0,102,102&gt;] &lt;255,255,255&gt;Marsh         &lt;0,102,102&gt;[&lt;102,102,0&gt;-&lt;0,102,102&gt;] &lt;255,255,255&gt;D Rd E-W")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,102,102&gt;~&lt;0,102,102&gt;] &lt;255,255,255&gt;Water        &lt;0,102,102&gt;[&lt;255,0,0&gt;M&lt;0,102,102&gt;] &lt;255,255,255&gt;High Mount    &lt;0,102,102&gt;[&lt;102,102,0&gt;+&lt;0,102,102&gt;] &lt;255,255,255&gt;D Inters") 
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,0,102&gt;=&lt;0,102,102&gt;] &lt;255,255,255&gt;Deep Water   &lt;0,102,102&gt;[&lt;51,51,51&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Planes        &lt;0,102,102&gt;[&lt;51,51,51&gt;C&lt;0,102,102&gt;] &lt;255,255,255&gt;Cave") 
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>DrawFrames</name>
						<packageName></packageName>
						<script>function GUI.draw_frames()
  -- Frame drawing removed - frame images are incompatible with adjustable containers
  -- Adjustable containers have their own border styling through the adjLabelstyle property
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MSDP</name>
						<packageName></packageName>
						<script>function GUI.onProtocolEnabled(_, protocol)
  if protocol == "MSDP" then
    print("[GUI] MSDP Protocol enabled - initializing variables")
    
    -- Send REPORT requests for all MSDP variables
    sendMSDP("REPORT", "CHARACTER_NAME")
		sendMSDP("REPORT", "RACE")
		sendMSDP("REPORT", "CLASS")
		sendMSDP("REPORT", "ALIGNMENT")
		sendMSDP("REPORT", "LEVEL")
		sendMSDP("REPORT", "STR")
		sendMSDP("REPORT", "DEX")
		sendMSDP("REPORT", "CON")
		sendMSDP("REPORT", "INT")
		sendMSDP("REPORT", "WIS")
		sendMSDP("REPORT", "CHA")
		sendMSDP("REPORT", "AC")
		sendMSDP("REPORT", "MONEY")
		sendMSDP("REPORT", "HEALTH")
    sendMSDP("REPORT", "HEALTH_MAX")
    sendMSDP("REPORT", "OPPONENT_HEALTH")
    sendMSDP("REPORT", "OPPONENT_HEALTH_MAX")
    sendMSDP("REPORT", "OPPONENT_NAME")
    sendMSDP("REPORT", "MOVEMENT")
    sendMSDP("REPORT", "MOVEMENT_MAX")
    sendMSDP("REPORT", "PSP")
    sendMSDP("REPORT", "PSP_MAX")
    sendMSDP("REPORT", "EXPERIENCE")
    sendMSDP("REPORT", "EXPERIENCE_TNL")
    sendMSDP("REPORT", "ACTIONS")
		sendMSDP("REPORT", "GROUP")
		--sendMSDP("REPORT", "INVENTORY")
		sendMSDP("REPORT", "AFFECTS")
		sendMSDP("REPORT", "ROOM")
		sendMSDP("REPORT", "AREA_NAME")
		sendMSDP("REPORT", "ROOM_EXITS")
		sendMSDP("REPORT", "ROOM_NAME")
		sendMSDP("REPORT", "ROOM_VNUM")
		sendMSDP("REPORT", "WORLD_TIME")
    
    -- Debug: Show what variables are available after a short delay
    tempTimer(2, function()
      print("[GUI] MSDP variables received:")
      local count = 0
      for k, v in pairs(msdp) do
        if type(v) ~= "function" then
          count = count + 1
          if k == "ACTIONS" then
            -- Special handling for ACTIONS to show its structure
            print(string.format("  %s = %s (type: %s)", k, tostring(v), type(v)))
            if type(v) == "table" then
              print("    ACTIONS table contents:")
              for action_k, action_v in pairs(v) do
                print(string.format("      %s = %s", action_k, tostring(action_v)))
              end
            end
          else
            print(string.format("  %s = %s", k, tostring(v)))
          end
        end
      end
      print(string.format("[GUI] Total MSDP variables: %d", count))
    end)
    
    -- Initialize or refresh GUI after a short delay to ensure MSDP data arrives
    tempTimer(0.5, function()
      GUI.initializeOrRefresh("MSDP protocol enabled")
    end)
  end
end

function GUI.updateHealthGauge()
  -- This function handles the following events:
  --   msdp.HEALTH
  --   msdp.HEALTH_MAX
  
  -- Check if gauge exists
  if not GUI.Health then
    return
  end
  
  -- Get values with defaults
  local health = tonumber(msdp.HEALTH) or 0
  local max_health = tonumber(msdp.HEALTH_MAX) or 1
  
  -- Calculate percentage
  local pct_health
  if health &gt; max_health then
    health = max_health
  end
  
  if max_health &gt; 0 then
    pct_health = (health / max_health) * 100
  else
    pct_health = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;HEALTH: " .. health .. "/" .. max_health .. "&lt;/b&gt;"
  GUI.Health.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
  GUI.Health.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
  
  -- Set gauge value
  if pct_health &gt; 100 then
    GUI.Health:setValue(100, 100)
  else
    GUI.Health:setValue(pct_health, 100)
  end
end

function GUI.updateMovesGauge()
  -- This function handles the following events:
  --   msdp.MOVEMENT
  --   msdp.MOVEMENT_MAX
  
  -- Check if gauge exists
  if not GUI.Moves then
    return
  end
  
  -- Get values with defaults
  local moves = tonumber(msdp.MOVEMENT) or 0
  local max_moves = tonumber(msdp.MOVEMENT_MAX) or 1
  
  -- Calculate percentage
  local pct_moves
  if max_moves &gt; 0 then
    pct_moves = (moves / max_moves) * 100
  else
    pct_moves = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;MOVES: " .. moves .. "/" .. max_moves .. "&lt;/b&gt;"
  GUI.Moves.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
  GUI.Moves.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
  
  -- Set gauge value
  if pct_moves &gt; 100 then
    GUI.Moves:setValue(100, 100)
  else
    GUI.Moves:setValue(pct_moves, 100)
  end
end

-- function GUI.updateExperienceGauge()
--   -- This function handles the following events:
--   --   msdp.EXPERIENCE
--   --   msdp.EXPERIENCE_TNL
--   
--   -- Check if gauge exists
--   if not GUI.Experience then
--     return
--   end
--   
--   -- Get values with defaults
--   local xp = tonumber(msdp.EXPERIENCE) or 0
--   local xp_tnl = tonumber(msdp.EXPERIENCE_TNL) or 0
--   
--   -- Calculate percentage
--   local pct_xp
--   local total_xp = xp + xp_tnl
--   if total_xp &gt; 0 then
--     pct_xp = (xp / total_xp) * 100
--   else
--     pct_xp = 0
--   end
--   
--   -- Update display with dynamic font sizes
--   local gaugeHeight = GUI.Experience:get_height()
--   local fontSize1 = math.max(8, math.floor(gaugeHeight * 0.4))
--   local fontSize2 = math.max(6, math.floor(gaugeHeight * 0.3))
--   local displayText = "&lt;b&gt;EXP: &lt;span style='font-size:" .. fontSize1 .. "px;'&gt;" .. xp .. "&lt;/span&gt;&lt;span style='color:#4B0082;'&gt;/&lt;/span&gt;&lt;span style='font-size:" .. fontSize2 .. "px;'&gt;" .. total_xp .. "&lt;/span&gt;&lt;/b&gt;"
--   GUI.Experience.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
--   GUI.Experience.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
--   
--   -- Set gauge value
--   if pct_xp &gt; 100 then
--     GUI.Experience:setValue(100, 100)
--   else
--     GUI.Experience:setValue(pct_xp, 100)
--   end
-- end

function GUI.updatePSPGauge()
  -- This function handles the following events:
  --   msdp.PSP
  --   msdp.PSP_MAX
  
  -- Check if gauge exists
  if not GUI.PSP then
    return
  end
  
  -- Get values with defaults
  local psp = tonumber(msdp.PSP) or 0
  local max_psp = tonumber(msdp.PSP_MAX) or 1
  
  -- Calculate percentage
  local pct_psp
  if max_psp &gt; 0 then
    pct_psp = (psp / max_psp) * 100
  else
    pct_psp = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;PSP: " .. psp .. "/" .. max_psp .. "&lt;/b&gt;"
  GUI.PSP.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
  GUI.PSP.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
  
  -- Set gauge value
  if pct_psp &gt; 100 then
    GUI.PSP:setValue(100, 100)
  else
    GUI.PSP:setValue(pct_psp, 100)
  end
end

function GUI.updateEnemyGauge()
  -- This function handles the following events:
  --   msdp.OPPONENT_HEALTH
  --   msdp.OPPONENT_HEALTH_MAX
  --   msdp.OPPONENT_NAME
  
  -- Check if gauge exists
  if not GUI.Enemy then
    return
  end
  
  -- Get opponent name
  local opponent_name = msdp.OPPONENT_NAME or ""
  
  -- Show/Hide the gauge based on opponent presence
  if opponent_name == "" then
    GUI.Enemy:hide()
    return
  else
    GUI.Enemy:show()
  end
  
  -- Get values with defaults
  local health = tonumber(msdp.OPPONENT_HEALTH) or 0
  local max_health = tonumber(msdp.OPPONENT_HEALTH_MAX) or 1
  
  -- Calculate percentage
  local pct_health
  if max_health &gt; 0 then
    pct_health = (health / max_health) * 100
  else
    pct_health = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;" .. opponent_name:upper() .. ": &lt;span style='color:#FF0000;'&gt;" .. health .. "&lt;/span&gt;&lt;span style='color:#9370DB;'&gt;/&lt;/span&gt;&lt;span style='color:#FFFFFF;'&gt;" .. max_health .. "&lt;/span&gt;&lt;/b&gt;"
  GUI.Enemy.front:echo(displayText)
  GUI.Enemy.back:echo(displayText)
  
  -- Set gauge value
  if pct_health &gt; 100 then
    GUI.Enemy:setValue(100, 100)
  else
    GUI.Enemy:setValue(pct_health, 100)
  end
end

function GUI.updateActionIcons()
  -- Check if ACTIONS data exists
  if not msdp.ACTIONS then
    -- No ACTIONS data yet, skip update
    return
  end
  
  -- Ensure action icons exist before updating
  if not GUI.StandardActionIcon or not GUI.MoveActionIcon or not GUI.SwiftActionIcon then
    print("[GUI] Action icons not initialized yet")
    return
  end
  
  -- Update Standard Action icon
  if msdp.ACTIONS.STANDARD_ACTION == "1" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-standard.png");]]
    )
    GUI.StandardActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  elseif msdp.ACTIONS.STANDARD_ACTION == "0" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-standard-50.png");]]
    )
    GUI.StandardActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  end
  
  -- Update Move Action icon
  if msdp.ACTIONS.MOVE_ACTION == "1" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-move.png");]]
    )
    GUI.MoveActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  elseif msdp.ACTIONS.MOVE_ACTION == "0" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-move-50.png");]]
    )
    GUI.MoveActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  end
  
  -- Update Swift Action icon
  if msdp.ACTIONS.SWIFT_ACTION == "1" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-swift.png");]]
    )
    GUI.SwiftActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  elseif msdp.ACTIONS.SWIFT_ACTION == "0" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-swift-50.png");]]
    )
    GUI.SwiftActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  end
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Config</name>
						<packageName></packageName>
						<script>  -- CRITICAL: These initialization calls MUST remain outside any function!
  -- Mudlet requires GUI elements to be created immediately when the script loads.
  -- Moving these inside GUI.init() or any other function will cause complete failure.
  -- The GUI background, borders, and boxes must exist before any other initialization.
  -- This needs to be outside the config, since YATCO needs to have the boxes set.
	GUI.image_location = getMudletHomeDir():gsub("\\", "/") .. "/LuminariGUI/images/"
	GUI.init_background()
  GUI.set_borders()
  GUI.init_boxes()
	
function GUI.init()
  GUI.AffectIcons = GUI.AffectIcons or {}
  GUI.Affects = GUI.Affects or {}
  GUI.Affects.Rows = GUI.Affects.Rows or {}
  GUI.Affects.Modes = GUI.Affects.Modes or {}
  --
  GUI.init_gauges()
  GUI.init_action_icons()
  --GUI.init_header_icons()
  GUI.tabbedInfoWindow.init()
  GUI.init_player()
  GUI.init_group()
  GUI.Affects.init()
  GUI.draw_frames()
	GUI.buttonWindow.init()
  GUI.init_castConsole()
  GUI.styleScrollbar()
	
  -- Register all event handlers with error handling
  GUI.registerEventHandlers()
  
  -- Ensure proper z-order of adjustable containers
  tempTimer(0.5, function()
    -- Bring containers to front in correct order
    -- Map should be at the back
    if map and map.container then
      map.container:show()
    end
    if GUI.chatContainer then
      GUI.chatContainer:show()
    end
    if GUI.roomInfoContainer then
      GUI.roomInfoContainer:show()
      GUI.roomInfoContainer:raise()  -- Bring above map
    end
    if GUI.buttonPanelContainer then
      GUI.buttonPanelContainer:show()
      GUI.buttonPanelContainer:raise()  -- Bring to front
    end
    if GUI.actionIconsContainer then
      GUI.actionIconsContainer:show()
      GUI.actionIconsContainer:raise()  -- Bring to front
    end
  end)
  
  -- Mark GUI as initialized for the refresh system
  GUI.initialized = true
end

-- Robust event handler registration with error handling and verification
function GUI.registerEventHandlers()
  -- Define all event handlers in a table for easy management
  local eventHandlers = {
    -- GUI event handlers
    ["msdp.GROUP"] = "GUI.updateGroup",
    ["msdp.AFFECTS"] = "GUI.updateAffectIcons",
    ["sysProtocolEnabled"] = "GUI.onProtocolEnabled",
    ["msdp.HEALTH"] = "GUI.updateHealthGauge",
    ["msdp.HEALTH_MAX"] = "GUI.updateHealthGauge",
    ["msdp.OPPONENT_HEALTH"] = "GUI.updateEnemyGauge",
    ["msdp.OPPONENT_HEALTH_MAX"] = "GUI.updateEnemyGauge",
    ["msdp.OPPONENT_NAME"] = "GUI.updateEnemyGauge",
    ["msdp.MOVEMENT"] = "GUI.updateMovesGauge",
    ["msdp.MOVEMENT_MAX"] = "GUI.updateMovesGauge",
    -- ["msdp.EXPERIENCE"] = "GUI.updateExperienceGauge",
    -- ["msdp.EXPERIENCE_TNL"] = "GUI.updateExperienceGauge",
    ["msdp.PSP"] = "GUI.updatePSPGauge",
    ["msdp.PSP_MAX"] = "GUI.updatePSPGauge",
    ["msdp.ACTIONS"] = "GUI.updateActionIcons",
    ["msdp.CHARACTER_NAME"] = "GUI.updatePlayer",
    ["msdp.RACE"] = "GUI.updatePlayer",
    ["msdp.CLASS"] = "GUI.updatePlayer",
    ["msdp.ALIGNMENT"] = "GUI.updatePlayer",
    ["msdp.LEVEL"] = "GUI.updatePlayer",
    ["msdp.STR"] = "GUI.updatePlayer",
    ["msdp.DEX"] = "GUI.updatePlayer",
    ["msdp.CON"] = "GUI.updatePlayer",
    ["msdp.INT"] = "GUI.updatePlayer",
    ["msdp.WIS"] = "GUI.updatePlayer",
    ["msdp.CHA"] = "GUI.updatePlayer",
    ["msdp.AC"] = "GUI.updatePlayer",
    ["msdp.MONEY"] = "GUI.updatePlayer",
    -- Room update for GUI display
    ["msdp.ROOM"] = "GUI.updateRoom",
    -- Map event handlers (non-MSDP)
    ["shiftRoom"] = "map.eventHandler",
    ["sysConnectionEvent"] = "map.eventHandler",
    ["sysDownloadDone"] = "map.eventHandler"
  }
  
  -- Register MSDP.ROOM for map separately
  -- NOTE: Both GUI.updateRoom and map.eventHandler need to handle msdp.ROOM events:
  -- - GUI.updateRoom: Updates the room info display in the GUI
  -- - map.eventHandler: Updates mapper position and handles environment transitions
  -- Mudlet allows multiple handlers for the same event, so both will fire
  local mapEventHandlers = {
    ["msdp.ROOM"] = "map.eventHandler",
    ["sysProtocolEnabled"] = "map.onProtocolEnabled"
  }
  
  -- Store handler IDs for potential cleanup
  GUI.eventHandlerIds = GUI.eventHandlerIds or {}
  
  -- Register GUI event handlers
  for event, handler in pairs(eventHandlers) do
    local success, handlerId = pcall(registerAnonymousEventHandler, event, handler)
    if success then
      GUI.eventHandlerIds[event] = handlerId
      -- Optional: uncomment for debugging
      -- print(string.format(" Registered GUI handler for %s", event))
    else
      print(string.format(" Failed to register GUI handler for %s: %s", event, handlerId))
    end
  end
  
  -- Register map event handlers separately
  for event, handler in pairs(mapEventHandlers) do
    local success, handlerId = pcall(registerAnonymousEventHandler, event, handler)
    if success then
      GUI.eventHandlerIds[event .. "_map"] = handlerId
      -- Optional: uncomment for debugging
      -- print(string.format(" Registered map handler for %s", event))
    else
      print(string.format(" Failed to register map handler for %s: %s", event, handlerId))
    end
  end
  
  -- Verify critical handlers are working and refresh displays
  tempTimer(2, function()
    -- Group tab refresh
    if msdp.GROUP and #msdp.GROUP > 0 then
      GUI.updateGroup()
    end
    
    -- Gauge refreshes
    if msdp.HEALTH and msdp.HEALTH_MAX then
      GUI.updateHealthGauge()
    end
    if msdp.MOVEMENT and msdp.MOVEMENT_MAX then
      GUI.updateMovesGauge()
    end
    -- if msdp.EXPERIENCE and msdp.EXPERIENCE_TNL then
    --   GUI.updateExperienceGauge()
    -- end
    if msdp.PSP and msdp.PSP_MAX then
      GUI.updatePSPGauge()
    end
    
    -- Enemy gauge refresh (only if opponent data exists)
    if msdp.OPPONENT_NAME and msdp.OPPONENT_NAME ~= "" then
      GUI.updateEnemyGauge()
    else
      -- Hide enemy gauge if not in combat
      if GUI.Enemy then
        GUI.Enemy:hide()
      end
    end
    
    -- Player tab refresh
    if msdp.CHARACTER_NAME then
      GUI.updatePlayer()
    end
    
    -- Room info refresh
    if msdp.ROOM then
      GUI.updateRoom()
    end
  end)
  
  -- Initialize chat system if it's enabled but not created
  tempTimer(1, function()
    if demonnic.chat.use and not demonnic.chat.container then
      demonnicOnStart()
    end
  end)
end

-- =============================================================================
-- CENTRALIZED GUI INITIALIZATION SYSTEM
-- =============================================================================
-- This function provides a single point of control for all GUI initialization
-- and refresh operations. It should be called from ALL relevant entry points.
--
-- WHEN TO CALL THIS FUNCTION:
-- 1. Package load/install (sysLoadEvent, sysInstall) 
-- 2. Connection established (sysConnectionEvent)
-- 3. MSDP protocol enabled (sysProtocolEnabled)
-- 4. Manual refresh commands (fix gui, fix chat)
-- 5. After login/reconnect (when MSDP data starts flowing)
--
-- WHAT IT DOES:
-- - Initializes or refreshes all GUI components
-- - Re-registers event handlers that may have failed
-- - Refreshes all displays with current MSDP data
-- - Ensures proper container visibility and z-order
-- - Handles both initial setup and runtime refresh
-- =============================================================================
function GUI.initializeOrRefresh(context)
  context = context or "unknown"
  
  -- Track if this is initial setup or refresh
  local isRefresh = (GUI.initialized == true)
  
  if not isRefresh then
    -- GUI not initialized yet - initialize it now
    cecho(string.format("\n&lt;yellow&gt;Initializing GUI components (%s)...", context))
    GUI.init()
    return
  else
    -- Refresh existing GUI
    cecho(string.format("\n&lt;yellow&gt;Refreshing GUI components (%s)...", context))
  end
  
  -- Always ensure event handlers are registered
  GUI.registerEventHandlers()
  
  -- Refresh all adjustable containers
  local refreshed = {}
  
  -- Status Gauges
  if GUI.Box7 then
    GUI.Box7:show()
    GUI.Box7:raise()
    if msdp.HEALTH then GUI.updateHealthGauge() end
    if msdp.MOVEMENT then GUI.updateMovesGauge() end
    -- if msdp.EXPERIENCE then GUI.updateExperienceGauge() end
    if msdp.PSP then GUI.updatePSPGauge() end
    table.insert(refreshed, "status gauges")
  end
  
  -- TabbedInfo Window
  if GUI.tabbedInfoWindowContainer then
    GUI.tabbedInfoWindowContainer:show()
    GUI.tabbedInfoWindowContainer:raise()
    -- Ensure Player tab is visible and updated
    if GUI.tabbedInfoWindow and GUI.tabbedInfoWindow.Player then
      GUI.tabbedInfoWindow.click("Player")
      if msdp.CHARACTER_NAME then GUI.updatePlayer() end
    end
    table.insert(refreshed, "tabbed info window")
  end
  
  -- Action Icons
  if GUI.actionIconsContainer then
    GUI.actionIconsContainer:show()
    GUI.actionIconsContainer:raise()
    if msdp.ACTIONS then GUI.updateActionIcons() end
    table.insert(refreshed, "action icons")
  end
  
  -- Enemy gauge (combat only)
  if msdp.OPPONENT_NAME and msdp.OPPONENT_NAME ~= "" then
    GUI.updateEnemyGauge()
  elseif GUI.Enemy then
    GUI.Enemy:hide()
  end
  
  -- Group tab
  if GUI.groupWindow and msdp.GROUP then
    GUI.updateGroup()
    table.insert(refreshed, "Group tab")
  end
  
  -- Player tab
  if GUI.playerWindow and msdp.CHARACTER_NAME then
    GUI.updatePlayer()
    table.insert(refreshed, "Player tab")
  end
  
  -- Room info
  if GUI.Box5 and msdp.ROOM then
    GUI.updateRoom()
    table.insert(refreshed, "room info")
  end
  
  -- ASCII map
  if map.minimap and msdp.ROOM then
    map.eventHandler("msdp.ROOM")
    table.insert(refreshed, "ASCII map")
  end
  
  -- Mudlet mapper
  if map.mapwindow then
    map.mapwindow:show()
    map.mapwindow:resize()
    -- Force refresh with delayed operations
    tempTimer(0.1, function()
      if map.mapwindow then
        map.mapwindow:resize()
        if map.mapwindow.raise then
          map.mapwindow:raise()
        end
        -- Try to center on current room
        if map.currentRoom and map.currentRoom > 0 then
          centerview(map.currentRoom)
        end
      end
    end)
    table.insert(refreshed, "Mudlet mapper")
  end
  
  -- Chat system
  if GUI.chatContainer then
    GUI.chatContainer:show()
    -- Initialize chat if needed
    if demonnic.chat.use and not demonnic.chat.container then
      demonnicOnStart()
      table.insert(refreshed, "chat system (initialized)")
    else
      table.insert(refreshed, "chat container")
    end
  end
  
  -- Button Panel (Controls)
  if GUI.buttonPanelContainer then
    GUI.buttonPanelContainer:show()
    GUI.buttonPanelContainer:raise()
    table.insert(refreshed, "button panel")
  end
  
  -- Room Info Container
  if GUI.roomInfoContainer then
    GUI.roomInfoContainer:show()
    GUI.roomInfoContainer:raise()
    -- Update room data if available
    if msdp.ROOM then
      GUI.updateRoom()
    end
    table.insert(refreshed, "room info container")
  end
  
  -- Cast Console
  if GUI.castConsoleContainer then
    GUI.castConsoleContainer:show()
    GUI.castConsoleContainer:raise()
    table.insert(refreshed, "cast console")
  end
  
  -- ASCII Map Container (ensure it exists before mode check)
  if GUI.asciiMapContainer then
    GUI.asciiMapContainer:show()
    table.insert(refreshed, "ASCII map container")
  end
  
  -- Handle map container visibility based on mode
  if GUI.buttonWindow and GUI.buttonWindow.mudletOrAscii then
    if GUI.buttonWindow.mudletOrAscii == "ASCII" then
      if map.container then map.container:hide() end
      if GUI.asciiMapContainer then
        GUI.asciiMapContainer:raise()
      end
    else
      if GUI.asciiMapContainer then GUI.asciiMapContainer:hide() end
      if map.container then
        map.container:show()
        map.container:raise()
      end
    end
  end
  
  -- Ensure proper z-order (delayed to allow all components to initialize)
  tempTimer(0.5, function()
    -- Let Adjustable Containers manage their own z-order
    -- Only raise containers that need to be on top of others
    if GUI.chatContainer then GUI.chatContainer:raise() end
    if GUI.actionIconsContainer then GUI.actionIconsContainer:raise() end
  end)
  
  -- Report results
  if #refreshed > 0 then
    cecho(string.format("\n&lt;green&gt;%s complete: %s", 
      isRefresh and "Refresh" or "Initialization",
      table.concat(refreshed, ", ")))
  end
end

-- =============================================================================
-- ENTRY POINT HANDLERS
-- These ensure GUI.initializeOrRefresh is called at the right times
-- while preserving other initialization functions
-- =============================================================================

-- The onProtocolEnabled handler is defined in the MSDP script section
-- It handles MSDP variable registration and GUI initialization

-- The main initialization handlers are registered at the bottom of this script
-- along with the original GUI.init() registration to ensure proper order

-- Register the proper initialization sequence
registerAnonymousEventHandler("sysLoadEvent", "GUI.init")
registerAnonymousEventHandler("sysInstall", "GUI.init")

-- Register protocol handler early to ensure it catches MSDP enablement
-- This is critical because MSDP can be enabled before GUI.init() completes
registerAnonymousEventHandler("sysProtocolEnabled", "GUI.onProtocolEnabled")

-- Add connection-based refresh
registerAnonymousEventHandler("sysConnectionEvent", function()
  tempTimer(1, function()
    GUI.initializeOrRefresh("connection established")
  end)
end)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>AdjustableContainers</name>
						<packageName></packageName>
						<script>-- GUI.AdjustableContainers - Foundation for Adjustable Container System
-- This namespace manages all adjustable containers in the LuminariGUI

GUI.AdjustableContainers = GUI.AdjustableContainers or {}

-- Container registry for lifecycle management
GUI.AdjustableContainers.containers = GUI.AdjustableContainers.containers or {}

-- Current active layout profile
GUI.AdjustableContainers.currentProfile = GUI.AdjustableContainers.currentProfile or "default"

-- Save/Load directory configuration
GUI.AdjustableContainers.saveDir = string.format("%s/LuminariGUI/layouts/", getMudletHomeDir())

-- Default container styles matching current theme
GUI.AdjustableContainers.defaultStyle = {
  adjLabelstyle = [[
    background-image: url(]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/ui_texture.jpg);
    background-color: rgba(38, 25, 47, 0.9);
    border: 2px solid rgba(184, 115, 27, 0.8);
    border-radius: 5px;
    padding: 5px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
    font-family: Tahoma, Geneva, sans-serif;
  ]],
  buttonstyle = [[
    QLabel { 
      border-radius: 7px; 
      background-color: rgba(100,100,100,100%); 
      border: 1px solid rgba(184, 115, 27, 0.5);
    }
    QLabel::hover { 
      background-color: rgba(120,120,120,100%); 
      border: 1px solid rgba(184, 115, 27, 0.8);
      box-shadow: 0px 0px 3px rgba(184, 115, 27, 0.5);
    }
    QLabel::pressed {
      background-color: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(184, 115, 27, 1.0);
    }
  ]],
  titleTxtColor = "#FFD700",  -- Golden color for better contrast
  buttonFontSize = 10,
  buttonsize = 20,
  padding = 5,
  autoSave = true,
  autoLoad = true,
  noClose = true,
  defaultDir = GUI.AdjustableContainers.saveDir
}

-- Container naming convention
function GUI.AdjustableContainers.generateName(baseName)
  return "LuminariGUI_" .. baseName
end

-- Container registration system
function GUI.AdjustableContainers.register(container, name, componentType)
  if not container then
    print("ERROR: Cannot register nil container: " .. (name or "unknown"))
    return false
  end
  
  local containerInfo = {
    container = container,
    name = name,
    componentType = componentType,
    created = os.time(),
    profile = GUI.AdjustableContainers.currentProfile
  }
  
  GUI.AdjustableContainers.containers[name] = containerInfo
  print(" Registered container: " .. name .. " (" .. componentType .. ")")
  return true
end

-- Container lifecycle management
function GUI.AdjustableContainers.create(name, componentType, config)
  local fullName = GUI.AdjustableContainers.generateName(name)
  
  -- Merge default style with custom config
  local containerConfig = {}
  for k, v in pairs(GUI.AdjustableContainers.defaultStyle) do
    containerConfig[k] = v
  end
  if config then
    for k, v in pairs(config) do
      containerConfig[k] = v
    end
  end
  
  -- Set the container name
  containerConfig.name = fullName
  
  -- Create the adjustable container
  local container = Adjustable.Container:new(containerConfig)
  
  if container then
    GUI.AdjustableContainers.register(container, fullName, componentType)
    return container
  else
    print("ERROR: Failed to create container: " .. fullName)
    return nil
  end
end

function GUI.AdjustableContainers.show(name)
  local containerInfo = GUI.AdjustableContainers.containers[name]
  if containerInfo and containerInfo.container then
    containerInfo.container:show()
    return true
  end
  return false
end

function GUI.AdjustableContainers.hide(name)
  local containerInfo = GUI.AdjustableContainers.containers[name]
  if containerInfo and containerInfo.container then
    containerInfo.container:hide()
    return true
  end
  return false
end

function GUI.AdjustableContainers.destroy(name)
  local containerInfo = GUI.AdjustableContainers.containers[name]
  if containerInfo and containerInfo.container then
    containerInfo.container:hide()
    -- Note: Adjustable containers handle their own cleanup
    GUI.AdjustableContainers.containers[name] = nil
    print(" Destroyed container: " .. name)
    return true
  end
  return false
end

-- Layout Profile System
GUI.AdjustableContainers.profiles = {
  default = {
    name = "Default Layout",
    description = "Standard layout for general gameplay",
    containers = {
      chat = { x = "25%", y = "-25%", width = "50%", height = "25%" },
      gauges = { x = "0%", y = "75%", width = "25%", height = "25%" },
      tabinfo = { x = "0%", y = "0%", width = "25%", height = "75%" },
      room = { x = "-25%", y = "15%", width = "25%", height = "35%" },
      buttons = { x = "-25%", y = "0%", width = "25%", height = "15%" },
      actions = { x = "-25%", y = "50%", width = "25%", height = "35%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  },
  combat = {
    name = "Combat Layout",
    description = "Optimized for combat situations",
    containers = {
      chat = { x = "25%", y = "-25%", width = "50%", height = "25%" },
      gauges = { x = "0%", y = "75%", width = "25%", height = "25%" },
      tabinfo = { x = "0%", y = "0%", width = "25%", height = "75%" },
      room = { x = "-25%", y = "15%", width = "25%", height = "35%" },
      buttons = { x = "-25%", y = "0%", width = "25%", height = "15%" },
      actions = { x = "-25%", y = "50%", width = "25%", height = "35%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  },
  social = {
    name = "Social Layout", 
    description = "Emphasizes chat and communication",
    containers = {
      chat = { x = "25%", y = "-40%", width = "50%", height = "40%" },
      gauges = { x = "0%", y = "85%", width = "25%", height = "15%" },
      tabinfo = { x = "0%", y = "0%", width = "25%", height = "85%" },
      room = { x = "-25%", y = "15%", width = "25%", height = "35%" },
      buttons = { x = "-25%", y = "0%", width = "25%", height = "15%" },
      actions = { x = "-25%", y = "50%", width = "25%", height = "35%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  },
  minimal = {
    name = "Minimal Layout",
    description = "Minimalist layout for maximum game text visibility",
    containers = {
      chat = { x = "20%", y = "-20%", width = "60%", height = "20%" },
      gauges = { x = "0%", y = "80%", width = "20%", height = "20%" },
      tabinfo = { x = "0%", y = "0%", width = "20%", height = "80%" },
      room = { x = "-20%", y = "10%", width = "20%", height = "30%" },
      buttons = { x = "-20%", y = "0%", width = "20%", height = "10%" },
      actions = { x = "-20%", y = "40%", width = "20%", height = "30%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  }
}

-- Profile management functions
function GUI.AdjustableContainers.switchProfile(profileName)
  if not GUI.AdjustableContainers.profiles[profileName] then
    print("ERROR: Profile '" .. profileName .. "' does not exist")
    return false
  end
  
  print("Switching to profile: " .. GUI.AdjustableContainers.profiles[profileName].name)
  GUI.AdjustableContainers.currentProfile = profileName
  
  -- Apply profile to all containers
  local profile = GUI.AdjustableContainers.profiles[profileName]
  for containerName, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    local componentType = containerInfo.componentType
    local profileConfig = profile.containers[componentType]
    
    if profileConfig and containerInfo.container then
      containerInfo.container:move(profileConfig.x, profileConfig.y)
      containerInfo.container:resize(profileConfig.width, profileConfig.height)
    end
  end
  
  print(" Applied profile: " .. profileName)
  return true
end

function GUI.AdjustableContainers.saveProfile(profileName)
  if not profileName then
    profileName = GUI.AdjustableContainers.currentProfile
  end
  
  print("Saving profile: " .. profileName)
  Adjustable.Container:saveAll(profileName)
  print(" Profile saved: " .. profileName)
end

function GUI.AdjustableContainers.loadProfile(profileName)
  if not profileName then
    profileName = GUI.AdjustableContainers.currentProfile
  end
  
  print("Loading profile: " .. profileName)
  Adjustable.Container:loadAll(profileName)
  GUI.AdjustableContainers.currentProfile = profileName
  print(" Profile loaded: " .. profileName)
end

function GUI.AdjustableContainers.resetProfile(profileName)
  if not profileName then
    profileName = GUI.AdjustableContainers.currentProfile
  end
  
  print("Resetting profile: " .. profileName)
  GUI.AdjustableContainers.switchProfile(profileName)
  GUI.AdjustableContainers.saveProfile(profileName)
  print(" Profile reset: " .. profileName)
end

-- Container utility functions
function GUI.AdjustableContainers.showAll()
  for name, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    if containerInfo.container then
      containerInfo.container:show()
    end
  end
  print(" All containers shown")
end

function GUI.AdjustableContainers.hideAll()
  for name, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    if containerInfo.container then
      containerInfo.container:hide()
    end
  end
  print(" All containers hidden")
end

function GUI.AdjustableContainers.listContainers()
  print("=== LuminariGUI Container Registry ===")
  print("Current Profile: " .. GUI.AdjustableContainers.currentProfile)
  print("Save Directory: " .. GUI.AdjustableContainers.saveDir)
  print("")
  
  for name, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    local status = containerInfo.container and "" or ""
    print(string.format("%s %s (%s)", status, name, containerInfo.componentType))
  end
  
  print("")
  print("Available Profiles:")
  for profileName, profile in pairs(GUI.AdjustableContainers.profiles) do
    local marker = (profileName == GUI.AdjustableContainers.currentProfile) and "* " or "  "
    print(string.format("%s%s - %s", marker, profile.name, profile.description))
  end
end

-- Initialize the directory structure
function GUI.AdjustableContainers.init()
  -- Create save directory if it doesn't exist
  lfs.mkdir(GUI.AdjustableContainers.saveDir)
  
  -- Save default profile on first run
  if not io.exists(GUI.AdjustableContainers.saveDir .. "default.json") then
    GUI.AdjustableContainers.saveProfile("default")
  end
  
  print(" AdjustableContainers initialized")
  print("  Save Directory: " .. GUI.AdjustableContainers.saveDir)
  print("  Current Profile: " .. GUI.AdjustableContainers.currentProfile)
end

-- Register initialization
registerAnonymousEventHandler("sysLoadEvent", "GUI.AdjustableContainers.init")
registerAnonymousEventHandler("sysInstall", "GUI.AdjustableContainers.init")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Custom Scrollbar</name>
						<packageName></packageName>
						<script>function GUI.styleScrollbar()
  local background_color = "#202020"
  local handle_color = "#d0d0d0"     -- Light gray for visible handles
  local border_color = "#a0a0a0"     -- Light border for handle outline
  setProfileStyleSheet(
    [[
  QScrollBar:vertical {
     background: ]] ..
    background_color ..
    [[;
     width: 15px;
     margin: 22px 0 22px 0;
  }
  QScrollBar:horizontal {
     background: ]] ..
    background_color ..
    [[;
     height: 15px;
     margin: 0 22px 0 22px;
  }
  QScrollBar::handle:vertical {
     background-color: ]] ..
    handle_color ..
    [[;
     min-height: 20px;
     border-width: 2px;
     border-style: solid;
     border-color: ]] ..
    border_color ..
    [[;
     border-radius: 7px;
  }
  QScrollBar::handle:horizontal {
     background-color: ]] ..
    handle_color ..
    [[;
     min-width: 20px;
     border-width: 2px;
     border-style: solid;
     border-color: ]] ..
    border_color ..
    [[;
     border-radius: 7px;
  }
  QScrollBar::add-line:vertical {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-bottom-left-radius: 7px;
   border-bottom-right-radius: 7px;
        height: 15px;
        subcontrol-position: bottom;
        subcontrol-origin: margin;
  }
  QScrollBar::add-line:horizontal {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-bottom-right-radius: 7px;
   border-top-right-radius: 7px;
        width: 15px;
        subcontrol-position: right;
        subcontrol-origin: margin;
  }
  QScrollBar::sub-line:vertical {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-top-left-radius: 7px;
   border-top-right-radius: 7px;
        height: 15px;
        subcontrol-position: top;
        subcontrol-origin: margin;
  }
  QScrollBar::sub-line:horizontal {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-bottom-left-radius: 7px;
   border-top-left-radius: 7px;
        width: 15px;
        subcontrol-position: left;
        subcontrol-origin: margin;
  }
  QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
     background: #404040;
     width: 4px;
     height: 3px;
  }
  QScrollBar::left-arrow:horizontal, QScrollBar::right-arrow:horizontal {
     background: #404040;
     width: 3px;
     height: 4px;
  }
  QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
     background: none;
  }
  QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {
     background: none;
  }
]]
  )
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Delete Line and  Prompt</name>
						<packageName></packageName>
						<script>function deleteLineP()
  deleteLine()
  tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>YATCOConfig</name>
				<packageName>YATCOConfig</packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>YATCOCONFIG</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.config = demonnic.chat.config or {}</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Configuration Options</name>
						<packageName></packageName>
						<script>--[[
This is where all of the configuration options can be set. 
Anything I've put in this script object can be changed, but please do pay attention to what you're doing.
If you change one of the values to something it shouldn't be, you could break it. 
]]

--This is where you tell it to use tabbed chat.
demonnic.chat.use = true

--[[
This is where you put what container to put the tabbed chat stuff into. Make it
equal to the actual container object you want it in, or false for none. Defaults to false
Which is to say if you want to put the tabbed chat stuff into a container made using 
uiRight = Geyser.Container:new()

you would put

demonnic.chat.useContainer = uiRight

and if you don't want it in a container you would put

demonnic.chat.useContainer = false
]]

-- Chat container will be set after GUI initialization
demonnic.chat.useContainer = false

--[[
The timestamp option is set here.
Set to false if you do not want any timestamps displayed for chat.
If you do want it displayed, set to the string for the format you wish. 
see http://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for information
how to format the string
]]
--demonnic.chat.config.timestamp = "HH:mm:ss"
demonnic.chat.config.timestamp = false

--[[ Should we use our own colors for the timestamp?
Set to true if you want to specify foreground and background colors
for the timestamp.
Set to false if you want the timestamps background and foreground
colors to match that of the mud output.
]]
demonnic.chat.config.timestampCustomColor = false
--[[
and what foreground color? You can either use one of the 'named' colors
(see http://wiki.mudlet.org/images/c/c3/ShowColors.png for available colors)
demonnic.chat.config.timestampFG = "slate_grey"

Or you can use a table of R,G,B values. 
demonnic.chat.config.timestampFG = {
  255,
    0,
    0,
}
then the foreground for the timestamp would be 255 read, 100 green, and 0 blue
]]
demonnic.chat.config.timestampFG = "red"

--and background? Same rules as for the foreground above
demonnic.chat.config.timestampBG = "blue"

--[[
This is where you say what corner of the screen you want the tabbed chat on
Valid settings are "topright", "topleft", "bottomright", "bottomleft"
]]--
demonnic.chat.config.location = "topright"

--[[
This is a table of channels you would like.
AKA the place you tell the script what tabs you want.
Each entry must be a string. The defaults should be a pretty effective guide.
]]

demonnic.chat.config.channels = {
  "All",
  "Tell",
  "Chat",
	"Say",
	"Wiz",
	"Group",
	"Congrats",
	"Auction",  
}


--Set this to the name of the channel you want to have everything sent to. 
--Per the default, this would be the "All" channel. If you have a different name for it:
--
--demonnic.chat.config.Alltab = "Bucket"  
--
--And if you don't want it turned on at all:
--
--demonnic.chat.config.Alltab = false

demonnic.chat.config.Alltab = "All"

--Set this to the name of the channel you want to display your map. Set to "" if you
--don't want to display the map in your YATCO tabs
demonnic.chat.config.Maptab = ""


---------------------------------------------------------------------------------
--                                                                             --
--The infamous blinking stuff!!!                                               --
--                                                                             --
---------------------------------------------------------------------------------

--[[
Do you want tabs to blink when you get new messages, until you click on the tab?
True if yes, false if no.
]]
demonnic.chat.config.blink = true

--How long (in seconds) between blinks? For example, 1 would mean a 1 second pause in between blinks.
demonnic.chat.config.blinkTime = 3

--Blink if the bucket tab ("All" by default, but configured above) is in focus?
demonnic.chat.config.blinkFromAll = false

-- Sound notification settings
demonnic.chat.config.soundEnabled = demonnic.chat.config.soundEnabled or false  -- Default OFF
demonnic.chat.config.soundFile = demonnic.chat.config.soundFile or "audio/chat_sound.mp3"   -- Default sound file
demonnic.chat.config.soundVolume = demonnic.chat.config.soundVolume or 100      -- Volume 0-100
demonnic.chat.config.soundCooldown = demonnic.chat.config.soundCooldown or 0      -- Cooldown in seconds (0 = no cooldown)
demonnic.chat.lastSoundTime = demonnic.chat.lastSoundTime or 0                   -- Track last sound timestamp




--Font size for the chat messages

demonnic.chat.config.fontSize = getFontSize("main")

--[[
Should we preserve the formatting of the text. 
Or should we set the background of it to match the window color?
Set this to false if you want the background for all chat to match the background of the window.
Useful if you change the background from black, and don't like the way the pasted chat makes blocks in it
]]

demonnic.chat.config.preserveBackground = true

--[[
Gag the chat lines in the main window?
defaults to false, set to true if you want to gag.
]]

demonnic.chat.config.gag = false

--[[
Number of lines of chat visible at once. 
Will determine how tall the window for the chats is.
]]

demonnic.chat.config.lines = 22

--[[
Number of characters to wrap the chatlines at.
This will also determine how wide the chat windows are.
]]

demonnic.chat.config.width = getColumnCount("main")

--[[
Set the color for the active tab. R,G,B format.
The default here is a brightish green
]]

demonnic.chat.config.activeColors = {
  r = 0,
  g = 180,
  b = 0,
}

--[[
Set the color for the inactive tab. R,G,B format.
The default here is a drab grey
]]

demonnic.chat.config.inactiveColors = {
  r = 60,
  g = 60,
  b = 60,
}

--[[
Set the color for the chat window itself. R,G,B format.
Defaulted to the black of my twisted hardened soul. Or something.
]]

demonnic.chat.config.windowColors = {
  r = 0,
  g = 0,
  b = 0,
}

--[[
Set the color for the text on the active tab. Uses color names.
Set the default to purple. So the tab you're looking at, by default will be purple on bright green. 
Did I mention I'm a bit colorblind?
]]

demonnic.chat.config.activeTabText = "yellow"

--[[
Set the color for the text on the inactive tabs. Uses color names.
Defaulted this to white. So the tabs you're not looking at will be white text on boring grey background.
]]

demonnic.chat.config.inactiveTabText = "white"

--[[
have to make sure a currentTab is set... 
so we'll use the one for the bucket, or the first one in the channels table
Or, you know... what it's currently set to, if it's already set.
]]
demonnic.chat.currentTab = demonnic.chat.currentTab or demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>YATCO</name>
				<packageName>YATCO</packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Demonnic</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>Shared</name>
						<packageName></packageName>
						<script>--Bootstrapping variables/etc. Don't touch this unless you really know what you're doing

--I mean it. I'll point. AND laugh. loudly. 
demonnic = demonnic or {}
demonnic.config = demonnic.config or {}
demonnic.balances = demonnic.balances or {}
demonnic.balances.balance = demonnic.balances.balance or 1
demonnic.balances.equilibrium = demonnic.balances.equilibrium or 1
demonnic.debug = demonnic.debug or {}
demonnic.debug.active = demonnic.debug.active or nil
demonnic.debug.categories = demonnic.debug.categories or { }


function demonnic:echo(msg)
 cecho(string.format("\n&lt;blue&gt;(&lt;green&gt;Demonnic&lt;blue&gt;):&lt;white&gt; %s", msg))
end</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>Debugging</name>
							<packageName></packageName>
							<script>--Adds debugging functionality 

function demonnic:Debug(category,debugData)
   if category then
      if table.contains(demonnic.debug.categories, category) then
         if type(debugData) == "table" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt;")
            display(debugData)
         elseif type(debugData) == "string" or type(debugData) == "number" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. debugData .. "\n" )
         else
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. tostring(debugData) .. "\n" )
         end
      end
   else
      if type(debugData) == "table" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt;")
         display(debugData)
      elseif type(debugData) == "string" or type(debugData) == "number" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. debugData)
      else
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. tostring(debugData))
      end
   end
end

function demonnic:printDebug(category, debugData)
   if not demonnic.debug.active then return end
   demonnic:Debug(category, debugData)
end

function demonnic:toggleDebug()
   if demonnic.debug.active then demonnic.debug.active = nil
   else demonnic.debug.active = true
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:watchCategory( category )
   if table.contains(demonnic.debug.categories, category) then
      for i,v in ipairs(demonnic.debug.categories) do
         if v == category then
            table.remove(demonnic.debug.categories, i)
         end
      end
      demonnic:echo("No longer watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.") 
   else
      table.insert(demonnic.debug.categories, category)
      demonnic:echo("Now watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.")
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:listCategories()
   if #demonnic.debug.categories &gt; 0 then
      demonnic:echo("You are currently watching the following categories:\n" .. table.concat(demonnic.debug.categories,", ") )
   else
      demonnic:echo("You are not watching any debugs.")
   end
end
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>Geyser Additions</name>
							<packageName></packageName>
							<script>function Geyser.MiniConsole:clear()
   clearWindow(self.name)
end

function Geyser.MiniConsole:append()
  appendBuffer(self.name)
end</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>Tabbed Chat</name>
						<packageName></packageName>
						<script>--Do not remove the following lines. Or change them.
demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.tabsToBlink = demonnic.chat.tabsToBlink or {}
demonnic.chat.tabs = demonnic.chat.tabs or {}
demonnic.chat.windows = demonnic.chat.windows or {}
if not demonnic.chat.config then
  cecho("&lt;red:white&gt;YOU DO NOT HAVE THE YATCO CONFIG PACKAGE IN PLACE. THINGS WILL NOT WORK AS EXPECTED\n\n")
  demonnic.chat.error = "NO CONFIG"
end</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>Code</name>
							<packageName></packageName>
							<script>--[[
If the label callbacks ever decide to start taking a function which is part of a table, 0then this will change.
Or if it's modified to take actual functions. Anonymouse function clickcallback would be awfully nice.
]]

function demonnicChatSwitch(chat)
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local newr = demonnic.chat.config.activeColors.r
  local newg = demonnic.chat.config.activeColors.g
  local newb = demonnic.chat.config.activeColors.b
  local oldchat = demonnic.chat.currentTab
  if demonnic.chat.currentTab ~= chat then
    demonnic.chat.windows[oldchat]:hide()
    demonnic.chat.tabs[oldchat]:setColor(r,g,b)
    demonnic.chat.tabs[oldchat]:echo(oldchat, demonnic.chat.config.inactiveTabText, "c")
    if demonnic.chat.config.blink and demonnic.chat.tabsToBlink[chat] then
      demonnic.chat.tabsToBlink[chat] = nil
    end
    if demonnic.chat.config.blink and chat == demonnic.chat.config.Alltab then
      demonnic.chat.tabsToBlink = {}
    end
  end
  demonnic.chat.tabs[chat]:setColor(newr,newg,newb)
  demonnic.chat.tabs[chat]:echo(chat, demonnic.chat.config.activeTabText, "c")
  demonnic.chat.windows[chat]:show()
  demonnic.chat.currentTab = chat  
end

function demonnic.chat:resetUI()
  demonnic.chat.container = demonnic.chat.useContainer or Geyser.Container:new(demonnic.chat[demonnic.chat.config.location]())
  demonnic.chat.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "25px",
    name = "DemonChatTabs",
  },demonnic.chat.container)

end

function demonnic.chat:create()
  --reset the UI
  demonnic.chat:resetUI()
  --Set some variables locally to increase readability
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local winr = demonnic.chat.config.windowColors.r
  local wing = demonnic.chat.config.windowColors.g
  local winb = demonnic.chat.config.windowColors.b

  --iterate the table of channels and create some windows and tabs
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.tabs[tab] = Geyser.Label:new({
      name=string.format("tab%s", tab),
    }, demonnic.chat.tabBox)
    demonnic.chat.tabs[tab]:echo(tab, demonnic.chat.config.inactiveTabText, "c")
    demonnic.chat.tabs[tab]:setColor(r,g,b)
    demonnic.chat.tabs[tab]:setClickCallback("demonnicChatSwitch", tab)
		
		demonnic.chat.tabs[tab]:setStyleSheet(
		 [[font-family: Tahoma, Geneva, sans-serif; 
		border-image: url(]] ..
    getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
		border: 1px solid rgba(184, 115, 27, 0.5);
		border-radius: 3px 3px 0px 0px;
		padding: 2px;
		font-weight: bold;
		]])
		
    demonnic.chat.windows[tab] = Geyser.MiniConsole:new({
--      fontSize = demonnic.chat.config.fontSize,
      x = 0,
      y = 25,
      height = "100%",
      width = "100%",
      name = string.format("win%s", tab),
    }, demonnic.chat.container)
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
    demonnic.chat.windows[tab]:setColor(winr,wing,winb)
    demonnic.chat.windows[tab]:setWrap(demonnic.chat.config.width)
    demonnic.chat.windows[tab]:hide()
  end
  if demonnic.chat.config.Maptab and demonnic.chat.config.Maptab ~= "" then
    demonnic.chat.mapWindow = Geyser.Mapper:new({
      x = 0,
      y = 0,
      height = "100%",
      width = "100%",
    }, demonnic.chat.windows[demonnic.chat.config.Maptab])
    demonnic.chat.windows[demonnic.chat.config.Maptab]:hide()
  end
  local showme = demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
  demonnicChatSwitch(showme)
  --start the blink timers, if enabled
  if demonnic.chat.config.blink and not demonnic.chat.blinkTimerOn then
    demonnic.chat:blink()
  end
end

function demonnic.chat:append(chat)
  local r = demonnic.chat.config.windowColors.r
  local g = demonnic.chat.config.windowColors.g
  local b = demonnic.chat.config.windowColors.b
  selectCurrentLine()
  local ofr,ofg,ofb = getFgColor()
  local obr,obg,obb = getBgColor()
  if demonnic.chat.config.preserveBackground then
    setBgColor(r,g,b)
  end
  copy()
  if demonnic.chat.config.timestamp then
    local timestamp = getTime(true, demonnic.chat.config.timestamp)
    local tsfg = {}
    local tsbg = {}
    local colorLeader = ""
    if demonnic.chat.config.timestampCustomColor then
      if type(demonnic.chat.config.timestampFG) == "string" then
        tsfg = color_table[demonnic.chat.config.timestampFG]
      else
        tsfg = demonnic.chat.config.timestampFG
      end
      if type(demonnic.chat.config.timestampBG) == "string" then
        tsbg = color_table[demonnic.chat.config.timestampBG]
      else
        tsbg = demonnic.chat.config.timestampBG
      end
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",tsfg[1],tsfg[2],tsfg[3],tsbg[1],tsbg[2],tsbg[3])
    else
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",ofr,ofg,ofb,obr,obg,obb)
    end
    local fullstamp = string.format("%s%s",colorLeader,timestamp)
      demonnic.chat.windows[chat]:decho(fullstamp)
      demonnic.chat.windows[chat]:echo(" ")
      if demonnic.chat.config.Alltab then 
        demonnic.chat.windows[demonnic.chat.config.Alltab]:decho(fullstamp)
        demonnic.chat.windows[demonnic.chat.config.Alltab]:echo(" ")
      end
  end
  
  -- Add colored channel prefixes based on TASK_LIST.md requirements
  local channelColors = {
    ["Group"] = "&lt;green&gt;[GSAY]&lt;reset&gt; ",      -- Bright green for GSAY
    ["OOC"] = "&lt;light_gray&gt;[OOC]&lt;reset&gt; ",        -- Silver/Light gray for OOC
    ["Tell"] = "&lt;magenta&gt;[TELL]&lt;reset&gt; ",    -- Bright magenta for TELLS
    ["Say"] = "&lt;white&gt;[SAY]&lt;reset&gt; ",        -- White for SAYS
    ["Auction"] = "&lt;gold&gt;[AUC]&lt;reset&gt; ",     -- Gold for AUC
    ["Chat"] = "&lt;cyan&gt;[CHAT]&lt;reset&gt; ",       -- Default cyan for other chat
    ["Congrats"] = "&lt;yellow&gt;[GRATS]&lt;reset&gt; ", -- Yellow for congrats
    ["Wiz"] = "&lt;purple&gt;[WIZ]&lt;reset&gt; "        -- Purple for wizard channel
  }
  
  -- Add channel prefix before the message
  if channelColors[chat] then
    demonnic.chat.windows[chat]:cecho(channelColors[chat])
    if demonnic.chat.config.Alltab then
      demonnic.chat.windows[demonnic.chat.config.Alltab]:cecho(channelColors[chat])
    end
  end
  
  demonnic.chat.windows[chat]:append()
  if demonnic.chat.config.gag then 
    deleteLine() 
    tempLineTrigger(1,1, [[if isPrompt() then deleteLine() end]])
  end
  if demonnic.chat.config.Alltab then appendBuffer(string.format("win%s", demonnic.chat.config.Alltab)) end
  if demonnic.chat.config.blink and chat ~= demonnic.chat.currentTab then 
    if not ((demonnic.chat.config.Alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll) then
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
  
  -- Sound notification logic - play for ALL channels when enabled
  if demonnic.chat.config.soundEnabled then
    -- Check if we should play sound
    local shouldPlaySound = true
    
    -- Don't play sound if we're viewing the specific channel tab (not "All")
    if demonnic.chat.currentTab ~= demonnic.chat.config.Alltab and chat == demonnic.chat.currentTab then
      shouldPlaySound = false
    end
    
    if shouldPlaySound then
      -- Check cooldown
      local currentTime = os.time()
      if currentTime - demonnic.chat.lastSoundTime >= demonnic.chat.config.soundCooldown then
        -- Construct sound file path - try package directory first
        local soundPath = getMudletHomeDir() .. "/LuminariGUI/" .. demonnic.chat.config.soundFile
        
        -- Check if file exists before playing
        local file = io.open(soundPath, "r")
        if file then
          file:close()
          playSoundFile(soundPath, demonnic.chat.config.soundVolume)
          demonnic.chat.lastSoundTime = currentTime
        else
          -- Try user's home directory as fallback
          soundPath = getMudletHomeDir() .. "/" .. demonnic.chat.config.soundFile
          file = io.open(soundPath, "r")
          if file then
            file:close()
            playSoundFile(soundPath, demonnic.chat.config.soundVolume)
            demonnic.chat.lastSoundTime = currentTime
          else
            -- Use system beep as final fallback
            playSoundFile("")  -- Empty string triggers system beep in Mudlet
            demonnic.chat.lastSoundTime = currentTime
          end
        end
      end
    end
  end
end



function demonnic.chat:blink()
  if demonnic.chat.blinkID then killTimer(demonnic.chat.blinkID) end
  if not demonnic.chat.config.blink then 
    demonnic.chat.blinkTimerOn = false
    return 
  end
  if not demonnic.chat.container.hidden then
    for tab,_ in pairs(demonnic.chat.tabsToBlink) do
      demonnic.chat.tabs[tab]:flash()
    end
  end
  demonnic.chat.blinkID = tempTimer(demonnic.chat.config.blinkTime, function () demonnic.chat:blink() end)
end

function demonnic.chat:topright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=0,
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:topleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=0,
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>demonnicOnStart</name>
							<packageName></packageName>
							<script>function demonnicOnStart()
  if demonnic.chat.use then
    -- Check if we're using EMCO
    if LuminariGUI and LuminariGUI.chatSystem == "EMCO" then
      -- EMCO is already initialized by LuminariGUI_EMCO_Init
      -- Just ensure it's visible
      if demonnic.chat.container then
        demonnic.chat.container:show()
      end
      return
    end
    
    -- Original YATCO initialization
    -- Set the container now that GUI is initialized
    -- Use the inner container to account for title bar and padding
    if GUI.chatContainerInner then
      demonnic.chat.useContainer = GUI.chatContainerInner
    elseif GUI.chatContainer then
      -- Fallback to main container if inner doesn't exist
      demonnic.chat.useContainer = GUI.chatContainer
    else
      print("Warning: GUI.chatContainer not found. Chat system may not display properly.")
    end
    
    local success, err = pcall(demonnic.chat.create, demonnic.chat)
    if not success then
      print(string.format("Error initializing chat system: %s", err))
    end
  end
end</script>
							<eventHandlerList>
								<string>sysLoadEvent</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>echo functions</name>
							<packageName></packageName>
							<script>
function demonnic.chat:cecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  cecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    cecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:decho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  decho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    decho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:hecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  hecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    hecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:echo(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  echo(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    echo(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>demonnicOnInstall</name>
							<packageName></packageName>
							<script>function demonnicOnInstall(_, package)
  -- Check for both LuminariGUI and YATCO package names to handle mid-session imports
  if package:find("YATCO") or package:find("LuminariGUI") then
    demonnicOnStart()
  end
end</script>
							<eventHandlerList>
								<string>sysInstall</string>
							</eventHandlerList>
						</Script>
					</ScriptGroup>
				</ScriptGroup>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>LuminariGUI_EMCO_Init</name>
				<packageName></packageName>
				<script>-- LuminariGUI EMCO Initialization Script
-- This script determines whether to use YATCO or EMCO based on user preference

-- Flag to track which chat system is active
LuminariGUI = LuminariGUI or {}
LuminariGUI.chatSystem = LuminariGUI.chatSystem or "YATCO"  -- Default to YATCO

-- Debug function for init
local function initDebug(msg, isError)
  if EMCO_DEBUG then
    if isError then
      cecho(string.format("&lt;red&gt;[INIT ERROR] %s&lt;reset&gt;\n", msg))
      debugc(string.format("[INIT ERROR] %s", msg))
    else
      cecho(string.format("&lt;green&gt;[INIT DEBUG] %s&lt;reset&gt;\n", msg))
      if EMCO_DEBUG_VERBOSE then
        debugc(string.format("[INIT DEBUG] %s", msg))
      end
    end
  end
end

-- Function to initialize EMCO
function LuminariGUI.initializeEMCO()
  initDebug("=== Starting EMCO Initialization ===")
  
  -- Check if modules are loaded
  if not package.loaded["EMCO"] then
    initDebug("EMCO module not loaded, attempting to initialize modules", true)
    if not initializeEMCOModules() then
      initDebug("Failed to initialize EMCO modules", true)
      return false
    end
  end
  
  -- Load EMCO compatibility layer
  initDebug("Loading EMCO compatibility layer")
  local ok, EMCO_COMPAT = pcall(require, "EMCO_Compatibility_Layer")
  if not ok then
    initDebug("Failed to load compatibility layer: " .. tostring(EMCO_COMPAT), true)
    return false
  end
  
  -- Check if EMCO global exists
  if not EMCO then
    initDebug("EMCO global not found", true)
    return false
  end
  
  initDebug("EMCO global found, creating instance")
  
  -- Get container
  local container = demonnic.chat.useContainer
  initDebug("Using container: " .. tostring(container and container.name or "nil"))
  
  -- Create EMCO instance with YATCO's configuration
  local emcoConfig = {
    name = "LuminariChat",
    x = 0,
    y = 0,
    width = "100%",
    height = "100%",
    
    -- Map YATCO config to EMCO
    timestamp = demonnic.chat.config.timestamp ~= nil,
    timestampFormat = demonnic.chat.config.timestamp or "HH:mm:ss",
    customTimestampColor = demonnic.chat.config.timestampCustomColor,
    timestampFGColor = demonnic.chat.config.timestampFG or "red",
    timestampBGColor = demonnic.chat.config.timestampBG or "blue",
    
    consoles = demonnic.chat.config.channels or {"All", "Chat", "Newbie", "OOC"},
    allTab = demonnic.chat.config.Alltab ~= nil,
    allTabName = demonnic.chat.config.Alltab or "All",
    
    blink = demonnic.chat.config.blink,
    blinkTime = demonnic.chat.config.blinkTime or 3,
    blinkFromAll = demonnic.chat.config.blinkFromAll,
    
    fontSize = demonnic.chat.config.fontSize or 9,
    preserveBackground = demonnic.chat.config.preserveBackground,
    gag = demonnic.chat.config.gag,
    
    activeTabBGColor = string.format("&lt;%d,%d,%d&gt;", 
      demonnic.chat.config.activeColors.r, 
      demonnic.chat.config.activeColors.g, 
      demonnic.chat.config.activeColors.b),
    inactiveTabBGColor = string.format("&lt;%d,%d,%d&gt;", 
      demonnic.chat.config.inactiveColors.r, 
      demonnic.chat.config.inactiveColors.g, 
      demonnic.chat.config.inactiveColors.b),
    consoleColor = string.format("&lt;%d,%d,%d&gt;", 
      demonnic.chat.config.windowColors.r, 
      demonnic.chat.config.windowColors.g, 
      demonnic.chat.config.windowColors.b),
    
    activeTabFGColor = demonnic.chat.config.activeTabText or "purple",
    inactiveTabFGColor = demonnic.chat.config.inactiveTabText or "white",
  }
  
  initDebug("Creating EMCO instance with config")
  local success, emco = pcall(EMCO.new, EMCO, emcoConfig, container)
  if not success then
    initDebug("Failed to create EMCO instance: " .. tostring(emco), true)
    return false
  end
  
  initDebug("EMCO instance created successfully")
  
  -- Initialize the compatibility layer
  initDebug("Initializing compatibility layer")
  local wrapper = EMCO_COMPAT.initialize(emco)
  if not wrapper then
    initDebug("Failed to initialize compatibility wrapper", true)
    return false
  end
  
  -- Store original config before replacing
  local originalConfig = demonnic.chat.config
  
  -- Replace demonnic.chat with the wrapper
  initDebug("Replacing demonnic.chat with EMCO wrapper")
  demonnic.chat = wrapper
  
  -- Restore config and custom properties
  wrapper.config = originalConfig
  wrapper.use = true
  wrapper.config.soundEnabled = originalConfig.soundEnabled or false
  wrapper.config.soundFile = originalConfig.soundFile or "audio/chat_sound.mp3"
  wrapper.config.soundVolume = originalConfig.soundVolume or 100
  wrapper.config.soundCooldown = originalConfig.soundCooldown or 0
  
  -- Store blink table
  wrapper.tabsToBlink = {}
  
  initDebug("=== EMCO Initialization Complete ===")
  cecho("&lt;green&gt;LuminariGUI: EMCO chat system initialized successfully\n")
  
  return true
end

-- Function to switch between chat systems
function LuminariGUI.toggleChatSystem()
  if LuminariGUI.chatSystem == "YATCO" then
    -- Switch to EMCO
    local success = pcall(LuminariGUI.initializeEMCO)
    if success then
      LuminariGUI.chatSystem = "EMCO"
      cecho("&lt;green&gt;Switched to EMCO chat system\n")
      LuminariGUI.updateChatSystemIndicator()
      tempTimer(0.1, function() raiseEvent("sysLoadEvent") end)
    else
      cecho("&lt;red&gt;Failed to initialize EMCO, staying with YATCO\n")
    end
  else
    -- Switch back to YATCO would require a restart
    cecho("&lt;yellow&gt;Switching from EMCO to YATCO requires a profile restart\n")
  end
end

-- Function to create/update chat system indicator
function LuminariGUI.updateChatSystemIndicator()
  -- Create indicator if it doesn't exist
  if not GUI.ChatSystemIndicator then
    -- Try to create it in the chat container if available
    local parent = GUI.chatContainerInner or GUI.chatContainer
    if parent then
      GUI.ChatSystemIndicator = Geyser.Label:new({
        name = "GUI.ChatSystemIndicator",
        x = -80,
        y = 2,
        width = 75,
        height = 20,
      }, parent)
      
      GUI.ChatSystemIndicator:setStyleSheet([[
        background-color: rgba(0, 0, 0, 150);
        border: 1px solid rgba(255, 255, 255, 100);
        border-radius: 5px;
        padding: 2px;
        qproperty-alignment: AlignCenter;
      ]])
    end
  end
  
  -- Update the indicator text
  if GUI.ChatSystemIndicator then
    local system = LuminariGUI.chatSystem or "YATCO"
    local color = system == "EMCO" and "&lt;green&gt;" or "&lt;yellow&gt;"
    GUI.ChatSystemIndicator:echo(string.format("&lt;center&gt;%s%s&lt;reset&gt;", color, system))
    GUI.ChatSystemIndicator:setToolTip(string.format("Chat System: %s\nUse 'toggle chat system' to switch", system))
  end
end

-- Check if we should use EMCO on startup
registerAnonymousEventHandler("sysLoadEvent", function()
  -- Check for saved preference
  local configFile = getMudletHomeDir() .. "/LuminariGUI_chatSystem.txt"
  if io.exists(configFile) then
    local f = io.open(configFile, "r")
    if f then
      local system = f:read("*l")
      f:close()
      if system == "EMCO" then
        tempTimer(2, function()
          if demonnic and demonnic.chat and demonnic.chat.config then
            LuminariGUI.toggleChatSystem()
          end
        end)
      end
    end
  end
  
  -- Always update the indicator on load
  tempTimer(3, function()
    LuminariGUI.updateChatSystemIndicator()
  end)
end)
</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>EMCO</name>
				<packageName>EMCO</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>EMCO_demontools</name>
					<packageName></packageName>
					<script><![CDATA[-- Store content for master loader
EMCO_demontools_content = [==[
--- Collection of miscellaneous functions and tools which don't necessarily warrant their own module/class
-- @module demontools
-- @author Damian Monogue <demonnic@gmail.com>
-- @copyright 2020 Damian Monogue
-- @license MIT, see LICENSE.lua
local DemonTools = {}
local cheatConsole = Geyser.MiniConsole:new({name = "DemonnicCheatConsole", width = 4000, wrapWidth = 10000, color = "black"})
cheatConsole:hide()
local function exists(path)
  path = path:gsub([[\$]], "")
  path = path:gsub([[/$]], "")
  return io.exists(path)
end

local function isWindows()
  return package.config:sub(1, 1) == [[\]]
end

local function isDir(path)
  if not exists(path) then return false end
    path = path:gsub([[\]], "/")
  if path:ends("/") then
    path = path:sub(1,-2)
  end
  local ok, err, code = lfs.attributes(path, "mode")
  if ok then
    if ok == "directory" then
      return true
    else
      return false
    end
  end
  return ok, err, code
end

local function mkdir_p(path)
  path = path:gsub("\\", "/")
  local pathTbl = path:split("/")
  local cwd = "/"
  if isWindows() then
    cwd = ""
  end
  for index, dirName in ipairs(pathTbl) do
    if index == 1 then
      cwd = cwd .. dirName
    else
      cwd = cwd .. "/" .. dirName
      cwd = cwd:gsub("//", "/")
    end
    if not table.contains({"/", "C:"}, cwd) and not exists(cwd) then
      local ok, err = lfs.mkdir(cwd)
      if not ok then
        return ok, err
      end
    end
  end
  return true
end

local htmlHeader = [=[  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
    <style type="text/css">
      body {
        background-color: black;
        font-family: 'Droid Sans Mono';
        white-space: pre; 
        font-size: 12px;
      }
    </style>
  </head>
<body><span>
]=]

local htmlHeaderPattern = [=[  <!DOCTYPE HTML PUBLIC "%-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http%-equiv="Content%-Type" content="text/html;charset=utf%-8" >
    <link href='http://fonts.googleapis.com/css%?family=Droid%+Sans%+Mono' rel='stylesheet' type='text/css'>
    <style type="text/css">
      body {
        background%-color: black;
        font%-family: 'Droid Sans Mono';
        white%-space: pre; 
        font%-size: 12px;
      }
    </style>
  </head>
<body><span>
]=]

-- internal function, recursively digs for a value within subtables if possible
local function digForValue(dataFrom, tableTo)
  if dataFrom == nil or table.size(tableTo) == 0 then
    return dataFrom
  else
    local newData = dataFrom[tableTo[1]]
    table.remove(tableTo, 1)
    return digForValue(newData, tableTo)
  end
end

-- Internal function, used to turn a string variable name into a value
local function getValueAt(accessString)
  if accessString == "" then
    return nil
  end
  local tempTable = accessString:split("%.")
  local accessTable = {}
  for i, v in ipairs(tempTable) do
    if tonumber(v) then
      accessTable[i] = tonumber(v)
    else
      accessTable[i] = v
    end
  end
  return digForValue(_G, accessTable)
end

-- internal sorting function, sorts first by hue, then luminosity, then value
local function sortColorsByHue(lhs, rhs)
  local lh, ll, lv = unpack(lhs.sort)
  local rh, rl, rv = unpack(rhs.sort)
  if lh < rh then
    return true
  elseif lh > rh then
    return false
  elseif ll < rl then
    return true
  elseif ll > rl then
    return false
  else
    return lv < rv
  end
end

-- internal sorting function, removes _ from snake_case and compares to camelCase
local function sortColorsByName(a, b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  return aname < bname
end

-- internal function used to turn sorted colors table into columns
local function chunkify(tbl, num_chunks)
  local pop = function(t)
    return table.remove(t, 1)
  end
  tbl = table.deepcopy(tbl)
  local tblsize = #tbl
  local base_chunk_size = tblsize / num_chunks
  local chunky_chunks = tblsize % num_chunks
  local chunks = {}
  for i = 1, num_chunks do
    local chunk_size = base_chunk_size
    if i <= chunky_chunks then
      chunk_size = chunk_size + 1
    end
    local chunk = {}
    for j = 1, chunk_size do
      chunk[j] = pop(tbl)
    end
    chunks[i] = chunk
  end
  return chunks
end

-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local function rgbToHsv(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  local d = max - min
  if max == 0 then
    s = 0
  else
    s = d / max
  end
  if max == min then
    h = 0
    -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g < b then
        h = h + 6
      end
    elseif max == g then
      h = (b - r) / d + 2
    elseif max == b then
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  return h, s, v
end

-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local function step(r, g, b)
  local lum = math.sqrt(.241 * r + .691 * g + .068 * b)
  local reps = 8
  local h, s, v = rgbToHsv(r, g, b)
  local h2 = math.floor(h * reps)
  local lum2 = math.floor(lum * reps)
  local v2 = math.floor(v * reps)
  if h2 % 2 == 1 then
    v2 = reps - v2
    lum2 = reps - lum2
  end
  return h2, lum2, v2
end

local function calc_luminosity(r, g, b)
  r = r < 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g < 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b < 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end

local function include(color, options)
  if options.removeDupes and (string.find(color, "_") and not color:starts("ansi")) or string.find(color:lower(), 'gray') then
    return false
  end
  if options.removeAnsi255 and string.find(color, "ansi_%d%d%d") then
    return false
  end
end

local function echoColor(color, options)
  local rgb = color.rgb
  local fgc = "white"
  if calc_luminosity(unpack(rgb)) > 0.5 then
    fgc = "black"
  end
  local colorString
  if options.justText then
    colorString = string.format('<%s:%s> %-23s<reset> ', color.name, 'black', color.name)
  else
    colorString = string.format('<%s:%s> %-23s<reset> ', fgc, color.name, color.name)
  end
  if options.window == "main" then
    if options.echoOnly then
      cecho(colorString)
    else
      cechoLink(colorString, [[appendCmdLine("]] .. color.name .. [[")]], table.concat(rgb, ", "), true)
    end
  else
    if options.echoOnly then
      cecho(options.window, colorString)
    else
      cechoLink(options.window, colorString, [[appendCmdLine("]] .. color.name .. [[")]], table.concat(rgb, ", "), true)
    end
  end
end

local cnames = {}

local function _color_name(rgb)
  if cnames[rgb] then
    return cnames[rgb]
  end
  local least_distance = math.huge
  local cname = ""
  for name, color in pairs(color_table) do
    local color_distance = math.sqrt((color[1] - rgb[1]) ^ 2 + (color[2] - rgb[2]) ^ 2 + (color[3] - rgb[3]) ^ 2)
    if color_distance < least_distance then
      least_distance = color_distance
      cname = name
    end
  end
  cnames[rgb] = cname
  return cname
end

-- converts decho color information to ansi escape sequences
local function rgbToAnsi(rgb)
  local result = ""
  local cols = rgb:split(":")
  local fore = cols[1]
  local back = cols[2]
  if fore ~= "" then
    local components = fore:split(",")
    result = string.format("%s\27[38:2::%s:%s:%sm", result, components[1] or "0", components[2] or "0", components[3] or "0")
  end
  if back then
    local components = back:split(",")
    result = string.format("%s\27[48:2::%s:%s:%sm", result, components[1] or "0", components[2] or "0", components[3] or "0")
  end
  return result
end

-- converts a 6 digit hex color code to ansi escape sequence
local function hexToAnsi(hexcode)
  local result = ""
  local cols = hexcode:split(",")
  local fore = cols[1]
  local back = cols[2]
  if fore ~= "" then
    local components = {tonumber(fore:sub(1, 2), 16), tonumber(fore:sub(3, 4), 16), tonumber(fore:sub(5, 6), 16)}
    result = string.format("%s\27[38:2::%s:%s:%sm", result, components[1] or "0", components[2] or "0", components[3] or "0")
  end
  if back then
    local components = {tonumber(back:sub(1, 2), 16), tonumber(back:sub(3, 4), 16), tonumber(back:sub(5, 6), 16)}
    result = string.format("%s\27[48:2::%s:%s:%sm", result, components[1] or "0", components[2] or "0", components[3] or "0")
  end
  return result
end

local function hexToRgb(hexcode)
  local result = "<"
  local cols = hexcode:split(",")
  local fore = cols[1]
  local back = cols[2]
  if fore ~= "" then
    local r, g, b = Geyser.Color.parse("#" .. fore)
    result = string.format("%s%s,%s,%s", result, r, g, b)
  end
  if back then
    local r, g, b = Geyser.Color.parse("#" .. back)
    result = string.format("%s:%s,%s,%s", result, r, g, b)
  end
  return string.format("%s>", result)
end

local function rgbToHex(rgb)
  local result = "#"
  local cols = rgb:split(":")
  local fore = cols[1]
  local back = cols[2]
  if fore ~= "" then
    local r, g, b = unpack(string.split(fore, ","))
    result = string.format("%s%02x%02x%02x", result, r, g, b)
  end
  if back then
    local r, g, b = unpack(string.split(back, ","))
    result = string.format("%s,%02x%02x%02x", result, r, g, b)
  end
  return result
end

local function rgbToCname(rgb)
  local result = "<"
  local cols = rgb:split(":")
  local fore = cols[1]
  local back = cols[2]
  if fore ~= "" then
    result = string.format("%s%s", result, _color_name(fore:split(",")))
  end
  if back then
    result = string.format("%s:%s", result, _color_name(back:split(",")))
  end
  return string.format("%s>", result)
end

local function cnameToRgb(cname)
  local result = "<"
  local cols = cname:split(":")
  local fore = cols[1]
  local back = cols[2]
  if fore ~= "" then
    local rgb = color_table[fore] or {0, 0, 0}
    result = string.format("%s%s", result, table.concat(rgb, ","))
  end
  if back then
    local rgb = color_table[back] or {0, 0, 0}
    result = string.format("%s:%s", result, table.concat(rgb, ","))
  end
  return string.format("%s>", result)
end

local function toFromDecho(from, to, text)
  local patterns = {d = _Echos.Patterns.Decimal[1], c = _Echos.Patterns.Color[1], h = _Echos.Patterns.Hex[1]}
  local funcs = {d = {c = rgbToCname, h = rgbToHex, a = rgbToAnsi}, c = {d = cnameToRgb}, h = {d = hexToRgb}}
  local resetCodes = {d = "<r>", h = "#r", c = "<reset>", a = "\27[39;49m"}

  local colorPattern = patterns[from]
  local func = funcs[from][to]
  local reset = resetCodes[to]
  local result = ""
  for str, color, res in rex.split(text, colorPattern) do
    result = result .. str
    if color then
      if color:sub(1, 1) == "|" then
        color = color:gsub("|c", "#")
      end
      if from == "h" then
        result = result .. func(color:sub(2, -1))
      else
        result = result .. func(color:match("<(.+)>"))
      end
    end
    if res then
      result = result .. reset
    end
  end
  return result
end

local function decho2cecho(text)
  return toFromDecho("d", "c", text)
end

local function cecho2decho(text)
  return toFromDecho("c", "d", text)
end

local function decho2hecho(text)
  return toFromDecho("d", "h", text)
end

local function hecho2decho(text)
  return toFromDecho("h", "d", text)
end

local function cecho2ansi(text)
  local dtext = cecho2decho(text)
  return decho2ansi(dtext)
end

local function cecho2hecho(text)
  local dtext = cecho2decho(text)
  return decho2hecho(dtext)
end

local function hecho2cecho(text)
  local dtext = hecho2decho(text)
  return decho2cecho(dtext)
end

local function ansi2decho(tstring)
  local cpattern = [=[\e\[([0-9;:]+)m]=]
  local result = ""
  local resets = {"39;49", "00", "0"}
  local colours = {
    [0] = color_table.ansiBlack,
    [1] = color_table.ansiRed,
    [2] = color_table.ansiGreen,
    [3] = color_table.ansiYellow,
    [4] = color_table.ansiBlue,
    [5] = color_table.ansiMagenta,
    [6] = color_table.ansiCyan,
    [7] = color_table.ansiWhite,
  }
  local lightColours = {
    [0] = color_table.ansiLightBlack,
    [1] = color_table.ansiLightRed,
    [2] = color_table.ansiLightGreen,
    [3] = color_table.ansiLightYellow,
    [4] = color_table.ansiLightBlue,
    [5] = color_table.ansiLightMagenta,
    [6] = color_table.ansiLightCyan,
    [7] = color_table.ansiLightWhite,
  }

  local function colorCodeToRGB(color, parts)
    local rgb
    if color ~= 8 then
      rgb = colours[color]
    else
      if parts[2] == "5" then
        local color_number = tonumber(parts[3])
        if color_number < 8 then
          rgb = colours[color_number]
        elseif color_number > 7 and color_number < 16 then
          rgb = lightColours[color_number - 8]
        else
          rgb = color_table["ansi_" .. color_number]
        end
      elseif parts[2] == "2" then
        local r = parts[4] or 0
        local g = parts[5] or 0
        local b = parts[6] or 0
        if r == "" then
          r = 0
        end
        if g == "" then
          g = 0
        end
        if b == "" then
          b = 0
        end
        rgb = {r, g, b}
      end
    end
    return rgb
  end

  for str, color in rex.split(tstring, cpattern) do
    result = result .. str
    if color then
      if table.contains(resets, color) then
        result = result .. "<r>"
      else
        local parts
        if color:find(";") then
          parts = color:split(";")
        else
          parts = color:split(":")
        end
        local code = parts[1]
        if code:starts("3") then
          color = tonumber(code:sub(2, 2))
          local rgb = colorCodeToRGB(color, parts)
          result = string.format("%s<%s,%s,%s>", result, rgb[1], rgb[2], rgb[3])
        elseif code:starts("4") then
          color = tonumber(code:sub(2, 2))
          local rgb = colorCodeToRGB(color, parts)
          result = string.format("%s<:%s,%s,%s>", result, rgb[1], rgb[2], rgb[3])
        elseif tonumber(code) >= 90 and tonumber(code) <= 97 then
          local rgb = colours[tonumber(code) - 90]
          result = string.format("%s<%s,%s,%s>", result, rgb[1], rgb[2], rgb[3])
        elseif tonumber(code) >= 100 and tonumber(code) <= 107 then
          local rgb = colours[tonumber(code) - 100]
          result = string.format("%s<:%s,%s,%s>", result, rgb[1], rgb[2], rgb[3])
        end
      end
    end
  end
  return result
end

local function decho2ansi(text)
  local colorPattern = _Echos.Patterns.Decimal[1]
  local result = ""
  for str, color, res in rex.split(text, colorPattern) do
    result = result .. str
    if color then
      result = result .. rgbToAnsi(color:match("<(.+)>"))
    end
    if res then
      result = result .. "\27[39;49m"
    end
  end
  return result
end

local function hecho2ansi(text)
  local colorPattern = _Echos.Patterns.Hex[1]
  local result = ""
  for str, color, res in rex.split(text, colorPattern) do
    result = result .. str
    if color then
      if color:sub(1, 1) == "|" then
        color = color:gsub("|c", "#")
      end
      result = result .. hexToAnsi(color:sub(2, -1))
    end
    if res then
      result = result .. "\27[39;49m"
    end
  end
  return result
end

local function ansi2hecho(text)
  local dtext = ansi2decho(text)
  return decho2hecho(dtext)
end

local function displayColors(options)
  options = options or {}
  local optionsType = type(options)
  assert(optionsType == "table", "displayColors(options) argument error: options as table expects, got " .. optionsType)
  options.cols = options.cols or 4
  options.search = options.search or ""
  options.sort = options.sort or false
  if options.removeDupes == nil then
    options.removeDupes = true
  end
  if options.removeAnsi255 == nil then
    options.removeAnsi255 = true
  end
  if options.columnSort == nil then
    options.columnSort = true
  end
  if type(options.window) == "table" then
    options.window = options.window.name
  end
  options.window = options.window or "main"
  local color_table = options.color_table or color_table
  local cols, search, sort = options.cols, options.search, options.sort
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if include(k, options) and k:lower():find(search) then
      table.insert(colors, color)
    end
  end
  if sort then
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors, sortColorsByHue)
  end
  if options.columnSort then
    local columns_table = chunkify(colors, cols)
    local lines = #columns_table[1]
    for i = 1, lines do
      for j = 1, cols do
        local color = columns_table[j][i]
        if color then
          echoColor(color, options)
        end
      end
      echo(options.window, "\n")
    end
  else
    local i = 1
    for _, k in ipairs(colors) do
      echoColor(k, options)
      if i == cols then
        echo(options.window, "\n")
        i = 1
      else
        i = i + 1
      end
    end
    if i ~= 1 then
      echo(options.window, "\n")
    end
  end
end

local function cecho2string(text)
  local pattern = _Echos.Patterns.Color[2]
  local result = rex.gsub(text, pattern, "")
  return result
end

local function decho2string(text)
  local pattern = _Echos.Patterns.Decimal[2]
  local result = rex.gsub(text, pattern, "")
  return result
end

local function hecho2string(text)
  local pattern = _Echos.Patterns.Hex[2]
  local result = rex.gsub(text, pattern, "")
  return result
end

local function append2decho()
  cheatConsole:clear()
  cheatConsole:appendBuffer()
  local str = copy2decho(cheatConsole.name)
  cheatConsole:clear()
  return str
end

local function html2decho(text)
  text = text:gsub(htmlHeaderPattern, "")
  text = text:gsub("<span style='color: rgb%((%d+,%d+,%d+)%);background: rgb%((%d+,%d+,%d+)%);'>", "<%1:%2>")
  text = text:gsub("<br>", "\n")
  text = text:gsub("</span>", "")
  return text
end

local function html2cecho(text)
  local dtext = html2decho(text)
  return decho2cecho(dtext)
end

local function html2hecho(text)
  local dtext = html2decho(text)
  return decho2hecho(dtext)
end

local function html2ansi(text)
  local dtext = html2decho(text)
  return decho2ansi(dtext)
end

local function html2string(text)
  local dtext = html2decho(text)
  return decho2string(text)
end

local function consoleToString(options)
  options = options or {}
  options.win = options.win or "main"
  options.format = options.format or "d"
  options.start_line = options.start_line or 0
  if options.includeHtmlWrapper == nil then
    options.includeHtmlWrapper = true
  end
  local console_line_count = options.win == "main" and getLineCount() or getLineCount(options.win)
  if not options.end_line then
    options.end_line = console_line_count
  end
  if options.end_line > console_line_count then
    options.end_line = console_line_count
  end
  local start, finish, format = options.start_line, options.end_line, options.format
  local current_x, current_y
  if options.win == "main" then
    current_x = getColumnNumber()
    current_y = getLineNumber()
  else
    current_x = getColumnNumber(options.win)
    current_y = getLineNumber(options.win)
  end

  local function move(x, y)
    if options.win == "main" then
      return moveCursor(x, y)
    else
      return moveCursor(options.win, x, y)
    end
  end
  local function gcl()
    local win, raw
    if options.win ~= "main" then
      win = options.win
      raw = getCurrentLine(win)
    else
      win = nil
      raw = getCurrentLine()
    end
    if raw == "" then
      return ""
    end
    if format == "h" then
      return copy2html(win)
    elseif format == "d" then
      return copy2decho(win)
    elseif format == "a" then
      return decho2ansi(copy2decho(win))
    elseif format == "c" then
      return decho2cecho(copy2decho(win))
    elseif format == "x" then
      return decho2hecho(copy2decho(win))
    elseif format == "r" then
      return raw
    end
  end
  local lines = {}
  if format == "h" and options.includeHtmlWrapper then
    lines[#lines + 1] = htmlHeader
  end
  for line_number = start, finish do
    move(0, line_number)
    lines[#lines + 1] = gcl()
  end
  if format == "h" and options.includeHtmlWrapper then
    lines[#lines + 1] = "</span></body></html>"
  end
  moveCursor(current_x, current_y)
  return table.concat(lines, "\n")
end

local function decho2html(text)
  cheatConsole:clear()
  text = text:gsub("\n", "<br>")
  cheatConsole:decho(text)
  local html = copy2html(cheatConsole.name)
  cheatConsole:clear()
  return html
end

local function cecho2html(text)
  local dtext = cecho2decho(text)
  return decho2html(dtext)
end

local function hecho2html(text)
  local dtext = hecho2decho(text)
  return decho2html(dtext)
end

local function ansi2html(text)
  local dtext = ansi2decho(text)
  return decho2html(dtext)
end

local function scientific_round(number, sigDigits)
  local decimalPlace = string.find(number, "%.")
  if not decimalPlace or (sigDigits < decimalPlace) then
    local numberTable = {}
    local count = 1
    for digit in string.gmatch(number, "%d") do
      table.insert(numberTable, digit)
    end
    local endNumber = ""
    for i, digit in ipairs(numberTable) do
      if i < sigDigits then
        endNumber = endNumber .. digit
      end
      if i == sigDigits then
        if tonumber(numberTable[i + 1]) >= 5 then
          endNumber = endNumber .. digit + 1
        else
          endNumber = endNumber .. digit
        end
      end
      if i > sigDigits and (not decimalPlace or (i < decimalPlace)) then
        endNumber = endNumber .. "0"
      end
    end
    return tonumber(endNumber)
  else
    local decimalDigits = sigDigits - decimalPlace + 1
    return tonumber(string.format("%" .. decimalPlace - 1 .. "." .. decimalDigits .. "f", number))
  end
end

local function roundInt(number)
  return math.floor(number + 0.5)
end

function string.tobyte(self)
  return (self:gsub('.', function(c)
    return string.byte(c)
  end))
end

function string.tocolor(self)
  -- This next bit takes the string and 'unshuffles' it, breaking it into odds and evens
  -- reverses the evens, then adds the odds to the new even set. So demonnic becomes cnoedmni
  -- this makes sure that names which are similar in the beginning don't color the same
  -- especially since we have to cut the number for the random seed due to OSX using a default
  -- randomseed if you feed it something too large, which made every name longer than 7 characters
  -- always the same color, no matter what it was.
  local strTable = {}
  local part1 = {}
  local part2 = {}
  self:gsub(".", function(c)
    table.insert(strTable, c)
  end)
  for index, value in ipairs(strTable) do
    if (index % 2 == 0) then
      table.insert(part1, value)
    else
      table.insert(part2, value)
    end
  end
  local newStr = string.reverse(table.concat(part1)) .. table.concat(part2)
  -- end munging of the original string to get more uniqueness
  math.randomseed(string.cut(newStr:tobyte(), 18))
  local r = math.random(0, 255)
  local g = math.random(0, 255)
  local b = math.random(0, 255)
  math.randomseed(os.time())
  return {r, g, b}
end

local function colorMunge(strForColor, strToEcho, format)
  format = format or 'd'
  local rgb = strForColor:tocolor()
  local color
  if format == "d" then
    color = string.format("<%s>", table.concat(rgb, ","))
  elseif format == "c" then
    color = string.format("<%s>", _color_name(rgb))
  elseif format == "h" then
    color = string.format("#%02x%02x%02x", rgb[1], rgb[2], rgb[3])
  end
  return color .. strToEcho
end

local function colorMungeEcho(strForColor, strToEcho, format, win)
  format = format or "d"
  win = win or "main"
  local str = colorMunge(strForColor, strToEcho, format)
  local func
  if format == "d" then
    func = decho
  end
  if format == "c" then
    func = cecho
  end
  if format == "h" then
    func = hecho
  end
  if win == "main" then
    func(str)
  else
    func(win, str)
  end
end

local function milliToHuman(milliseconds)
  local totalseconds = math.floor(milliseconds / 1000)
  milliseconds = milliseconds % 1000
  local seconds = totalseconds % 60
  local minutes = math.floor(totalseconds / 60)
  local hours = math.floor(minutes / 60)
  minutes = minutes % 60
  return string.format("%02d:%02d:%02d:%03d", hours, minutes, seconds, milliseconds)
end

--- Takes a list table and returns it as a table of 'chunks'. If the table has 12 items and you ask for 3 chunks, each chunk will have 4 items in it
-- @tparam table tbl The table you want to turn into chunks. Must be traversable using ipairs()
-- @tparam number num_chunks The number of chunks to turn the table into
-- @usage local dt = require("MDK.demontools")
-- testTable = { "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten" }
-- display(dt.chunkify(testTable, 3))
-- --displays the following
-- {
--   {
--     "one",
--     "two",
--     "three",
--     "four"
--   },
--   {
--     "five",
--     "six",
--     "seven"
--   },
--   {
--     "eight",
--     "nine",
--     "ten"
--   }
-- }

function DemonTools.chunkify(tbl, num_chunks)
  return chunkify(tbl, num_chunks)
end

--- Takes an ansi colored text string and returns a cecho colored one
-- @tparam string text the text to convert
-- @usage   dt.ansi2cecho("[31mTest")
-- --returns "<ansiRed>Test"
function DemonTools.ansi2cecho(text)
  local dtext = ansi2decho(text)
  return decho2cecho(dtext)
end

--- Takes an ansi colored text string and returns a decho colored one. Handles 256 color SGR codes better than Mudlet's ansi2decho
-- @tparam string text the text to convert
-- @usage   dt.ansi2decho("[31mTest") --returns "<128,0,0>Test"
-- @usage dt.ansi2decho("[38:2::127:0:0mTest") --returns "<127,0,0>Test"
-- @usage ansi2decho("[38:2::127:0:0mTest") -- doesn't parse this format of colors and so returns "[38:2::127:0:0mTest"
function DemonTools.ansi2decho(text)
  return ansi2decho(text)
end

--- Takes an ansi colored text string and returns a hecho colored one
-- @tparam string text the text to convert
-- @usage   dt.ansi2hecho("[31mTest")
-- --returns "#800000Test"
function DemonTools.ansi2hecho(text)
  return ansi2hecho(text)
end

--- Takes an cecho colored text string and returns a decho colored one
-- @tparam string text the text to convert
-- @usage  dt.cecho2decho("<green>Test") --returns "<0,255,0>Test"
function DemonTools.cecho2decho(text)
  return cecho2decho(text)
end

--- Takes an cecho colored text string and returns an ansi colored one
-- @tparam string text the text to convert
-- @usage dt.cecho2ansi("<green>Test") --returns "[38:2::0:255:0mTest"
function DemonTools.cecho2ansi(text)
  return cecho2ansi(text)
end

--- Takes an cecho colored text string and returns a hecho colored one
-- @tparam string text the text to convert
-- @usage dt.cecho2hecho("<green>Test") --returns "#00ff00Test"
function DemonTools.cecho2hecho(text)
  return cecho2hecho(text)
end

--- Takes an decho colored text string and returns a cecho colored one
-- @tparam string text the text to convert
-- @usage   dt.decho2cecho("<127,0,0:0,0,127>Test") --returns "<ansiRed:ansi_blue>Test"
function DemonTools.decho2cecho(text)
  return decho2cecho(text)
end

--- Takes an decho colored text string and returns an ansi colored one
-- @tparam string text the text to convert
-- @usage dt.decho2ansi("<127,0,0:0,0,127>Test") --returns "[38:2::127:0:0m[48:2::0:0:127mTest"
function DemonTools.decho2ansi(text)
  return decho2ansi(text)
end

--- Takes an decho colored text string and returns an hecho colored one
-- @tparam string text the text to convert
-- @usage dt.decho2hecho("<127,0,0:0,0,127>Test") --returns "#7f0000,00007fTest"
function DemonTools.decho2hecho(text)
  return decho2hecho(text)
end

--- Takes a decho colored text string and returns html.
-- @tparam string text the text to convert
function DemonTools.decho2html(text)
  return decho2html(text)
end

--- Takes a cecho colored text string and returns html.
-- @tparam string text the text to convert
function DemonTools.cecho2html(text)
  return cecho2html(text)
end

--- Takes a hecho colored text string and returns html.
-- @tparam string text the text to convert
function DemonTools.hecho2html(text)
  return hecho2html(text)
end

--- Takes an ansi colored text string and returns html.
-- @tparam string text the text to convert
function DemonTools.ansi2html(text)
  return ansi2html(text)
end

--- Takes an html colored string of the sort turned out by the DemonTools *2html functions and returns a cecho string
-- @tparam string text the text to convert
function DemonTools.html2cecho(text)
  return html2cecho(text)
end

--- Takes an html colored string of the sort turned out by the DemonTools *2html functions and returns a decho string
-- @tparam string text the text to convert
function DemonTools.html2decho(text)
  return html2decho(text)
end

--- Takes an html colored string of the sort turned out by the DemonTools *2html functions and returns an ansi string
-- @tparam string text the text to convert
function DemonTools.html2ansi(text)
  return html2ansi(text)
end

--- Takes an html colored string of the sort turned out by the DemonTools *2html functions and returns an hecho string
-- @tparam string text the text to convert
function DemonTools.html2hecho(text)
  return html2hecho(text)
end

--- Takes a cecho string and returns it without the formatting
-- @param text the text to transform
function DemonTools.cecho2string(text)
  return cecho2string(text)
end

--- Takes a decho string and returns it without the formatting
-- @param text the text to transform
function DemonTools.decho2string(text)
  return decho2string(text)
end

--- Takes a hecho string and returns it without the formatting
-- @param text the text to transform
function DemonTools.hecho2string(text)
  return hecho2string(text)
end

--- Takes an html colored string of the sort turned out by the DemonTools *2html functions and returns a clean string
function DemonTools.html2string(text)
  return html2string(text)
end

--- Takes an hecho colored text string and returns a ansi colored one
-- @tparam string text the text to convert
-- @usage dt.hecho2ansi("#7f0000,00007fTest") --returns "[38:2::127:0:0m[48:2::0:0:127mTest"
function DemonTools.hecho2ansi(text)
  return hecho2ansi(text)
end

--- Takes an hecho colored text string and returns a cecho colored one
-- @tparam string text the text to convert
-- @usage   dt.hecho2cecho("#7f0000,00007fTest") --returns "<ansiRed:ansi_blue>Test"
function DemonTools.hecho2cecho(text)
  return hecho2cecho(text)
end

--- Takes an hecho colored text string and returns a decho colored one
-- @tparam string text the text to convert
-- @usage   dt.hecho2decho("#7f0000,00007fTest") --returns "<127,0,0:0,0,127>Test"
function DemonTools.hecho2decho(text)
  return hecho2decho(text)
end

--- Takes the currently copy()ed item and returns it as a decho string
function DemonTools.append2decho()
  return append2decho()
end

--- Dump the contents of a miniconsole, user window, or the main window in one of several formats, as determined by a table of options
-- @tparam table options Table of options which controls which console and how it returns the data.
-- <table class="tg">
-- <thead>
--   <tr>
--     <th>option name</th>
--     <th>description</th>
--     <th>default</th>
--   </tr>
-- </thead>
-- <tbody>
--   <tr>
--     <td class="tg-odd">format</td>
--     <td class="tg-odd">What format to return the text as? 'h' for html, 'c' for cecho, 'a' for ansi, 'd' for decho, and 'x' for hecho</td>
--     <td class="tg-odd">"d"</td>
--   </tr>
--   <tr>
--     <td class="tg-even">win</td>
--     <td class="tg-even">what console/window to dump the buffer of?</td>
--     <td class="tg-even">"main"</td>
--   </tr>
--   <tr>
--     <td class="tg-odd">start_line</td>
--     <td class="tg-odd">What line to start dumping the buffer from?</td>
--     <td class="tg-odd">0</td>
--   </tr>
--   <tr>
--     <td class="tg-even">end_line</td>
--     <td class="tg-even">What line to stop dumping the buffer on?</td>
--     <td class="tg-even">Last line of the console</td>
--   </tr>
--   <tr>
--     <td class="tg-odd">includeHtmlWrapper</td>
--     <td class="tg-odd">If the format is html, should it include the front and back portions required to make it a functioning html page?</td>
--     <td class="tg-odd">true</td>
--   </tr>
-- </tbody>
-- </table>
function DemonTools.consoleToString(options)
  return consoleToString(options)
end

--- Alternative to Mudlet's showColors(), this one has additional options.
-- @tparam table options table of options which control the output of displayColors
-- <table class="tg">
-- <thead>
--   <tr>
--     <th>option name</th>
--     <th>description</th>
--     <th>default</th>
--   </tr>
-- </thead>
-- <tbody>
--   <tr>
--     <td class="tg-odd">cols</td>
--     <td class="tg-odd">Number of columsn wide to display the colors in</td>
--     <td class="tg-odd">4</td>
--   </tr>
--   <tr>
--     <td class="tg-even">search</td>
--     <td class="tg-even">If not the empty string, will check colors against string.find using this property.<br>IE if set to "blue" only colors which include the word 'blue' would be listed</td>
--     <td class="tg-even">""</td>
--   </tr>
--   <tr>
--     <td class="tg-odd">sort</td>
--     <td class="tg-odd">If true, sorts alphabetically. Otherwise sorts based on the color value</td>
--     <td class="tg-odd">false</td>
--   </tr>
--   <tr>
--     <td class="tg-even">echoOnly</td>
--     <td class="tg-even">If true, colors will not be clickable links</td>
--     <td class="tg-even">false</td>
--   </tr>
--   <tr>
--     <td class="tg-odd">window</td>
--     <td class="tg-odd">What window/console to echo the colors out to.</td>
--     <td class="tg-odd">"main"</td>
--   </tr>
--   <tr>
--     <td class="tg-even">removeDupes</td>
--     <td class="tg-even">If true, will remove snake_case entries and 'gray' in favor of 'grey'</td>
--     <td class="tg-even">true</td>
--   </tr>
--   <tr>
--     <td class="tg-odd">columnSort</td>
--     <td class="tg-odd">If true, will print top-to-bottom, then left-to-right. false is like showColors</td>
--     <td class="tg-odd">true</td>
--   </tr>
--   <tr>
--     <td class="tg-even">justText</td>
--     <td class="tg-even">If true, will echo the text in the color and leave the background black.<br>If false, the background will be the colour(like showColors).</td>
--     <td class="tg-even">false</td>
--   </tr>
--   <tr>
--     <td class="tg-odd">color_table</td>
--     <td class="tg-odd">Table of colors to display. If you provide your own table, it must be in the same format as Mudlet's own color_table</td>
--     <td class="tg-odd">color_table</td>
--   </tr>
-- </tbody>
-- </table>
function DemonTools.displayColors(options)
  return displayColors(options)
end

--- Rounds a number to the nearest whole integer
-- @param number the number to round off
-- @usage dt.roundInt(8.3) -- returns 8
-- @usage dt.roundInt(10.7) -- returns 11
function DemonTools.roundInt(number)
  local num = tonumber(number)
  local numType = type(num)
  assert(numType == "number", string.format("DemonTools.roundInt(number): number as number expected, got %s", type(number)))
  return roundInt(num)
end

--- Rounds a number to a specified number of significant digits
-- @tparam number number the number to round
-- @tparam number sig_digits the number of significant digits to keep
-- @usage dt.scientific_round(1348290, 3) -- will return 1350000
-- @usage dt.scientific_found(123.3452, 5) -- will return 123.34
function DemonTools.scientific_round(number, sig_digits)
  return scientific_round(number, sig_digits)
end

--- Returns a color table {r,g,b} derived from str. Will return the same color every time for the same string.
-- @tparam string str the string to turn into a color.
-- @usage   dt.string2color("Demonnic") --returns { 131, 122, 209 }
function DemonTools.string2color(str)
  return string.tocolor(str)
end

--- Returns a colored string where strForColor is run through DemonTools.string2color and applied to strToColor based on format.
-- @tparam string strForColor the string to turn into a color using DemonTools.string2color
-- @tparam string strToColor the string you want to color based on strForColor
-- @param format What format to use for the color portion. "d" for decho, "c" for cecho, or "h" for hecho. Defaults to "d"
-- @usage   dt.colorMunge("Demonnic", "Test") --returns "<131,122,209>Test"
function DemonTools.colorMunge(strForColor, strToColor, format)
  return colorMunge(strForColor, strToColor, format)
end

--- Like colorMunge but also echos the result to win. 
-- @tparam string strForColor the string to turn into a color using DemonTools.string2color
-- @tparam string strToEcho the string you want to color and echo based on strForColor
-- @param format What format to use for the color portion. "d" for decho, "c" for cecho, or "h" for hecho. Defaults to "d"
-- @param win the window to echo to. You must provide the format if you want to change the window. Defaults to "main"
function DemonTools.colorMungeEcho(strForColor, strToEcho, format, win)
  colorMungeEcho(strForColor, strToEcho, format, win)
end

--- Converts milliseconds to hours:minutes:seconds:milliseconds
-- @tparam number milliseconds the number of milliseconds to convert
-- @tparam boolean tbl if true, returns the time as a key/value table instead
-- @usage dt.milliToHuman(37194572) --returns "10:19:54:572"
-- @usage display(dt.milliToHuman(37194572, true))
-- {
--   minutes = 19,
--   original = 37194572,
--   hours = 10,
--   milliseconds = 572,
--   seconds = 54
-- }
function DemonTools.milliToHuman(milliseconds, tbl)
  local human = milliToHuman(milliseconds)
  local output
  if tbl then
    local timetbl = human:split(":")
    output = {
      hours = tonumber(timetbl[1]),
      minutes = tonumber(timetbl[2]),
      seconds = tonumber(timetbl[3]),
      milliseconds = tonumber(timetbl[4]),
      original = milliseconds,
    }
  else
    output = human
  end
  return output
end

--- Takes the name of a variable as a string and returns the value. "health" will return the value in varable health, "gmcp.Char.Vitals" will return the table at gmcp.Char.Vitals, etc
-- @tparam string variableString the string name of the variable you want the value of
-- @usage currentHP = 50
-- dt.getValueAt("currentHP") -- returns 50
function DemonTools.getValueAt(variableString)
  return getValueAt(variableString)
end

--- Returns if a file or directory exists on the filesystem
-- @tparam string path the path to the file or directory to check
function DemonTools.exists(path)
  return exists(path)
end

--- Returns if a path is a directory or not
-- @tparam string path the path to check
function DemonTools.isDir(path)
  return isDir(path)
end

--- Returns true if running on windows, false otherwise
function DemonTools.isWindows()
  return isWindows()
end

--- Creates a directory, creating each directory as necessary along the way.
-- @tparam string path the path to create
function DemonTools.mkdir_p(path)
  return mkdir_p(path)
end

DemonTools.htmlHeader = htmlHeader
DemonTools.htmlHeaderPattern = htmlHeaderPattern

return DemonTools
]==]

-- Execute the content to define the module
local DemonTools = assert(loadstring(EMCO_demontools_content))()
return DemonTools]]></script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EMCO_loggingconsole</name>
					<packageName></packageName>
					<script><![CDATA[-- Store content for master loader
EMCO_loggingconsole_content = [==[
--- MiniConsole with logging capabilities
-- @classmod LoggingConsole
-- @author Damian Monogue <demonnic@gmail.com>
-- @copyright 2020 Damian Monogue
-- @license MIT, see LICENSE.lua
local homedir = getMudletHomeDir():gsub("\\", "/")
-- Modified for EMCO in LuminariGUI - use global demontools
local dt = require("demontools")
local exists, htmlHeader, htmlHeaderPattern = dt.exists, dt.htmlHeader, dt.htmlHeaderPattern

local LoggingConsole = {log = true, logFormat = "h", path = "|h/log/consoleLogs/|y/|m/|d/", fileName = "|n.|e"}

--- Creates and returns a new LoggingConsole.
-- @param cons table of constraints. Includes all the valid Geyser.MiniConsole constraints, plus
-- <table class="tg">
-- <thead>
--   <tr>
--     <th>option name</th>
--     <th>description</th>
--     <th>default</th>
--   </tr>
-- </thead>
-- <tbody>
--   <tr>
--     <td class="tg-1">log</td>
--     <td class="tg-1">Should the miniconsole be logging?</td>
--     <td class="tg-1">true</td>
--   </tr>
--   <tr>
--     <td class="tg-2">logFormat</td>
--     <td class="tg-2">"h" for html, "t" for plaintext, "l" for log (with ansi)</td>
--     <td class="tg-2">h</td>
--   </tr>
--   <tr>
--     <td class="tg-1">path</td>
--     <td class="tg-1">The path the file lives in. It is templated.<br>|h is replaced by the profile homedir.<br>|y by 4 digit year.<br>|m by 2 digit month<br>|d by 2 digit day<br>|n by the name constraint<br>|e by the file extension (html for h logType, log for others)</td>
--     <td class="tg-1">"|h/log/consoleLogs/|y/|m/|d/"</td>
--   </tr>
--   <tr>
--     <td class="tg-2">fileName</td>
--     <td class="tg-2">The name of the log file. It is templated, same as path above</td>
--     <td class="tg-2">"|n.|e"</td>
--   </tr>
-- </tbody>
-- </table>
-- @param container the container for the console
-- @usage
-- local LoggingConsole = require("MDK.loggingconsole")
-- myLoggingConsole = LoggingConsole:new({
-- name = "my logging console",
--   x = 0,
--   y = 0,
--   height = 200,
--   width = 400,
-- }) -- just like making a miniconsole, really
function LoggingConsole:new(cons, container)
  cons = cons or {}
  local consType = type(cons)
  assert(consType == "table", "LoggingConsole:new(cons, container): cons must be a valid table of constraints. Got: " .. consType)
  local me = Geyser.MiniConsole:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  return me
end

--- Returns the file extension of the logfile this console will log to
function LoggingConsole:getExtension()
  local extension = "log"
  if table.contains({"h", "html"}, self.logFormat) then
    extension = "html"
  end
  return extension
end

--- Returns a string with all templated items replaced
---@tparam string str The templated string to transform
---@local
function LoggingConsole:transformTemplate(str)
  local ttbl = getTime()
  local year = ttbl.year
  local month = string.format("%02d", ttbl.month)
  local day = string.format("%02d", ttbl.day)
  local name = self.name
  local extension = self:getExtension()
  str = str:gsub("|h", homedir)
  str = str:gsub("|y", year)
  str = str:gsub("|m", month)
  str = str:gsub("|d", day)
  str = str:gsub("|n", name)
  str = str:gsub("|e", extension)
  return str
end

--- Returns the path to the logfile for this console
function LoggingConsole:getPath()
  local path = self:transformTemplate(self.path)
  if not path:ends("/") then
    path = path .. "/"
  end
  return path
end

--- Sets the path to use for the log file.
-- @param path the path to put the log file in. It is templated.<br>|h is replaced by the profile homedir.<br>|y by 4 digit year.<br>|m by 2 digit month<br>|d by 2 digit day<br>|n by the name constraint<br>|e by the file extension (html for h logType, log for others)
function LoggingConsole:setPath(path)
  self.path = path
end

--- Returns the filename for the logfile for this console
function LoggingConsole:getFileName()
  local fileName = self:transformTemplate(self.fileName)
  fileName = fileName:gsub("[<>:'\"/\\?*]", "_")
  return fileName
end

--- Sets the fileName to use for the log file.
-- @param fileName the fileName to use for the logfile. It is templated.<br>|h is replaced by the profile homedir.<br>|y by 4 digit year.<br>|m by 2 digit month<br>|d by 2 digit day<br>|n by the name constraint<br>|e by the file extension (html for h logType, log for others)
function LoggingConsole:setFileName(fileName)
  self.fileName = fileName
end

--- Returns the pull path and filename for the logfile for this console
function LoggingConsole:getFullFilename()
  local path = self:getPath()
  local fileName = self:getFileName()
  local fullPath = path .. fileName
  fullPath = fullPath:gsub("|", "_")
  return fullPath
end

--- Turns logging for this console on
function LoggingConsole:enableLogging()
  self.log = true
end

--- Turns logging for this console off
function LoggingConsole:disableLogging()
  self.log = false
end

--- Creates the path for the logfile for this console if necessary
---@local
function LoggingConsole:createPathIfNotExists()
  local path = self:transformTemplate(self.path)
  if not path:ends("/") then
    path = path .. "/"
  end
  if not exists(path) then
    local ok, err = dt.mkdir_p(path)
    if not ok then
      assert(false, "Could not create directory for log files:" .. path .. "\n Reason was: " .. err)
    end
  end
  return true
end

--- Handles actually writing to the log file
---@local
function LoggingConsole:writeToLog(str)
  local fileName = self:getFullFilename()
  self:createPathIfNotExists()
  if self:getExtension() == "html" then
    if not io.exists(fileName) then
      str = htmlHeader .. str
    end
    str = str
  end
  local file, err = io.open(fileName, "a")
  if not file then
    echo(err .. "\n")
    return
  end
  file:write(str)
  file:close()
end

local parent = Geyser.MiniConsole
--- Handler function which does the lifting for c/d/h/echo and appendBuffer to provide the logfile writing functionality
---@param str the string to echo. Use "" for appends
---@param etype the type of echo. Valid are "c", "d", "h", "e", and "a"
---@param log Allows you to override the default behaviour defined by the .log property. Pass true to definitely log, false to skip logging.
---@local
function LoggingConsole:xEcho(str, etype, log)
  if log == nil then
    log = self.log
  end
  local logStr
  local logType = self.logFormat
  if logType:find("h") then
    logType = "h"
  elseif logType ~= "t" then
    logType = "l"
  end
  if etype == "d" then -- decho
    if logType == "h" then
      logStr = dt.decho2html(str)
    elseif logType == "t" then
      logStr = dt.decho2string(str)
    else
      logStr = dt.decho2ansi(str)
    end
    parent.decho(self, str)
  elseif etype == "c" then -- cecho
    if logType == "h" then
      logStr = dt.cecho2html(str)
    elseif logType == "t" then
      logStr = dt.cecho2string(str)
    else
      logStr = dt.cecho2ansi(str)
    end
    parent.cecho(self, str)
  elseif etype == "h" then -- hecho
    if logType == "h" then
      logStr = dt.hecho2html(str)
    elseif logType == "t" then
      logStr = dt.hecho2string(str)
    else
      logStr = dt.hecho2ansi(str)
    end
    parent.hecho(self, str)
  elseif etype == "a" then -- append
    str = dt.append2decho()
    if logType == "h" then
      logStr = dt.decho2html(str .. "\n")
    elseif logType == "t" then
      logStr = dt.decho2string(str) .. "\n"
    else
      logStr = dt.decho2ansi(str) .. "\n"
    end
    parent.appendBuffer(self)
  elseif etype == "e" then -- echo
    if logType == "h" then
      logStr = dt.decho2html(str)
    elseif logType == "t" then
      logStr = str
    else
      logStr = str
    end
    parent.echo(self, str)
  end
  if log then
    self:writeToLog(logStr)
  end
end

--- Works like Geyser.MiniConsole:echo, but also logs the text if the .log property is true
-- @param str the string to echo to the console
-- @param log Allows you to override the default behaviour defined by the .log property. Pass true to definitely log, false to skip logging.
function LoggingConsole:echo(str, log)
  self:xEcho(str, "e", log)
end

--- Works like Geyser.MiniConsole:hecho, but also logs the text if the .log property is true
-- @param str the string to hecho to the console
-- @param log Allows you to override the default behaviour defined by the .log property. Pass true to definitely log, false to skip logging.
function LoggingConsole:hecho(str, log)
  self:xEcho(str, "h", log)
end

--- Works like Geyser.MiniConsole:decho, but also logs the text if the .log property is true
-- @param str the string to decho to the console
-- @param log Allows you to override the default behaviour defined by the .log property. Pass true to definitely log, false to skip logging.
function LoggingConsole:decho(str, log)
  self:xEcho(str, "d", log)
end

--- Works like Geyser.MiniConsole:cecho, but also logs the text if the .log property is true
-- @param str the string to cecho to the console
-- @param log Allows you to override the default behaviour defined by the .log property. Pass true to definitely log, false to skip logging.
function LoggingConsole:cecho(str, log)
  self:xEcho(str, "c", log)
end

--- Works like Geyser.MiniConsole:appendBuffer, but also logs the text if the .log property is true
-- @param log Allows you to override the default behaviour defined by the .log property. Pass true to definitely log, false to skip logging.
function LoggingConsole:appendBuffer(log)
  self:xEcho("", "a", log)
end

--- Replays the last X lines from the console's log file, if it exists
-- @param numberOfLines The number of lines to replay from the end of the file
function LoggingConsole:replay(numberOfLines)
  local fileName = self:getFullFilename()
  if not exists(fileName) then
    return
  end
  local file = io.open(fileName, "r")
  local lines = file:read("*a")
  file:close()
  if self:getExtension() == "html" then
    for _, line in ipairs(dt.html2decho(lines):split("\n")) do
      self:decho(line .. "\n", false)
    end
  else
    for _, line in ipairs(lines:split("\n")) do
      self:decho(dt.ansi2decho(line) .. "\n", false)
    end
  end
end

return LoggingConsole
]==]

-- Execute the content to define the module
local LoggingConsole = assert(loadstring(EMCO_loggingconsole_content))()
return LoggingConsole]]></script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EMCO_core</name>
					<packageName></packageName>
					<script><![CDATA[-- Store content for master loader
EMCO_core_content = [==[
--- Embeddable Multi Console Object.
-- This is essentially YATCO, but with some tweaks, updates, and it returns an object
-- similar to Geyser so that you can a.) have multiple of them and b.) easily embed it
-- into your existing UI as you would any other Geyser element.
-- @classmod EMCO
-- @author Damian Monogue <demonnic@gmail.com>
-- @copyright 2020 Damian Monogue
-- @copyright 2021 Damian Monogue
-- @license MIT, see LICENSE.lua
local EMCO = Geyser.Container:new({
  name = "TabbedConsoleClass",
  timestampExceptions = {},
  path = "|h/log/|E/|y/|m/|d/",
  fileName = "|N.|e",
  bufferSize = "100000",
  deleteLines = "1000",
  blinkTime = 3,
  tabFontSize = 8,
  tabAlignment = "c",
  fontSize = 9,
  activeTabCSS = "",
  inactiveTabCSS = "",
  activeTabFGColor = "purple",
  inactiveTabFGColor = "white",
  activeTabBGColor = "<0,180,0>",
  inactiveTabBGColor = "<60,60,60>",
  consoleColor = "black",
  tabBoxCSS = "",
  tabBoxColor = "black",
  consoleContainerCSS = "",
  consoleContainerColor = "black",
  tabHeight = 25,
  leftMargin = 0,
  rightMargin = 0,
  topMargin = 0,
  bottomMargin = 0,
  gap = 1,
  wrapAt = 300,
  autoWrap = true,
  logExclusions = {},
  logFormat = "h",
  gags = {},
  notifyTabs = {},
  notifyWithFocus = false,
  cmdLineStyleSheet = [[
    QPlainTextEdit {
      border: 1px solid grey;
    }
  ]]
})

-- patch Geyser.MiniConsole if it does not have its own display method defined
if Geyser.MiniConsole.display == Geyser.display then
  function Geyser.MiniConsole:display(...)
    local arg = {...}
    arg.n = table.maxn(arg)
    if arg.n > 1 then
      for i = 1, arg.n do
        self:display(arg[i])
      end
    else
      self:echo((prettywrite(arg[1], '  ') or 'nil') .. '\n')
    end
  end
end

-- Modified for EMCO in LuminariGUI - use global LoggingConsole
local ok, content = pcall(require, "LoggingConsole")
local LC
if ok then
  LC = content
else
  debugc("EMCO tried to require LoggingConsole but could not because: " .. content)
end
--- Creates a new Embeddable Multi Console Object.
-- <br>see https://github.com/demonnic/EMCO/wiki for information on valid constraints and defaults
-- @tparam table cons table of constraints which configures the EMCO.
-- <table class="tg">
-- <thead>
--   <tr>
--     <th>option name</th>
--     <th>description</th>
--     <th>default</th>
--   </tr>
-- </thead>
-- <tbody>
--   <tr>
--     <td class="tg-1">timestamp</td>
--     <td class="tg-1">display timestamps on the miniconsoles?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">blankLine</td>
--     <td class="tg-2">put a blank line between appends/echos?</td>
--     <td class="tg-2">false</td>
--   </tr>
--   <tr>
--     <td class="tg-1">scrollbars</td>
--     <td class="tg-1">enable scrollbars for the miniconsoles?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">customTimestampColor</td>
--     <td class="tg-2">if showing timestamps, use a custom color?</td>
--     <td class="tg-2">false</td>
--   </tr>
--   <tr>
--     <td class="tg-1">mapTab</td>
--     <td class="tg-1">should we attach the Mudlet Mapper to this EMCO?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">mapTabName</td>
--     <td class="tg-2">Which tab should we attach the map to?
--                     <br>If mapTab is true and you do not set this, it will throw an error</td>
--     <td class="tg-2"></td>
--   </tr>
--   <tr>
--     <td class="tg-1">blinkFromAll</td>
--     <td class="tg-1">should tabs still blink, even if you're on the 'all' tab?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">preserveBackground</td>
--     <td class="tg-2">preserve the miniconsole background color during append()?</td>
--     <td class="tg-2">false</td>
--   </tr>
--   <tr>
--     <td class="tg-1">gag</td>
--     <td class="tg-1">when running :append(), should we also gag the line?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">timestampFormat</td>
--     <td class="tg-2">Format string for the timestamp. Uses getTime()</td>
--     <td class="tg-2">"HH:mm:ss"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">timestampBGColor</td>
--     <td class="tg-1">Custom BG color to use for timestamps. Any valid Geyser.Color works.</td>
--     <td class="tg-1">"blue"</td>
--   </tr>
--   <tr>
--     <td class="tg-2">timestampFGColor</td>
--     <td class="tg-2">Custom FG color to use for timestamps. Any valid Geyser.Color works</td>
--     <td class="tg-2">"red"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">allTab</td>
--     <td class="tg-1">Should we send everything to an 'all' tab?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">allTabName</td>
--     <td class="tg-2">And which tab should we use for the 'all' tab?</td>
--     <td class="tg-2">"All"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">blink</td>
--     <td class="tg-1">Should we blink tabs that have been written to since you looked at them?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">blinkTime</td>
--     <td class="tg-2">How long to wait between blinks, in seconds?</td>
--     <td class="tg-2">3</td>
--   </tr>
--   <tr>
--     <td class="tg-1">fontSize</td>
--     <td class="tg-1">What font size to use for the miniconsoles?</td>
--     <td class="tg-1">9</td>
--   </tr>
--   <tr>
--     <td class="tg-2">font</td>
--     <td class="tg-2">What font to use for the miniconsoles?</td>
--     <td class="tg-2"></td>
--   </tr>
--   <tr>
--     <td class="tg-1">tabFont</td>
--     <td class="tg-1">What font to use for the tabs?</td>
--     <td class="tg-1"></td>
--   </tr>
--   <tr>
--     <td class="tg-2">activeTabCss</td>
--     <td class="tg-2">What css to use for the active tab?</td>
--     <td class="tg-2">""</td>
--   </tr>
--   <tr>
--     <td class="tg-1">inactiveTabCSS</td>
--     <td class="tg-1">What css to use for the inactive tabs?</td>
--     <td class="tg-1">""</td>
--   </tr>
--   <tr>
--     <td class="tg-2">activeTabFGColor</td>
--     <td class="tg-2">What color to use for the text on the active tab. Any Geyser.Color works.</td>
--     <td class="tg-2">"purple"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">inactiveTabFGColor</td>
--     <td class="tg-1">What color to use for the text on the inactive tabs. Any Geyser.Color works.</td>
--     <td class="tg-1">"white"</td>
--   </tr>
--   <tr>
--     <td class="tg-2">activeTabBGColor</td>
--     <td class="tg-2">What BG color to use for the active tab? Any Geyser.Color works. Overriden by activeTabCSS</td>
--     <td class="tg-2">"<0,180,0>"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">inactiveTabBGColor</td>
--     <td class="tg-1">What BG color to use for the inactavie tabs? Any Geyser.Color works. Overridden by inactiveTabCSS</td>
--     <td class="tg-1">"<60,60,60>"</td>
--   </tr>
--   <tr>
--     <td class="tg-2">consoleColor</td>
--     <td class="tg-2">Default background color for the miniconsoles. Any Geyser.Color works</td>
--     <td class="tg-2">"black"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">tabBoxCSS</td>
--     <td class="tg-1">tss for the entire tabBox (not individual tabs)</td>
--     <td class="tg-1">""</td>
--   </tr>
--   <tr>
--     <td class="tg-2">tabBoxColor</td>
--     <td class="tg-2">What color to use for the tabBox? Any Geyser.Color works. Overridden by tabBoxCSS</td>
--     <td class="tg-2">"black"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">consoleContainerCSS</td>
--     <td class="tg-1">CSS to use for the container holding the miniconsoles</td>
--     <td class="tg-1">""</td>
--   </tr>
--   <tr>
--     <td class="tg-2">consoleContainerColor</td>
--     <td class="tg-2">Color to use for the container holding the miniconsole. Any Geyser.Color works. Overridden by consoleContainerCSS</td>
--     <td class="tg-2">"black"</td>
--   </tr>
--   <tr>
--     <td class="tg-1">gap</td>
--     <td class="tg-1">How many pixels to place between the tabs and the miniconsoles?</td>
--     <td class="tg-1">1</td>
--   </tr>
--   <tr>
--     <td class="tg-2">consoles</td>
--     <td class="tg-2">List of the tabs for this EMCO in table format</td>
--     <td class="tg-2">{ "All" }</td>
--   </tr>
--   <tr>
--     <td class="tg-1">allTabExclusions</td>
--     <td class="tg-1">List of the tabs which should never echo to the 'all' tab in table format</td>
--     <td class="tg-1">{}</td>
--   </tr>
--   <tr>
--     <td class="tg-2">tabHeight</td>
--     <td class="tg-2">How many pixels high should the tabs be?</td>
--     <td class="tg-2">25</td>
--   </tr>
--   <tr>
--     <td class="tg-1">autoWrap</td>
--     <td class="tg-1">Use autoWrap for the miniconsoles?</td>
--     <td class="tg-1">true</td>
--   </tr>
--   <tr>
--     <td class="tg-2">wrapAt</td>
--     <td class="tg-2">How many characters to wrap it, if autoWrap is turned off?</td>
--     <td class="tg-2">300</td>
--   </tr>
--   <tr>
--     <td class="tg-1">leftMargin</td>
--     <td class="tg-1">Number of pixels to put between the left edge of the EMCO and the miniconsole?</td>
--     <td class="tg-1">0</td>
--   </tr>
--   <tr>
--     <td class="tg-2">rightMargin</td>
--     <td class="tg-2">Number of pixels to put between the right edge of the EMCO and the miniconsole?</td>
--     <td class="tg-2">0</td>
--   </tr>
--   <tr>
--     <td class="tg-1">bottomMargin</td>
--     <td class="tg-1">Number of pixels to put between the bottom edge of the EMCO and the miniconsole?</td>
--     <td class="tg-1">0</td>
--   </tr>
--   <tr>
--     <td class="tg-2">topMargin</td>
--     <td class="tg-2">Number of pixels to put between the top edge of the miniconsole container, and the miniconsole? This is in addition to gap</td>
--     <td class="tg-2">0</td>
--   </tr>
--   <tr>
--     <td class="tg-1">timestampExceptions</td>
--     <td class="tg-1">Table of tabnames which should not get timestamps even if timestamps are turned on</td>
--     <td class="tg-1">{}</td>
--   </tr>
--   <tr>
--     <td class="tg-2">tabFontSize</td>
--     <td class="tg-2">Font size for the tabs</td>
--     <td class="tg-2">8</td>
--   </tr>
--   <tr>
--     <td class="tg-1">tabBold</td>
--     <td class="tg-1">Should the tab text be bold? Boolean value</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">tabItalics</td>
--     <td class="tg-2">Should the tab text be italicized?</td>
--     <td class="tg-2">false</td>
--   </tr>
--   <tr>
--     <td class="tg-1">tabUnderline</td>
--     <td class="tg-1">Should the tab text be underlined?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">tabAlignment</td>
--     <td class="tg-2">Valid alignments are 'c', 'center', 'l', 'left', 'r', 'right', or '' to not include the alignment as part of the echo (to allow the stylesheet to handle it)</td>
--     <td class="tg-2">'c'</td>
--   </tr>
--   <tr>
--     <td class="tg-1">commandLine</td>
--     <td class="tg-1">Should we enable commandlines for the miniconsoles?</td>
--     <td class="tg-1">false</td>
--   </tr>
--   <tr>
--     <td class="tg-2">cmdActions</td>
--     <td class="tg-2">A table with console names as keys, and values which are templates for the command to send. see the setCustomCommandline function for more</td>
--     <td class="tg-2">{}</td>
--   </tr>
--   <tr>
--     <td class="tg-1">cmdLineStyleSheet</td>
--     <td class="tg-1">What stylesheet to use for the command lines.</td>
--     <td class="tg-1">"QPlainTextEdit {\n      border: 1px solid grey;\n    }\n"</td>
--   </tr>
--   <tr>
--     <td class="tg-2">backgroundImages</td>
--     <td class="tg-2">A table containing definitions for the background images. Each entry should have a key the same name as the tab it applies to, with entries "image" which is the path to the image file,<br>and "mode" which determines how it is displayed. "border" stretches, "center" center, "tile" tiles, and "style". See Mudletwikilink for details.</td>
--     <td class="tg-2">{}</td>
--   </tr>
--   <tr>
--     <td class="tg-1">bufferSize</td>
--     <td class="tg-1">Number of lines of scrollback to keep for the miniconsoles</td>
--     <td class="tg-1">100000</td>
--   </tr>
--   <tr>
--     <td class="tg-2">deleteLines</td>
--     <td class="tg-2">Number of lines to delete if a console's buffer fills up.</td>
--     <td class="tg-2">1000</td>
--   </tr>
--   <tr>
--     <td class="tg-1">gags</td>
--     <td class="tg-1">A table of Lua patterns you wish to gag from being added to the EMCO. Useful for removing mob says and such example: {[[^A green leprechaun says, ".*"$]], "^Bob The Dark Lord of the Keep mutters darkly to himself.$"} see <a href="http://lua-users.org/wiki/PatternsTutorial">this tutorial</a> on Lua patterns for more information.</td>
--     <td class="tg-1">{}</td>
--   </tr>
--   <tr>
--     <td class="tg-2">notifyTabs</td>
--     <td class="tg-2">Tables containing the names of all tabs you want to send notifications. IE {"Says", "Tells", "Org"}</td>
--     <td class="tg-2">{}</td>
--   </tr>
--   <tr>
--     <td class="tg-1">notifyWithFocus</td>
--     <td class="tg-1">If true, EMCO will send notifications even if Mudlet has focus. If false, it will only send them when Mudlet does NOT have focus.</td>
--     <td class="tg-1">false</td>
--   </tr>
-- </tbody>
-- </table>
-- @tparam GeyserObject container The container to use as the parent for the EMCO
-- @return the newly created EMCO
function EMCO:new(cons, container)
  local funcName = "EMCO:new(cons, container)"
  cons = cons or {}
  cons.type = cons.type or "tabbedConsole"
  cons.consoles = cons.consoles or {"All"}
  if cons.mapTab then
    if not type(cons.mapTabName) == "string" then
      self:ce(funcName, [["mapTab" is true, thus constraint "mapTabName" as string expected, got ]] .. type(cons.mapTabName))
    elseif not table.contains(cons.consoles, cons.mapTabName) then
      self:ce(funcName, [["mapTabName" must be one of the consoles contained within constraint "consoles". Valid option for tha mapTab are: ]] ..
                table.concat(cons.consoles, ","))
    end
  end
  cons.allTabExclusions = cons.allTabExclusions or {}
  if not type(cons.allTabExclusions) == "table" then
    self:se(funcName, "allTabExclusions must be a table if it is provided")
  end
  local me = self.parent:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  -- set some defaults. Almost all the defaults we had for YATCO, plus a few new ones
  me.cmdActions = cons.cmdActions or {}
  if not type(me.cmdActions) == "table" then
    self:se(funcName, "cmdActions must be a table if it is provided")
  end
  me.backgroundImages = cons.backgroundImages or {}
  if not type(me.backgroundImages) == "table" then
    self:se(funcName, "backgroundImages must be a table if provided.")
  end
  if me:fuzzyBoolean(cons.timestamp) then
    me:enableTimestamp()
  else
    me:disableTimestamp()
  end
  if me:fuzzyBoolean(cons.customTimestampColor) then
    me:enableCustomTimestampColor()
  else
    me:disableCustomTimestampColor()
  end
  if me:fuzzyBoolean(cons.mapTab) then
    me.mapTab = true
  else
    me.mapTab = false
  end
  if me:fuzzyBoolean(cons.blinkFromAll) then
    me:enableBlinkFromAll()
  else
    me:disableBlinkFromAll()
  end
  if me:fuzzyBoolean(cons.preserveBackground) then
    me:enablePreserveBackground()
  else
    me:disablePreserveBackground()
  end
  if me:fuzzyBoolean(cons.gag) then
    me:enableGag()
  else
    me:disableGag()
  end
  me:setTimestampFormat(cons.timestampFormat or "HH:mm:ss")
  me:setTimestampBGColor(cons.timestampBGColor or "blue")
  me:setTimestampFGColor(cons.timestampFGColor or "red")
  if me:fuzzyBoolean(cons.allTab) then
    me:enableAllTab(cons.allTab)
  else
    me:disableAllTab()
  end
  if me:fuzzyBoolean(cons.blink) then
    me:enableBlink()
  else
    me:disableBlink()
  end
  if me:fuzzyBoolean(cons.blankLine) then
    me:enableBlankLine()
  else
    me:disableBlankLine()
  end
  if me:fuzzyBoolean(cons.scrollbars) then
    me.scrollbars = true
  else
    me.scrollbars = false
  end
  me.tabUnderline = me:fuzzyBoolean(cons.tabUnderline) and true or false
  me.tabBold = me:fuzzyBoolean(cons.tabBold) and true or false
  me.tabItalics = me:fuzzyBoolean(cons.tabItalics) and true or false
  me.commandLine = me:fuzzyBoolean(cons.commandLine) and true or false
  me.consoles = cons.consoles
  me.font = cons.font
  me.tabFont = cons.tabFont
  me.currentTab = ""
  me.tabs = {}
  me.tabsToBlink = {}
  me.mc = {}
  if me.blink then
    me:enableBlink()
  end
  me.gags = {}
  for _,pattern in ipairs(cons.gags or {}) do
    me:addGag(pattern)
  end
  for _,tname in ipairs(cons.notifyTabs or {}) do
    me:addNotifyTab(tname)
  end
  if me:fuzzyBoolean(cons.notifyWithFocus) then
    self:enableNotifyWithFocus()
  end
  me:reset()
  if me.allTab then
    me:setAllTabName(me.allTabName or me.consoles[1])
  end
  return me
end

function EMCO:readYATCO()
  local config
  if demonnic and demonnic.chat and demonnic.chat.config then
    config = demonnic.chat.config
  else
    cecho("<white>(<blue>EMCO<white>)<reset> Could not find demonnic.chat.config, nothing to convert\n")
    return
  end
  local constraints = "EMCO:new({\n"
  constraints = string.format("%s  x = %d,\n", constraints, demonnic.chat.container.get_x())
  constraints = string.format("%s  y = %d,\n", constraints, demonnic.chat.container.get_y())
  constraints = string.format("%s  width = %d,\n", constraints, demonnic.chat.container.get_width())
  constraints = string.format("%s  height = %d,\n", constraints, demonnic.chat.container.get_height())
  if config.timestamp then
    constraints = string.format("%s  timestamp = true,\n  timestampFormat = \"%s\",\n", constraints, config.timestamp)
  else
    constraints = string.format("%s  timestamp = false,\n", constraints)
  end
  if config.timestampColor then
    constraints = string.format("%s  customTimestampColor = true,\n", constraints)
  else
    constraints = string.format("%s  customTimestampColor = false,\n", constraints)
  end
  if config.timestampFG then
    constraints = string.format("%s  timestampFGColor = \"%s\",\n", constraints, config.timestampFG)
  end
  if config.timestampBG then
    constraints = string.format("%s  timestampBGColor = \"%s\",\n", constraints, config.timestampBG)
  end
  if config.channels then
    local channels = "consoles = {\n"
    for _, channel in ipairs(config.channels) do
      if _ == #config.channels then
        channels = string.format("%s    \"%s\"", channels, channel)
      else
        channels = string.format("%s    \"%s\",\n", channels, channel)
      end
    end
    channels = string.format("%s\n  },\n", channels)
    constraints = string.format([[%s  %s]], constraints, channels)
  end
  if config.Alltab then
    constraints = string.format("%s  allTab = true,\n", constraints)
    constraints = string.format("%s  allTabName = \"%s\",\n", constraints, config.Alltab)
  else
    constraints = string.format("%s  allTab = false,\n", constraints)
  end
  if config.Maptab and config.Maptab ~= "" then
    constraints = string.format("%s  mapTab = true,\n", constraints)
    constraints = string.format("%s  mapTabName = \"%s\",\n", constraints, config.Maptab)
  else
    constraints = string.format("%s  mapTab = false,\n", constraints)
  end
  constraints = string.format("%s  blink = %s,\n", constraints, tostring(config.blink))
  constraints = string.format("%s  blinkFromAll = %s,\n", constraints, tostring(config.blinkFromAll))
  if config.fontSize then
    constraints = string.format("%s  fontSize = %d,\n", constraints, config.fontSize)
  end
  constraints = string.format("%s  preserveBackground = %s,\n", constraints, tostring(config.preserveBackground))
  constraints = string.format("%s  gag = %s,\n", constraints, tostring(config.gag))
  constraints = string.format("%s  activeTabBGColor = \"<%s,%s,%s>\",\n", constraints, config.activeColors.r, config.activeColors.g,
                              config.activeColors.b)
  constraints = string.format("%s  inactiveTabBGColor = \"<%s,%s,%s>\",\n", constraints, config.inactiveColors.r, config.inactiveColors.g,
                              config.inactiveColors.b)
  constraints =
    string.format("%s  consoleColor = \"<%s,%s,%s>\",\n", constraints, config.windowColors.r, config.windowColors.g, config.windowColors.b)
  constraints = string.format("%s  activeTabFGColor = \"%s\",\n", constraints, config.activeTabText)
  constraints = string.format("%s  inactiveTabFGColor = \"%s\"", constraints, config.inactiveTabText)
  constraints = string.format("%s\n})", constraints)
  return constraints
end

--- Scans for the old YATCO configuration values and prints out a set of constraints to use.
-- with EMCO to achieve the same effect. Is just the invocation
function EMCO:miniConvertYATCO()
  local constraints = self:readYATCO()
  cecho(
    "<white>(<blue>EMCO<white>)<reset> Found a YATCO config. Here are the constraints to use with EMCO(x,y,width, and height have been converted to their absolute values):\n\n")
  echo(constraints .. "\n")
end

--- Echos to the main console a script object you can add which will fully convert YATCO to EMCO.
-- This replaces the demonnic.chat variable with a newly created EMCO object, so that the main
-- functions used to place information on the consoles (append(), cecho(), etc) should continue to
-- work in the user's triggers and events.
function EMCO:convertYATCO()
  local invocation = self:readYATCO()
  local header = [[
  <white>(<blue>EMCO<white>)<reset> Found a YATCO config. Make a new script, then copy and paste the following output into it.
  <white>(<blue>EMCO<white>)<reset> Afterward, uninstall YATCO (you can leave YATCOConfig until you're sure everything is right) and restart Mudlet
  <white>(<blue>EMCO<white>)<reset> If everything looks right, you can uninstall YATCOConfig. 


-- Copy everything below this line until the next line starting with --
demonnic = demonnic or {}
demonnic.chat = ]]
  cecho(string.format("%s%s\n--- End script\n", header, invocation))
end

function EMCO:checkTabPosition(position)
  if position == nil then
    return 0
  end
  return tonumber(position) or type(position)
end

function EMCO:checkTabName(tabName)
  if not tostring(tabName) then
    return "tabName as string expected, got" .. type(tabName)
  end
  tabName = tostring(tabName)
  if table.contains(self.consoles, tabName) then
    return "tabName must be unique, and we already have a tab named " .. tabName
  else
    return "clear"
  end
end

function EMCO.ae(funcName, message)
  error(string.format("%s: Argument Error: %s", funcName, message))
end

function EMCO:ce(funcName, message)
  error(string.format("%s:gg Constraint Error: %s", funcName, message))
end

--- Display the contents of one or more variables to an EMCO tab. like display() but targets the miniconsole
-- @tparam string tabName the name of the tab you want to display to
-- @param tabName string the tab to displayu to
-- @param item any The thing to display()
-- @param[opt] any item2 another thing to display()
function EMCO:display(tabName, ...)
  local funcName = "EMCO:display(tabName, item)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be a tab which exists in this EMCO. valid options are: " .. table.concat(self.consoles, ","))
  end
  self.mc[tabName]:display(...)
end

--- Remove a tab from the EMCO
-- @param tabName string the name of the tab you want to remove from the EMCO
function EMCO:removeTab(tabName)
  local funcName = "EMCO:removeTab(tabName)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be a tab which exists in this EMCO. valid options are: " .. table.concat(self.consoles, ","))
  end
  if self.currentTab == tabName then
    if self.allTab and self.allTabName then
      self:switchTab(self.allTabName)
    else
      self:switchTab(self.consoles[1])
    end
  end
  table.remove(self.consoles, table.index_of(self.consoles, tabName))
  local window = self.mc[tabName]
  local tab = self.tabs[tabName]
  window:hide()
  tab:hide()
  self.tabBox:remove(tab)
  self.tabBox:organize()
  self.consoleContainer:remove(window)
  self.mc[tabName] = nil
  self.tabs[tabName] = nil
end

--- Adds a tab to the EMCO object
-- @tparam string tabName the name of the tab to add
-- @tparam[opt] number position position in the tab switcher to put this tab
function EMCO:addTab(tabName, position)
  local funcName = "EMCO:addTab(tabName, position)"
  position = self:checkTabPosition(position)
  if type(position) == "string" then
    self.ae(funcName, "position as number expected, got " .. position)
  end
  local tabCheck = self:checkTabName(tabName)
  if tabCheck ~= "clear" then
    self.ae(funcName, tabCheck)
  end
  if position == 0 then
    table.insert(self.consoles, tabName)
    self:createComponentsForTab(tabName)
  else
    table.insert(self.consoles, position, tabName)
    self:reset()
  end
end

--- Switches the active, visible tab of the EMCO to tabName
-- @param tabName string the name of the tab to show
function EMCO:switchTab(tabName)
  local oldTab = self.currentTab
  self.currentTab = tabName
  if oldTab ~= tabName and oldTab ~= "" then
    self.mc[oldTab]:hide()
    self:adjustTabBackground(oldTab)
    self.tabs[oldTab]:echo(oldTab, self.inactiveTabFGColor)
    if self.blink then
      if self.allTab and tabName == self.allTabName then
        self.tabsToBlink = {}
      elseif self.tabsToBlink[tabName] then
        self.tabsToBlink[tabName] = nil
      end
    end
  end
  self:adjustTabBackground(tabName)
  self.tabs[tabName]:echo(tabName, self.activeTabFGColor)
  -- if oldTab and self.mc[oldTab] then
  --   self.mc[oldTab]:hide()
  -- end
  self.mc[tabName]:show()
  if oldTab ~= tabName then
    raiseEvent("EMCO tab change", self.name, oldTab, tabName)
  end
end

--- Cycles between the tabs in order
-- @tparam boolean reverse Defaults to false. When true, moves backward through the tab list rather than forward.
function EMCO:cycleTab(reverse)
  -- add the property to demonnic.chat
  local consoles = self.consoles
  local cycleIndex = table.index_of(consoles, self.currentTab)

  local maxIndex = #consoles
  cycleIndex = reverse and cycleIndex - 1 or cycleIndex + 1
  if cycleIndex > maxIndex then cycleIndex = 1 end
  if cycleIndex < 1 then cycleIndex = maxIndex end
  self:switchTab(consoles[cycleIndex])
end

function EMCO:createComponentsForTab(tabName)
  local tab = Geyser.Label:new({name = string.format("%sTab%s", self.name, tabName)}, self.tabBox)
  if self.tabFont then
    tab:setFont(self.tabFont)
  end
  tab:setAlignment(self.tabAlignment)
  tab:setFontSize(self.tabFontSize)
  tab:setItalics(self.tabItalics)
  tab:setBold(self.tabBold)
  tab:setUnderline(self.tabUnderline)
  tab:setClickCallback(self.switchTab, self, tabName)
  self.tabs[tabName] = tab
  self:adjustTabBackground(tabName)
  tab:echo(tabName, self.inactiveTabFGColor)
  local window
  local windowConstraints = {
    x = self.leftMargin,
    y = self.topMargin,
    height = string.format("-%dpx", self.bottomMargin),
    width = string.format("-%dpx", self.rightMargin),
    name = string.format("%sWindow%s", self.name, tabName),
    commandLine = self.commandLine,
    cmdLineStyleSheet = self.cmdLineStyleSheet,
    path = self:processTemplate(self.path, tabName),
    fileName = self:processTemplate(self.fileName, tabName),
    logFormat = self.logFormat
  }
  if table.contains(self.logExclusions, tabName) then
    windowConstraints.log = false
  end
  local parent = self.consoleContainer
  local mapTab = self.mapTab and tabName == self.mapTabName
  if mapTab then
    window = Geyser.Mapper:new(windowConstraints, parent)
  else
    if LC then
      window = LC:new(windowConstraints, parent)
    else
      window = Geyser.MiniConsole:new(windowConstraints, parent)
    end
    if self.font then
      window:setFont(self.font)
    end
    window:setFontSize(self.fontSize)
    window:setColor(self.consoleColor)
    if self.autoWrap then
      window:enableAutoWrap()
    else
      window:setWrap(self.wrapAt)
    end
    if self.scrollbars then
      window:enableScrollBar()
    else
      window:disableScrollBar()
    end
    window:setBufferSize(self.bufferSize, self.deleteLines)
  end
  self.mc[tabName] = window
  if not mapTab then
    self:setCmdAction(tabName, nil)
  end
  window:hide()
  self:processImage(tabName)
  self:switchTab(tabName)
end

--- Sets the buffer size and number of lines to delete for all managed miniconsoles.
--- @tparam number bufferSize number of lines of scrollback to maintain in the miniconsoles. Uses current value if nil is passed
--- @tparam number deleteLines number of line to delete if the buffer filles up. Uses current value if nil is passed
function EMCO:setBufferSize(bufferSize, deleteLines)
  bufferSize = bufferSize or self.bufferSize
  deleteLines = deleteLines or self.deleteLines
  self.bufferSize = bufferSize
  self.deleteLines = deleteLines
  for tabName, window in pairs(self.mc) do
    local mapTab = self.mapTab and tabName == self.mapTabName
    if not mapTab then
      window:setBufferSize(bufferSize, deleteLines)
    end
  end
end

--- Sets the background image for a tab's console. use EMCO:resetBackgroundImage(tabName) to remove an image.
--- @tparam string tabName the tab to change the background image for.
--- @tparam string imagePath the path to the image file to use.
--- @tparam string mode the mode to use. Will default to "center" if not provided.
function EMCO:setBackgroundImage(tabName, imagePath, mode)
  mode = mode or "center"
  local tabNameType = type(tabName)
  local imagePathType = type(imagePath)
  local modeType = type(mode)
  local funcName = "EMCO:setBackgroundImage(tabName, imagePath, mode)"
  if tabNameType ~= "string" or not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be a string and an existing tab")
  end
  if imagePathType ~= "string" or not io.exists(imagePath) then
    self.ae(funcName, "imagePath must be a string and point to an existing image file")
  end
  if modeType ~= "string" or not table.contains({"border", "center", "tile", "style"}, mode) then
    self.ae(funcName, "mode must be one of 'border', 'center', 'tile', or 'style'")
  end
  local image = {image = imagePath, mode = mode}
  self.backgroundImages[tabName] = image
  self:processImage(tabName)
end

--- Resets the background image on a tab's console, returning it to the background color
--- @tparam string tabName the tab to change the background image for.
function EMCO:resetBackgroundImage(tabName)
  local tabNameType = type(tabName)
  local funcName = "EMCO:resetBackgroundImage(tabName)"
  if tabNameType ~= "string" or not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be a string and an existing tab")
  end
  self.backgroundImages[tabName] = nil
  self:processImage(tabName)
end

--- Does the work of actually setting/resetting the background image on a tab
--- @tparam string tabName the name of the tab to process the image for.
--- @local
function EMCO:processImage(tabName)
  if self.mapTab and tabName == self.mapTabName then
    return
  end
  local image = self.backgroundImages[tabName]
  local window = self.mc[tabName]
  if image then
    if image.image and io.exists(image.image) then
      window:setBackgroundImage(image.image, image.mode)
    end
  else
    window:resetBackgroundImage()
  end
end

--- Replays the last numLines lines from the log for tabName
-- @param tabName the name of the tab to replay
-- @param numLines the number of lines to replay
function EMCO:replay(tabName, numLines)
  if not LC then
    return
  end
  if self.mapTab and tabName == self.mapTabName then
    return
  end
  numLines = numLines or 10
  self.mc[tabName]:replay(numLines)
end

--- Replays the last numLines in all miniconsoles
-- @param numLines
function EMCO:replayAll(numLines)
  if not LC then
    return
  end
  numLines = numLines or 10
  for _, tabName in ipairs(self.consoles) do
    self:replay(tabName, numLines)
  end
end

--- Formats the string through EMCO's template. |E is replaced with the EMCO's name. |N is replaced with the tab's name.
-- @param str the string to replace tokens in
-- @param tabName optional, if included will be used for |N in the templated string.
function EMCO:processTemplate(str, tabName)
  local safeName = self.name:gsub("[<>:'\"?*]", "_")
  local safeTabName = tabName and tabName:gsub("[<>:'\"?*]", "_") or ""
  str = str:gsub("|E", safeName)
  str = str:gsub("|N", safeTabName)
  return str
end

--- Sets the path for the EMCO for logging
-- @param path the template for the path. @see EMCO:new()
function EMCO:setPath(path)
  if not LC then
    return
  end
  path = path or self.path
  self.path = path
  path = self:processTemplate(path)
  for name, window in pairs(self.mc) do
    if not (self.mapTab and self.mapTabName == name) then
      window:setPath(path)
    end
  end
end

--- Sets the fileName for the EMCO for logging
-- @param fileName the template for the path. @see EMCO:new()
function EMCO:setFileName(fileName)
  if not LC then
    return
  end
  fileName = fileName or self.fileName
  self.fileName = fileName
  fileName = self:processTemplate(fileName)
  for name, window in pairs(self.mc) do
    if not (self.mapTab and self.mapTabName == name) then
      window:setFileName(fileName)
    end
  end
end

--- Sets the stylesheet for command lines in this EMCO
-- @tparam string styleSheet the stylesheet to use for the command line. See https://wiki.mudlet.org/w/Manual:Lua_Functions#setCmdLineStyleSheet for examples
function EMCO:setCmdLineStyleSheet(styleSheet)
  self.cmdLineStyleSheet = styleSheet
  if not styleSheet then
    return
  end
  for _, window in pairs(self.mc) do
    window:setCmdLineStyleSheet(styleSheet)
  end
end
--- Enables the commandLine on the specified tab.
-- @tparam string tabName the name of the tab to turn the commandLine on for
-- @param template the template for the commandline to use, or the function to run when enter is hit.
-- @usage myEMCO:enableCmdLine(tabName, template)
function EMCO:enableCmdLine(tabName, template)
  if not table.contains(self.consoles, tabName) then
    return nil, f"{self.name}:enableCmdLine(tabName,template) tabName is not in the console list. Valid options are {table.concat(self.consoles, 'm')}"
  end
  local window = self.mc[tabName]
  window:enableCommandLine()
  if self.cmdLineStyleSheet then
    window:setCmdLineStyleSheet(self.cmdLineStyleSheet)
  end
  self:setCmdAction(tabName, template)
end

--- Enables all command lines, using whatever template they may currently have set
function EMCO:enableAllCmdLines()
  for _, tabName in ipairs(self.consoles) do
    self:enableCmdLine(tabName, self.cmdActions[tabName])
  end
end

--- Disables all commands line, but does not change their template
function EMCO:disableAllCmdLines()
  for _, tabName in ipairs(self.consoles) do
    self:disableCmdLine(tabName)
  end
end

--- Disables the command line for a particular tab
-- @tparam string tabName the name of the tab to disable the command line of.
function EMCO:disableCmdLine(tabName)
  if not table.contains(self.consoles, tabName) then
    return nil, f"{self.name}:disableCmdLine(tabName,template) tabName is not in the console list. Valid options are {table.concat(self.consoles, 'm')}"
  end
  local window = self.mc[tabName]
  window:disableCommandLine()
end

--- Sets the command action for a tab's command line. Can either be a template string to send where '|t' is replaced by the text sent, or a funnction which takes the text
--- @tparam string tabName the name of the tab to set the command action on
--- @param template the template for the commandline to use, or the function to run when enter is hit.
--- @usage myEMCO:setCmdAction("CT", "ct |t") -- will send everything in the CT tab's command line to CT by doing "ct Hi there!" if you type "Hi there!" in CT's command line
--- @usage myEMCO:setCmdAction("CT", function(txt) send("ct " .. txt) end) -- functionally the same as the above
function EMCO:setCmdAction(tabName, template)
  template = template or self.cmdActions[tabName]
  if template == "" then
    template = nil
  end
  self.cmdActions[tabName] = template
  local window = self.mc[tabName]
  if template then
    if type(template) == "string" then
      window:setCmdAction(function(txt)
        txt = template:gsub("|t", txt)
        send(txt)
      end)
    elseif type(template) == "function" then
      window:setCmdAction(template)
    else
      debugc(string.format(
               "EMCO:setCmdAction(tabName, template): template must be a string or function if provided. Leaving CmdAction for tab %s be. Template type was: %s",
               tabName, type(template)))
    end
  else
    window:resetCmdAction()
  end
end

--- Resets the command action for tabName's miniconsole, which makes it work like the normal commandline
--- @tparam string tabName the name of the tab to reset the cmdAction for
function EMCO:resetCmdAction(tabName)
  self.cmdActions[tabName] = nil
  self.mc[tabName]:resetCmdAction()
end

--- Gets the contents of tabName's cmdLine
--- @param tabName the name of the tab to get the commandline of
function EMCO:getCmdLine(tabName)
  return self.mc[tabName]:getCmdLine()
end

--- Prints to tabName's command line
--- @param tabName the tab whose command line you want to print to
--- @param txt the text to print to the command line
function EMCO:printCmd(tabName, txt)
  return self.mc[tabName]:printCmd(txt)
end

--- Clears tabName's command line
--- @tparam string tabName the tab whose command line you want to clear
function EMCO:clearCmd(tabName)
  return self.mc[tabName]:clearCmd()
end

--- Appends text to tabName's command line
--- @tparam string tabName the tab whose command line you want to append to
--- @tparam string txt the text to append to the command line
function EMCO:appendCmd(tabName, txt)
  return self.mc[tabName]:appendCmd(txt)
end

--- resets the object, redrawing everything
function EMCO:reset()
  self:createContainers()
  for _, tabName in ipairs(self.consoles) do
    self:createComponentsForTab(tabName)
  end

  local default = self.allTabName or self.consoles[1]
  self:switchTab(default)
end

function EMCO:createContainers()
  self.tabBoxLabel = Geyser.Label:new({
    x = 0,
    y = 0,
    width = "100%",
    height = tostring(tonumber(self.tabHeight) + 2) .. "px",
    name = self.name .. "TabBoxLabel",
  }, self)
  self.tabBox = Geyser.HBox:new({x = 0, y = 0, width = "100%", height = "100%", name = self.name .. "TabBox"}, self.tabBoxLabel)
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)

  local heightPlusGap = tonumber(self.tabHeight) + tonumber(self.gap)
  self.consoleContainer = Geyser.Label:new({
    x = 0,
    y = tostring(heightPlusGap) .. "px",
    width = "100%",
    height = "-0px",
    name = self.name .. "ConsoleContainer",
  }, self)
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

function EMCO:stripTimeChars(str)
  return string.gsub(string.trim(str), '[ThHmMszZaApPdy0-9%-%+:. ]', '')
end

--- Expands boolean definitions to be more flexible.
-- <br>True values are "true", "yes", "0", 0, and true
-- <br>False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function EMCO:fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {"yes", "true", "0"}
    local untruth = {"no", "false", "1"}
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end

--- clears a specific tab
--- @tparam string tabName the name of the tab to clear
function EMCO:clear(tabName)
  local funcName = "EMCO:clear(tabName)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  if self.mapTab and self.mapTabName == tabName then
    self.ae(funcName, "Cannot clear the map tab")
  end
  self.mc[tabName]:clear()
end

--- clears all the tabs
function EMCO:clearAll()
  for _, tabName in ipairs(self.consoles) do
    if not self.mapTab or (tabName ~= self.mapTabName) then
      self:clear(tabName)
    end
  end
end

--- sets the font for all tabs
--- @tparam string font the font to use.
function EMCO:setTabFont(font)
  self.tabFont = font
  for _, tab in pairs(self.tabs) do
    tab:setFont(font)
  end
end

--- sets the font for a single tab. If you use setTabFont this will be overridden
--- @tparam string tabName the tab to change the font of
--- @tparam string font the font to use for that tab
function EMCO:setSingleTabFont(tabName, font)
  local funcName = "EMCO:setSingleTabFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  self.tabs[tabName]:setFont(font)
end

--- sets the font for all the miniconsoles
--- @tparam string font the name of the font to use
function EMCO:setFont(font)
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setFont(font): attempt to call setFont with font '" .. font ..
                  "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.font = font
  for _, tabName in pairs(self.consoles) do
    if not self.mapTab or tabName ~= self.mapTabName then
      self.mc[tabName]:setFont(font)
    end
  end
end

--- sets the font for a specific miniconsole. If setFont is called this will be overridden
--- @tparam string tabName the name of window to set the font for
--- @tparam string font the name of the font to use
function EMCO:setSingleWindowFont(tabName, font)
  local funcName = "EMCO:setSingleWindowFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setSingleWindowFont(tabName, font): attempt to call setFont with font '" .. font ..
                  "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.mc[tabName]:setFont(font)
end

--- sets the font size for all tabs
--- @tparam number fontSize the font size to use for the tabs
function EMCO:setTabFontSize(fontSize)
  self.tabFontSize = fontSize
  for _, tab in pairs(self.tabs) do
    tab:setFontSize(fontSize)
  end
end

--- Sets the alignment for all the tabs
-- @param alignment Valid alignments are 'c', 'center', 'l', 'left', 'r', 'right', or '' to not include the alignment as part of the echo
function EMCO:setTabAlignment(alignment)
  self.tabAlignment = alignment
  for _, tab in pairs(self.tabs) do
    tab:setAlignment(self.tabAlignment)
  end
end

--- enables underline on all tabs
function EMCO:enableTabUnderline()
  self.tabUnderline = true
  for _, tab in pairs(self.tabs) do
    tab:setUnderline(self.tabUnderline)
  end
end

--- disables underline on all tabs
function EMCO:disableTabUnderline()
  self.tabUnderline = false
  for _, tab in pairs(self.tabs) do
    tab:setUnderline(self.tabUnderline)
  end
end

--- enables italics on all tabs
function EMCO:enableTabItalics()
  self.tabItalics = true
  for _, tab in pairs(self.tabs) do
    tab:setItalics(self.tabItalics)
  end
end

--- enables italics on all tabs
function EMCO:disableTabItalics()
  self.tabItalics = false
  for _, tab in pairs(self.tabs) do
    tab:setItalics(self.tabItalics)
  end
end

--- enables bold on all tabs
function EMCO:enableTabBold()
  self.tabBold = true
  for _, tab in pairs(self.tabs) do
    tab:setBold(self.tabBold)
  end
end

--- disables bold on all tabs
function EMCO:disableTabBold()
  self.tabBold = false
  for _, tab in pairs(self.tabs) do
    tab:setBold(self.tabBold)
  end
end

--- enables custom colors for the timestamp, if displayed
function EMCO:enableCustomTimestampColor()
  self.customTimestampColor = true
end

--- disables custom colors for the timestamp, if displayed
function EMCO:disableCustomTimestampColor()
  self.customTimestampColor = false
end

--- enables the display of timestamps
function EMCO:enableTimestamp()
  self.timestamp = true
end

--- disables the display of timestamps
function EMCO:disableTimestamp()
  self.timestamp = false
end

--- Sets the formatting for the timestamp, if enabled
-- @tparam string format Format string which describes the display of the timestamp. See: https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime
function EMCO:setTimestampFormat(format)
  local funcName = "EMCO:setTimestampFormat(format)"
  local strippedFormat = self:stripTimeChars(format)
  if strippedFormat ~= "" then
    self.ae(funcName,
            "format contains invalid time format characters. Please see https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for formatting information")
  else
    self.timestampFormat = format
  end
end

--- Sets the background color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampBGColor(color)
  self.timestampBGColor = color
end
--- Sets the foreground color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampFGColor(color)
  self.timestampFGColor = color
end

--- Sets the 'all' tab name.
-- <br>This is the name of the tab itself
-- @tparam string allTabName name of the tab to use as the all tab. Must be a tab which exists in the object.
function EMCO:setAllTabName(allTabName)
  local funcName = "EMCO:setAllTabName(allTabName)"
  local allTabNameType = type(allTabName)
  if allTabNameType ~= "string" then
    self.ae(funcName, "allTabName expected as string, got" .. allTabNameType)
  end
  if not table.contains(self.consoles, allTabName) then
    self.ae(funcName, "allTabName must be the name of one of the console tabs. Valid options are: " .. table.concat(self.consoles, ","))
  end
  self.allTabName = allTabName
end

--- Enables use of the 'all' tab
function EMCO:enableAllTab()
  self.allTab = true
end

--- Disables use of the 'all' tab
function EMCO:disableAllTab()
  self.allTab = false
end

--- Enables tying the Mudlet Mapper to one of the tabs.
-- <br>mapTabName must be set, or this will error. Forces a redraw of the entire object
function EMCO:enableMapTab()
  local funcName = "EMCO:enableMapTab()"
  if not self.mapTabName then
    error(funcName ..
            ": cannot enable the map tab, mapTabName not set. try running :setMapTabName(mapTabName) first with the name of the tab you want to bind the map to")
  end
  self.mapTab = true
  self:reset()
end

--- disables binding the Mudlet Mapper to one of the tabs.
-- <br>CAUTION: this may have unexpected behaviour, as you can only open one Mapper console per profile
-- so you can't really unbind it. Binding of the Mudlet Mapper is best decided at instantiation.
function EMCO:disableMapTab()
  self.mapTab = false
end

--- sets the name of the tab to bind the Mudlet Map.
-- <br>Forces a redraw of the object
-- <br>CAUTION: Mudlet only allows one Map object to be open at one time, so if you are going to attach the map to an object
-- you should probably do it at instantiation.
-- @tparam string mapTabName name of the tab to connect the Mudlet Map to.
function EMCO:setMapTabName(mapTabName)
  local funcName = "EMCO:setMapTabName(mapTabName)"
  local mapTabNameType = type(mapTabName)
  if mapTabNameType ~= "string" then
    self.ae(funcName, "mapTabName as string expected, got" .. mapTabNameType)
  end
  if not table.contains(self.consoles, mapTabName) and mapTabName ~= "" then
    self.ae(funcName, "mapTabName must be one of the existing console tabs. Current tabs are: " .. table.concat(self.consoles, ","))
  end
  self.mapTabName = mapTabName
end

--- Enables tab blinking even if you're on the 'all' tab
function EMCO:enableBlinkFromAll()
  self.enableBlinkFromAll = true
end

--- Disables tab blinking when you're on the 'all' tab
function EMCO:disableBlinkFromAll()
  self.enableBlinkFromAll = false
end

--- Enables gagging of the line passed in to :append(tabName)
function EMCO:enableGag()
  self.gag = true
end

--- Disables gagging of the line passed in to :append(tabName)
function EMCO:disableGag()
  self.gag = false
end

--- Enables tab blinking when new information comes in to an inactive tab
function EMCO:enableBlink()
  self.blink = true
  if not self.blinkTimerID then
    self.blinkTimerID = tempTimer(self.blinkTime, function()
      self:doBlink()
    end, true)
  end
end

--- Disables tab blinking when new information comes in to an inactive tab
function EMCO:disableBlink()
  self.blink = false
  if self.blinkTimerID then
    killTimer(self.blinkTimerID)
    self.blinkTimerID = nil
  end
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:enablePreserveBackground()
  self.preserveBackground = true
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:disablePreserveBackground()
  self.preserveBackground = false
end

--- Sets how long in seconds to wait between blinks
-- @tparam number blinkTime time in seconds to wait between blinks
function EMCO:setBlinkTime(blinkTime)
  local funcName = "EMCO:setBlinkTime(blinkTime)"
  local blinkTimeNumber = tonumber(blinkTime)
  if not blinkTimeNumber then
    self.ae(funcName, "blinkTime as number expected, got " .. type(blinkTime))
  else
    self.blinkTime = blinkTimeNumber
    if self.blinkTimerID then
      killTimer(self.blinkTimerID)
    end
    self.blinkTimerID = tempTimer(blinkTimeNumber, function()
      self:blink()
    end, true)
  end
end

function EMCO:doBlink()
  if self.hidden or self.auto_hidden or not self.blink then
    return
  end
  for tab, _ in pairs(self.tabsToBlink) do
    self.tabs[tab]:flash()
  end
end

--- Sets the font size of the attached consoles
-- @tparam number fontSize font size for attached consoles
function EMCO:setFontSize(fontSize)
  local funcName = "EMCO:setFontSize(fontSize)"
  local fontSizeNumber = tonumber(fontSize)
  local fontSizeType = type(fontSize)
  if not fontSizeNumber then
    self.ae(funcName, "fontSize as number expected, got " .. fontSizeType)
  else
    self.fontSize = fontSizeNumber
    for _, tabName in ipairs(self.consoles) do
      if self.mapTab and tabName == self.mapTabName then
        -- skip this one
      else
        local window = self.mc[tabName]
        window:setFontSize(fontSizeNumber)
      end
    end
  end
end

function EMCO:adjustTabNames()
  for _, console in ipairs(self.consoles) do
    if console == self.currentTab then
      self.tabs[console]:echo(console, self.activTabFGColor, 'c')
    else
      self.tabs[console]:echo(console, self.inactiveTabFGColor, 'c')
    end
  end
end

function EMCO:adjustTabBackground(console)
  local tab = self.tabs[console]
  local activeTabCSS = self.activeTabCSS
  local inactiveTabCSS = self.inactiveTabCSS
  local activeTabBGColor = self.activeTabBGColor
  local inactiveTabBGColor = self.inactiveTabBGColor
  if console == self.currentTab then
    if activeTabCSS and activeTabCSS ~= "" then
      tab:setStyleSheet(activeTabCSS)
    elseif activeTabBGColor then
      tab:setColor(activeTabBGColor)
    end
  else
    if inactiveTabCSS and inactiveTabCSS ~= "" then
      tab:setStyleSheet(inactiveTabCSS)
    elseif inactiveTabBGColor then
      tab:setColor(inactiveTabBGColor)
    end
  end
end

function EMCO:adjustTabBackgrounds()
  for _, console in ipairs(self.consoles) do
    self:adjustTabBackground(console)
  end
end

--- Sets the inactiveTabCSS
-- @tparam string stylesheet the stylesheet to use for inactive tabs.
function EMCO:setInactiveTabCSS(stylesheet)
  self.inactiveTabCSS = stylesheet
  self:adjustTabBackgrounds()
end

--- Sets the activeTabCSS
-- @tparam string stylesheet the stylesheet to use for active tab.
function EMCO:setActiveTabCSS(stylesheet)
  self.activeTabCSS = stylesheet
  self:adjustTabBackgrounds()
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabFGColor(color)
  self.activeTabFGColor = color
  self:adjustTabNames()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabFGColor(color)
  self.inactiveTabFGColor = color
  self:adjustTabNames()
end

--- Sets the BG color for the active tab.
-- <br>NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabBGColor(color)
  self.activeTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the inactive tab.
-- <br>NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabBGColor(color)
  self.inactiveTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the consoles attached to this object
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleColor(color)
  self.consoleColor = color
  self:adjustConsoleColors()
end

function EMCO:adjustConsoleColors()
  for _, console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:setColor(self.consoleColor)
    end
  end
end

--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function EMCO:setTabBoxCSS(css)
  local funcName = "EMCHO:setTabBoxCSS(css)"
  local cssType = type(css)
  if cssType ~= "string" then
    self.ae(funcName, "css as string expected, got " .. cssType)
  else
    self.tabBoxCSS = css
    self:adjustTabBoxBackground()
  end
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTabBoxColor(color)
  self.tabBoxColor = color
  self:adjustTabBoxBackground()
end

function EMCO:adjustTabBoxBackground()
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)
end

--- Sets the color for the container which holds the consoles attached to this object.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleContainerColor(color)
  self.consoleContainerColor = color
  self:adjustConsoleContainerBackground()
end

--- Sets the CSS to use for the container which holds the consoles attached to this object
-- @tparam string css CSS to use for the container
function EMCO:setConsoleContainerCSS(css)
  self.consoleContainerCSS = css
  self:adjustConsoleContainerBackground()
end

function EMCO:adjustConsoleContainerBackground()
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function EMCO:setGap(gap)
  local gapNumber = tonumber(gap)
  local funcName = "EMCO:setGap(gap)"
  local gapType = type(gap)
  if not gapNumber then
    self.ae(funcName, "gap expected as number, got " .. gapType)
  else
    self.gap = gapNumber
    self:reset()
  end
end

--- Sets the height of the tabs in pixels
-- @tparam number tabHeight the height of the tabs for the object, in pixels
function EMCO:setTabHeight(tabHeight)
  local tabHeightNumber = tonumber(tabHeight)
  local funcName = "EMCO:setTabHeight(tabHeight)"
  local tabHeightType = type(tabHeight)
  if not tabHeightNumber then
    self.ae(funcName, "tabHeight as number expected, got " .. tabHeightType)
  else
    self.tabHeight = tabHeightNumber
    self:reset()
  end
end

--- Enables autowrap for the object, and by extension all attached consoles.
-- <br>To enable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:enableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:enableAutoWrap()
  self.autoWrap = true
  for _, console in ipairs(self.consoles) do
    if self.mapTab and console == self.mapTabName then
      -- skip the map
    else
      self.mc[console]:enableAutoWrap()
    end
  end
end

--- Disables autowrap for the object, and by extension all attached consoles.
-- <br>To disable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:disableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:disableAutoWrap()
  self.autoWrap = false
  for _, console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:disableAutoWrap()
    end
  end
end

--- Sets the number of characters to wordwrap the attached consoles at.
-- <br>it is generally recommended to make use of autoWrap unless you need
-- a specific width for some reason
function EMCO:setWrap(wrapAt)
  local funcName = "EMCO:setWrap(wrapAt)"
  local wrapAtNumber = tonumber(wrapAt)
  local wrapAtType = type(wrapAt)
  if not wrapAtNumber then
    self.ae(funcName, "wrapAt as number expect, got " .. wrapAtType)
  else
    self.wrapAt = wrapAtNumber
    for _, console in ipairs(self.consoles) do
      if self.mapTab and self.mapTabName == console then
        -- skip the Map
      else
        self.mc[console]:setWrap(wrapAtNumber)
      end
    end
  end
end

--- Appends the current line from the MUD to a tab.
-- <br>depending on this object's configuration, may gag the line
-- <br>depending on this object's configuration, may gag the next prompt
-- @tparam string tabName The name of the tab to append the line to
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:append(tabName, excludeAll)
  local funcName = "EMCO:append(tabName, excludeAll)"
  local tabNameType = type(tabName)
  local validTab = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    self.ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTab then
    self.ae(funcName, "tabName must be a tab which is contained in this object. Valid tabnames are: " .. table.concat(self.consoles, ","))
  end
  self:xEcho(tabName, nil, 'a', excludeAll)
end

function EMCO:checkEchoArgs(funcName, tabName, message, excludeAll)
  local tabNameType = type(tabName)
  local messageType = type(message)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local ae = self.ae
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif messageType ~= "string" then
    ae(funcName, "message as string expected, got " .. messageType)
  elseif not validTabName then
    ae(funcName, "tabName must be the name of a tab attached to this object. Valid names are: " .. table.concat(self.consoles, ","))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

--- Adds a tab to the list of tabs to send OS toast/popup notifications for
--@tparam string tabName the name of a tab to enable notifications for
--@return true if it was added, false if it was already included, nil if the tab does not exist.
function EMCO:addNotifyTab(tabName)
  if not table.contains(self.consoles, tabName) then
    return nil, "Tab does not exist"
  end
  if self.notifyTabs[tabName] then
    return false
  end
  self.notifyTabs[tabName] = true
  return true
end

--- Removes a tab from the list of tabs to send OS toast/popup notifications for
--@tparam string tabName the name of a tab to disable notifications for
--@return true if it was removed, false if it wasn't enabled to begin with, nil if the tab does not exist.
function EMCO:removeNotifyTab(tabName)
  if not table.contains(self.consoles, tabName) then
    return nil, "Tab does not exist"
  end
  if not self.notifyTabs[tabName] then
    return false
  end
  self.notifyTabs[tabName] = nil
  return true
end

--- Adds a pattern to the gag list for the EMCO
--@tparam string pattern a Lua pattern to gag. http://lua-users.org/wiki/PatternsTutorial
--@return true if it was added, false if it was already included.
function EMCO:addGag(pattern)
  if self.gags[pattern] then
    return false
  end
  self.gags[pattern] = true
  return true
end

--- Removes a pattern from the gag list for the EMCO
--@tparam string pattern a Lua pattern to no longer gag. http://lua-users.org/wiki/PatternsTutorial
--@return true if it was removed, false if it was not there to remove.
function EMCO:removeGag(pattern)
  if self.gags[pattern] then
    self.gags[pattern] = nil
    return true
  end
  return false
end

--- Checks if a string matches any of the EMCO's gag patterns
--@tparam string str The text you're testing against the gag patterns
--@return false if it does not match any gag patterns. true and the matching pattern if it does match.
function EMCO:matchesGag(str)
  for pattern,_ in pairs(self.gags) do
    if str:match(pattern) then
      return true, pattern
    end
  end
  return false
end

--- Enables sending OS notifications even if Mudlet has focus
function EMCO:enableNotifyWithFocus()
  self.notifyWithFocus = true
end

--- Disables sending OS notifications if Mudlet has focus
function EMCO:disableNotifyWithFocus()
  self.notifyWithFocus = false
end

function EMCO:strip(message, xtype)
  local strippers = {
    a = function(msg) return msg end,
    echo = function(msg) return msg end,
    cecho = cecho2string,
    decho = decho2string,
    hecho = hecho2string,
  }
  local result = strippers[xtype](message)
  return result
end

function EMCO:sendNotification(tabName, msg)
  if self.notifyWithFocus or not hasFocus() then
    if self.notifyTabs[tabName] then
      showNotification(f'{self.name}:{tabName}', msg)
    end
  end
end

function EMCO:xEcho(tabName, message, xtype, excludeAll)
  if self.mapTab and self.mapTabName == tabName then
    error("You cannot send text to the Map tab")
  end
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and
                   self.mc[self.allTabName] or false
  local ofr, ofg, ofb, obr, obg, obb
  if xtype == "a" then
    local line = getCurrentLine()
    local mute, reason = self:matchesGag(line)
    if mute then
      debugc(f"{self.name}:append(tabName) denied because current line matches the pattern '{reason}'")
      return
    end
    selectCurrentLine()
    ofr, ofg, ofb = getFgColor()
    obr, obg, obb = getBgColor()
    if self.preserveBackground then
      local r, g, b = Geyser.Color.parse(self.consoleColor)
      setBgColor(r, g, b)
    end
    copy()
    if self.preserveBackground then
      setBgColor(obr, obg, obb)
    end
    deselect()
    resetFormat()
  else
    local mute, reason = self:matchesGag(message)
    if mute then
      debugc(f"{self.name}:{xtype}(tabName, msg, excludeAll) denied because msg matches '{reason}'")
      return
    end
    ofr, ofg, ofb = Geyser.Color.parse("white")
    obr, obg, obb = Geyser.Color.parse(self.consoleColor)
  end
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr, tfg, tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr, tbg, tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("<%s,%s,%s:%s,%s,%s>", tfr, tfg, tfb, tbr, tbg, tbb)
    else
      colorString = string.format("<%s,%s,%s:%s,%s,%s>", ofr, ofg, ofb, obr, obg, obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s<r> ", colorString, timestamp)
    if not table.contains(self.timestampExceptions, tabName) then
      console:decho(fullTimestamp)
    end
    if allTab and tabName ~= self.allTabName and not table.contains(self.timestampExceptions, self.allTabName) then
      allTab:decho(fullTimestamp)
    end
  end
  if self.blink and tabName ~= self.currentTab then
    if not (self.allTabName == self.currentTab and not self.blinkFromAll) then
      self.tabsToBlink[tabName] = true
    end
  end
  if xtype == "a" then
    console:appendBuffer()
    local txt = self:strip(getCurrentLine(), xtype)
    self:sendNotification(tabName, txt)
    if allTab then
      allTab:appendBuffer()
    end
    if self.gag then
      deleteLine()
      if self.gagPrompt then
        tempPromptTrigger(function()
          deleteLine()
        end, 1)
      end
    end
  else
    console[xtype](console, message)
    self:sendNotification(tabName, self:strip(message, xtype))
    if allTab then
      allTab[xtype](allTab, message)
    end
  end
  if self.blankLine then
    console:echo("\n")
    if allTab then
      allTab:echo("\n")
    end
  end
end

--- cecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to cecho to
-- @tparam string message the message to cecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cecho(tabName, message, excludeAll)
  local funcName = "EMCO:cecho(tabName, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'cecho', excludeAll)
end

--- decho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to decho to
-- @tparam string message the message to decho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:decho(tabName, message, excludeAll)
  local funcName = "EMCO:decho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'decho', excludeAll)
end

--- hecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to hecho to
-- @tparam string message the message to hecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hecho(tabName, message, excludeAll)
  local funcName = "EMCO:hecho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'hecho', excludeAll)
end

--- echo to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to echo to
-- @tparam string message the message to echo to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echo(tabName, message, excludeAll)
  local funcName = "EMCO:echo(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'echo', excludeAll)
end

-- internal function used for type checking echoLink/Popup arguments
function EMCO:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, popup)
  local expectedType = popup and "table" or "string"
  local textType = type(text)
  local commandsType = type(commands)
  local hintsType = type(hints)
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local sf = string.format
  local ae = self.ae
  if textType ~= "string" then
    ae(funcName, "text as string expected, got " .. textType)
  elseif commandsType ~= expectedType then
    ae(funcName, sf("commands as %s expected, got %s", expectedType, commandsType))
  elseif hintsType ~= expectedType then
    ae(funcName, sf("hints as %s expected, got %s", expectedType, hintsType))
  elseif tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, sf("tabName must be a tab which exists, tab %s could not be found", tabName))
  elseif self.mapTab and tabName == self.mapTabName then
    ae(funcName, sf("You cannot echo to the map tab, and %s is configured as the mapTabName", tabName))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "Optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

-- internal function used for handling echoLink/popup
function EMCO:xLink(tabName, linkType, text, commands, hints, useCurrentFormat, excludeAll)
  local gag, reason = self:matchesGag(text)
  if gag then
    debugc(f"{self.name}:{linkType}(tabName, text, command, hint, excludeAll) denied because text matches '{reason}'")
    return
  end
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and
                   self.mc[self.allTabName] or false
  local arguments = {text, commands, hints, useCurrentFormat}
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr, tfg, tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr, tbg, tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("<%s,%s,%s:%s,%s,%s>", tfr, tfg, tfb, tbr, tbg, tbb)
    else
      local ofr, ofg, ofb = Geyser.Color.parse("white")
      local obr, obg, obb = Geyser.Color.parse(self.consoleColor)
      colorString = string.format("<%s,%s,%s:%s,%s,%s>", ofr, ofg, ofb, obr, obg, obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s<r> ", colorString, timestamp)
    if not table.contains(self.timestampExceptions, tabName) then
      console:decho(fullTimestamp)
    end
    if allTab and tabName ~= self.allTabName and not table.contains(self.timestampExceptions, self.allTabName) then
      allTab:decho(fullTimestamp)
    end
  end
  console[linkType](console, unpack(arguments))
  if allTab then
    allTab[linkType](allTab, unpack(arguments))
  end
end

--- cechoLink to a tab
-- @tparam string tabName the name of the tab to cechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:cechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "cechoLink", text, command, hint, true, excludeAll)
end

--- dechoLink to a tab
-- @tparam string tabName the name of the tab to dechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:dechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "dechoLink", text, command, hint, true, excludeAll)
end

--- hechoLink to a tab
-- @tparam string tabName the name of the tab to hechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:hechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "hechoLink", text, command, hint, true, excludeAll)
end

--- echoLink to a tab
-- @tparam string tabName the name of the tab to echoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoLink(tabName, text, command, hint, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoLink(tabName, text, command, hint, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "echoLink", text, command, hint, useCurrentFormat, excludeAll)
end

--- cechoPopup to a tab
-- @tparam string tabName the name of the tab to cechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:cechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "cechoPopup", text, commands, hints, true, excludeAll)
end

--- dechoPopup to a tab
-- @tparam string tabName the name of the tab to dechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:dechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "dechoPopup", text, commands, hints, true, excludeAll)
end

--- hechoPopup to a tab
-- @tparam string tabName the name of the tab to hechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:hechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "hechoPopup", text, commands, hints, true, excludeAll)
end

--- echoPopup to a tab
-- @tparam string tabName the name of the tab to echoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "echoPopup", text, commands, hints, useCurrentFormat, excludeAll)
end

--- adds a tab to the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to add to the exclusion list
function EMCO:addAllTabExclusion(tabName)
  local funcName = "EMCO:addAllTabExclusion(tabName)"
  self:validTabNameOrError(tabName, funcName)
  if not table.contains(self.allTabExclusions, tabName) then
    table.insert(self.allTabExclusions, tabName)
  end
end

--- removess a tab from the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to remove from the exclusion list
function EMCO:removeAllTabExclusion(tabName)
  local funcName = "EMCO:removeAllTabExclusion(tabName)"
  self:validTabNameOrError(tabName, funcName)
  local index = table.index_of(self.allTabExclusions, tabName)
  if index then
    table.remove(self.allTabExclusions, index)
  end
end

function EMCO:validTabNameOrError(tabName, funcName)
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
end

function EMCO:addTimestampException(tabName)
  local funcName = "EMCO:addTimestampException(tabName)"
  self:validTabNameOrError(tabName, funcName)
  if not table.contains(self.timestampExceptions, tabName) then
    table.insert(self.timestampExceptions, tabName)
  end
end

function EMCO:removeTimestampException(tabName)
  local funcName = "EMCO:removeTimestampTabException(tabName)"
  self:validTabNameOrError(tabName, funcName)
  local index = table.index_of(self.timestampExceptions, tabName)
  if index then
    table.remove(self.timestampExceptions, index)
  end
end

--- Enable placing a blank line between all messages.
function EMCO:enableBlankLine()
  self.blankLine = true
end

--- Enable placing a blank line between all messages.
function EMCO:disableBlankLine()
  self.blankLine = false
end

--- Enable scrollbars for the miniconsoles
function EMCO:enableScrollbars()
  self.scrollbars = true
  self:adjustScrollbars()
end

--- Disable scrollbars for the miniconsoles
function EMCO:disableScrollbars()
  self.scrollbars = false
  self:adjustScrollbars()
end

function EMCO:adjustScrollbars()
  for _, console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip the Map tab
    else
      if self.scrollbars then
        self.mc[console]:enableScrollBar()
      else
        self.mc[console]:disableScrollBar()
      end
    end
  end
end

--- Save an EMCO's configuration for reloading later. Filename is based on the EMCO's name property.
function EMCO:save()
  local configtable = {
    timestamp = self.timestamp,
    blankLine = self.blankLine,
    scrollbars = self.scrollbars,
    customTimestampColor = self.customTimestampColor,
    mapTab = self.mapTab,
    mapTabName = self.mapTabName,
    blinkFromAll = self.blinkFromAll,
    preserveBackground = self.preserveBackground,
    gag = self.gag,
    timestampFormat = self.timestampFormat,
    timestampFGColor = self.timestampFGColor,
    timestampBGColor = self.timestampBGColor,
    allTab = self.allTab,
    allTabName = self.allTabName,
    blink = self.blink,
    blinkTime = self.blinkTime,
    fontSize = self.fontSize,
    font = self.font,
    tabFont = self.tabFont,
    activeTabCSS = self.activeTabCSS,
    inactiveTabCSS = self.inactiveTabCSS,
    activeTabFGColor = self.activeTabFGColor,
    activeTabBGColor = self.activeTabBGColor,
    inactiveTabFGColor = self.inactiveTabFGColor,
    inactiveTabBGColor = self.inactiveTabBGColor,
    consoleColor = self.consoleColor,
    tabBoxCSS = self.tabBoxCSS,
    tabBoxColor = self.tabBoxColor,
    consoleContainerCSS = self.consoleContainerCSS,
    consoleContainerColor = self.consoleContainerColor,
    gap = self.gap,
    consoles = self.consoles,
    allTabExclusions = self.allTabExclusions,
    timestampExceptions = self.timestampExceptions,
    tabHeight = self.tabHeight,
    autoWrap = self.autoWrap,
    wrapAt = self.wrapAt,
    leftMargin = self.leftMargin,
    rightMargin = self.rightMargin,
    bottomMargin = self.bottomMargin,
    topMargin = self.topMargin,
    x = self.x,
    y = self.y,
    height = self.height,
    width = self.width,
    tabFontSize = self.tabFontSize,
    tabBold = self.tabBold,
    tabItalics = self.tabItalics,
    tabUnderline = self.tabUnderline,
    tabAlignment = self.tabAlignment,
    bufferSize = self.bufferSize,
    deleteLines = self.deleteLines,
    logExclusions = self.logExclusions,
    gags = self.gags,
    notifyTabs = self.notifyTabs,
    notifyWithFocus = self.notifyWithFocus,
    cmdLineStyleSheet = self.cmdLineStyleSheet,
  }
  local dirname = getMudletHomeDir() .. "/EMCO/"
  local filename = dirname .. self.name:gsub("[<>:'\"/\\|?*]", "_") .. ".lua"
  if not (io.exists(dirname)) then
    lfs.mkdir(dirname)
  end
  table.save(filename, configtable)
end

--- Load and apply a saved config for this EMCO
function EMCO:load()
  local dirname = getMudletHomeDir() .. "/EMCO/"
  local filename = dirname .. self.name .. ".lua"
  local configTable = {}
  if io.exists(filename) then
    table.load(filename, configTable)
  else
    debugc(string.format("Attempted to load config for EMCO named %s but the file could not be found. Filename: %s", self.name, filename))
    return
  end

  self.timestamp = configTable.timestamp
  self.blankLine = configTable.blankLine
  self.scrollbars = configTable.scrollbars
  self.customTimestampColor = configTable.customTimestampColor
  self.mapTab = configTable.mapTab
  self.mapTabName = configTable.mapTabName
  self.blinkFromAll = configTable.blinkFromAll
  self.preserveBackground = configTable.preserveBackground
  self.gag = configTable.gag
  self.timestampFormat = configTable.timestampFormat
  self.timestampFGColor = configTable.timestampFGColor
  self.timestampBGColor = configTable.timestampBGColor
  self.allTab = configTable.allTab
  self.allTabName = configTable.allTabName
  self.blink = configTable.blink
  self.blinkTime = configTable.blinkTime
  self.activeTabCSS = configTable.activeTabCSS
  self.inactiveTabCSS = configTable.inactiveTabCSS
  self.activeTabFGColor = configTable.activeTabFGColor
  self.activeTabBGColor = configTable.activeTabBGColor
  self.inactiveTabFGColor = configTable.inactiveTabFGColor
  self.inactiveTabBGColor = configTable.inactiveTabBGColor
  self.consoleColor = configTable.consoleColor
  self.tabBoxCSS = configTable.tabBoxCSS
  self.tabBoxColor = configTable.tabBoxColor
  self.consoleContainerCSS = configTable.consoleContainerCSS
  self.consoleContainerColor = configTable.consoleContainerColor
  self.gap = configTable.gap
  self.consoles = configTable.consoles
  self.allTabExclusions = configTable.allTabExclusions
  self.timestampExceptions = configTable.timestampExceptions
  self.tabHeight = configTable.tabHeight
  self.wrapAt = configTable.wrapAt
  self.leftMargin = configTable.leftMargin
  self.rightMargin = configTable.rightMargin
  self.bottomMargin = configTable.bottomMargin
  self.topMargin = configTable.topMargin
  self.tabFontSize = configTable.tabFontSize
  self.tabBold = configTable.tabBold
  self.tabItalics = configTable.tabItalics
  self.tabUnderline = configTable.tabUnderline
  self.tabAlignment = configTable.tabAlignment
  self.bufferSize = configTable.bufferSize
  self.deleteLines = configTable.deleteLines
  self.logExclusions = configTable.logExclusions
  self.gags = configTable.gags
  self.notifyTabs = configTable.notifyTabs
  self.notifyWithFocus = configTable.notifyWithFocus
  self.cmdLineStyleSheet = configTable.cmdLineStyleSheet
  self:move(configTable.x, configTable.y)
  self:resize(configTable.width, configTable.height)
  self:reset()
  if configTable.fontSize then
    self:setFontSize(configTable.fontSize)
  end
  if configTable.font then
    self:setFont(configTable.font)
  end
  if configTable.tabFont then
    self:setTabFont(configTable.tabFont)
  end
  if configTable.autoWrap then
    self:enableAutoWrap()
  else
    self:disableAutoWrap()
  end
end

--- Enables logging for tabName
--@tparam string tabName the name of the tab you want to enable logging for
function EMCO:enableTabLogging(tabName)
  local console = self.mc[tabName]
  if not console then
    debugc(f"EMCO:enableTabLogging(tabName): tabName {tabName} not found.")
    return
  end
  console.log = true
  local logDisabled = table.index_of(self.logExclusions, tabName)
  if logDisabled then table.remove(self.logExclusions, logDisabled) end
end

--- Disables logging for tabName
--@tparam string tabName the name of the tab you want to disable logging for
function EMCO:disableTabLogging(tabName)
  local console = self.mc[tabName]
  if not console then
    debugc(f"EMCO:disableTabLogging(tabName): tabName {tabName} not found.")
    return
  end
  console.log = false
  local logDisabled = table.index_of(self.logExclusions, tabName)
  if not logDisabled then table.insert(self.logExclusions, tabName) end
end

--- Enables logging on all EMCO managed consoles
function EMCO:enableAllLogging()
  for _,console in pairs(self.mc) do
    console.log = true
  end
  self.logExclusions = {}
end

--- Disables logging on all EMCO managed consoles
function EMCO:disableAllLogging()
  self.logExclusions = {}
  for tabName,console in pairs(self.mc) do
    console.log = false
    self.logExclusions[#self.logExclusions+1] = tabName
  end
end

EMCO.parent = Geyser.Container

return EMCO
]==]

-- Execute the content to define the module
local EMCO = assert(loadstring(EMCO_core_content))()
return EMCO
]]></script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EMCO_Compatibility_Layer</name>
					<packageName></packageName>
					<script><![CDATA[-- Store content for master loader
EMCO_Compatibility_Layer_content = [==[
-- EMCO Compatibility Layer for LuminariGUI
-- This module provides a compatibility layer that maintains YATCO's API while using EMCO internally
-- This allows all existing triggers, aliases, and scripts to work without modification

local EMCO_COMPAT = {}

-- Store the actual EMCO instance
local emcoInstance = nil

-- Debug function
local function compatDebug(msg, isError)
  if EMCO_DEBUG then
    if isError then
      cecho(string.format("&lt;red&gt;[COMPAT ERROR] %s&lt;reset&gt;\n", msg))
      debugc(string.format("[COMPAT ERROR] %s", msg))
    else
      cecho(string.format("&lt;yellow&gt;[COMPAT DEBUG] %s&lt;reset&gt;\n", msg))
      if EMCO_DEBUG_VERBOSE then
        debugc(string.format("[COMPAT DEBUG] %s", msg))
      end
    end
  end
end

-- Create the compatibility wrapper
function EMCO_COMPAT.createWrapper(emco)
  compatDebug("Creating EMCO compatibility wrapper")
  emcoInstance = emco
  
  if not emco then
    compatDebug("ERROR: No EMCO instance provided to createWrapper", true)
    return nil
  end
  
  -- Create the main wrapper object
  local wrapper = {
    -- Store references that scripts might access
    use = true,
    useContainer = false,
    currentTab = emco.currentTab,
    error = nil,
    
    -- Sound support properties
    lastSoundTime = 0,
    
    -- Initialize config table
    config = {},
    
    -- Initialize blink tracking
    tabsToBlink = {},
  }
  
  compatDebug("Wrapper object created with initial properties")
  
  -- Method: append - Core functionality for chat triggers
  function wrapper:append(tabName)
    compatDebug(string.format("append() called for tab: %s", tabName))
    
    if not emcoInstance then
      compatDebug("ERROR: EMCO instance is nil in append()", true)
      error("EMCO not initialized")
    end
    
    -- Get current line for custom processing
    selectCurrentLine()
    local line = getLine()
    
    -- Call EMCO's append
    local success, err = pcall(function()
      emcoInstance:append(tabName)
    end)
    
    if not success then
      compatDebug(string.format("ERROR: Failed to call EMCO:append(%s): %s", tabName, err), true)
      return
    end
    
    compatDebug(string.format("Successfully appended to tab: %s", tabName))
    
    -- Handle gagging if enabled (preserves YATCO behavior)
    if self.config.gag then
      deleteLine()
      tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
    end
    
    -- Handle sound notifications
    if self.config.soundEnabled and tabName ~= self.currentTab then
      local currentTime = os.time()
      if currentTime - self.lastSoundTime >= self.config.soundCooldown then
        self.lastSoundTime = currentTime
        local soundPath = getMudletHomeDir() .. "/LuminariGUI/" .. self.config.soundFile
        if io.exists(soundPath) then
          playSoundFile(soundPath, self.config.soundVolume)
        end
      end
    end
    
    -- Handle blinking
    if self.config.blink and tabName ~= self.currentTab then
      if not ((self.config.Alltab == self.currentTab) and not self.config.blinkFromAll) then
        self.tabsToBlink[tabName] = true
      end
    end
  end
  
  -- Method: create - Initialize the chat system
  function wrapper:create()
    compatDebug("create() called")
    -- EMCO is already created, just ensure it's visible
    if emcoInstance then
      compatDebug("Showing EMCO instance")
      emcoInstance:show()
      return true
    end
    compatDebug("ERROR: No EMCO instance in create()", true)
    return false
  end
  
  -- Method: resetUI - Reset the UI
  function wrapper:resetUI()
    if emcoInstance then
      emcoInstance:reset()
    end
  end
  
  -- Method: showAllTabs - Show all tabs
  function wrapper:showAllTabs()
    if emcoInstance then
      for _, tabName in ipairs(emcoInstance.consoles) do
        emcoInstance:showTab(tabName)
      end
    end
  end
  
  -- Method: blink - Start/restart blink timer
  function wrapper:blink()
    -- EMCO handles blinking internally, but we need to maintain compatibility
    if emcoInstance and emcoInstance.blink then
      -- Trigger EMCO's blink functionality if needed
      return true
    end
  end
  
  -- Create config metatable that maps to EMCO properties
  wrapper.config = setmetatable({}, {
    __index = function(t, k)
      if not emcoInstance then return nil end
      
      -- Map YATCO config names to EMCO properties
      local mapping = {
        timestamp = "timestamp",
        timestampFormat = "timestampFormat",
        timestampCustomColor = "timestampCustomColor",
        timestampFG = "timestampFG",
        timestampBG = "timestampBG",
        channels = "consoles",
        Alltab = "allTabName",
        blink = "blink",
        blinkTime = "blinkTime",
        blinkFromAll = "blinkFromAll",
        fontSize = "fontSize",
        preserveBackground = "preserveBackground",
        gag = "gag",
        lines = "height",
        width = "wrapAt",
        activeColors = {r = 0, g = 180, b = 0},
        inactiveColors = {r = 60, g = 60, b = 60},
        windowColors = {r = 0, g = 0, b = 0},
        activeTabText = "activeTabFGColor",
        inactiveTabText = "inactiveTabFGColor",
        -- Sound settings (not in EMCO, stored in wrapper)
        soundEnabled = false,
        soundFile = "audio/chat_sound.mp3",
        soundVolume = 100,
        soundCooldown = 0,
      }
      
      local mapped = mapping[k]
      if type(mapped) == "string" then
        return emcoInstance[mapped]
      elseif type(mapped) == "table" then
        return mapped
      else
        -- Store custom config in wrapper
        return rawget(t, k)
      end
    end,
    
    __newindex = function(t, k, v)
      if not emcoInstance then return end
      
      -- Map YATCO config names to EMCO properties
      local mapping = {
        timestamp = "timestamp",
        timestampFormat = "timestampFormat",
        channels = "consoles",
        Alltab = "allTabName",
        blink = "blink",
        blinkTime = "blinkTime",
        fontSize = "fontSize",
        preserveBackground = "preserveBackground",
        gag = "gag",
      }
      
      local mapped = mapping[k]
      if mapped then
        emcoInstance[mapped] = v
      else
        -- Store custom config in wrapper
        rawset(t, k, v)
      end
    end
  })
  
  -- Create windows accessor that maps to EMCO's mc (MiniConsole)
  wrapper.windows = setmetatable({}, {
    __index = function(t, k)
      if emcoInstance and emcoInstance.mc then
        return emcoInstance.mc[k]
      end
    end,
    __newindex = function(t, k, v)
      if emcoInstance and emcoInstance.mc then
        emcoInstance.mc[k] = v
      end
    end
  })
  
  -- Create tabs accessor
  wrapper.tabs = setmetatable({}, {
    __index = function(t, k)
      if emcoInstance and emcoInstance.tabs then
        return emcoInstance.tabs[k]
      end
    end,
    __newindex = function(t, k, v)
      if emcoInstance and emcoInstance.tabs then
        emcoInstance.tabs[k] = v
      end
    end
  })
  
  -- Create tabsToBlink accessor
  wrapper.tabsToBlink = setmetatable({}, {
    __index = function(t, k)
      if emcoInstance and emcoInstance.tabsToBlink then
        return emcoInstance.tabsToBlink[k]
      end
    end,
    __newindex = function(t, k, v)
      if emcoInstance and emcoInstance.tabsToBlink then
        emcoInstance.tabsToBlink[k] = v
      end
    end
  })
  
  -- Create container accessor
  setmetatable(wrapper, {
    __index = function(t, k)
      if k == "container" and emcoInstance then
        return emcoInstance
      end
      return rawget(t, k)
    end,
    __newindex = function(t, k, v)
      if k == "currentTab" and emcoInstance then
        -- Update both wrapper and EMCO
        rawset(t, k, v)
        emcoInstance.currentTab = v
      else
        rawset(t, k, v)
      end
    end
  })
  
  return wrapper
end

-- Helper function to sync wrapper state with EMCO
function EMCO_COMPAT.syncState(wrapper)
  if emcoInstance then
    wrapper.currentTab = emcoInstance.currentTab
  end
end

-- Store original demonnicChatSwitch function for compatibility
local originalChatSwitch = nil

-- Create replacement for demonnicChatSwitch that works with EMCO
function EMCO_COMPAT.createChatSwitch()
  return function(chat)
    if emcoInstance then
      emcoInstance:switchTab(chat)
      -- Update wrapper's currentTab
      if demonnic and demonnic.chat then
        demonnic.chat.currentTab = chat
      end
    elseif originalChatSwitch then
      -- Fallback to original if EMCO not ready
      originalChatSwitch(chat)
    end
  end
end

-- Initialize the compatibility layer
function EMCO_COMPAT.initialize(emco)
  compatDebug("=== Initializing EMCO Compatibility Layer ===")
  
  -- Validate input
  if not emco then
    compatDebug("ERROR: No EMCO instance provided to initialize", true)
    return nil
  end
  
  -- Store EMCO instance
  emcoInstance = emco
  compatDebug("Stored EMCO instance")
  
  -- Create wrapper
  compatDebug("Creating compatibility wrapper")
  local wrapper = EMCO_COMPAT.createWrapper(emco)
  
  if not wrapper then
    compatDebug("ERROR: Failed to create wrapper", true)
    return nil
  end
  
  -- Store original functions if they exist
  if demonnicChatSwitch then
    originalChatSwitch = demonnicChatSwitch
  end
  
  -- Replace global functions
  compatDebug("Replacing global functions")
  demonnicChatSwitch = EMCO_COMPAT.createChatSwitch()
  
  compatDebug("=== Compatibility Layer Ready ===")
  return wrapper
end

return EMCO_COMPAT
]==]

-- Execute the content to define the module
local EMCO_COMPAT = assert(loadstring(EMCO_Compatibility_Layer_content))()
return EMCO_COMPAT]]></script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>EMCO_Master_Loader</name>
				<packageName></packageName>
				<script><![CDATA[-- EMCO Master Loader with Comprehensive Debugging
-- This script ensures proper module loading and provides extensive debug output

-- Global debug flag for EMCO
EMCO_DEBUG = true
EMCO_DEBUG_VERBOSE = true

-- Debug function
local function emcoDebug(msg, isError)
  if EMCO_DEBUG then
    if isError then
      cecho(string.format("&lt;red&gt;[EMCO ERROR] %s&lt;reset&gt;\n", msg))
      debugc(string.format("[EMCO ERROR] %s", msg))
    else
      cecho(string.format("&lt;cyan&gt;[EMCO DEBUG] %s&lt;reset&gt;\n", msg))
      if EMCO_DEBUG_VERBOSE then
        debugc(string.format("[EMCO DEBUG] %s", msg))
      end
    end
  end
end

-- Module loader with error handling
local function loadEMCOModule(name, content)
  emcoDebug("Loading module: " .. name)
  
  -- Create a function that returns the module
  local moduleFunc, err = loadstring(content)
  if not moduleFunc then
    emcoDebug("Failed to compile module " .. name .. ": " .. (err or "unknown error"), true)
    return false
  end
  
  -- Execute the module in a protected environment
  local success, result = pcall(moduleFunc)
  if not success then
    emcoDebug("Failed to execute module " .. name .. ": " .. (result or "unknown error"), true)
    return false
  end
  
  -- Register the module
  package.loaded[name] = result
  
  -- Also set as global for fallback access
  if name == "demontools" then
    _G.demontools = result
  elseif name == "LoggingConsole" then
    _G.LoggingConsole = result
  elseif name == "EMCO" then
    _G.EMCO = result
  elseif name == "EMCO_Compatibility_Layer" then
    _G.EMCO_COMPAT = result
  end
  
  emcoDebug("Successfully loaded module: " .. name)
  return true
end

-- Initialize EMCO modules
function initializeEMCOModules()
  emcoDebug("=== Starting EMCO Module Initialization ===")
  
  -- Clear any existing modules
  package.loaded.demontools = nil
  package.loaded.LoggingConsole = nil
  package.loaded.EMCO = nil
  package.loaded.EMCO_Compatibility_Layer = nil
  
  -- Load demontools first
  if not loadEMCOModule("demontools", EMCO_demontools_content) then
    emcoDebug("Failed to load demontools - aborting EMCO initialization", true)
    return false
  end
  
  -- Load LoggingConsole (depends on demontools)
  if not loadEMCOModule("LoggingConsole", EMCO_loggingconsole_content) then
    emcoDebug("Failed to load LoggingConsole - aborting EMCO initialization", true)
    return false
  end
  
  -- Load EMCO core (depends on both above)
  if not loadEMCOModule("EMCO", EMCO_core_content) then
    emcoDebug("Failed to load EMCO core - aborting EMCO initialization", true)
    return false
  end
  
  -- Load compatibility layer
  if not loadEMCOModule("EMCO_Compatibility_Layer", EMCO_Compatibility_Layer_content) then
    emcoDebug("Failed to load compatibility layer - aborting EMCO initialization", true)
    return false
  end
  
  -- Verify all modules are loaded
  local allLoaded = true
  local modules = {"demontools", "LoggingConsole", "EMCO", "EMCO_Compatibility_Layer"}
  for _, modName in ipairs(modules) do
    if not package.loaded[modName] then
      emcoDebug("Module " .. modName .. " not found in package.loaded", true)
      allLoaded = false
    else
      emcoDebug("Verified module loaded: " .. modName)
    end
  end
  
  emcoDebug("=== EMCO Module Initialization Complete ===")
  return allLoaded
end

-- Auto-initialize on script load
tempTimer(0, function()
  if initializeEMCOModules() then
    emcoDebug("EMCO modules ready for use")
  else
    emcoDebug("EMCO modules failed to initialize", true)
  end
end)
]]></script>
				<eventHandlerList />
			</Script>
			<Script isActive="no" isFolder="no">
				<name>Changelog</name>
				<packageName></packageName>
				<script>--Changelog

--[[


   1.) Changed the following to support moving chatbox to bottom:
	   
	   -Added GUI.Bottom to Create Background Script
	   -Changed bottom border in Set Borders Script from setBorderBottom(0) to setBorderBottom(h / 4)
	   -Now Utilizing GUI.Box2 fot chatbox at bottom.
	   -Rewrote createFrame() function to allow for automatic frame generating regardless of
		  box size. Using the function is no different.
	   -Adjusted chatContainer height to fit frame nicely.
	   -Adjusted chatContainer x and y to fit frame nicely.
	   -Changed GUI.chatContainer name from GUI.Box2 to GUI.chatContainer
		
			 
	 2.) Added the following to support adding buttons to Box3
	     
		 -Created a new Script named Button which handles buttons individually by row.
		 -Creating button drawing functions so that they will each be called in an init
		  alias to generate them row by row. This will make it easier to change buttons
		  in the future.
		 -Making Box3 smaller. We don't need as many buttons as we have room for and I
		  have ideas for new things to place below Box3!
		 -Box 5 and 6 created. 5 to be used for Legend/Room Info. 6 to be used for skill
		  cooldown icons.
		 -Buttons added in Buttons script. Callbacks there as well. Legend is a toggle and
		  Mudlet/ASCII are separate callbacks.
	     -Legend and room info script created in Room Info/Legend script and proper event
		  handlers added to config for room info.
		 -Added check to Capture Room Map trigger to only display ASCII map if 
		  GUI.buttonWindow.mudletOrAscii == "ASCII". 
				
				
	 3.) Changed the following to support release this week.
	   
	     -Commenting out box 6 draw frame function.
				
					 
	 4.) Various Bug Fixes:
	     
	     -Fixed the trigger for Group chat to capture others talking in group.
         -Fixed gauges so they can no longer overfill into the main buffer by adding:
       
          if pct_health &gt; 100 then
            GUI.Health:setValue(100, 100)
          else
            GUI.Health:setValue(pct_health, 100)
          end
  
          *Equivalent added for each gauge. May look to add an effect to show a bar
           is overfilled when an enemy rages in the future*

  
	 5.) Quality of life:
	     
		 -Added a function to delete a line and the following prompt. It can be
		  utilized in any trigger to delete any line and the prompt it would have
		  created, but I created it primarily for the chatbox. Function is called
		  using deleteLineP().
		 -Added toggles that are saved to a .lua on exit and loaded on load event.
		  Currently they're used to determine if you're shown in the group or not
		  and if you would like to gag chat from main buffer with the above
		  function. (deleteLineP())
			 
	     -

]]
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Movement</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>-1</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>Southwest</name>
				<packageName></packageName>
				<script></script>
				<command>southwest</command>
				<keyCode>49</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>South</name>
				<packageName></packageName>
				<script></script>
				<command>south</command>
				<keyCode>50</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Southeast</name>
				<packageName></packageName>
				<script></script>
				<command>southeast</command>
				<keyCode>51</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>West</name>
				<packageName></packageName>
				<script></script>
				<command>west</command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Look</name>
				<packageName></packageName>
				<script></script>
				<command>look</command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>East</name>
				<packageName></packageName>
				<script></script>
				<command>east</command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Northwest</name>
				<packageName></packageName>
				<script></script>
				<command>northwest</command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>North</name>
				<packageName></packageName>
				<script></script>
				<command>north</command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Northeast</name>
				<packageName></packageName>
				<script></script>
				<command>northeast</command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Inventory</name>
				<packageName></packageName>
				<script></script>
				<command>inv</command>
				<keyCode>47</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Scan</name>
				<packageName></packageName>
				<script></script>
				<command>scan</command>
				<keyCode>42</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Up</name>
				<packageName></packageName>
				<script></script>
				<command>up</command>
				<keyCode>45</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Down</name>
				<packageName></packageName>
				<script></script>
				<command>down</command>
				<keyCode>43</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
