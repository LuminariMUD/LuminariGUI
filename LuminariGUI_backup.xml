<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="2.0.4.015">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>LuminariGUI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>LuminariGUI</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>YATCOConfig</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName>YATCOConfig</packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Tell</name>
					<script>-- Tell Trigger: Captures private messages between players
-- Regex patterns:
-- 1. ^(\w+) tells you, '(.*)' - Captures incoming tells: player name and message
-- 2. You tell - Captures outgoing tell confirmations
demonnic.chat:append("Tell")
if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>39</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) tells you, '(.*)'</string>
						<string>You tell </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Congrats</name>
					<script>-- Congrats Trigger: Captures congratulations channel messages
-- Regex patterns:
-- 1. ^(\w+) congrats, '(.*)' - Captures congrats messages: player name and content
-- 2. You congrat, ' - Captures outgoing congrats confirmations
demonnic.chat:append("Congrats")
if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) congrats, '(.*)</string>
						<string>You congrat, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chat</name>
					<script>demonnic.chat:append("Chat")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>39</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) chats, '(.*)</string>
						<string>You chat, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Say</name>
					<script>demonnic.chat:append("Say")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You say, '</string>
						<string>You shout, '</string>
						<string>You holler, '</string>
						<string>You whisper to</string>
						<string>You ask</string>
						<string>You say out-of-character, '</string>
						<string>^(\w+) says, '</string>
						<string>^(\w+) shouts, '</string>
						<string>^(\w+) hollers, '</string>
						<string>whispers to you, '</string>
						<string>asks you, '</string>
						<string>^(\w+) says out-of-character, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Auction</name>
					<script>demonnic.chat:append("Auction")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) auctalks, '(.*)</string>
						<string>You auctalk, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Group</name>
					<script>demonnic.chat:append("Group")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[Group]</string>
						<string>You group-say, '</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Wiznet</name>
					<script>demonnic.chat:append("Wiz")

if GUI.toggles.gagChat == true then
  deleteLineP()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[wiznet]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GUI</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture Wilderness Map</name>
					<script>deleteLine()
clearUserWindow("map.minimap")

map.container:hide()
GUI.asciiMapContainer:show()

maplineTrig = tempLineTrigger(1,23,[[onMapLine()]])  -- Edit the max lines to how many your MAP display shows.
padding = map.calcMinimapPadding()

-- Map Line Processing Handler
-- Processes individual lines of ASCII map data and handles map display completion
-- Enhanced with comprehensive error handling for robust map processing
function onMapLine()
  -- Validate that we have a valid line to process
  if not line or line == "" then
    print("Warning: Empty or invalid map line received")
    return
  end
  -- Check for map completion marker
  local isLastLine = string.findPattern(line, "&lt;/WILDERNESS_MAP&gt;")
  if isLastLine then
    deleteLine()
    -- Safely cleanup trigger with validation
    if maplineTrig and exists(maplineTrig, "trigger") ~= 0 then
      killTrigger(maplineTrig)
    end
    maplineTrig = nil
    return
  end
  -- Process map line with error handling
  pcall(function()
    selectCurrentLine()
    copy()
    if map.minimap and map.minimap.echo then
      for i = 1, padding do
        map.minimap:echo(" ")
      end
      map.adjustMinimapFontSize()
      appendBuffer("map.minimap")
    else
      print("Warning: map.minimap not available for line processing")
    end
    deleteLine()
  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&lt;WILDERNESS_MAP&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture Room Map</name>
					<script>deleteLine()
clearUserWindow("map.minimap")

if GUI.buttonWindow.mudletOrAscii == "ASCII" then
  map.container:hide()
  GUI.asciiMapContainer:show()
elseif GUI.buttonWindow.mudletOrAscii == "Mudlet" then
  map.container:show()
  GUI.asciiMapContainer:hide()
end
map.minimap:echo("\n")
maplineTrig = tempLineTrigger(1,11,[[onRoomMapLine()]])  -- Edit the max lines to how many your MAP display shows.
padding = map.calcAsciimapPadding()

-- Room Map Line Processing Handler
-- Processes individual lines of room-specific ASCII map data
-- Enhanced with comprehensive error handling for robust map processing
function onRoomMapLine()
  -- Validate that we have a valid line to process
  if not line or line == "" then
    print("Warning: Empty or invalid room map line received")
    return
  end
  -- Check for room map completion marker
  local isLastLine = string.findPattern(line, "&lt;/ROOM_MAP&gt;")
  if isLastLine then
    deleteLine()
    -- Safely cleanup trigger with validation
    if maplineTrig and exists(maplineTrig, "trigger") ~= 0 then
      killTrigger(maplineTrig)
    end
    maplineTrig = nil
    return
  end
  -- Process room map line with error handling
  pcall(function()
    selectCurrentLine()
    copy()
    if map.minimap and map.minimap.echo then
      map.minimap:echo(" ")
      map.adjustAsciimapFontSize()
      appendBuffer("map.minimap")
    else
      print("Warning: map.minimap not available for room map line processing")
    end
    deleteLine()
  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&lt;ROOM_MAP&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Gag blank lines</name>
					<script>deleteLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Cast Console</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Started Cast</name>
						<script>GUI.castConsole_startCast(matches[2], matches[3])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Casting\: (.+) (\*+)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Cast Complete</name>
						<script>GUI.castConsole_completeCast()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You complete your spell...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Cast Aborted</name>
						<script>GUI.castConsole_abortedCast()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You abort your spell.</string>
							<string>Your spell is aborted!</string>
							<string>You are unable to find the target for your spell!</string>
							<string>You are unable to find the object for your spell!</string>
							<string>You are unable to continue your spell in your current position!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Cast Canceled</name>
						<script>GUI.castConsole_canceledCast()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are unable to continue casting!</string>
							<string>You are too nauseated to continue casting!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>LuminariGUI</name>
			<script></script>
			<command></command>
			<packageName>LuminariGUI</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Toggles</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Gag Chat</name>
					<script>--[[Toggling this will determine if the line and follow up
    prompt are removed from the main buffer for chat.]]
GUI.gagChatToggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^gag chat$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Show Self</name>
					<script>--Toggles whether or not you are shown in the group tab.
GUI.showSelfToggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^show self$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Horizontal Scroll</name>
					<script>--Toggles horizontal scroll bar on main window
GUI.horizontalScrollToggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^hscroll$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>YATCO</name>
				<script></script>
				<command></command>
				<packageName>YATCO</packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Demonnic</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>Shared</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Reset chasing</name>
							<script>demonnic.chaser:reset()</script>
							<command></command>
							<packageName></packageName>
							<regex>^chaseres$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Fix GUI Events</name>
							<script>-- =============================================================================
-- FIX GUI COMMAND
-- This command uses the centralized initialization system to refresh all
-- GUI components. It's the user-facing command for manual refresh.
-- =============================================================================
if GUI and GUI.initializeOrRefresh then
    GUI.initializeOrRefresh("fix gui command")
else
    cecho("\n&lt;yellow&gt;GUI system not fully loaded. Please close and reopen your profile, then try again.")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^fix gui$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Debug</name>
							<script>if matches[2] then
  demonnic:listCategories()
else
  demonnic:toggleDebug()
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^debug(?: (list))?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>debug categories</name>
							<script>if matches[2] then
  demonnic:watchCategory( matches[2] )
else
  demonnic:listCategories()
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^debugc(?: (.*))?$</regex>
						</Alias>
					</AliasGroup>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>Tabbed Chat</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Toggle blinking (temporary change)</name>
							<script>if demonnic.chat.config.blink then
  demonnic.chat.config.blink = false
  demonnic.chat.tabsToBlink = {}
  demonnic:echo("Blinking temporarily turned &lt;red&gt;off&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to false in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
else
  demonnic.chat.config.blink = true
  demonnic.chat:blink()
  demonnic:echo("Blinking temporarily turned &lt;red&gt;on&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to true in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^dblink$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>dsound</name>
							<script>-- Toggle chat sound notifications
if demonnic and demonnic.chat and demonnic.chat.config then
    demonnic.chat.config.soundEnabled = not demonnic.chat.config.soundEnabled
    
    if demonnic.chat.config.soundEnabled then
        cecho("\n&lt;green&gt;Chat sound notifications ENABLED&lt;reset&gt;\n")
        -- Play a test sound
        local soundPath = getMudletHomeDir() .. "/LuminariGUI/" .. demonnic.chat.config.soundFile
        local file = io.open(soundPath, "r")
        if file then
            file:close()
            playSoundFile(soundPath, demonnic.chat.config.soundVolume)
        else
            -- Try user's home directory as fallback
            soundPath = getMudletHomeDir() .. "/" .. demonnic.chat.config.soundFile
            file = io.open(soundPath, "r")
            if file then
                file:close()
                playSoundFile(soundPath, demonnic.chat.config.soundVolume)
            else
                -- Try system beep as final fallback
                playSoundFile("")  -- Empty string triggers system beep in Mudlet
            end
        end
    else
        cecho("\n&lt;red&gt;Chat sound notifications DISABLED&lt;reset&gt;\n")
    end
    
    -- Save to GUI.toggles for persistence
    if GUI and GUI.toggles then
        GUI.toggles.chatSound = demonnic.chat.config.soundEnabled
        table.save(getMudletHomeDir() .. "/GUI.toggles.lua", GUI.toggles)
    end
else
    cecho("\n&lt;red&gt;Chat system not initialized. Type 'fix chat' to reinitialize.&lt;reset&gt;\n")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^dsound$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>set chat sound</name>
							<script>local args = matches[2]:split(" ")
local command = args[1]
local value = args[2]

if command == "on" or command == "off" then
    -- Enable/disable sounds
    demonnic.chat.config.soundEnabled = (command == "on")
    GUI.toggles.chatSound = demonnic.chat.config.soundEnabled
    table.save(getMudletHomeDir() .. "/GUI.toggles.lua", GUI.toggles)
    cecho(string.format("\n&lt;yellow&gt;Chat sounds %s&lt;reset&gt;\n", command:upper()))
    
elseif command == "volume" and value then
    -- Set volume (0-100)
    local vol = tonumber(value)
    if vol and vol >= 0 and vol &lt;= 100 then
        demonnic.chat.config.soundVolume = vol
        cecho(string.format("\n&lt;yellow&gt;Chat sound volume set to %d&lt;reset&gt;\n", vol))
    else
        cecho("\n&lt;red&gt;Volume must be between 0 and 100&lt;reset&gt;\n")
    end
    
elseif command == "file" and value then
    -- Set sound file
    demonnic.chat.config.soundFile = value
    cecho(string.format("\n&lt;yellow&gt;Chat sound file set to: %s&lt;reset&gt;\n", value))
    
elseif command == "cooldown" and value then
    -- Set cooldown between sounds
    local cd = tonumber(value)
    if cd and cd >= 0 then
        demonnic.chat.config.soundCooldown = cd
        cecho(string.format("\n&lt;yellow&gt;Chat sound cooldown set to %d seconds&lt;reset&gt;\n", cd))
    else
        cecho("\n&lt;red&gt;Cooldown must be 0 or positive number&lt;reset&gt;\n")
    end
    
elseif command == "test" then
    -- Test the sound
    local soundPath = getMudletHomeDir() .. "/LuminariGUI/" .. demonnic.chat.config.soundFile
    local file = io.open(soundPath, "r")
    if file then
        file:close()
        playSoundFile(soundPath, demonnic.chat.config.soundVolume)
        cecho("\n&lt;green&gt;Playing test sound...&lt;reset&gt;\n")
    else
        -- Try user's home directory as fallback
        soundPath = getMudletHomeDir() .. "/" .. demonnic.chat.config.soundFile
        file = io.open(soundPath, "r")
        if file then
            file:close()
            playSoundFile(soundPath, demonnic.chat.config.soundVolume)
            cecho("\n&lt;green&gt;Playing test sound from user directory...&lt;reset&gt;\n")
        else
            playSoundFile("")  -- Empty string triggers system beep in Mudlet
            cecho("\n&lt;yellow&gt;Sound file not found, playing default beep&lt;reset&gt;\n")
        end
    end
    
else
    -- Show help
    cecho("\n&lt;cyan&gt;Chat Sound Commands:&lt;reset&gt;\n")
    cecho("  &lt;white&gt;set chat sound on/off&lt;reset&gt; - Enable or disable sounds for ALL channels\n")
    cecho("  &lt;white&gt;set chat sound volume &lt;0-100&gt;&lt;reset&gt; - Set volume level\n")
    cecho("  &lt;white&gt;set chat sound file &lt;filename&gt;&lt;reset&gt; - Set sound file\n")
    cecho("  &lt;white&gt;set chat sound cooldown &lt;seconds&gt;&lt;reset&gt; - Set cooldown between sounds\n")
    cecho("  &lt;white&gt;set chat sound test&lt;reset&gt; - Test the current sound\n")
    cecho("\n&lt;yellow&gt;Current settings:&lt;reset&gt;\n")
    cecho(string.format("  Enabled: %s (plays for ALL channels)\n", demonnic.chat.config.soundEnabled and "YES" or "NO"))
    cecho(string.format("  Volume: %d\n", demonnic.chat.config.soundVolume))
    cecho(string.format("  File: %s\n", demonnic.chat.config.soundFile))
    cecho(string.format("  Cooldown: %d seconds\n", demonnic.chat.config.soundCooldown))
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^set chat sound(?:\s+(.*))?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>fixChat</name>
							<script>-- =============================================================================
-- FIX CHAT COMMAND
-- This command uses the centralized initialization system with focus on chat.
-- It ensures the chat system is properly initialized and visible.
-- =============================================================================
GUI.initializeOrRefresh("fix chat command")

-- Additional chat-specific actions
if GUI.chatContainer then
  GUI.chatContainer:raise()
  if demonnic.chat and demonnic.chat.container then
    demonnic.chat:showAllTabs()
  end
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^fix chat$</regex>
						</Alias>
					</AliasGroup>
				</AliasGroup>
			</AliasGroup>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>LuminariGUI</name>
			<packageName>LuminariGUI</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>MSDPMapper</name>
				<packageName>Generic Mapper</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>MSDPMapper</name>
					<packageName></packageName>
					<script>
map = map or {}
map.room_info = map.room_info or {}
map.prev_info = map.prev_info or {}
map.aliases = map.aliases or {}
map.enabled = false
map.minimap_font_size = 8
map.minimap_width = 21
map.minimap_height = 21


local defaults = {
    -- using Geyser to handle the mapper in this, since this is a totally new script
    mapper = {x = "75%", y = "0%", width = "25%", height = "50%"}
}

local terrain_types = {
    -- used to make rooms of different terrain types have different colors
    -- add a new entry for each terrain type, and set the color with RGB values
    -- each id value must be unique, terrain types not listed here will use mapper default color
    ["Inside"]         	= {id = 1, r = 130, g = 130, b = 130},
		["City"]           	= {id = 2, r = 200, g = 200, b = 200},
		["Field"] 					= {id = 3, r = 0, g = 170, b = 0},
		["Forest"] 					= {id = 4, r = 0, g = 122, b = 0},
		["Hills"] 					= {id = 5, r = 122, g = 69, b = 0},
		["Low Mountains"] 	= {id = 6, r = 100, g = 100, b = 100},
		["Water (Swim)"] 		= {id = 7, r = 0, g = 0, b = 255},
		["Water (No Swim)"] = {id = 8, r = 0, g = 0, b = 130},
		["In Flight"] 			= {id = 9, r = 200, g = 200, b = 255},
		["Underwater"] 			= {id = 10, r = 43, g = 43, b = 124},
		["Zone Entrance"] 	= {id = 211, r = 255, g = 0, b = 0},
		["Road North-South"] = {id = 12, r = 119, g = 101, b = 86},
		["Road East-West"] 	= {id = 13, r = 119, g = 101, b = 86},
		["Road Intersection"] = {id = 14, r = 119, g = 101, b = 86},
		["Desert"] 					= {id = 15, r = 234, g = 219, b = 124},
		["Ocean"] 					= {id = 16, r = 0, g = 90, b = 90},
		["Marshland"] 			= {id = 17, r = 81, g = 47, b = 109},
		["High Mountains"] 	= {id = 18, r = 255, g = 255, b = 255},
		["Outer Planes"] 		= {id = 19, r = 168, g = 42, b = 138},
		["Underdark - Wild"] = {id = 20, r = 131, g = 110, b = 145},
		["Underdark - City"] = {id = 21, r = 183, g = 178, b = 186},
		["Underdark - Inside"] = {id = 22, r = 132, g = 132, b = 132},
		["Underdark - Water (Swim)"] = {id = 23, r = 70, g = 139, b = 175},
		["Underdark - Water (No Swim)"] = {id = 24, r = 34, g = 68, b = 86},
		["Underdark - In Flight"] = {id = 25, r = 158, g = 178, b = 188},
		["Lava"] 						= {id = 26, r = 255, g = 119, b = 0},
		["Dirt Road North-South"] = {id = 27, r = 142, g = 85, b = 0},
		["Dirt Road East-West"] = {id = 28, r = 142, g = 85, b = 0},
		["Dirt Road Intersection"] = {id = 29, r = 142, g = 85, b = 0},
		["Cave"] 						= {id = 30, r = 80, g = 80, b = 80},
		["Jungle"] 					= {id = 31, r = 21, g = 132, b = 101},
		["Tundra"] 					= {id = 32, r = 224, g = 224, b = 224},
		["Taiga"] 					= {id = 33, r = 103, g = 137, b = 104},
		["Beach"] 					= {id = 34, r = 239, g = 235, b = 0},
}

-- list of possible movement directions and appropriate coordinate changes
local move_vectors = {
    north = {0,1,0}, south = {0,-1,0}, east = {1,0,0}, west = {-1,0,0},
    northwest = {-1,1,0}, northeast = {1,1,0}, southwest = {-1,-1,0}, southeast = {1,-1,0},
    up = {0,0,1}, down = {0,0,-1}
}

-- used to convert short dirs for full dirs
local exits = {
    n = "north", s = "south", w = "west", e = "east",
    nw = "northwest", ne = "northeast", sw = "southwest", se = "southeast",
    u = "up", d = "down"
}

local exitmap = {
    north = 1,      northeast = 2,      northwest = 3,      east = 4,
    west = 5,       south = 6,          southeast = 7,      southwest = 8,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    [1] = "north",  [2] = "northeast",  [3] = "northwest",  [4] = "east",
    [5] = "west",   [6] = "south",      [7] = "southeast",  [8] = "southwest",
    [9] = "up",     [10] = "down",      [11] = "in",        [12] = "out",
}
	
for k, v in pairs(exitmap) do
	
end	

local function make_room()
    local info = map.room_info
    local coords = {0,0,0}
    addRoom(info.VNUM)
    local areas = getAreaTable()
    local areaID = areas[info.AREA]
    if not areaID then
        areaID = addAreaName(info.AREA)
    else
        coords = {getRoomCoordinates(map.prev_info.VNUM)}								
        local shift = {0,0,0}
        for k,v in pairs(map.prev_info.EXITS) do
            if v == info.VNUM and move_vectors[k] then
                shift = move_vectors[k]								
                break
            end
        end
				
        for n = 1,3 do
            coords[n] = coords[n] + shift[n]
        end
											
        -- map stretching
        local overlap = getRoomsByPosition(areaID,coords[1],coords[2],coords[3])				
				
        if not table.is_empty(overlap) then
            local rooms = getAreaRooms(areaID)
            local rcoords		
            for _,id in ipairs(rooms) do
                local x, y, z = getRoomCoordinates(id)
								rcoords = {x, y, z}
                for n = 1,3 do
                    if shift[n] ~= 0 and (rcoords[n] - coords[n]) * shift[n] &gt;= 0 then
                        rcoords[n] = rcoords[n] + shift[n]
                    end
                end
                setRoomCoordinates(id,rcoords[1],rcoords[2],rcoords[3])
            end
        end
    end
		setRoomArea(info.VNUM, areaID)
    setRoomCoordinates(info.VNUM, coords[1], coords[2], coords[3])
    if terrain_types[info.TERRAIN] then
        setRoomEnv(info.VNUM, terrain_types[info.TERRAIN].id + 16)
    end
    -- Set the room name from MSDP data
    if info.NAME then
        setRoomName(info.VNUM, info.NAME)
    end
		if map.prev_info then -- Check if you moved into here from another room.
			local prev_exits = getRoomExits(map.prev_info.VNUM)
			for dir, id in pairs(map.prev_info.EXITS) do
				if prev_exits[dir] == nil then
			    if not setExit(map.prev_info.VNUM, id, exitmap[dir]) then       
            setExitStub(map.prev_info.VNUM, exitmap[dir], true)
          end
				end
			end
		end
    for dir, id in pairs(info.EXITS) do
        -- need to see how special exits are represented to handle those properly here				
        if not setExit(info.VNUM, id, exitmap[dir]) then       
            setExitStub(info.VNUM, exitmap[dir], true)
        end
    end
end

local function shift_room(dir)
    local ID = map.room_info.VNUM
    local x,y,z = getRoomCoordinates(ID)
    local x1,y1,z1 = move_vectors[dir]
    x = x + x1
    y = y + y1
    z = z + z1
    setRoomCoordinates(ID,x,y,z)
    updateMap()
end

local function handle_move()
	if map.enabled == true and map.room_info.ENVIRONMENT ~= "Wilderness" then
    if not getRoomName(map.room_info.VNUM) then
        make_room()
    else		
			if terrain_types[map.room_info.TERRAIN] then
        setRoomEnv(map.room_info.VNUM, terrain_types[map.room_info.TERRAIN].id + 16)
    	end 	  
      local stubs = getExitStubs1(map.room_info.VNUM)				
			if stubs then		
       	for _, n in ipairs(stubs) do
          local dir = exitmap[n]				
	        local id = map.room_info.EXITS[dir]
	        -- need to see how special exits are represented to handle those properly here
	        if getRoomName(id) then	        
					  setExit(map.room_info.VNUM, id, exitmap[dir])
	        end
  	    end
			end
    end
	end
  centerview(map.room_info.VNUM)
end

local function make_aliases()

-- Aliases
    -- Let the user shift a room around via command line
    table.insert(map.aliases,tempAlias([[^shift (\w+)$]],[[raiseEvent("shiftRoom",matches[2])]]))
		table.insert(map.aliases,tempAlias([[^mc on$]],[[raiseEvent("startMapping")]]))
		table.insert(map.aliases,tempAlias([[^mc off$]],[[raiseEvent("stopMapping")]]))
		
    map.aliases = map.aliases or {}
    local id
    local tbl = {
        ["Start Mapping Alias"] = {[[^start mapping$]], [[map.start_mapping()]]},
        ["Stop Mapping Alias"] = {[[^stop mapping$]], [[map.stop_mapping()]]},
				["Shift Room Alias"] = {[[^shift (\w+)$]],[[raiseEvent("shiftRoom",matches[2])]]},				
        
				--["Save Map Alias"] = {[[^save map$]], [[saveMap(getMudletHomeDir() .. "/map.dat")]]},
        --["Load Map Alias"] = {[[^load map(?: (local))?$]], [[map.load_map(matches[2])]]},
        --["Export Map Area Alias"] = {[[^export area (.*)]],[[map.export_area(matches[2])]]},
        --["Import Map Area Alias"] = {[[^import area (.*)]],[[map.import_area(matches[2])]]},

        --["Set Room Area Alias"] = {[[^set area (.*)$]], [[map.set_area(matches[2])]]},
        --["Set Map Mode Alias"] = {[[^map mode (\w+)$]],[[map.set_mode(matches[2])]]},
        
        --["Merge Rooms Alias"] = {[[^merge rooms$]], [[map.merge_rooms()]]},
        --["Add Door Alias"] = {[[^add door (\w+)(?: (none|open|closed|locked)(?: (yes|no))?)?$]],[[map.set_door(matches[2],matches[3],matches[4])]]},
        --["Add Portal Alias"] = {[[^add portal (.*)$]],[[map.set_portal(matches[2])]]},
        --["Set Room Exit Alias"] = {[[^set exit (.+) (\d+)]],[[map.set_exit(matches[2],matches[3])]]},
        --["Clear Moves Alias"] = {[[^clear moves$]], [[map.clear_moves()]]},

        --["Find Me Alias"] = {[[^find me$]], [[map.find_me()]]},
        --["Find Path Alias"] = {[[find path ([^;]+)(?:\s*;\s*(.+))?]],[[map.find_path(matches[2],matches[3])]]},
        --["Set Recall Alias"] = {[[^set recall$]],[[map.set_recall()]]},
        --["Set Character Alias"] = {[[^set character (.*)$]],[[map.character = matches[2]]},
    }
    for k,v in pairs(tbl) do
        if map.aliases[k] and exists(map.aliases[k],"alias") ~= 0 then
            killAlias(map.aliases[k])
        end
        id = tempAlias(v[1],v[2])
        map.aliases[k] = id
    end
end

--function map.set_door(dir,status,one_way)
--    -- adds a door on a given exit
--    if map.enabled then
--        if not map.room_info then error("Make Door: No room found.") end
--        dir = exitmap[dir] or dir
--        if not stubmap[dir] then error("Make Door: Invalid direction.") end
--        status = (status ~= "" and status) or "closed"
--        one_way = (one_way ~= "" and one_way) or "no"
--        if not table.contains({"yes","no"},one_way) then error("Make Door: Invalid one-way status, must be yes or no.") end

--        local exits = getRoomExits(currentRoom)
--        local target_room = exits[dir]
--        if target_room then
--            exits = getRoomExits(target_room)
--        end
--        if one_way == "no" and (target_room and exits[reverse_dirs[dir]] == currentRoom) then
--            add_door(target_room,reverse_dirs[dir],status)
--        end
--        add_door(currentRoom,dir,status)
--				print("Door added.")
--    end
--end

function map.load_map(use_local)
    local path = getMudletHomeDir() .. "/map.dat"		
    if use_local then
        loadMap(path)
        print("Map reloaded from local copy.")
    else
        local address = 'http://www.luminarimud.com/download/map.dat'
        downloading = true
        downloadFile(path,address)
        print("Downloading Map File.")
    end
end

function map.adjustMinimapFontSize()
  local w = map.minimap.get_width()
  local h = map.minimap.get_height()
  local font_size = 8
  repeat
    font_size = font_size + 1
    local width, height = calcFontSize(font_size)
    width = width * map.minimap_width
    height = height * map.minimap_height
  until (w &lt; width) or (h &lt; height)
	map.minimap_font_size = font_size - 1
  setMiniConsoleFontSize("map.minimap", map.minimap_font_size)
end

function map.adjustAsciimapFontSize()
  local w = map.minimap.get_width()
  local h = map.minimap.get_height()
  local font_size = 8
  repeat
    font_size = font_size + 1
    local width, height = calcFontSize(font_size)
    width = width * 20
    height = height * 11
  until (w &lt; width) or (h &lt; height)
	map.minimap_font_size = font_size - 1
  setMiniConsoleFontSize("map.minimap", map.minimap_font_size)
end

function map.calcMinimapPadding()
	local width = calcFontSize(map.minimap_font_size)
	local characters = map.minimap.get_width() / width
	return (characters - map.minimap_width) / 4
end

function map.calcAsciimapPadding()
	local width = calcFontSize(map.minimap_font_size)
	local characters = map.minimap.get_width() / width
	return (characters - 19) / 4
end

local function config()        
    -- setting terrain colors
    for k,v in pairs(terrain_types) do
        setCustomEnvColor(v.id + 16, v.r, v.g, v.b, 255)
    end
    -- making mapper window
    local info = defaults.mapper
    
    -- Create map as Adjustable Container
    map.container = GUI.AdjustableContainers.create("Map", "map", {
      x = info.x,
      y = info.y,
      width = info.width,
      height = info.height,
      name = "LuminariGUI_Map",
      titleText = "Map",
      adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
      buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
      tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
      titleTxtColor = "green",
      padding = 9,
      lockStyle = "border",
      autoSave = true,
      autoLoad = true,
      attached = "tr",  -- Top-right attachment
      defaultDir = GUI.AdjustableContainers.saveDir,
      noClose = true
    })
    
    -- Create separate Adjustable Container for ASCII map
    GUI.asciiMapContainer = GUI.AdjustableContainers.create("ASCIIMap", "ascii_map", {
      x = info.x,
      y = info.y,
      width = info.width,
      height = info.height,
      name = "LuminariGUI_ASCIIMap",
      titleText = "ASCII Map",
      adjLabelstyle = info.adjLabelstyle or "background-color: rgba(0,0,0,0%); border: 4px solid #444444;",
      raiseOnClick = false,
      savePosition = true,
      titleTxtColor = "green",
      padding = 9,
      lockStyle = "border",
      autoSave = true,
      autoLoad = true,
      attached = "tr",  -- Top-right attachment
      defaultDir = GUI.AdjustableContainers.saveDir,
      noClose = true
    })
    
    -- Create ASCII minimap MiniConsole inside the new container
		map.minimap = Geyser.MiniConsole:new({
  		name="map.minimap",
  		x=9, y= 25,
  		width="-18", height="-34",
		}, GUI.asciiMapContainer)
		
		map.minimap:setColor("black")
		
		-- Keep reference for backward compatibility
		map.minimapcontainer = GUI.asciiMapContainer
		
		-- Hide ASCII map by default (Mudlet map shows first)
		GUI.asciiMapContainer:hide()
    
    -- Create mapper window within the adjustable container
    if not map.container then
      print("ERROR: Map container not created - cannot initialize mapper")
      return
    end
    
		map.mapwindow = Geyser.Mapper:new({
      name = "map.mapwindow", 
      x = 0, 
      y = 0, 
      width = "100%", 
      height = "100%"
    }, map.container)
    
    if not map.mapwindow then
      print("ERROR: Failed to create Geyser.Mapper instance")
      return
    end
    
    -- Single initialization timer to ensure proper rendering
    tempTimer(0.2, function()
      if map.mapwindow then
        map.mapwindow:show()
        map.mapwindow:resize()
        -- Force a second resize to handle any rendering issues
        map.mapwindow:resize()
      else
        print("ERROR: Failed to initialize map window")
      end
    end)
    
    -- Show the map container
    if map.container then
      map.container:show()
      -- No need to manipulate z-order here - let Adjustable Container handle it
    end
		
		map.adjustMinimapFontSize()
		make_aliases()		
		
		map.get_default_map()
end

function map.get_default_map()
	-- If the user has no map, download the default map from the server!
	local areas = getAreaTable()
	local path = getMudletHomeDir() .. "/map.dat"
	 
	
	if (areas["Mosswood"] == nil) then
		local address = 'http://www.luminarimud.com/download/map.dat'
    downloading = true
    downloadFile(path,address)
    print("Downloading Map File.")
	end
end

function map.start_mapping()
  map.enabled=true
	print("Mapping enabled.")
end

function map.stop_mapping()
	map.enabled=false
	print("Mapping disabled.")
end

function map.eventHandler(event,...)     
    if event == "msdp.ROOM" then
        map.prev_info = map.room_info
        map.room_info = table.update({},msdp.ROOM)
				-- Check if we have moved between regular and wilderness areas

				if map.prev_info.ENVIRONMENT == "Wilderness" and map.room_info.ENVIRONMENT == "Room" then
					 -- re-enable the mapper!
					 if GUI.asciiMapContainer then GUI.asciiMapContainer:hide() end
					 if map.container then 
					   map.container:show()
					   -- Delay mapper refresh to ensure container is visible
					   tempTimer(0.1, function()
					     if map.mapwindow then
					       map.mapwindow:show()
					       map.mapwindow:resize()
					     end
					   end)
					 end
				elseif map.prev_info.ENVIRONMENT == "Room" and map.room_info.ENVIRONMENT == "Wilderness" then
					 -- disable the mapper!
					 if map.container then map.container:hide() end
					 if GUI.asciiMapContainer then GUI.asciiMapContainer:show() end
				end
        handle_move()
    elseif event == "shiftRoom" then
        local dir = exits[arg[1]] or arg[1]
        if not table.contains(exits, dir) then
            echo("Error: Invalid direction '" .. dir .. "'.")
        else
            shift_room(dir)
        end
		elseif event == "sysDownloadDone" and downloading then
        loadMap(getMudletHomeDir() .. "/map.dat")
        downloading = false
        print("Map File Loaded.")				
    elseif event == "sysConnectionEvent" then
        config()			 
		end
		
end

function map.onProtocolEnabled(_, protocol)
  if protocol == "MSDP" then
    print("MSDP enabled!")
		sendMSDP("REPORT", "ROOM")
		config()	
  end
end

registerAnonymousEventHandler("msdp.ROOM","map.eventHandler")
registerAnonymousEventHandler("shiftRoom","map.eventHandler")
registerAnonymousEventHandler("sysConnectionEvent", "map.eventHandler")
registerAnonymousEventHandler("sysProtocolEnabled", "map.onProtocolEnabled")
registerAnonymousEventHandler("sysDownloadDone", "map.eventHandler")</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>GUI</name>
				<packageName>Template</packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>CSSman</name>
					<packageName>CSSman</packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>CSSMan</name>
						<packageName></packageName>
						<script>-- CSSMan by Vadi. Public domain.

CSSMan = {}
CSSMan.__index = CSSMan

function CSSMan.new(stylesheet)
  local obj  = { stylesheet = {} }
  setmetatable(obj,CSSMan)
  local trim = string.trim

  assert(type(stylesheet) == "string", "CSSMan.new: no stylesheet provided. A possible error is that you might have used CSSMan.new, not CSSMan:new")

  for line in stylesheet:gmatch("[^\r\n]+") do
    local attribute, value = line:match("^(.-):(.-);$")
    if attribute and value then
      attribute, value = trim(attribute), trim(value)
      obj.stylesheet[attribute] = value
    end
  end

  return obj
end

function CSSMan:set(key, value)
  self.stylesheet[key] = value
end

function CSSMan:get(key)
  return self.stylesheet[key]
end

function CSSMan:getCSS(key)
  local lines, concat = {}, table.concat
  for k,v in pairs(self.stylesheet) do lines[#lines+1] = concat({k,": ", v, ";"}) end
  return concat(lines, "\n")
end

function CSSMan:gettable()
  return self.stylesheet
end

function CSSMan:settable(tbl)
  assert(type(tbl) == "table", "CSSMan:settable: table expected, got "..type(tbl))

  self.stylesheet = tbl
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>GUI</name>
					<packageName></packageName>
					<script>-- =============================================================================
-- LUMINARIGUI INITIALIZATION DOCUMENTATION
-- =============================================================================
-- The LuminariGUI uses a CENTRALIZED INITIALIZATION SYSTEM to ensure all
-- components are properly initialized and refreshed at the right times.
--
-- MAIN INITIALIZATION FUNCTION: GUI.initializeOrRefresh(context)
-- Located at line ~3079 in this file
--
-- This function handles ALL initialization and refresh operations for:
-- - Initial package load
-- - Connection/reconnection
-- - MSDP protocol activation
-- - Manual refresh commands (fix gui, fix chat)
-- - Runtime component refresh
--
-- ENTRY POINTS (all use GUI.initializeOrRefresh):
-- 1. sysLoadEvent - Package loaded
-- 2. sysInstall - Package installed  
-- 3. sysConnectionEvent - Connected to game
-- 4. sysProtocolEnabled - MSDP activated
-- 5. "fix gui" command - Manual refresh
-- 6. "fix chat" command - Chat-focused refresh
--
-- TO ADD NEW INITIALIZATION:
-- 1. Add your initialization code to GUI.init() function
-- 2. Add your refresh code to GUI.initializeOrRefresh() function
-- 3. DO NOT create separate initialization handlers
-- 4. DO NOT duplicate refresh code in commands
--
-- COMPONENTS MANAGED:
-- - Event handler registration (GUI.registerEventHandlers)
-- - All Adjustable Containers (chat, gauges, map, etc.)
-- - MSDP data refresh (health, movement, room, etc.)
-- - Mapper initialization and refresh
-- - Chat system initialization
-- - Container z-order management
-- =============================================================================

GUI = GUI or {}
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Toggles</name>
						<packageName></packageName>
						<script>--Toggle the gagging of chat from main buffer.
function GUI.gagChatToggle()
  if GUI.toggles.gagChat == false then
	  GUI.toggles.gagChat = true
		cecho("\n&lt;b&gt;&lt;white&gt;[CHAT]&lt;/b&gt; &lt;green&gt;Now gagging chat from main buffer.&lt;reset&gt;")
	elseif GUI.toggles.gagChat == true then
	  GUI.toggles.gagChat = false
		cecho("\n&lt;b&gt;&lt;white&gt;[CHAT]&lt;/b&gt; &lt;red&gt;No longer gagging chat from main buffer.&lt;reset&gt;")
	else
	  GUI.toggles = {
		       gagChat = true,
	  includeInGroup = true,
	  horizontalScroll = false,
	  chatSound = false,
		}
		table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
	end
end

--Toggles whether or not you are shown in the group tab.
function GUI.showSelfToggle()
  if GUI.toggles.includeInGroup == false then
	  GUI.toggles.includeInGroup = true
		GUI.updateGroup()
		cecho("\n&lt;b&gt;&lt;cyan&gt;[GROUP]&lt;/b&gt; &lt;green&gt;Now showing self in group display.&lt;reset&gt;")
	elseif GUI.toggles.includeInGroup == true then
	  GUI.toggles.includeInGroup = false
		GUI.updateGroup()
		cecho("\n&lt;b&gt;&lt;cyan&gt;[GROUP]&lt;/b&gt; &lt;red&gt;No longer showing self in group display.&lt;reset&gt;")
	else
	  GUI.toggles = {
		       gagChat = true,
	  includeInGroup = true,
	  horizontalScroll = false,
	  chatSound = false,
		}
		table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
		cecho("\n&lt;b&gt;&lt;cyan&gt;[GROUP]&lt;/b&gt; &lt;green&gt;Now showing self in group display.&lt;reset&gt;")
	end
end

--Toggle horizontal scroll bar on main window
function GUI.horizontalScrollToggle()
  if GUI.toggles.horizontalScroll == false then
    GUI.toggles.horizontalScroll = true
    -- Disable word wrap and enable horizontal scrollbar
    setWindowWrap("main", 999)
    if enableHorizontalScrollBar then
      enableHorizontalScrollBar("main")
    end
    cecho("\n&lt;white&gt;Horizontal scrolling enabled on main window.")
  elseif GUI.toggles.horizontalScroll == true then
    GUI.toggles.horizontalScroll = false
    -- Re-enable word wrap and disable horizontal scrollbar
    setWindowWrap("main", 100)
    if disableHorizontalScrollBar then
      disableHorizontalScrollBar("main")
    end
    cecho("\n&lt;white&gt;Horizontal scrolling disabled on main window (word wrap enabled).")
  else
    GUI.toggles = {
           gagChat = true,
      includeInGroup = true,
      horizontalScroll = false,
    }
    table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
    -- Re-enable word wrap and disable horizontal scrollbar
    setWindowWrap("main", 100)
    if disableHorizontalScrollBar then
      disableHorizontalScrollBar("main")
    end
    cecho("\n&lt;white&gt;Horizontal scrolling disabled on main window (word wrap enabled).")
  end
  
  -- Save the toggle state
  GUI.saveToggles()
end

function GUI.loadToggles()
--Check for saved .lua. Create if not.
  GUI.toggles = {}
  if not io.exists(getMudletHomeDir().."/GUI.toggles.lua") then
	  GUI.toggles = {
		       gagChat = true,
	  includeInGroup = true,
	  horizontalScroll = false,
	  chatSound = false,
		}
		table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
	else
		table.load(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
  end
  
  -- Sync chat sound setting with demonnic.chat.config
  if GUI.toggles.chatSound and demonnic and demonnic.chat and demonnic.chat.config then
    demonnic.chat.config.soundEnabled = true
  end
end

--Save Toggle Preferences
function GUI.saveToggles()
  table.save(getMudletHomeDir().."/GUI.toggles.lua", GUI.toggles)
end

--Apply horizontal scroll setting to main window
function GUI.applyHorizontalScrollSetting()
  local enabled = GUI.toggles.horizontalScroll or false
  
  if enabled then
    -- Disable word wrap and enable horizontal scrollbar
    setWindowWrap("main", 999)
    if enableHorizontalScrollBar then
      enableHorizontalScrollBar("main")
    end
  else
    -- Re-enable word wrap and disable horizontal scrollbar
    setWindowWrap("main", 100)
    if disableHorizontalScrollBar then
      disableHorizontalScrollBar("main")
    end
  end
end

-- Basic resource cleanup function
function GUI.cleanup()
  -- Clean up any temporary triggers
  if maplineTrig and exists(maplineTrig, "trigger") ~= 0 then
    killTrigger(maplineTrig)
    maplineTrig = nil
  end
  -- Save current toggle preferences
  GUI.saveToggles()
end

registerAnonymousEventHandler("sysLoadEvent", "GUI.loadToggles")
registerAnonymousEventHandler("sysExitEvent", "GUI.saveToggles")
registerAnonymousEventHandler("sysExitEvent", "GUI.cleanup")

-- Apply horizontal scroll settings after chat system loads
registerAnonymousEventHandler("sysLoadEvent", function()
  tempTimer(2, function()
    GUI.applyHorizontalScrollSetting()
    -- Also sync chat sound setting after chat system loads
    if GUI.toggles.chatSound and demonnic and demonnic.chat and demonnic.chat.config then
      demonnic.chat.config.soundEnabled = true
    end
  end)
end)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Create Background</name>
						<packageName></packageName>
						<script>function GUI.init_background()
  GUI.BackgroundCSS = CSSMan.new([[
  background-color: rgba(38, 25, 47, 0.9);
  border: 1px solid rgba(184, 115, 27, 0.5);
  border-radius: 5px;
  padding: 5px;
  box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
]])
  -- Left
  GUI.Left = Geyser.Label:new({name = "GUI.Left", x = 0, y = 0, width = "25%", height = "100%"})
  GUI.Left:setStyleSheet(GUI.BackgroundCSS:getCSS())
  GUI.Left:hide() -- Hidden: No longer needed with Adjustable Containers
  --Right
	GUI.Right =
    Geyser.Label:new({name = "GUI.Right", x = "-25%", y = "-50%", width = "25%", height = "50%"})
  GUI.Right:setStyleSheet(GUI.BackgroundCSS:getCSS())
  GUI.Right:hide() -- Hidden: No longer needed with Adjustable Containers
	--Top
	--[[
	GUI.Top = Geyser.Label:new({name = "GUI.Top", x = "25%", y = 0, width = "50%", height = "25%"})
  GUI.Top:setStyleSheet(GUI.BackgroundCSS:getCSS())
	]]
	--Bottom
	GUI.Bottom = Geyser.Label:new({name = "GUI.Bottom", x = "25%", y = "-25%", width = "50%", height = "25%"})
  GUI.Bottom:setStyleSheet(GUI.BackgroundCSS:getCSS())
  GUI.Bottom:hide() -- Hidden: No longer needed with Adjustable Containers
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Set Borders</name>
						<packageName></packageName>
						<script>function GUI.set_borders()
  local w, h = getMainWindowSize()
  setBorderLeft(0)  -- Changed from w/4 to 0 - main window now starts at left edge
  setBorderTop(0)
  setBorderBottom(h / 4)
  setBorderRight(w / 2)  -- Changed from w/4 to w/2 - main window ends at 50%
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Boxes</name>
						<packageName></packageName>
						<script>function GUI.init_boxes()

  GUI.BoxCSS =
    CSSMan.new(
      [[    
	background-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/ui_texture.jpg);
	background-color: rgba(38, 25, 47, 0.8);
	border: 1px solid rgba(184, 115, 27, 0.5);
	border-radius: 5px;
	padding: 5px;
	box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
	font-family: Tahoma, Geneva, sans-serif;
]]
    )
  --GUI.Box1 = Geyser.Label:new({
  --  name = "GUI.Box1",
  --  x = 0, y = 0,
  --  width = "100%",
  --  height = "50%",
  --},GUI.Right)
  --GUI.Box1:setStyleSheet(GUI.BoxCSS:getCSS())
  --GUI.Box1:echo("&lt;center&gt;GUI.Box1")
	
	--Box2
  GUI.Box2 =
    Geyser.Label:new({name = "GUI.Box2", x = 0, y = 0, width = "100%", height = "100%", color = "black"}, GUI.Bottom)
  GUI.Box2:setStyleSheet(GUI.BoxCSS:getCSS())
  GUI.Box2:hide() -- Hidden: No longer needed with Adjustable Containers
  -- GUI.Box2:echo("&lt;center&gt;GUI.Box2") -- Removed: No longer needed with Adjustable Containers
  -- Create chat container using Adjustable.Container
  GUI.chatContainer = GUI.AdjustableContainers.create("Chat", "chat", {
    x = "0%",
    y = "75%", 
    width = "50%",
    height = "25%",
    name = "LuminariGUI_Chat",
    titleText = "Chat",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    titleTxtColor = "green",
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "b",  -- Bottom attachment
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  
  -- Create inner wrapper for YATCO to account for title bar and padding
  GUI.chatContainerInner = Geyser.Container:new({
    name = "GUI.chatContainerInner",
    x = 9,        -- Respect padding
    y = 25,       -- Below title bar  
    width = "-18", -- Account for padding on both sides
    height = "-34" -- Account for title bar + bottom padding
  }, GUI.chatContainer)
  
  -- Show the chat container
  if GUI.chatContainer then
    GUI.chatContainer:show()
    print("✓ Chat container created successfully")
  else
    print("✗ Failed to create chat container")
  end

  --Box3 - Now created as Adjustable Container
  -- Create as Adjustable Container for button panel
  GUI.buttonPanelContainer = GUI.AdjustableContainers.create("ButtonPanel", "button_panel", {
    x = "50%",
    y = "0%",
    width = "25%",
    height = "15%",
    name = "LuminariGUI_ButtonPanel",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    titleText = "Controls",
    titleTxtColor = "green",
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "tr",  -- Top-right attachment
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  
  -- Store reference to old Box3 for compatibility
  GUI.Box3 = GUI.buttonPanelContainer
  GUI.Box3CSS = CSSMan.new(GUI.BoxCSS:getCSS())
  GUI.Box3CSS:set("border-width", "0px")

  --Box4 - Now created as Adjustable Container in GUI.tabbedInfoWindow.init()
  -- Placeholder will be set when tabbedInfoWindow initializes

  --Box5 - Now created as Adjustable Container in GUI.init_boxes()
  -- Create as Adjustable Container for room info and map legend
  GUI.roomInfoContainer = GUI.AdjustableContainers.create("RoomInfo", "room_info", {
    x = "75%",
    y = "50%",
    width = "25%",
    height = "39%",
    name = "LuminariGUI_RoomInfo",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    titleText = "Room Info / Legend",
    titleTxtColor = "green",
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "tr",  -- Top-right attachment
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  
  -- Store reference to old Box5 for compatibility
  GUI.Box5 = GUI.roomInfoContainer
  GUI.Box5CSS = CSSMan.new(GUI.BoxCSS:getCSS())
  GUI.Box5CSS:set("border-width", "0px")
 
 --Commenting out Box 6 echo until skill Icons are finished. 
	GUI.Box6 =
    Geyser.Label:new(
      {name = "GUI.Box6", x = "0%", y = "65%", width = "100%", height = "35%"}, GUI.Right
    )
  GUI.Box6CSS = CSSMan.new(GUI.BoxCSS:getCSS())
  GUI.Box6CSS:set("border-width", "0px")
  GUI.Box6:setStyleSheet(GUI.Box6CSS:getCSS())
  GUI.Box6:hide() -- Hidden: No longer needed with Adjustable Containers
  --GUI.Box6:echo("&lt;center&gt;Skill Icons")

  -- Create status gauges container using Adjustable.Container
  GUI.Box7 = GUI.AdjustableContainers.create("StatusGauges", "gauges", {
    titleText = "Status",
    titleTxtColor = "green",
    x = "50%",
    y = "75%",
    width = "25%",
    height = "25%",
    noClose = true
  })
  
  -- Show the status gauges container
  if GUI.Box7 then
    GUI.Box7:show()
    print("✓ Status gauges container created successfully")
  else
    print("✗ Failed to create status gauges container")
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Gauges</name>
						<packageName></packageName>
						<script>function GUI.init_gauges()
  GUI.Footer =
    Geyser.HBox:new(
      {name = "GUI.Footer", x = 0, y = 10, width = "100%", height = "75%"}, GUI.Bottom
    )
  GUI.Status =
    Geyser.HBox:new(
      {name = "GUI.Status", x = 9, y = 18, width = "-18", height = "-18", margin = 5}, GUI.Box7
    )
  -- Action icons moved to separate Adjustable Container
  GUI.GaugeBar =
    Geyser.VBox:new(
      {
        name = "GUI.GaugeBar",
        x = 0,
        y = 0,
        height = "100%",
        width = "100%", -- Full width now that action icons are separate
        h_policy = Geyser.Fixed,
        v_policy = Geyser.Fixed,
      },
      GUI.Status
    )
  --GUI.LeftColumn = Geyser.VBox:new({
  --  name = "GUI.LeftColumn",
  --},GUI.Footer)
  --GUI.RightColumn = Geyser.VBox:new({
  --  name = "GUI.RightColumn",
  --},GUI.Footer)
  GUI.GaugeBackCSS =
    CSSMan.new(
      [[
  background-color: rgba(0,0,0,0.3);
  border-style: solid;
  border-color: rgba(184, 115, 27, 0.8);
  border-width: 2px;
  border-radius: 10px;
  margin: 5px;
  width: 100%;
  font-family: BitstreamVeraSans;
  font-weight: bold;
  font-size: 14px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 2px rgba(184, 115, 27, 0.3);
  padding: 2px;
]]
    )
  GUI.GaugeFrontCSS =
    CSSMan.new(
      [[
  background-color: rgba(0,0,0,0);
  border-style: solid;
  border-color: rgba(255,255,255,0.4);
  border-width: 1px;
  border-radius: 8px;
  margin: 5px;
  width: 100%;
  font-family: BitstreamVeraSans;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
  box-shadow: 0 0 5px rgba(255,255,255,0.3), inset 0 1px 3px rgba(255,255,255,0.2);
]]
    )
  GUI.Health =
    Geyser.Gauge:new({name = "GUI.Health", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#FF6B6B")
  GUI.GaugeBackCSS:set("background-color", "#8B0000")
  GUI.Health.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.Health.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.Health:setValue(100, 100)
  GUI.Health.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;HEALTH: 100/100&lt;/b&gt;&lt;/span&gt;]])
  -- GUI.Experience =
  --   Geyser.Gauge:new({name = "GUI.Experience", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  -- GUI.GaugeFrontCSS:set("background-color", "#9370DB")
  -- GUI.GaugeBackCSS:set("background-color", "#4B0082")
  -- GUI.Experience.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  -- GUI.Experience.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  -- GUI.Experience:setValue(math.random(100), 100)
  -- GUI.Experience.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;EXPERIENCE&lt;/b&gt;&lt;/span&gt;]])
  GUI.PSP =
    Geyser.Gauge:new({name = "GUI.PSP", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#40E0D0")
  GUI.GaugeBackCSS:set("background-color", "#008B8B")
  GUI.PSP.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.PSP.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.PSP:setValue(100, 100)
  GUI.PSP.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;PSP: 100/100&lt;/b&gt;&lt;/span&gt;]])
  GUI.Moves =
    Geyser.Gauge:new({name = "GUI.Moves", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#FFD700")
  GUI.GaugeBackCSS:set("background-color", "#B8860B")
  GUI.Moves.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.Moves.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.Moves:setValue(100, 100)
  GUI.Moves.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;&lt;b&gt;MOVES: 100/100&lt;/b&gt;&lt;/span&gt;]])
  GUI.Enemy =
    Geyser.Gauge:new({name = "GUI.Enemy", height = "17%", h_policy = Geyser.Dynamic, v_policy = Geyser.Dynamic}, GUI.GaugeBar)
  GUI.GaugeFrontCSS:set("background-color", "#9370DB")
  GUI.GaugeBackCSS:set("background-color", "#4B0082")
  GUI.Enemy.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
  GUI.Enemy.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
  GUI.Enemy:setValue(0, 100)
  GUI.Enemy.front:echo([[&lt;b&gt;ENEMY: 0/0&lt;/b&gt;]])
  GUI.Enemy:hide() -- Hide until there's an actual enemy
  GUI.AffectedByIconsBox =
    Geyser.HBox:new(
      {
        name = "GUI.AffectedByIconsBox",
        x = 0,
        y = 0,
        height = "32%",
        width = "100%",
        h_policy = Geyser.Dynamic,
        v_policy = Geyser.Dynamic,
      },
      GUI.GaugeBar
    )
end

function GUI.init_action_icons()
  -- Create Adjustable Container for action icons
  GUI.actionIconsContainer = GUI.AdjustableContainers.create("ActionIcons", "action_icons", {
    x = "75%",
    y = "89%",
    width = "8%",
    height = "11%",
    name = "LuminariGUI_ActionIcons",
    titleText = "Actions",
    attached = "tr",  -- Top-right attachment
    autoSave = true,
    autoLoad = true,
    lockStyle = "border",
    padding = 9,
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    titleTxtColor = "green",
    defaultDir = GUI.AdjustableContainers.saveDir,
    noClose = true
  })
  GUI.ActionIconsBox = GUI.actionIconsContainer  -- Backward compatibility
  
  -- Create the HBox inside the container
  GUI.actionIconsHBox = Geyser.HBox:new({
    name = "GUI.actionIconsHBox",
    x = 9,
    y = 25,
    height = "-34",
    width = "-18"
  }, GUI.actionIconsContainer)
  
  -- Initialize action icon CSS
  GUI.ActionIconCSS = CSSMan.new([[
	margin: 0px;
	vertical-align: top;
	border: 1px solid rgba(184, 115, 27, 0.5);
	border-radius: 3px;
	box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
]])
  
  -- Create standard action icon
  GUI.StandardActionIcon = Geyser.Label:new({
    name = "GUI.StandardActionIcon",
    width = 32,
    height = 32,
    h_policy = Geyser.Fixed,
    v_policy = Geyser.Fixed,
  }, GUI.actionIconsHBox)
  GUI.StandardActionIcon:setStyleSheet([[
    QLabel { 
      border-image: url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-standard.png"); 
      margin: 0px; 
      vertical-align: top; 
    }
  ]])
  GUI.StandardActionIcon:setToolTip("Standard Action", "10")
  
  -- Create move action icon
  GUI.MoveActionIcon = Geyser.Label:new({
    name = "GUI.MoveActionIcon",
    width = 32,
    height = 32,
    h_policy = Geyser.Fixed,
    v_policy = Geyser.Fixed,
  }, GUI.actionIconsHBox)
  GUI.MoveActionIcon:setStyleSheet([[
    QLabel { 
      border-image: url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-move.png"); 
      margin: 0px; 
      vertical-align: top; 
    }
  ]])
  GUI.MoveActionIcon:setToolTip("Move Action", "10")
  
  -- Create swift action icon
  GUI.SwiftActionIcon = Geyser.Label:new({
    name = "GUI.SwiftActionIcon",
    width = 32,
    height = 32,
    h_policy = Geyser.Fixed,
    v_policy = Geyser.Fixed,
  }, GUI.actionIconsHBox)
  GUI.SwiftActionIcon:setStyleSheet([[
    QLabel { 
      border-image: url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-swift.png"); 
      margin: 0px; 
      vertical-align: top; 
    }
  ]])
  GUI.SwiftActionIcon:setToolTip("Swift Action", "10")
  
  -- Show the container
  GUI.actionIconsContainer:show()
end

--GUI.Endurance = Geyser.Gauge:new({
--  name = "GUI.Endurance",
--},GUI.RightColumn)
--GUI.Endurance.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
--GUI.GaugeFrontCSS:set("background-color","yellow")
--GUI.Endurance.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
--GUI.Endurance:setValue(math.random(100),100)
--GUI.Endurance.front:echo("GUI.Endurance")
--GUI.Endurance.front:echo([[&lt;span style = "color: black"&gt;GUI.Endurance&lt;/span&gt;]])
--GUI.Willpower = Geyser.Gauge:new({
--  name = "GUI.Willpower",
--},GUI.RightColumn)
--GUI.Willpower.back:setStyleSheet(GUI.GaugeBackCSS:getCSS())
--GUI.GaugeFrontCSS:set("background-color","purple")
--GUI.Willpower.front:setStyleSheet(GUI.GaugeFrontCSS:getCSS())
--GUI.Willpower:setValue(math.random(100),100)
--GUI.Willpower.front:echo("GUI.Willpower")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Cast Console</name>
						<packageName></packageName>
						<script>function GUI.init_castConsole()
  -- Convert Cast Console to Adjustable Container
  GUI.castConsoleContainer = GUI.AdjustableContainers.create("CastConsole", "cast_console", {
    x = "50%",
    y = "60%",
    width = "25%",
    height = "15%",
    padding = 9,
    name = "LuminariGUI_CastConsole",
    titleText = "Cast Console",
    titleTxtColor = "green",
    attached = "br",  -- Bottom-right attachment
    adjLabelstyle = "background-color: rgba(0,0,0,0%); border: 9px groove #444444;",
    locked = false,
    lockStyle = "standard",
    noClose = true
  })
  
  -- Create internal MiniConsole for spell casting display
  -- Position below title bar (approximately 20-25 pixels) and respect padding
  GUI.castConsole = Geyser.MiniConsole:new({
    name = "GUI.castConsole",
    x = 10,  -- Slight offset from left to respect container padding
    y = 25,  -- Position below title bar
    width = -20,  -- Use negative value to respect padding on both sides
    height = -35,  -- Use negative value to account for title bar and bottom padding
    color = "black"
  }, GUI.castConsoleContainer)
  
  -- Set font size to match main window
  setMiniConsoleFontSize("GUI.castConsole", getFontSize("main"))
  
  -- Ensure proper z-order
  GUI.castConsoleContainer:raise()
end


function GUI.castConsole_startCast(spellName, spellLength)
  GUI.currentlyCasting = spellName
	GUI.castingNow = true
  clearUserWindow("GUI.castConsole")
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..spellName:title().."&lt;/b&gt; &lt;white&gt;- &lt;cyan&gt;&lt;b&gt;"..spellLength.."&lt;/b&gt;")
	if GUI.castConsoleTimer then
	  killTimer(GUI.castConsoleTimer)
	end
end

function GUI.castConsole_completeCast()
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..GUI.currentlyCasting:title().."&lt;/b&gt; &lt;white&gt;- &lt;b&gt;&lt;green&gt;✓ CAST COMPLETE&lt;/b&gt;")
	GUI.castConsoleTimer = tempTimer(10, [[clearUserWindow("GUI.castConsole")]])
end

function GUI.castConsole_abortedCast()
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..GUI.currentlyCasting:title().."&lt;/b&gt; &lt;white&gt;- &lt;b&gt;&lt;red&gt;✗ ABORTED&lt;/b&gt;")
	GUI.castingNow = false
	GUI.castConsoleTimer = tempTimer(10, [[clearUserWindow("GUI.castConsole")]])
end


function GUI.castConsole_canceledCast()
  GUI.castConsole:cecho("\n&lt;b&gt;&lt;white&gt;Spell:&lt;/b&gt; &lt;b&gt;&lt;yellow&gt;"..GUI.currentlyCasting:title().."&lt;/b&gt; &lt;white&gt;- &lt;b&gt;&lt;red&gt;✗ CANCELED&lt;/b&gt;")
	GUI.castingNow = false
	GUI.castConsoleTimer = tempTimer(10, [[clearUserWindow("GUI.castConsole")]])
end

</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Header Icons</name>
						<packageName></packageName>
						<script>function GUI.init_header_icons()
  GUI.Header =
    Geyser.HBox:new({name = "GUI.Header", x = 0, y = 0, width = "100%", height = "100%"}, GUI.Top)
  GUI.IconCSS =
    CSSMan.new(
      [[
  background-color: rgba(0,0,0,100);
  border-style: solid;
  border-width: 1px;
  border-color: white;
  border-radius: 5px;
  margin: 5px;
  qproperty-wordWrap: true;
]]
    )
  --[[
for i=1,12 do
  GUI["Icon"..i] = Geyser.Label:new({
    name = "GUI.Icon"..i,
  },GUI.Header)
  GUI["Icon"..i]:setStyleSheet(GUI.IconCSS:getCSS())
  GUI["Icon"..i]:echo("&lt;center&gt;GUI. Icon"..i)
end
]]
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>TabbedInfoWindow</name>
						<packageName></packageName>
						<script>GUI.tabbedInfoWindow =
  GUI.tabbedInfoWindow or
  {
    tabs = {"Player", "Affects", "Group"},
    color1 = "rgba(0,0,0,0)",
    color2 = "rgba(0,0,0,0)",
    width = "100%",
    height = "100%",
    current = "Player",
  }

-- createFrame function removed - frame images are incompatible with adjustable containers

function GUI.tabbedInfoWindow.click(tab)
  GUI.tabbedInfoWindow[GUI.tabbedInfoWindow.current]:hide()
  GUI.tabbedInfoWindow[GUI.tabbedInfoWindow.current .. "tab"]:echo(
    GUI.tabbedInfoWindow.current, "white", "c"
  )
  GUI.tabbedInfoWindow.current = tab
  GUI.tabbedInfoWindow[GUI.tabbedInfoWindow.current]:show()
  GUI.tabbedInfoWindow[tab .. "tab"]:echo(tab, "yellow", "c")
end

function GUI.tabbedInfoWindow.init()
  GUI.tabbedInfoWindowTabCSS =
    CSSMan.new(
      [[font-family: Tahoma, Geneva, sans-serif; 
			border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
			border: 1px solid rgba(184, 115, 27, 0.8);
			border-radius: 3px;
			padding: 3px;
		]]
    )
  
  -- Create Adjustable Container for tabbed info window
  local containerConfig = {
    x = "50%",  -- Column 2 position
    y = "15%",  -- Below Controls
    width = "25%",
    height = "45%",  -- Adjusted to fit: 15% to 60%
    name = "character_stats",
    titleText = "Character Stats",
    titleTxtColor = "green",
    adjLabelstyle = GUI.AdjustableContainers.defaultStyle.adjLabelstyle,
    buttonstyle = GUI.AdjustableContainers.defaultStyle.buttonstyle,
    tabstyle = GUI.AdjustableContainers.defaultStyle.tabstyle,
    padding = 9,
    lockStyle = "border",
    autoSave = true,
    autoLoad = true,
    attached = "tr",  -- Changed from "tl" to "tr" - now attaches to top-right since it's on right side
    defaultDir = GUI.AdjustableContainers.saveDir
  }
  
  -- Add noClose to containerConfig
  containerConfig.noClose = true
  
  -- Create adjustable container
  GUI.tabbedInfoWindowContainer = GUI.AdjustableContainers.create("TabbedInfo", "tabbed_info", containerConfig)
  
  -- Store reference to old Box4 for compatibility
  GUI.Box4 = GUI.tabbedInfoWindowContainer
  
  -- Create inner container for backwards compatibility
  GUI.tabbedInfoWindow.container =
    Geyser.Container:new(
      {
        name = "GUI.tabbedInfoWindow.back",
        x = 9,
        y = 25,
        width = "-18",
        height = "-34",
      },
      GUI.tabbedInfoWindowContainer
    )
  GUI.tabbedInfoWindow.header =
    Geyser.HBox:new(
      {name = "GUI.tabbedInfoWindow.header", x = 0, y = 0, width = "100%", height = "8%"},
      GUI.tabbedInfoWindow.container
    )
  GUI.tabbedInfoWindow.footer =
    Geyser.Label:new(
      {name = "GUI.tabbedInfoWindow.footer", x = 0, y = "8%", width = "100%", height = "92%"},
      GUI.tabbedInfoWindow.container
    )
  GUI.tabbedInfoWindow.footer:setStyleSheet([[font-family: Tahoma, Geneva, sans-serif;
]])
  GUI.tabbedInfoWindow.center =
    Geyser.Label:new(
      {name = "GUI.tabbedInfoWindow.center", x = 0, y = 0, width = "100%", height = "100%"},
      GUI.tabbedInfoWindow.footer
    )
  GUI.tabbedInfoWindow.center:setStyleSheet(
    [[
  background-color: ]] ..
    GUI.tabbedInfoWindow.color2 ..
    [[
	font-family: Tahoma, Geneva, sans-serif;
	]]
  )
  for k, v in pairs(GUI.tabbedInfoWindow.tabs) do
    GUI.tabbedInfoWindow[v .. "tab"] =
      Geyser.Label:new({name = "GUI.tabbedInfoWindow." .. v .. "tab"}, GUI.tabbedInfoWindow.header)
    GUI.tabbedInfoWindow[v .. "tab"]:setStyleSheet(GUI.tabbedInfoWindowTabCSS:getCSS())
    GUI.tabbedInfoWindow[v .. "tab"]:echo("&lt;center&gt;" .. v)
    GUI.tabbedInfoWindow[v .. "tab"]:setClickCallback("GUI.tabbedInfoWindow.click", v)
    GUI.tabbedInfoWindow[v] =
      Geyser.Label:new(
        {name = "GUI.tabbedInfoWindow." .. v, x = 0, y = 0, width = "100%", height = "100%"},
        GUI.tabbedInfoWindow.footer
      )
    GUI.tabbedInfoWindow[v]:setStyleSheet(
      [[
    background-color: ]] ..
      GUI.tabbedInfoWindow.color1 ..
      [[;    
	  font-family: Tahoma, Geneva, sans-serif;
	]]
    )
    GUI.tabbedInfoWindow[v .. "center"] =
      Geyser.Label:new(
        {
          name = "GUI.tabbedInfoWindow." .. v .. "center",
          x = 0,
          y = 0,
          width = "100%",
          height = "100%",
        },
        GUI.tabbedInfoWindow[v]
      )
    GUI.tabbedInfoWindow[v .. "center"]:setStyleSheet(
      [[
    background-color: ]] ..
      GUI.tabbedInfoWindow.color2 ..
      [[;
		border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/ui_texture.jpg) 0 0 0 0 stretch stretch;
		font-family: Tahoma, Geneva, sans-serif;
  ]]
    )
    GUI.tabbedInfoWindow[v]:hide()
    GUI.tabbedInfoWindow.current = v
  end
  -- Init to player tab
  GUI.tabbedInfoWindow.click("Player")
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Affects</name>
						<packageName></packageName>
						<script>-- Affects
-- -------
-- There are several types of affects in Luminari - Affected By (Status), Spell-Like Affects, Resistances and Damage Reduction
-- 'Affected By' also includes 'Modes' which change the character's behavior in some way, for example 'Flurry-of-Blows' or
-- 'Rapid-Shot'.  Modes are displayed in the box with the health bars, as this is important information even if you are not
-- Interested in the other types of affects.
--
-- Spell-like affects can create 'Affected By' status flags.
--
-- All other affects are displayed in the 'Affects' tab in the upper left.
--
-- Container: GUI.tabbedInfoWindow["Affectscenter"]
--

-- Initialize tables
GUI.AffectIcons = GUI.AffectIcons or {}
GUI.SLAffects = GUI.SLAffects or {}
GUI.SLAffects.Labels = GUI.SLAffects.Labels or {}
GUI.Affects = GUI.Affects or {}
GUI.Affects.Rows = GUI.Affects.Rows or {}
GUI.Affects.Modes = GUI.Affects.Modes or {}

function GUI.Affects.init()
  -- Initialize all the labels and such	
  -- Don't overwrite GUI.Affects itself - preserve the init function!
  GUI.Affects.Labels = {}
  GUI.Affects.Modes = {}
  GUI.Affects.Modes.Labels = {}
  GUI.Affects.Rows = {}
  -- CSS
  GUI.Affects.IconCSS = CSSMan.new([[
	  margin: 0px;	
  ]])
  GUI.Affects.Modes.IconCSS = CSSMan.new([[
	  margin: 0px;
  ]])  
  -- Calculate how many labels will fit into the container
  GUI.Affects.icon_width = 48
  GUI.Affects.icon_height = 48
  GUI.Affects.Modes.icon_width = 48
  GUI.Affects.Modes.icon_height = 48
  GUI.Affects.num_icons_row =
    (GUI.tabbedInfoWindow["Affectscenter"]:get_width()) / GUI.Affects.icon_width
  GUI.Affects.num_rows = 3 -- This is so we have room below for the other affect types.	
    --(GUI.tabbedInfoWindow["Affectscenter"]:get_height()) / GUI.Affects.icon_height
  
	-- Create the VBox
  GUI.Affects.container =
    Geyser.VBox:new(
      {
        name = "GUI.Affects.container",
        x = 0,
        y = 0,
        width = "100%",
        height = GUI.Affects.num_rows * GUI.Affects.icon_height,
        h_policy = Geyser.Fixed,
        v_policy = Geyser.Fixed,
      },
      GUI.tabbedInfoWindow["Affectscenter"]
    )
	-- Create the Affect Labels
  for i = 1, GUI.Affects.num_rows do
    --GUI.Affects.icon_width * GUI.Affects.num_icons_row,
    GUI.Affects.Rows[i] = {}
    GUI.Affects.Rows[i].Labels = {}
    GUI.Affects.Rows[i].container =
      Geyser.HBox:new(
        {
          name = "GUI.Affects.Row" .. i,
          x = 0,
          y = 0,
          height = GUI.Affects.icon_height,
          width = "100%",
          h_policy = Geyser.Fixed,
          v_policy = Geyser.Fixed,
        },
        GUI.Affects.container
      )
    for j = 1, GUI.Affects.num_icons_row do
      GUI.Affects.Rows[i].Labels[j] =
        Geyser.Label:new(
          {
            name = "GUI.Affects.Label" .. tostring(i) .. '_' .. tostring(j),
            width = GUI.Affects.icon_width,
            height = GUI.Affects.icon_height,
            h_policy = Geyser.Fixed,
            v_policy = Geyser.Fixed,
          },
          GUI.Affects.Rows[i].container
        )
      GUI.Affects.Rows[i].Labels[j]:setStyleSheet(GUI.Affects.IconCSS:getCSS())
      GUI.Affects.Rows[i].Labels[j]:setColor(0, 0, 0, 0)
    end
    GUI.Affects.current_row = 1
    GUI.Affects.current_column = 1
  end
  -- Initialize Modes - These will display along with the health bars.
  GUI.Affects.Modes.num_icons_row =
    GUI.AffectedByIconsBox:get_width() / GUI.Affects.Modes.icon_width
  GUI.Affects.Modes.ModeList =
    {
      ["Mode-RapidShot"] = true,
      ["Flurry-of-Blows"] = true,
      ["Sneaking"] = true,
      ["Hiding"] = true,
      ["Mode-PowerAttack"] = true,
      ["Mode-Expertise"] = true,
      ["Mode-Total-Defense"] = true,
      ["Spot-Mode"] = true,
      ["Listen-Mode"] = true,
      ["Mode-Spellbattle"] = true,
      ["Counterspell"] = true,
      ["Defensive-Casting"] = true,
      ["Charging"] = true,
      ["WildShape"] = true,
    }
  -- Create the Mode Labels
  for i = 1, GUI.Affects.Modes.num_icons_row do
    GUI.Affects.Modes.Labels[i] =
      Geyser.Label:new(
        {
          name = "GUI.AffectIcon" .. tostring(i),
          width = GUI.Affects.Modes.icon_width,
          height = GUI.Affects.Modes.icon_height,
          h_policy = Geyser.Dynamic,
          v_policy = Geyser.Dynamic,
        },
        GUI.AffectedByIconsBox
      )
    GUI.Affects.Modes.Labels[i]:setStyleSheet(GUI.Affects.Modes.IconCSS:getCSS())
  end
	GUI.tabbedInfoWindow["Affects"]:hide()
	
	-- Initialize the area for the Spell Like Affects - GUI.Affects.SLAffects
	GUI.SLAffects.row_height = 20
	-- Calculate how many rows we can have:
	GUI.SLAffects.num_rows = (GUI.tabbedInfoWindow["Affectscenter"]:get_height() - (GUI.Affects.icon_height*GUI.Affects.num_rows)) / GUI.SLAffects.row_height
	-- Set up the VBox
	GUI.SLAffects.container = 
	Geyser.VBox:new(
      {
        name = "GUI.SLAffects.container",
        x = 0,
        y = GUI.Affects.icon_height*GUI.Affects.num_rows,
        width = "100%",
        height = GUI.tabbedInfoWindow["Affectscenter"].get_height() - (GUI.Affects.icon_height*GUI.Affects.num_rows),        
        v_policy = Geyser.Fixed,
      },
      GUI.tabbedInfoWindow["Affectscenter"]
  )

	for i = 1, GUI.SLAffects.num_rows do
		GUI.SLAffects.Labels[i] = 
			Geyser.Label:new(
				{
					name = "GUI.SLAffect" .. tostring(i),
					width = "100%",
					height = GUI.SLAffects.row_height,
					h_policy = Geyser.Fixed,
				}, GUI.SLAffects.container
			)
		GUI.SLAffects.Labels[i]:setStyleSheet([[
        background-color: rgba(0,0,0,0%);
      ]])
    GUI.SLAffects.Labels[i]:hide()
	end 
end

function GUI.updateSLAffects()
	if msdp.AFFECTS and msdp.AFFECTS.SPELL_LIKE_AFFECTS and #msdp.AFFECTS.SPELL_LIKE_AFFECTS &gt; 0 then
		-- We have spell like affects to process!		
		for i = 1, GUI.SLAffects.num_rows do
			GUI.SLAffects.Labels[i]:echo("")
			GUI.SLAffects.Labels[i]:hide()
			if i &lt;= #msdp.AFFECTS.SPELL_LIKE_AFFECTS then
			  if (msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].LOCATION == "Damage-Reduction") then
					affect_string = string.format("&lt;pre&gt;[ %s ] %s %s (%s)&lt;/pre&gt;", msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].DURATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].NAME, 
					msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].LOCATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].TYPE)
				else
				  affect_string = string.format("&lt;pre&gt;[ %s ] %s %s to %s (%s)&lt;/pre&gt;", msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].DURATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].NAME, 
					msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].MODIFIER, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].LOCATION, msdp.AFFECTS.SPELL_LIKE_AFFECTS[i].TYPE)
				end
				GUI.SLAffects.Labels[i]:echo(affect_string)
				GUI.SLAffects.Labels[i]:show()
			end
		end		 
	end
end

function GUI.updateAffectIcons()
  -- Also update spell-like affects display
  GUI.updateSLAffects()
  
  if msdp.AFFECTS and msdp.AFFECTS.AFFECTED_BY and #msdp.AFFECTS.AFFECTED_BY &gt; 0 then
    -- We have a status to process!  Do MODES first.
    affected_by = msdp.AFFECTS.AFFECTED_BY
    for k, _ in ipairs(GUI.Affects.Modes.Labels) do
      GUI.Affects.Modes.Labels[k]:hide()
    end
    for k, _ in ipairs(GUI.Affects.Rows) do
      for l, _ in ipairs(GUI.Affects.Rows[k].Labels) do
        GUI.Affects.Rows[k].Labels[l]:hide()
      end
    end
    GUI.Affects.Modes.current_icon = 1
    GUI.Affects.current_row = 1
    GUI.Affects.current_column = 1
    for i = 1, #affected_by do
      -- Is this a Mode?
      if
        (
          (GUI.Affects.Modes.current_icon &lt;= GUI.Affects.Modes.num_icons_row) and
          (GUI.Affects.Modes.ModeList[affected_by[i].NAME] == true)
        )
      then
        -- Create the Icon!				
        GUI.Affects.Modes.Labels[GUI.Affects.Modes.current_icon]:setStyleSheet([[
          QLabel { 
            border-image: url("]] ..
            getMudletHomeDir():gsub("\\", "/") ..
            [[/LuminariGUI/images/affected_by/]] ..
            affected_by[i].NAME ..
            [[.png"); 
            margin: 0px; 
          }
        ]])
        -- Add tooltip for mode icons
        GUI.Affects.Modes.Labels[GUI.Affects.Modes.current_icon]:setToolTip(affected_by[i].NAME:gsub("_", " "), "10")
        GUI.Affects.Modes.Labels[GUI.Affects.Modes.current_icon]:show()
        GUI.Affects.Modes.current_icon = GUI.Affects.Modes.current_icon + 1
      else
        -- This is just an Affected By status flag
        if
          (
            (GUI.Affects.current_column &lt;= GUI.Affects.num_icons_row) and
            (GUI.Affects.current_row &lt;= GUI.Affects.num_rows)
          )
        then
          -- Create the Icon!				
          GUI.Affects.Rows[GUI.Affects.current_row].Labels[GUI.Affects.current_column]:setStyleSheet([[
            QLabel { 
              border-image: url("]] ..
              getMudletHomeDir():gsub("\\", "/") ..
              [[/LuminariGUI/images/affected_by/]] ..
              affected_by[i].NAME ..
              [[.png"); 
              margin: 0px; 
            }
          ]])
          -- Add tooltip for status effect icons
          GUI.Affects.Rows[GUI.Affects.current_row].Labels[GUI.Affects.current_column]:setToolTip(affected_by[i].NAME:gsub("_", " "), "10")
          GUI.Affects.Rows[GUI.Affects.current_row].Labels[GUI.Affects.current_column]:show()
          GUI.Affects.current_column = GUI.Affects.current_column + 1
          if GUI.Affects.current_column &gt; GUI.Affects.num_icons_row then
            GUI.Affects.current_column = 1
            GUI.Affects.current_row = GUI.Affects.current_row + 1
          end
        end
      end
    end
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Group</name>
						<packageName></packageName>
						<script>function GUI.init_group()
  GUI.GroupConsole =
    Geyser.MiniConsole:new(
      {name = "GUI.GroupConsole", x = 0, y = 0, width = "100%", height = "100%"},
      GUI.tabbedInfoWindow["Groupcenter"]
    )
  GUI.GroupConsole:setColor({r=0, b=0, g=0, a=0})
	GUI.tabbedInfoWindow["Group"]:hide()
end

function GUI.updateGroup()
  GUI.group_data = {}
  -- Remove the player from the group data if toggled off.
  local j = 1
  local status_msg
  for i = 1, #msdp.GROUP do
    if GUI.toggles.includeInGroup == false and msdp.GROUP[i].NAME ~= msdp.CHARACTER_NAME then
      while GUI.group_data[j] ~= nil do
        j = j + 1
      end
      GUI.group_data[j] = {}
      GUI.group_data[j].IS_LEADER = msdp.GROUP[i].IS_LEADER
      GUI.group_data[j].NAME = msdp.GROUP[i].NAME
      GUI.group_data[j].HEALTH = msdp.GROUP[i].HEALTH
      GUI.group_data[j].HEALTH_MAX = msdp.GROUP[i].HEALTH_MAX
      GUI.group_data[j].MOVEMENT = msdp.GROUP[i].MOVEMENT
      GUI.group_data[j].MOVEMENT_MAX = msdp.GROUP[i].MOVEMENT_MAX
      GUI.group_data[j].LEVEL = msdp.GROUP[i].LEVEL
      GUI.group_data[j].CLASS_STRING = msdp.GROUP[i].CLASS_STRING
  -- Add the player from the group data if toggled on.
		elseif GUI.toggles.includeInGroup == true then
      while GUI.group_data[j] ~= nil do
        j = j + 1
      end
      GUI.group_data[j] = {}
      GUI.group_data[j].IS_LEADER = msdp.GROUP[i].IS_LEADER
      GUI.group_data[j].NAME = msdp.GROUP[i].NAME
      GUI.group_data[j].HEALTH = msdp.GROUP[i].HEALTH
      GUI.group_data[j].HEALTH_MAX = msdp.GROUP[i].HEALTH_MAX
      GUI.group_data[j].MOVEMENT = msdp.GROUP[i].MOVEMENT
      GUI.group_data[j].MOVEMENT_MAX = msdp.GROUP[i].MOVEMENT_MAX
      GUI.group_data[j].LEVEL = msdp.GROUP[i].LEVEL
      GUI.group_data[j].CLASS_STRING = msdp.GROUP[i].CLASS_STRING	
    end -- if/elseif
  end -- for
	clearUserWindow("GUI.GroupConsole")
  num_grouped = #GUI.group_data
  for i = 1, num_grouped do
    -- Build the group member data and send it.
    --	+----------------------------------+
    --  | [level] Name                     |
    --  | hp: 90%  |=================    | |
    --  | Crown (leader), Shield (Tank)    |
    --  +----------------------------------+		
    if GUI.group_data[i].IS_LEADER == "1" then
      status_msg = "&lt;green&gt;LEADER"
    else
      status_msg = ""
    end
    local pct_health
    local health = tonumber(GUI.group_data[i].HEALTH)
    local max_health = tonumber(GUI.group_data[i].HEALTH_MAX)
    if health &gt; 0 then
      pct_health = (health / max_health) * 100
    else
      pct_health = 0
    end
    if pct_health &gt; 60 then
      hp_color = "&lt;green&gt;"
    elseif pct_health &gt; 15 then
        hp_color = "&lt;yellow&gt;"
      else
        hp_color = "&lt;red&gt;"
      end
			
			-- Format leader indicator
			local leader_icon = ""
			if GUI.group_data[i].IS_LEADER == "1" then
			  leader_icon = "&lt;gold&gt;♔ "  -- Crown symbol for leader
			else
			  leader_icon = "  "
			end
			
			-- Format name with class abbreviation
			local class_abbr = GUI.group_data[i].CLASS_STRING or ""
			if #class_abbr > 3 then
			  class_abbr = string.sub(class_abbr, 1, 3):upper()
			end
			
			-- Enhanced member display with better formatting
			local member = string.format("%s&lt;cyan&gt;[&lt;b&gt;%2s&lt;/b&gt;] &lt;white&gt;&lt;b&gt;%-20s&lt;/b&gt; &lt;light_gray&gt;%-3s\n", 
			                            leader_icon,
			                            GUI.group_data[i].LEVEL,
			                            GUI.group_data[i].NAME,
			                            class_abbr)
			                            
			-- Health bar visualization
			local health_pct = math.floor(pct_health)
			local bar_length = 20
			local filled = math.floor((health_pct / 100) * bar_length)
			local empty = bar_length - filled
			
			member = member .. string.format("   &lt;light_gray&gt;HP: %s%3d%%&lt;light_gray&gt; [%s%s&lt;light_gray&gt;%s&lt;light_gray&gt;] &lt;dim_gray&gt;%s/%s\n",
			                                hp_color,
			                                health_pct,
			                                hp_color,
			                                string.rep("=", filled),
			                                string.rep("-", empty),
			                                GUI.group_data[i].HEALTH,
			                                GUI.group_data[i].HEALTH_MAX)
			                                
			-- Movement display
			local move_pct = tonumber(GUI.group_data[i].MOVEMENT) / tonumber(GUI.group_data[i].MOVEMENT_MAX) * 100
			local move_color = move_pct > 50 and "&lt;cyan&gt;" or (move_pct > 20 and "&lt;yellow&gt;" or "&lt;red&gt;")
			member = member .. string.format("   &lt;light_gray&gt;MV: %s%3d%%&lt;light_gray&gt; &lt;dim_gray&gt;(%s/%s)\n",
			                                move_color,
			                                math.floor(move_pct),
			                                GUI.group_data[i].MOVEMENT,
			                                GUI.group_data[i].MOVEMENT_MAX)
			
			-- Add separator between members
			if i &lt; num_grouped then
			  member = member .. "&lt;dim_gray&gt;   ─────────────────────────────\n"
			end
			
      GUI.GroupConsole:cecho(member)
    end
  end


</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Player</name>
						<packageName></packageName>
						<script>function GUI.init_player()
  -- Check if tabbedInfoWindow is initialized
  if not GUI.tabbedInfoWindow or not GUI.tabbedInfoWindow["Playercenter"] then
    print("[GUI] Player tab not initialized yet")
    return
  end
  
  -- Add alignment to existing stylesheet without overwriting background and other styles
  local existingStyle = [[
    background-color: ]] .. GUI.tabbedInfoWindow.color2 .. [[;
    border-image: url(]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/ui_texture.jpg) 0 0 0 0 stretch stretch;
    font-family: Tahoma, Geneva, sans-serif;
    qproperty-alignment: 'AlignLeft | AlignTop';
  ]]
  
  GUI.tabbedInfoWindow["Playercenter"]:setStyleSheet(existingStyle)
end

function GUI.updatePlayer()
  -- Check if tabbedInfoWindow is initialized
  if not GUI.tabbedInfoWindow or not GUI.tabbedInfoWindow["Playercenter"] then
    print("[GUI] Player tab not ready for update")
    return
  end
  
  -- Build the player info display with proper null checks and enhanced styling
  local playerInfo = [[&lt;div style="padding: 5px;"&gt;]]
  
  -- Character name and level (larger, bold)
  playerInfo = playerInfo .. [[&lt;p style="font-size:18px;font-weight:bold;color:#FFD700;font-family:'Bitstream Vera Sans Mono';margin:0;text-shadow:1px 1px 2px #000;"&gt;]]
  playerInfo = playerInfo .. (msdp.CHARACTER_NAME or "Unknown") .. [[&lt;/p&gt;]]
  
  -- Level and Class
  playerInfo = playerInfo .. [[&lt;p style="font-size:16px;color:#C0C0C0;font-family:'Bitstream Vera Sans Mono';margin:2px 0;"&gt;Level &lt;span style="color:#00FF00;font-weight:bold;"&gt;]]
  playerInfo = playerInfo .. (msdp.LEVEL or "?") .. [[&lt;/span&gt; ]]
  playerInfo = playerInfo .. [[&lt;span style="color:#4169E1;font-weight:bold;"&gt;]] .. (msdp.CLASS or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
  
  -- Race
  playerInfo = playerInfo .. [[&lt;p style="font-size:14px;color:#DDA0DD;font-family:'Bitstream Vera Sans Mono';margin:2px 0;"&gt;]]
  playerInfo = playerInfo .. (msdp.RACE or "Unknown") .. [[&lt;/p&gt;]]
  
  -- Stats section with color coding
  playerInfo = playerInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:8px 0;"&gt;]]
  playerInfo = playerInfo .. [[&lt;p style="font-size:15px;color:#FFD700;font-weight:bold;font-family:'Bitstream Vera Sans Mono';margin:5px 0;"&gt;Attributes&lt;/p&gt;]]
  
  -- Stats in two columns with proper spacing
  playerInfo = playerInfo .. [[&lt;table style="width:100%;font-size:14px;font-family:'Bitstream Vera Sans Mono';border-spacing:15px 0;"&gt;]]
  playerInfo = playerInfo .. [[&lt;tr&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#FF6B6B;padding-right:20px;width:50%;"&gt;STR: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.STR or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#4169E1;padding-left:10px;width:50%;"&gt;INT: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.INT or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;/tr&gt;&lt;tr&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#90EE90;padding-right:20px;"&gt;DEX: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.DEX or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#87CEEB;padding-left:10px;"&gt;WIS: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.WIS or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;/tr&gt;&lt;tr&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#FFA500;padding-right:20px;"&gt;CON: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.CON or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;td style="color:#DDA0DD;padding-left:10px;"&gt;CHA: &lt;span style="color:#FFFFFF;font-weight:bold;"&gt;]] .. (msdp.CHA or "?") .. [[&lt;/span&gt;&lt;/td&gt;]]
  playerInfo = playerInfo .. [[&lt;/tr&gt;&lt;/table&gt;]]
  
  -- AC and Gold
  playerInfo = playerInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:8px 0;"&gt;]]
  playerInfo = playerInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;&lt;span style="color:#C0C0C0;"&gt;AC:&lt;/span&gt; &lt;span style="color:#00CED1;font-weight:bold;font-size:16px;"&gt;]] .. (msdp.AC or "?") .. [[&lt;/span&gt;&lt;/p&gt;]]
  playerInfo = playerInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;&lt;span style="color:#C0C0C0;"&gt;Gold:&lt;/span&gt; &lt;span style="color:#FFD700;font-weight:bold;font-size:16px;"&gt;]] .. (msdp.MONEY or "0") .. [[&lt;/span&gt;&lt;/p&gt;]]
  
  playerInfo = playerInfo .. [[&lt;/div&gt;]]
  
  -- Update the display
  GUI.tabbedInfoWindow["Playercenter"]:echo(playerInfo)
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Buttons</name>
						<packageName></packageName>
						<script>GUI.buttonWindow =
  GUI.buttonWindow or
  {
    button = {"Legend", "Mudlet", "ASCII"},
    color1 = "rgba(0,0,0,0)",
    color2 = "rgba(0,0,0,0)",
    width = "100%",
    height = "100%",
		roomOrLegend = "Room",
		mudletOrAscii = "Mudlet",
		--# of chars wide text needs to be
		legendWidth = 50,
		--# of lines needed to display text
		legendHeight = 11,
  }

--Determine font size for Legend
function GUI.buttonWindow.adjustLegendFont()
  local w = GUI.buttonWindow.Legend.get_width()
  local h = GUI.buttonWindow.Legend.get_height()
  local font_size = 8
  repeat
    font_size = font_size + 1
    local width, height = calcFontSize(font_size)
    width = width * GUI.buttonWindow.legendWidth
    height = height * GUI.buttonWindow.legendHeight
  until (w &lt; width) or (h &lt; height)
	GUI.buttonWindow.Legend_font_size = font_size - 1
  setMiniConsoleFontSize("GUI.buttonWindow.Legend", GUI.buttonWindow.Legend_font_size)
end

--Button callback for Legend
function GUI.buttonWindow.legendClick()	
  --Toggle For Room Info/Legend
	if GUI.buttonWindow.roomOrLegend == "Room" then
		GUI.buttonWindow.roomInfo:hide()
    GUI.buttonWindow.Legend:show()
		GUI.buttonWindow.roomOrLegend = "Legend"
		GUI.updateRoom()
		GUI.buttonWindow.Legendbutton:echo("Legend/Room", "yellow", "c")
	elseif GUI.buttonWindow.roomOrLegend == "Legend" then
		GUI.updateLegend()
		GUI.buttonWindow.roomInfo:show()
    GUI.buttonWindow.Legend:hide()
		GUI.buttonWindow.roomOrLegend = "Room"
		GUI.buttonWindow.Legendbutton:echo("Legend/Room", "white", "c")
	end
end

--Button callback for Mudlet map.
function GUI.buttonWindow.mudletClick()
    -- Ensure containers exist before toggling
    if not map.container or not GUI.asciiMapContainer then
      print("ERROR: Map containers not initialized")
      return
    end
    
    GUI.asciiMapContainer:hide()
    map.container:show()
	  GUI.buttonWindow.mudletOrAscii = "Mudlet"
		GUI.buttonWindow.Mudletbutton:echo("Mudlet", "yellow", "c")
		GUI.buttonWindow.ASCIIbutton:echo("ASCII", "white", "c")
		
		-- Ensure mapper is visible and properly refreshed with a small delay
		tempTimer(0.1, function()
		  if map.mapwindow then
		    map.mapwindow:show()
		    map.mapwindow:resize()
		  end
		end)
end

--Button callback for ASCII map.
function GUI.buttonWindow.asciiClick()
    -- Ensure containers exist before toggling
    if not map.container or not GUI.asciiMapContainer then
      print("ERROR: Map containers not initialized")
      return
    end
    
    map.container:hide()
    GUI.asciiMapContainer:show()
		GUI.buttonWindow.mudletOrAscii = "ASCII"
		GUI.buttonWindow.ASCIIbutton:echo("ASCII", "yellow", "c")
		GUI.buttonWindow.Mudletbutton:echo("Mudlet", "white", "c")
		GUI.asciiMapContainer:raise()
end

--Button Init
function GUI.buttonWindow.init()
  GUI.buttonWindowCSS =
    CSSMan.new(
      [[font-family: Tahoma, Geneva, sans-serif; 
			border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
			border: 1px solid rgba(184, 115, 27, 0.6);
			border-radius: 4px;
			padding: 4px;
			font-weight: bold;
			color: white;
		]]
    )
  
  -- Add hover and pressed effects CSS
  GUI.buttonWindowHoverCSS =
    CSSMan.new(
      [[font-family: Tahoma, Geneva, sans-serif; 
			border-image: url(]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
			border: 1px solid rgba(184, 115, 27, 1.0);
			border-radius: 4px;
			padding: 4px;
			font-weight: bold;
			color: white;
			background-color: rgba(255, 255, 255, 0.1);
			box-shadow: 0px 0px 4px rgba(184, 115, 27, 0.6);
		]]
    )
		
--Entire Box3 Container for Buttons
  GUI.buttonWindow.container =
    Geyser.Container:new(
      {
        name = "GUI.buttonWindow.container",
        x = 9,
        y = 25,
        width = "-18",
        height = "-34",
      },
      GUI.buttonPanelContainer
    )

--Room Info
  GUI.buttonWindow.roomInfo = 
	Geyser.Label:new(
		{
		  name = "GUI.buttonWindow.roomInfo",
			x = 9,
			y = 25,
			width = "-18",
			height = "-34",
			},
			GUI.roomInfoContainer
		)

--Map Legend
  GUI.buttonWindow.Legend = 
	Geyser.MiniConsole:new(
		{
		  name = "GUI.buttonWindow.Legend",
			x = 9,
			y = 25,
			width = "-18",
			height = "-34",
			color = "black",
			},
			GUI.roomInfoContainer
		)
		GUI.buttonWindow.adjustLegendFont()
		
--Button Container
  GUI.buttonWindow.buttonContainer =
    Geyser.HBox:new(
      {name = "GUI.buttonWindow.buttonContainer", x = 0, y = 0, width = "100%", height = "100%"},
      GUI.buttonWindow.container
    )

--Draw Buttons
  for k, v in pairs(GUI.buttonWindow.button) do
    GUI.buttonWindow[v .. "button"] =
      Geyser.Label:new({name = "GUI.buttonWindow." .. v .. "button"}, GUI.buttonWindow.buttonContainer)
    GUI.buttonWindow[v .. "button"]:setStyleSheet(GUI.buttonWindowCSS:getCSS())
    GUI.buttonWindow[v .. "button"]:echo("&lt;center&gt;" .. (v == "Legend" and "Legend/Room" or v))
  end

--Legend Call Back
  GUI.buttonWindow.Legendbutton:setClickCallback("GUI.buttonWindow.legendClick")		
--Mudlet/ASCII Callback
  GUI.buttonWindow.Mudletbutton:setClickCallback("GUI.buttonWindow.mudletClick")	
  GUI.buttonWindow.ASCIIbutton:setClickCallback("GUI.buttonWindow.asciiClick")	
	
--Show Room Info on Startup
	GUI.buttonWindow.roomInfo:show()
  GUI.buttonWindow.Legend:hide()
	
--Populating Legend
	GUI.updateLegend()

--[[Will error line 33 if we call mudletClick callback
  so handling echo this way since Mudlet loads its map
  by default. ]]
	GUI.buttonWindow.Mudletbutton:echo("Mudlet", "yellow", "c")
	GUI.buttonWindow.ASCIIbutton:echo("ASCII", "white", "c")
	
end </script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Room Info/Legend</name>
						<packageName></packageName>
						<script>
function GUI.updateRoom()
  local roomInfo = [[&lt;div style="padding: 5px;"&gt;]]
  
  if msdp.ROOM.ENVIRONMENT == "Wilderness" then
    -- Wilderness display
    roomInfo = roomInfo .. [[&lt;p style="font-size:16px;font-weight:bold;color:#90EE90;font-family:'Bitstream Vera Sans Mono';margin:0;text-shadow:1px 1px 2px #000;"&gt;]]
    roomInfo = roomInfo .. [[&lt;center&gt;🌲 WILDERNESS 🌲&lt;/center&gt;&lt;/p&gt;]]
    
    roomInfo = roomInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:5px 0;"&gt;]]
    
    -- Coordinates
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Coords:&lt;/span&gt; &lt;span style="color:#00CED1;font-weight:bold;"&gt;(]]
    roomInfo = roomInfo .. (msdp.ROOM.COORDS.X or "?") .. ", " .. (msdp.ROOM.COORDS.Y or "?")
    roomInfo = roomInfo .. [[)&lt;/span&gt;&lt;/p&gt;]]
    
    -- Terrain
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Terrain:&lt;/span&gt; &lt;span style="color:#FFA500;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.TERRAIN or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
    
  else
    -- Regular room display
    -- Room name
    roomInfo = roomInfo .. [[&lt;p style="font-size:16px;font-weight:bold;color:#FFD700;font-family:'Bitstream Vera Sans Mono';margin:0;text-align:center;text-shadow:1px 1px 2px #000;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.NAME or "Unknown") .. [[&lt;/p&gt;]]
    
    roomInfo = roomInfo .. [[&lt;hr style="border:1px solid #B8731B;margin:5px 0;"&gt;]]
    
    -- Room VNUM
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Room #:&lt;/span&gt; &lt;span style="color:#87CEEB;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.VNUM or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
    
    -- Terrain
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Terrain:&lt;/span&gt; &lt;span style="color:#FFA500;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.TERRAIN or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
    
    -- Area
    roomInfo = roomInfo .. [[&lt;p style="font-size:14px;font-family:'Bitstream Vera Sans Mono';margin:3px 0;"&gt;]]
    roomInfo = roomInfo .. [[&lt;span style="color:#C0C0C0;"&gt;Area:&lt;/span&gt; &lt;span style="color:#DDA0DD;font-weight:bold;"&gt;]]
    roomInfo = roomInfo .. (msdp.ROOM.AREA or "Unknown") .. [[&lt;/span&gt;&lt;/p&gt;]]
  end
  
  roomInfo = roomInfo .. [[&lt;/div&gt;]]
  GUI.buttonWindow.roomInfo:echo(roomInfo)
end
		
--Whattt to be replaced with MSDP or GMCP once coded in


function GUI.updateLegend()
  clearUserWindow("GUI.buttonWindow.Legend")
	GUI.buttonWindow.Legend:decho("\n &lt;102,0,0&gt; + &lt;255,255,255&gt; Up           &lt;0,102,102&gt;[&lt;0,255,255&gt;^&lt;0,102,102&gt;] &lt;255,255,255&gt;Air           &lt;0,102,102&gt;[&lt;255,0,255&gt;Y&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Wild")
	GUI.buttonWindow.Legend:decho("\n &lt;102,0,0&gt; - &lt;255,255,255&gt; Down         &lt;0,102,102&gt;[&lt;0,0,102&gt;U&lt;0,102,102&gt;] &lt;255,255,255&gt;Underwater    &lt;0,102,102&gt;[&lt;102,0,102&gt;C&lt;0,102,102&gt;] &lt;255,255,255&gt;UD City")
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;255,255,255&gt;&amp;&lt;0,102,102&gt;] &lt;255,255,255&gt;You          &lt;0,102,102&gt;[&lt;255,0,0&gt;X&lt;0,102,102&gt;] &lt;255,255,255&gt;Zone Entry    &lt;0,102,102&gt;[&lt;102,0,102&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Inside")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;192,192,192&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Inside       &lt;0,102,102&gt;[&lt;51,51,51&gt;|&lt;0,102,102&gt;] &lt;255,255,255&gt;Road N-S      &lt;0,102,102&gt;[&lt;102,0,102&gt;~&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Water") 
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;102,102,102&gt;C&lt;0,102,102&gt;] &lt;255,255,255&gt;City         &lt;0,102,102&gt;[&lt;51,51,51&gt;-&lt;0,102,102&gt;] &lt;255,255,255&gt;Road E-W      &lt;0,102,102&gt;[&lt;255,0,255&gt;=&lt;0,102,102&gt;] &lt;255,255,255&gt;UD D Water")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,102,0&gt;,&lt;0,102,102&gt;] &lt;255,255,255&gt;Field        &lt;0,102,102&gt;[&lt;51,51,51&gt;+&lt;0,102,102&gt;] &lt;255,255,255&gt;Intersect     &lt;0,102,102&gt;[&lt;102,0,102&gt;^&lt;0,102,102&gt;] &lt;255,255,255&gt;UD Air")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,255,0&gt;Y&lt;0,102,102&gt;] &lt;255,255,255&gt;Forest       &lt;0,102,102&gt;[&lt;255,255,0&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Desert        &lt;0,102,102&gt;[&lt;255,0,0&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Lava")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;102,102,0&gt;^&lt;0,102,102&gt;] &lt;255,255,255&gt;Hills        &lt;0,102,102&gt;[&lt;0,0,255&gt;o&lt;0,102,102&gt;] &lt;255,255,255&gt;Ocean         &lt;0,102,102&gt;[&lt;102,102,0&gt;|&lt;0,102,102&gt;] &lt;255,255,255&gt;D Rd N-S")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;102,0,0&gt;m&lt;0,102,102&gt;] &lt;255,255,255&gt;Mountain     &lt;0,102,102&gt;[&lt;255,0,255&gt;,&lt;0,102,102&gt;] &lt;255,255,255&gt;Marsh         &lt;0,102,102&gt;[&lt;102,102,0&gt;-&lt;0,102,102&gt;] &lt;255,255,255&gt;D Rd E-W")  
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,102,102&gt;~&lt;0,102,102&gt;] &lt;255,255,255&gt;Water        &lt;0,102,102&gt;[&lt;255,0,0&gt;M&lt;0,102,102&gt;] &lt;255,255,255&gt;High Mount    &lt;0,102,102&gt;[&lt;102,102,0&gt;+&lt;0,102,102&gt;] &lt;255,255,255&gt;D Inters") 
	GUI.buttonWindow.Legend:decho("\n &lt;0,102,102&gt;[&lt;0,0,102&gt;=&lt;0,102,102&gt;] &lt;255,255,255&gt;Deep Water   &lt;0,102,102&gt;[&lt;51,51,51&gt;.&lt;0,102,102&gt;] &lt;255,255,255&gt;Planes        &lt;0,102,102&gt;[&lt;51,51,51&gt;C&lt;0,102,102&gt;] &lt;255,255,255&gt;Cave") 
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>DrawFrames</name>
						<packageName></packageName>
						<script>function GUI.draw_frames()
  -- Frame drawing removed - frame images are incompatible with adjustable containers
  -- Adjustable containers have their own border styling through the adjLabelstyle property
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MSDP</name>
						<packageName></packageName>
						<script>function GUI.onProtocolEnabled(_, protocol)
  if protocol == "MSDP" then
    print("[GUI] MSDP Protocol enabled - initializing variables")
    
    -- Send REPORT requests for all MSDP variables
    sendMSDP("REPORT", "CHARACTER_NAME")
		sendMSDP("REPORT", "RACE")
		sendMSDP("REPORT", "CLASS")
		sendMSDP("REPORT", "ALIGNMENT")
		sendMSDP("REPORT", "LEVEL")
		sendMSDP("REPORT", "STR")
		sendMSDP("REPORT", "DEX")
		sendMSDP("REPORT", "CON")
		sendMSDP("REPORT", "INT")
		sendMSDP("REPORT", "WIS")
		sendMSDP("REPORT", "CHA")
		sendMSDP("REPORT", "AC")
		sendMSDP("REPORT", "MONEY")
		sendMSDP("REPORT", "HEALTH")
    sendMSDP("REPORT", "HEALTH_MAX")
    sendMSDP("REPORT", "OPPONENT_HEALTH")
    sendMSDP("REPORT", "OPPONENT_HEALTH_MAX")
    sendMSDP("REPORT", "OPPONENT_NAME")
    sendMSDP("REPORT", "MOVEMENT")
    sendMSDP("REPORT", "MOVEMENT_MAX")
    sendMSDP("REPORT", "PSP")
    sendMSDP("REPORT", "PSP_MAX")
    sendMSDP("REPORT", "EXPERIENCE")
    sendMSDP("REPORT", "EXPERIENCE_TNL")
    sendMSDP("REPORT", "ACTIONS")
		sendMSDP("REPORT", "GROUP")
		--sendMSDP("REPORT", "INVENTORY")
		sendMSDP("REPORT", "AFFECTS")
		sendMSDP("REPORT", "ROOM")
		sendMSDP("REPORT", "AREA_NAME")
		sendMSDP("REPORT", "ROOM_EXITS")
		sendMSDP("REPORT", "ROOM_NAME")
		sendMSDP("REPORT", "ROOM_VNUM")
		sendMSDP("REPORT", "WORLD_TIME")
    
    -- Debug: Show what variables are available after a short delay
    tempTimer(2, function()
      print("[GUI] MSDP variables received:")
      local count = 0
      for k, v in pairs(msdp) do
        if type(v) ~= "function" then
          count = count + 1
          if k == "ACTIONS" then
            -- Special handling for ACTIONS to show its structure
            print(string.format("  %s = %s (type: %s)", k, tostring(v), type(v)))
            if type(v) == "table" then
              print("    ACTIONS table contents:")
              for action_k, action_v in pairs(v) do
                print(string.format("      %s = %s", action_k, tostring(action_v)))
              end
            end
          else
            print(string.format("  %s = %s", k, tostring(v)))
          end
        end
      end
      print(string.format("[GUI] Total MSDP variables: %d", count))
    end)
    
    -- Initialize or refresh GUI after a short delay to ensure MSDP data arrives
    tempTimer(0.5, function()
      GUI.initializeOrRefresh("MSDP protocol enabled")
    end)
  end
end

function GUI.updateHealthGauge()
  -- This function handles the following events:
  --   msdp.HEALTH
  --   msdp.HEALTH_MAX
  
  -- Check if gauge exists
  if not GUI.Health then
    return
  end
  
  -- Get values with defaults
  local health = tonumber(msdp.HEALTH) or 0
  local max_health = tonumber(msdp.HEALTH_MAX) or 1
  
  -- Calculate percentage
  local pct_health
  if health &gt; max_health then
    health = max_health
  end
  
  if max_health &gt; 0 then
    pct_health = (health / max_health) * 100
  else
    pct_health = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;HEALTH: " .. health .. "/" .. max_health .. "&lt;/b&gt;"
  GUI.Health.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
  GUI.Health.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
  
  -- Set gauge value
  if pct_health &gt; 100 then
    GUI.Health:setValue(100, 100)
  else
    GUI.Health:setValue(pct_health, 100)
  end
end

function GUI.updateMovesGauge()
  -- This function handles the following events:
  --   msdp.MOVEMENT
  --   msdp.MOVEMENT_MAX
  
  -- Check if gauge exists
  if not GUI.Moves then
    return
  end
  
  -- Get values with defaults
  local moves = tonumber(msdp.MOVEMENT) or 0
  local max_moves = tonumber(msdp.MOVEMENT_MAX) or 1
  
  -- Calculate percentage
  local pct_moves
  if max_moves &gt; 0 then
    pct_moves = (moves / max_moves) * 100
  else
    pct_moves = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;MOVES: " .. moves .. "/" .. max_moves .. "&lt;/b&gt;"
  GUI.Moves.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
  GUI.Moves.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
  
  -- Set gauge value
  if pct_moves &gt; 100 then
    GUI.Moves:setValue(100, 100)
  else
    GUI.Moves:setValue(pct_moves, 100)
  end
end

-- function GUI.updateExperienceGauge()
--   -- This function handles the following events:
--   --   msdp.EXPERIENCE
--   --   msdp.EXPERIENCE_TNL
--   
--   -- Check if gauge exists
--   if not GUI.Experience then
--     return
--   end
--   
--   -- Get values with defaults
--   local xp = tonumber(msdp.EXPERIENCE) or 0
--   local xp_tnl = tonumber(msdp.EXPERIENCE_TNL) or 0
--   
--   -- Calculate percentage
--   local pct_xp
--   local total_xp = xp + xp_tnl
--   if total_xp &gt; 0 then
--     pct_xp = (xp / total_xp) * 100
--   else
--     pct_xp = 0
--   end
--   
--   -- Update display with dynamic font sizes
--   local gaugeHeight = GUI.Experience:get_height()
--   local fontSize1 = math.max(8, math.floor(gaugeHeight * 0.4))
--   local fontSize2 = math.max(6, math.floor(gaugeHeight * 0.3))
--   local displayText = "&lt;b&gt;EXP: &lt;span style='font-size:" .. fontSize1 .. "px;'&gt;" .. xp .. "&lt;/span&gt;&lt;span style='color:#4B0082;'&gt;/&lt;/span&gt;&lt;span style='font-size:" .. fontSize2 .. "px;'&gt;" .. total_xp .. "&lt;/span&gt;&lt;/b&gt;"
--   GUI.Experience.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
--   GUI.Experience.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
--   
--   -- Set gauge value
--   if pct_xp &gt; 100 then
--     GUI.Experience:setValue(100, 100)
--   else
--     GUI.Experience:setValue(pct_xp, 100)
--   end
-- end

function GUI.updatePSPGauge()
  -- This function handles the following events:
  --   msdp.PSP
  --   msdp.PSP_MAX
  
  -- Check if gauge exists
  if not GUI.PSP then
    return
  end
  
  -- Get values with defaults
  local psp = tonumber(msdp.PSP) or 0
  local max_psp = tonumber(msdp.PSP_MAX) or 1
  
  -- Calculate percentage
  local pct_psp
  if max_psp &gt; 0 then
    pct_psp = (psp / max_psp) * 100
  else
    pct_psp = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;PSP: " .. psp .. "/" .. max_psp .. "&lt;/b&gt;"
  GUI.PSP.front:echo([[&lt;span style = "color: black; text-shadow: 1px 1px 1px rgba(255,255,255,0.5);"&gt;]] .. displayText .. [[&lt;/span&gt;]])
  GUI.PSP.back:echo([[&lt;span&gt;]] .. displayText .. [[&lt;/span&gt;]])
  
  -- Set gauge value
  if pct_psp &gt; 100 then
    GUI.PSP:setValue(100, 100)
  else
    GUI.PSP:setValue(pct_psp, 100)
  end
end

function GUI.updateEnemyGauge()
  -- This function handles the following events:
  --   msdp.OPPONENT_HEALTH
  --   msdp.OPPONENT_HEALTH_MAX
  --   msdp.OPPONENT_NAME
  
  -- Check if gauge exists
  if not GUI.Enemy then
    return
  end
  
  -- Get opponent name
  local opponent_name = msdp.OPPONENT_NAME or ""
  
  -- Show/Hide the gauge based on opponent presence
  if opponent_name == "" then
    GUI.Enemy:hide()
    return
  else
    GUI.Enemy:show()
  end
  
  -- Get values with defaults
  local health = tonumber(msdp.OPPONENT_HEALTH) or 0
  local max_health = tonumber(msdp.OPPONENT_HEALTH_MAX) or 1
  
  -- Calculate percentage
  local pct_health
  if max_health &gt; 0 then
    pct_health = (health / max_health) * 100
  else
    pct_health = 0
  end
  
  -- Update display
  local displayText = "&lt;b&gt;" .. opponent_name:upper() .. ": &lt;span style='color:#FF0000;'&gt;" .. health .. "&lt;/span&gt;&lt;span style='color:#9370DB;'&gt;/&lt;/span&gt;&lt;span style='color:#FFFFFF;'&gt;" .. max_health .. "&lt;/span&gt;&lt;/b&gt;"
  GUI.Enemy.front:echo(displayText)
  GUI.Enemy.back:echo(displayText)
  
  -- Set gauge value
  if pct_health &gt; 100 then
    GUI.Enemy:setValue(100, 100)
  else
    GUI.Enemy:setValue(pct_health, 100)
  end
end

function GUI.updateActionIcons()
  -- Check if ACTIONS data exists
  if not msdp.ACTIONS then
    -- No ACTIONS data yet, skip update
    return
  end
  
  -- Ensure action icons exist before updating
  if not GUI.StandardActionIcon or not GUI.MoveActionIcon or not GUI.SwiftActionIcon then
    print("[GUI] Action icons not initialized yet")
    return
  end
  
  -- Update Standard Action icon
  if msdp.ACTIONS.STANDARD_ACTION == "1" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-standard.png");]]
    )
    GUI.StandardActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  elseif msdp.ACTIONS.STANDARD_ACTION == "0" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-standard-50.png");]]
    )
    GUI.StandardActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  end
  
  -- Update Move Action icon
  if msdp.ACTIONS.MOVE_ACTION == "1" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-move.png");]]
    )
    GUI.MoveActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  elseif msdp.ACTIONS.MOVE_ACTION == "0" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-move-50.png");]]
    )
    GUI.MoveActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  end
  
  -- Update Swift Action icon
  if msdp.ACTIONS.SWIFT_ACTION == "1" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/action-swift.png");]]
    )
    GUI.SwiftActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  elseif msdp.ACTIONS.SWIFT_ACTION == "0" then
    GUI.ActionIconCSS:set(
      "border-image",
      [[url("]] ..
      getMudletHomeDir():gsub("\\", "/") ..
      [[/LuminariGUI/images/action-swift-50.png");]]
    )
    GUI.SwiftActionIcon:setStyleSheet(GUI.ActionIconCSS:getCSS())
  end
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Config</name>
						<packageName></packageName>
						<script>  -- CRITICAL: These initialization calls MUST remain outside any function!
  -- Mudlet requires GUI elements to be created immediately when the script loads.
  -- Moving these inside GUI.init() or any other function will cause complete failure.
  -- The GUI background, borders, and boxes must exist before any other initialization.
  -- This needs to be outside the config, since YATCO needs to have the boxes set.
	GUI.image_location = getMudletHomeDir():gsub("\\", "/") .. "/LuminariGUI/images/"
	GUI.init_background()
  GUI.set_borders()
  GUI.init_boxes()
	
function GUI.init()
  GUI.AffectIcons = GUI.AffectIcons or {}
  GUI.Affects = GUI.Affects or {}
  GUI.Affects.Rows = GUI.Affects.Rows or {}
  GUI.Affects.Modes = GUI.Affects.Modes or {}
  --
  GUI.init_gauges()
  GUI.init_action_icons()
  --GUI.init_header_icons()
  GUI.tabbedInfoWindow.init()
  GUI.init_player()
  GUI.init_group()
  GUI.Affects.init()
  GUI.draw_frames()
	GUI.buttonWindow.init()
  GUI.init_castConsole()
  GUI.styleScrollbar()
	
  -- Register all event handlers with error handling
  GUI.registerEventHandlers()
  
  -- Ensure proper z-order of adjustable containers
  tempTimer(0.5, function()
    -- Bring containers to front in correct order
    -- Map should be at the back
    if map and map.container then
      map.container:show()
    end
    if GUI.chatContainer then
      GUI.chatContainer:show()
    end
    if GUI.roomInfoContainer then
      GUI.roomInfoContainer:show()
      GUI.roomInfoContainer:raise()  -- Bring above map
    end
    if GUI.buttonPanelContainer then
      GUI.buttonPanelContainer:show()
      GUI.buttonPanelContainer:raise()  -- Bring to front
    end
    if GUI.actionIconsContainer then
      GUI.actionIconsContainer:show()
      GUI.actionIconsContainer:raise()  -- Bring to front
    end
  end)
  
  -- Mark GUI as initialized for the refresh system
  GUI.initialized = true
end

-- Robust event handler registration with error handling and verification
function GUI.registerEventHandlers()
  -- Define all event handlers in a table for easy management
  local eventHandlers = {
    -- GUI event handlers
    ["msdp.GROUP"] = "GUI.updateGroup",
    ["msdp.AFFECTS"] = "GUI.updateAffectIcons",
    ["sysProtocolEnabled"] = "GUI.onProtocolEnabled",
    ["msdp.HEALTH"] = "GUI.updateHealthGauge",
    ["msdp.HEALTH_MAX"] = "GUI.updateHealthGauge",
    ["msdp.OPPONENT_HEALTH"] = "GUI.updateEnemyGauge",
    ["msdp.OPPONENT_HEALTH_MAX"] = "GUI.updateEnemyGauge",
    ["msdp.OPPONENT_NAME"] = "GUI.updateEnemyGauge",
    ["msdp.MOVEMENT"] = "GUI.updateMovesGauge",
    ["msdp.MOVEMENT_MAX"] = "GUI.updateMovesGauge",
    -- ["msdp.EXPERIENCE"] = "GUI.updateExperienceGauge",
    -- ["msdp.EXPERIENCE_TNL"] = "GUI.updateExperienceGauge",
    ["msdp.PSP"] = "GUI.updatePSPGauge",
    ["msdp.PSP_MAX"] = "GUI.updatePSPGauge",
    ["msdp.ACTIONS"] = "GUI.updateActionIcons",
    ["msdp.CHARACTER_NAME"] = "GUI.updatePlayer",
    ["msdp.RACE"] = "GUI.updatePlayer",
    ["msdp.CLASS"] = "GUI.updatePlayer",
    ["msdp.ALIGNMENT"] = "GUI.updatePlayer",
    ["msdp.LEVEL"] = "GUI.updatePlayer",
    ["msdp.STR"] = "GUI.updatePlayer",
    ["msdp.DEX"] = "GUI.updatePlayer",
    ["msdp.CON"] = "GUI.updatePlayer",
    ["msdp.INT"] = "GUI.updatePlayer",
    ["msdp.WIS"] = "GUI.updatePlayer",
    ["msdp.CHA"] = "GUI.updatePlayer",
    ["msdp.AC"] = "GUI.updatePlayer",
    ["msdp.MONEY"] = "GUI.updatePlayer",
    -- Room update for GUI display
    ["msdp.ROOM"] = "GUI.updateRoom",
    -- Map event handlers (non-MSDP)
    ["shiftRoom"] = "map.eventHandler",
    ["sysConnectionEvent"] = "map.eventHandler",
    ["sysDownloadDone"] = "map.eventHandler"
  }
  
  -- Register MSDP.ROOM for map separately
  -- NOTE: Both GUI.updateRoom and map.eventHandler need to handle msdp.ROOM events:
  -- - GUI.updateRoom: Updates the room info display in the GUI
  -- - map.eventHandler: Updates mapper position and handles environment transitions
  -- Mudlet allows multiple handlers for the same event, so both will fire
  local mapEventHandlers = {
    ["msdp.ROOM"] = "map.eventHandler",
    ["sysProtocolEnabled"] = "map.onProtocolEnabled"
  }
  
  -- Store handler IDs for potential cleanup
  GUI.eventHandlerIds = GUI.eventHandlerIds or {}
  
  -- Register GUI event handlers
  for event, handler in pairs(eventHandlers) do
    local success, handlerId = pcall(registerAnonymousEventHandler, event, handler)
    if success then
      GUI.eventHandlerIds[event] = handlerId
      -- Optional: uncomment for debugging
      -- print(string.format("✓ Registered GUI handler for %s", event))
    else
      print(string.format("✗ Failed to register GUI handler for %s: %s", event, handlerId))
    end
  end
  
  -- Register map event handlers separately
  for event, handler in pairs(mapEventHandlers) do
    local success, handlerId = pcall(registerAnonymousEventHandler, event, handler)
    if success then
      GUI.eventHandlerIds[event .. "_map"] = handlerId
      -- Optional: uncomment for debugging
      -- print(string.format("✓ Registered map handler for %s", event))
    else
      print(string.format("✗ Failed to register map handler for %s: %s", event, handlerId))
    end
  end
  
  -- Verify critical handlers are working and refresh displays
  tempTimer(2, function()
    -- Group tab refresh
    if msdp.GROUP and #msdp.GROUP > 0 then
      GUI.updateGroup()
    end
    
    -- Gauge refreshes
    if msdp.HEALTH and msdp.HEALTH_MAX then
      GUI.updateHealthGauge()
    end
    if msdp.MOVEMENT and msdp.MOVEMENT_MAX then
      GUI.updateMovesGauge()
    end
    -- if msdp.EXPERIENCE and msdp.EXPERIENCE_TNL then
    --   GUI.updateExperienceGauge()
    -- end
    if msdp.PSP and msdp.PSP_MAX then
      GUI.updatePSPGauge()
    end
    
    -- Enemy gauge refresh (only if opponent data exists)
    if msdp.OPPONENT_NAME and msdp.OPPONENT_NAME ~= "" then
      GUI.updateEnemyGauge()
    else
      -- Hide enemy gauge if not in combat
      if GUI.Enemy then
        GUI.Enemy:hide()
      end
    end
    
    -- Player tab refresh
    if msdp.CHARACTER_NAME then
      GUI.updatePlayer()
    end
    
    -- Room info refresh
    if msdp.ROOM then
      GUI.updateRoom()
    end
  end)
  
  -- Initialize chat system if it's enabled but not created
  tempTimer(1, function()
    if demonnic.chat.use and not demonnic.chat.container then
      demonnicOnStart()
    end
  end)
end

-- =============================================================================
-- CENTRALIZED GUI INITIALIZATION SYSTEM
-- =============================================================================
-- This function provides a single point of control for all GUI initialization
-- and refresh operations. It should be called from ALL relevant entry points.
--
-- WHEN TO CALL THIS FUNCTION:
-- 1. Package load/install (sysLoadEvent, sysInstall) 
-- 2. Connection established (sysConnectionEvent)
-- 3. MSDP protocol enabled (sysProtocolEnabled)
-- 4. Manual refresh commands (fix gui, fix chat)
-- 5. After login/reconnect (when MSDP data starts flowing)
--
-- WHAT IT DOES:
-- - Initializes or refreshes all GUI components
-- - Re-registers event handlers that may have failed
-- - Refreshes all displays with current MSDP data
-- - Ensures proper container visibility and z-order
-- - Handles both initial setup and runtime refresh
-- =============================================================================
function GUI.initializeOrRefresh(context)
  context = context or "unknown"
  
  -- Track if this is initial setup or refresh
  local isRefresh = (GUI.initialized == true)
  
  if not isRefresh then
    -- GUI not initialized yet - initialize it now
    cecho(string.format("\n&lt;yellow&gt;Initializing GUI components (%s)...", context))
    GUI.init()
    return
  else
    -- Refresh existing GUI
    cecho(string.format("\n&lt;yellow&gt;Refreshing GUI components (%s)...", context))
  end
  
  -- Always ensure event handlers are registered
  GUI.registerEventHandlers()
  
  -- Refresh all adjustable containers
  local refreshed = {}
  
  -- Status Gauges
  if GUI.Box7 then
    GUI.Box7:show()
    GUI.Box7:raise()
    if msdp.HEALTH then GUI.updateHealthGauge() end
    if msdp.MOVEMENT then GUI.updateMovesGauge() end
    -- if msdp.EXPERIENCE then GUI.updateExperienceGauge() end
    if msdp.PSP then GUI.updatePSPGauge() end
    table.insert(refreshed, "status gauges")
  end
  
  -- TabbedInfo Window
  if GUI.tabbedInfoWindowContainer then
    GUI.tabbedInfoWindowContainer:show()
    GUI.tabbedInfoWindowContainer:raise()
    -- Ensure Player tab is visible and updated
    if GUI.tabbedInfoWindow and GUI.tabbedInfoWindow.Player then
      GUI.tabbedInfoWindow.click("Player")
      if msdp.CHARACTER_NAME then GUI.updatePlayer() end
    end
    table.insert(refreshed, "tabbed info window")
  end
  
  -- Action Icons
  if GUI.actionIconsContainer then
    GUI.actionIconsContainer:show()
    GUI.actionIconsContainer:raise()
    if msdp.ACTIONS then GUI.updateActionIcons() end
    table.insert(refreshed, "action icons")
  end
  
  -- Enemy gauge (combat only)
  if msdp.OPPONENT_NAME and msdp.OPPONENT_NAME ~= "" then
    GUI.updateEnemyGauge()
  elseif GUI.Enemy then
    GUI.Enemy:hide()
  end
  
  -- Group tab
  if GUI.groupWindow and msdp.GROUP then
    GUI.updateGroup()
    table.insert(refreshed, "Group tab")
  end
  
  -- Player tab
  if GUI.playerWindow and msdp.CHARACTER_NAME then
    GUI.updatePlayer()
    table.insert(refreshed, "Player tab")
  end
  
  -- Room info
  if GUI.Box5 and msdp.ROOM then
    GUI.updateRoom()
    table.insert(refreshed, "room info")
  end
  
  -- ASCII map
  if map.minimap and msdp.ROOM then
    map.eventHandler("msdp.ROOM")
    table.insert(refreshed, "ASCII map")
  end
  
  -- Mudlet mapper
  if map.mapwindow then
    map.mapwindow:show()
    map.mapwindow:resize()
    -- Force refresh with delayed operations
    tempTimer(0.1, function()
      if map.mapwindow then
        map.mapwindow:resize()
        if map.mapwindow.raise then
          map.mapwindow:raise()
        end
        -- Try to center on current room
        if map.currentRoom and map.currentRoom > 0 then
          centerview(map.currentRoom)
        end
      end
    end)
    table.insert(refreshed, "Mudlet mapper")
  end
  
  -- Chat system
  if GUI.chatContainer then
    GUI.chatContainer:show()
    -- Initialize chat if needed
    if demonnic.chat.use and not demonnic.chat.container then
      demonnicOnStart()
      table.insert(refreshed, "chat system (initialized)")
    else
      table.insert(refreshed, "chat container")
    end
  end
  
  -- Button Panel (Controls)
  if GUI.buttonPanelContainer then
    GUI.buttonPanelContainer:show()
    GUI.buttonPanelContainer:raise()
    table.insert(refreshed, "button panel")
  end
  
  -- Room Info Container
  if GUI.roomInfoContainer then
    GUI.roomInfoContainer:show()
    GUI.roomInfoContainer:raise()
    -- Update room data if available
    if msdp.ROOM then
      GUI.updateRoom()
    end
    table.insert(refreshed, "room info container")
  end
  
  -- Cast Console
  if GUI.castConsoleContainer then
    GUI.castConsoleContainer:show()
    GUI.castConsoleContainer:raise()
    table.insert(refreshed, "cast console")
  end
  
  -- ASCII Map Container (ensure it exists before mode check)
  if GUI.asciiMapContainer then
    GUI.asciiMapContainer:show()
    table.insert(refreshed, "ASCII map container")
  end
  
  -- Handle map container visibility based on mode
  if GUI.buttonWindow and GUI.buttonWindow.mudletOrAscii then
    if GUI.buttonWindow.mudletOrAscii == "ASCII" then
      if map.container then map.container:hide() end
      if GUI.asciiMapContainer then
        GUI.asciiMapContainer:raise()
      end
    else
      if GUI.asciiMapContainer then GUI.asciiMapContainer:hide() end
      if map.container then
        map.container:show()
        map.container:raise()
      end
    end
  end
  
  -- Ensure proper z-order (delayed to allow all components to initialize)
  tempTimer(0.5, function()
    -- Let Adjustable Containers manage their own z-order
    -- Only raise containers that need to be on top of others
    if GUI.chatContainer then GUI.chatContainer:raise() end
    if GUI.actionIconsContainer then GUI.actionIconsContainer:raise() end
  end)
  
  -- Report results
  if #refreshed > 0 then
    cecho(string.format("\n&lt;green&gt;%s complete: %s", 
      isRefresh and "Refresh" or "Initialization",
      table.concat(refreshed, ", ")))
  end
end

-- =============================================================================
-- ENTRY POINT HANDLERS
-- These ensure GUI.initializeOrRefresh is called at the right times
-- while preserving other initialization functions
-- =============================================================================

-- The onProtocolEnabled handler is defined in the MSDP script section
-- It handles MSDP variable registration and GUI initialization

-- The main initialization handlers are registered at the bottom of this script
-- along with the original GUI.init() registration to ensure proper order

-- Register the proper initialization sequence
registerAnonymousEventHandler("sysLoadEvent", "GUI.init")
registerAnonymousEventHandler("sysInstall", "GUI.init")

-- Register protocol handler early to ensure it catches MSDP enablement
-- This is critical because MSDP can be enabled before GUI.init() completes
registerAnonymousEventHandler("sysProtocolEnabled", "GUI.onProtocolEnabled")

-- Add connection-based refresh
registerAnonymousEventHandler("sysConnectionEvent", function()
  tempTimer(1, function()
    GUI.initializeOrRefresh("connection established")
  end)
end)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>AdjustableContainers</name>
						<packageName></packageName>
						<script>-- GUI.AdjustableContainers - Foundation for Adjustable Container System
-- This namespace manages all adjustable containers in the LuminariGUI

GUI.AdjustableContainers = GUI.AdjustableContainers or {}

-- Container registry for lifecycle management
GUI.AdjustableContainers.containers = GUI.AdjustableContainers.containers or {}

-- Current active layout profile
GUI.AdjustableContainers.currentProfile = GUI.AdjustableContainers.currentProfile or "default"

-- Save/Load directory configuration
GUI.AdjustableContainers.saveDir = string.format("%s/LuminariGUI/layouts/", getMudletHomeDir())

-- Default container styles matching current theme
GUI.AdjustableContainers.defaultStyle = {
  adjLabelstyle = [[
    background-image: url(]] .. getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/ui_texture.jpg);
    background-color: rgba(38, 25, 47, 0.9);
    border: 2px solid rgba(184, 115, 27, 0.8);
    border-radius: 5px;
    padding: 5px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
    font-family: Tahoma, Geneva, sans-serif;
  ]],
  buttonstyle = [[
    QLabel { 
      border-radius: 7px; 
      background-color: rgba(100,100,100,100%); 
      border: 1px solid rgba(184, 115, 27, 0.5);
    }
    QLabel::hover { 
      background-color: rgba(120,120,120,100%); 
      border: 1px solid rgba(184, 115, 27, 0.8);
      box-shadow: 0px 0px 3px rgba(184, 115, 27, 0.5);
    }
    QLabel::pressed {
      background-color: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(184, 115, 27, 1.0);
    }
  ]],
  titleTxtColor = "#FFD700",  -- Golden color for better contrast
  buttonFontSize = 10,
  buttonsize = 20,
  padding = 5,
  autoSave = true,
  autoLoad = true,
  noClose = true,
  defaultDir = GUI.AdjustableContainers.saveDir
}

-- Container naming convention
function GUI.AdjustableContainers.generateName(baseName)
  return "LuminariGUI_" .. baseName
end

-- Container registration system
function GUI.AdjustableContainers.register(container, name, componentType)
  if not container then
    print("ERROR: Cannot register nil container: " .. (name or "unknown"))
    return false
  end
  
  local containerInfo = {
    container = container,
    name = name,
    componentType = componentType,
    created = os.time(),
    profile = GUI.AdjustableContainers.currentProfile
  }
  
  GUI.AdjustableContainers.containers[name] = containerInfo
  print("✓ Registered container: " .. name .. " (" .. componentType .. ")")
  return true
end

-- Container lifecycle management
function GUI.AdjustableContainers.create(name, componentType, config)
  local fullName = GUI.AdjustableContainers.generateName(name)
  
  -- Merge default style with custom config
  local containerConfig = {}
  for k, v in pairs(GUI.AdjustableContainers.defaultStyle) do
    containerConfig[k] = v
  end
  if config then
    for k, v in pairs(config) do
      containerConfig[k] = v
    end
  end
  
  -- Set the container name
  containerConfig.name = fullName
  
  -- Create the adjustable container
  local container = Adjustable.Container:new(containerConfig)
  
  if container then
    GUI.AdjustableContainers.register(container, fullName, componentType)
    return container
  else
    print("ERROR: Failed to create container: " .. fullName)
    return nil
  end
end

function GUI.AdjustableContainers.show(name)
  local containerInfo = GUI.AdjustableContainers.containers[name]
  if containerInfo and containerInfo.container then
    containerInfo.container:show()
    return true
  end
  return false
end

function GUI.AdjustableContainers.hide(name)
  local containerInfo = GUI.AdjustableContainers.containers[name]
  if containerInfo and containerInfo.container then
    containerInfo.container:hide()
    return true
  end
  return false
end

function GUI.AdjustableContainers.destroy(name)
  local containerInfo = GUI.AdjustableContainers.containers[name]
  if containerInfo and containerInfo.container then
    containerInfo.container:hide()
    -- Note: Adjustable containers handle their own cleanup
    GUI.AdjustableContainers.containers[name] = nil
    print("✓ Destroyed container: " .. name)
    return true
  end
  return false
end

-- Layout Profile System
GUI.AdjustableContainers.profiles = {
  default = {
    name = "Default Layout",
    description = "Standard layout for general gameplay",
    containers = {
      chat = { x = "25%", y = "-25%", width = "50%", height = "25%" },
      gauges = { x = "0%", y = "75%", width = "25%", height = "25%" },
      tabinfo = { x = "0%", y = "0%", width = "25%", height = "75%" },
      room = { x = "-25%", y = "15%", width = "25%", height = "35%" },
      buttons = { x = "-25%", y = "0%", width = "25%", height = "15%" },
      actions = { x = "-25%", y = "50%", width = "25%", height = "35%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  },
  combat = {
    name = "Combat Layout",
    description = "Optimized for combat situations",
    containers = {
      chat = { x = "25%", y = "-25%", width = "50%", height = "25%" },
      gauges = { x = "0%", y = "75%", width = "25%", height = "25%" },
      tabinfo = { x = "0%", y = "0%", width = "25%", height = "75%" },
      room = { x = "-25%", y = "15%", width = "25%", height = "35%" },
      buttons = { x = "-25%", y = "0%", width = "25%", height = "15%" },
      actions = { x = "-25%", y = "50%", width = "25%", height = "35%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  },
  social = {
    name = "Social Layout", 
    description = "Emphasizes chat and communication",
    containers = {
      chat = { x = "25%", y = "-40%", width = "50%", height = "40%" },
      gauges = { x = "0%", y = "85%", width = "25%", height = "15%" },
      tabinfo = { x = "0%", y = "0%", width = "25%", height = "85%" },
      room = { x = "-25%", y = "15%", width = "25%", height = "35%" },
      buttons = { x = "-25%", y = "0%", width = "25%", height = "15%" },
      actions = { x = "-25%", y = "50%", width = "25%", height = "35%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  },
  minimal = {
    name = "Minimal Layout",
    description = "Minimalist layout for maximum game text visibility",
    containers = {
      chat = { x = "20%", y = "-20%", width = "60%", height = "20%" },
      gauges = { x = "0%", y = "80%", width = "20%", height = "20%" },
      tabinfo = { x = "0%", y = "0%", width = "20%", height = "80%" },
      room = { x = "-20%", y = "10%", width = "20%", height = "30%" },
      buttons = { x = "-20%", y = "0%", width = "20%", height = "10%" },
      actions = { x = "-20%", y = "40%", width = "20%", height = "30%" },
      cast = { x = "30%", y = "10%", width = "40%", height = "20%" }
    }
  }
}

-- Profile management functions
function GUI.AdjustableContainers.switchProfile(profileName)
  if not GUI.AdjustableContainers.profiles[profileName] then
    print("ERROR: Profile '" .. profileName .. "' does not exist")
    return false
  end
  
  print("Switching to profile: " .. GUI.AdjustableContainers.profiles[profileName].name)
  GUI.AdjustableContainers.currentProfile = profileName
  
  -- Apply profile to all containers
  local profile = GUI.AdjustableContainers.profiles[profileName]
  for containerName, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    local componentType = containerInfo.componentType
    local profileConfig = profile.containers[componentType]
    
    if profileConfig and containerInfo.container then
      containerInfo.container:move(profileConfig.x, profileConfig.y)
      containerInfo.container:resize(profileConfig.width, profileConfig.height)
    end
  end
  
  print("✓ Applied profile: " .. profileName)
  return true
end

function GUI.AdjustableContainers.saveProfile(profileName)
  if not profileName then
    profileName = GUI.AdjustableContainers.currentProfile
  end
  
  print("Saving profile: " .. profileName)
  Adjustable.Container:saveAll(profileName)
  print("✓ Profile saved: " .. profileName)
end

function GUI.AdjustableContainers.loadProfile(profileName)
  if not profileName then
    profileName = GUI.AdjustableContainers.currentProfile
  end
  
  print("Loading profile: " .. profileName)
  Adjustable.Container:loadAll(profileName)
  GUI.AdjustableContainers.currentProfile = profileName
  print("✓ Profile loaded: " .. profileName)
end

function GUI.AdjustableContainers.resetProfile(profileName)
  if not profileName then
    profileName = GUI.AdjustableContainers.currentProfile
  end
  
  print("Resetting profile: " .. profileName)
  GUI.AdjustableContainers.switchProfile(profileName)
  GUI.AdjustableContainers.saveProfile(profileName)
  print("✓ Profile reset: " .. profileName)
end

-- Container utility functions
function GUI.AdjustableContainers.showAll()
  for name, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    if containerInfo.container then
      containerInfo.container:show()
    end
  end
  print("✓ All containers shown")
end

function GUI.AdjustableContainers.hideAll()
  for name, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    if containerInfo.container then
      containerInfo.container:hide()
    end
  end
  print("✓ All containers hidden")
end

function GUI.AdjustableContainers.listContainers()
  print("=== LuminariGUI Container Registry ===")
  print("Current Profile: " .. GUI.AdjustableContainers.currentProfile)
  print("Save Directory: " .. GUI.AdjustableContainers.saveDir)
  print("")
  
  for name, containerInfo in pairs(GUI.AdjustableContainers.containers) do
    local status = containerInfo.container and "✓" or "✗"
    print(string.format("%s %s (%s)", status, name, containerInfo.componentType))
  end
  
  print("")
  print("Available Profiles:")
  for profileName, profile in pairs(GUI.AdjustableContainers.profiles) do
    local marker = (profileName == GUI.AdjustableContainers.currentProfile) and "* " or "  "
    print(string.format("%s%s - %s", marker, profile.name, profile.description))
  end
end

-- Initialize the directory structure
function GUI.AdjustableContainers.init()
  -- Create save directory if it doesn't exist
  lfs.mkdir(GUI.AdjustableContainers.saveDir)
  
  -- Save default profile on first run
  if not io.exists(GUI.AdjustableContainers.saveDir .. "default.json") then
    GUI.AdjustableContainers.saveProfile("default")
  end
  
  print("✓ AdjustableContainers initialized")
  print("  Save Directory: " .. GUI.AdjustableContainers.saveDir)
  print("  Current Profile: " .. GUI.AdjustableContainers.currentProfile)
end

-- Register initialization
registerAnonymousEventHandler("sysLoadEvent", "GUI.AdjustableContainers.init")
registerAnonymousEventHandler("sysInstall", "GUI.AdjustableContainers.init")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Custom Scrollbar</name>
						<packageName></packageName>
						<script>function GUI.styleScrollbar()
  local background_color = "#202020"
  local handle_color = "#d0d0d0"     -- Light gray for visible handles
  local border_color = "#a0a0a0"     -- Light border for handle outline
  setProfileStyleSheet(
    [[
  QScrollBar:vertical {
     background: ]] ..
    background_color ..
    [[;
     width: 15px;
     margin: 22px 0 22px 0;
  }
  QScrollBar:horizontal {
     background: ]] ..
    background_color ..
    [[;
     height: 15px;
     margin: 0 22px 0 22px;
  }
  QScrollBar::handle:vertical {
     background-color: ]] ..
    handle_color ..
    [[;
     min-height: 20px;
     border-width: 2px;
     border-style: solid;
     border-color: ]] ..
    border_color ..
    [[;
     border-radius: 7px;
  }
  QScrollBar::handle:horizontal {
     background-color: ]] ..
    handle_color ..
    [[;
     min-width: 20px;
     border-width: 2px;
     border-style: solid;
     border-color: ]] ..
    border_color ..
    [[;
     border-radius: 7px;
  }
  QScrollBar::add-line:vertical {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-bottom-left-radius: 7px;
   border-bottom-right-radius: 7px;
        height: 15px;
        subcontrol-position: bottom;
        subcontrol-origin: margin;
  }
  QScrollBar::add-line:horizontal {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-bottom-right-radius: 7px;
   border-top-right-radius: 7px;
        width: 15px;
        subcontrol-position: right;
        subcontrol-origin: margin;
  }
  QScrollBar::sub-line:vertical {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-top-left-radius: 7px;
   border-top-right-radius: 7px;
        height: 15px;
        subcontrol-position: top;
        subcontrol-origin: margin;
  }
  QScrollBar::sub-line:horizontal {
   background-color: ]] ..
    background_color ..
    [[;
   border-width: 2px;
   border-style: solid;
   border-color: ]] ..
    border_color ..
    [[;
   border-bottom-left-radius: 7px;
   border-top-left-radius: 7px;
        width: 15px;
        subcontrol-position: left;
        subcontrol-origin: margin;
  }
  QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
     background: #404040;
     width: 4px;
     height: 3px;
  }
  QScrollBar::left-arrow:horizontal, QScrollBar::right-arrow:horizontal {
     background: #404040;
     width: 3px;
     height: 4px;
  }
  QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
     background: none;
  }
  QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {
     background: none;
  }
]]
  )
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Delete Line and  Prompt</name>
						<packageName></packageName>
						<script>function deleteLineP()
  deleteLine()
  tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>YATCOConfig</name>
				<packageName>YATCOConfig</packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>YATCOCONFIG</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.config = demonnic.chat.config or {}</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Configuration Options</name>
						<packageName></packageName>
						<script>--[[
This is where all of the configuration options can be set. 
Anything I've put in this script object can be changed, but please do pay attention to what you're doing.
If you change one of the values to something it shouldn't be, you could break it. 
]]

--This is where you tell it to use tabbed chat.
demonnic.chat.use = true

--[[
This is where you put what container to put the tabbed chat stuff into. Make it
equal to the actual container object you want it in, or false for none. Defaults to false
Which is to say if you want to put the tabbed chat stuff into a container made using 
uiRight = Geyser.Container:new()

you would put

demonnic.chat.useContainer = uiRight

and if you don't want it in a container you would put

demonnic.chat.useContainer = false
]]

-- Chat container will be set after GUI initialization
demonnic.chat.useContainer = false

--[[
The timestamp option is set here.
Set to false if you do not want any timestamps displayed for chat.
If you do want it displayed, set to the string for the format you wish. 
see http://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for information
how to format the string
]]
--demonnic.chat.config.timestamp = "HH:mm:ss"
demonnic.chat.config.timestamp = false

--[[ Should we use our own colors for the timestamp?
Set to true if you want to specify foreground and background colors
for the timestamp.
Set to false if you want the timestamps background and foreground
colors to match that of the mud output.
]]
demonnic.chat.config.timestampCustomColor = false
--[[
and what foreground color? You can either use one of the 'named' colors
(see http://wiki.mudlet.org/images/c/c3/ShowColors.png for available colors)
demonnic.chat.config.timestampFG = "slate_grey"

Or you can use a table of R,G,B values. 
demonnic.chat.config.timestampFG = {
  255,
    0,
    0,
}
then the foreground for the timestamp would be 255 read, 100 green, and 0 blue
]]
demonnic.chat.config.timestampFG = "red"

--and background? Same rules as for the foreground above
demonnic.chat.config.timestampBG = "blue"

--[[
This is where you say what corner of the screen you want the tabbed chat on
Valid settings are "topright", "topleft", "bottomright", "bottomleft"
]]--
demonnic.chat.config.location = "topright"

--[[
This is a table of channels you would like.
AKA the place you tell the script what tabs you want.
Each entry must be a string. The defaults should be a pretty effective guide.
]]

demonnic.chat.config.channels = {
  "All",
  "Tell",
  "Chat",
	"Say",
	"Wiz",
	"Group",
	"Congrats",
	"Auction",  
}


--Set this to the name of the channel you want to have everything sent to. 
--Per the default, this would be the "All" channel. If you have a different name for it:
--
--demonnic.chat.config.Alltab = "Bucket"  
--
--And if you don't want it turned on at all:
--
--demonnic.chat.config.Alltab = false

demonnic.chat.config.Alltab = "All"

--Set this to the name of the channel you want to display your map. Set to "" if you
--don't want to display the map in your YATCO tabs
demonnic.chat.config.Maptab = ""


---------------------------------------------------------------------------------
--                                                                             --
--The infamous blinking stuff!!!                                               --
--                                                                             --
---------------------------------------------------------------------------------

--[[
Do you want tabs to blink when you get new messages, until you click on the tab?
True if yes, false if no.
]]
demonnic.chat.config.blink = true

--How long (in seconds) between blinks? For example, 1 would mean a 1 second pause in between blinks.
demonnic.chat.config.blinkTime = 3

--Blink if the bucket tab ("All" by default, but configured above) is in focus?
demonnic.chat.config.blinkFromAll = false

-- Sound notification settings
demonnic.chat.config.soundEnabled = demonnic.chat.config.soundEnabled or false  -- Default OFF
demonnic.chat.config.soundFile = demonnic.chat.config.soundFile or "audio/chat_sound.mp3"   -- Default sound file
demonnic.chat.config.soundVolume = demonnic.chat.config.soundVolume or 100      -- Volume 0-100
demonnic.chat.config.soundCooldown = demonnic.chat.config.soundCooldown or 0      -- Cooldown in seconds (0 = no cooldown)
demonnic.chat.lastSoundTime = demonnic.chat.lastSoundTime or 0                   -- Track last sound timestamp




--Font size for the chat messages

demonnic.chat.config.fontSize = getFontSize("main")

--[[
Should we preserve the formatting of the text. 
Or should we set the background of it to match the window color?
Set this to false if you want the background for all chat to match the background of the window.
Useful if you change the background from black, and don't like the way the pasted chat makes blocks in it
]]

demonnic.chat.config.preserveBackground = true

--[[
Gag the chat lines in the main window?
defaults to false, set to true if you want to gag.
]]

demonnic.chat.config.gag = false

--[[
Number of lines of chat visible at once. 
Will determine how tall the window for the chats is.
]]

demonnic.chat.config.lines = 22

--[[
Number of characters to wrap the chatlines at.
This will also determine how wide the chat windows are.
]]

demonnic.chat.config.width = getColumnCount("main")

--[[
Set the color for the active tab. R,G,B format.
The default here is a brightish green
]]

demonnic.chat.config.activeColors = {
  r = 0,
  g = 180,
  b = 0,
}

--[[
Set the color for the inactive tab. R,G,B format.
The default here is a drab grey
]]

demonnic.chat.config.inactiveColors = {
  r = 60,
  g = 60,
  b = 60,
}

--[[
Set the color for the chat window itself. R,G,B format.
Defaulted to the black of my twisted hardened soul. Or something.
]]

demonnic.chat.config.windowColors = {
  r = 0,
  g = 0,
  b = 0,
}

--[[
Set the color for the text on the active tab. Uses color names.
Set the default to purple. So the tab you're looking at, by default will be purple on bright green. 
Did I mention I'm a bit colorblind?
]]

demonnic.chat.config.activeTabText = "yellow"

--[[
Set the color for the text on the inactive tabs. Uses color names.
Defaulted this to white. So the tabs you're not looking at will be white text on boring grey background.
]]

demonnic.chat.config.inactiveTabText = "white"

--[[
have to make sure a currentTab is set... 
so we'll use the one for the bucket, or the first one in the channels table
Or, you know... what it's currently set to, if it's already set.
]]
demonnic.chat.currentTab = demonnic.chat.currentTab or demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>YATCO</name>
				<packageName>YATCO</packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Demonnic</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>Shared</name>
						<packageName></packageName>
						<script>--Bootstrapping variables/etc. Don't touch this unless you really know what you're doing

--I mean it. I'll point. AND laugh. loudly. 
demonnic = demonnic or {}
demonnic.config = demonnic.config or {}
demonnic.balances = demonnic.balances or {}
demonnic.balances.balance = demonnic.balances.balance or 1
demonnic.balances.equilibrium = demonnic.balances.equilibrium or 1
demonnic.debug = demonnic.debug or {}
demonnic.debug.active = demonnic.debug.active or nil
demonnic.debug.categories = demonnic.debug.categories or { }


function demonnic:echo(msg)
 cecho(string.format("\n&lt;blue&gt;(&lt;green&gt;Demonnic&lt;blue&gt;):&lt;white&gt; %s", msg))
end</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>Debugging</name>
							<packageName></packageName>
							<script>--Adds debugging functionality 

function demonnic:Debug(category,debugData)
   if category then
      if table.contains(demonnic.debug.categories, category) then
         if type(debugData) == "table" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt;")
            display(debugData)
         elseif type(debugData) == "string" or type(debugData) == "number" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. debugData .. "\n" )
         else
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. tostring(debugData) .. "\n" )
         end
      end
   else
      if type(debugData) == "table" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt;")
         display(debugData)
      elseif type(debugData) == "string" or type(debugData) == "number" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. debugData)
      else
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. tostring(debugData))
      end
   end
end

function demonnic:printDebug(category, debugData)
   if not demonnic.debug.active then return end
   demonnic:Debug(category, debugData)
end

function demonnic:toggleDebug()
   if demonnic.debug.active then demonnic.debug.active = nil
   else demonnic.debug.active = true
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:watchCategory( category )
   if table.contains(demonnic.debug.categories, category) then
      for i,v in ipairs(demonnic.debug.categories) do
         if v == category then
            table.remove(demonnic.debug.categories, i)
         end
      end
      demonnic:echo("No longer watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.") 
   else
      table.insert(demonnic.debug.categories, category)
      demonnic:echo("Now watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.")
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:listCategories()
   if #demonnic.debug.categories &gt; 0 then
      demonnic:echo("You are currently watching the following categories:\n" .. table.concat(demonnic.debug.categories,", ") )
   else
      demonnic:echo("You are not watching any debugs.")
   end
end
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>Geyser Additions</name>
							<packageName></packageName>
							<script>function Geyser.MiniConsole:clear()
   clearWindow(self.name)
end

function Geyser.MiniConsole:append()
  appendBuffer(self.name)
end</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>Tabbed Chat</name>
						<packageName></packageName>
						<script>--Do not remove the following lines. Or change them.
demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.tabsToBlink = demonnic.chat.tabsToBlink or {}
demonnic.chat.tabs = demonnic.chat.tabs or {}
demonnic.chat.windows = demonnic.chat.windows or {}
if not demonnic.chat.config then
  cecho("&lt;red:white&gt;YOU DO NOT HAVE THE YATCO CONFIG PACKAGE IN PLACE. THINGS WILL NOT WORK AS EXPECTED\n\n")
  demonnic.chat.error = "NO CONFIG"
end</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>Code</name>
							<packageName></packageName>
							<script>--[[
If the label callbacks ever decide to start taking a function which is part of a table, 0then this will change.
Or if it's modified to take actual functions. Anonymouse function clickcallback would be awfully nice.
]]

function demonnicChatSwitch(chat)
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local newr = demonnic.chat.config.activeColors.r
  local newg = demonnic.chat.config.activeColors.g
  local newb = demonnic.chat.config.activeColors.b
  local oldchat = demonnic.chat.currentTab
  if demonnic.chat.currentTab ~= chat then
    demonnic.chat.windows[oldchat]:hide()
    demonnic.chat.tabs[oldchat]:setColor(r,g,b)
    demonnic.chat.tabs[oldchat]:echo(oldchat, demonnic.chat.config.inactiveTabText, "c")
    if demonnic.chat.config.blink and demonnic.chat.tabsToBlink[chat] then
      demonnic.chat.tabsToBlink[chat] = nil
    end
    if demonnic.chat.config.blink and chat == demonnic.chat.config.Alltab then
      demonnic.chat.tabsToBlink = {}
    end
  end
  demonnic.chat.tabs[chat]:setColor(newr,newg,newb)
  demonnic.chat.tabs[chat]:echo(chat, demonnic.chat.config.activeTabText, "c")
  demonnic.chat.windows[chat]:show()
  demonnic.chat.currentTab = chat  
end

function demonnic.chat:resetUI()
  demonnic.chat.container = demonnic.chat.useContainer or Geyser.Container:new(demonnic.chat[demonnic.chat.config.location]())
  demonnic.chat.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "25px",
    name = "DemonChatTabs",
  },demonnic.chat.container)

end

function demonnic.chat:create()
  --reset the UI
  demonnic.chat:resetUI()
  --Set some variables locally to increase readability
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local winr = demonnic.chat.config.windowColors.r
  local wing = demonnic.chat.config.windowColors.g
  local winb = demonnic.chat.config.windowColors.b

  --iterate the table of channels and create some windows and tabs
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.tabs[tab] = Geyser.Label:new({
      name=string.format("tab%s", tab),
    }, demonnic.chat.tabBox)
    demonnic.chat.tabs[tab]:echo(tab, demonnic.chat.config.inactiveTabText, "c")
    demonnic.chat.tabs[tab]:setColor(r,g,b)
    demonnic.chat.tabs[tab]:setClickCallback("demonnicChatSwitch", tab)
		
		demonnic.chat.tabs[tab]:setStyleSheet(
		 [[font-family: Tahoma, Geneva, sans-serif; 
		border-image: url(]] ..
    getMudletHomeDir():gsub("\\", "/") .. [[/LuminariGUI/images/buttons/button.png) 0 0 0 0 stretch stretch;
		border: 1px solid rgba(184, 115, 27, 0.5);
		border-radius: 3px 3px 0px 0px;
		padding: 2px;
		font-weight: bold;
		]])
		
    demonnic.chat.windows[tab] = Geyser.MiniConsole:new({
--      fontSize = demonnic.chat.config.fontSize,
      x = 0,
      y = 25,
      height = "100%",
      width = "100%",
      name = string.format("win%s", tab),
    }, demonnic.chat.container)
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
    demonnic.chat.windows[tab]:setColor(winr,wing,winb)
    demonnic.chat.windows[tab]:setWrap(demonnic.chat.config.width)
    demonnic.chat.windows[tab]:hide()
  end
  if demonnic.chat.config.Maptab and demonnic.chat.config.Maptab ~= "" then
    demonnic.chat.mapWindow = Geyser.Mapper:new({
      x = 0,
      y = 0,
      height = "100%",
      width = "100%",
    }, demonnic.chat.windows[demonnic.chat.config.Maptab])
    demonnic.chat.windows[demonnic.chat.config.Maptab]:hide()
  end
  local showme = demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
  demonnicChatSwitch(showme)
  --start the blink timers, if enabled
  if demonnic.chat.config.blink and not demonnic.chat.blinkTimerOn then
    demonnic.chat:blink()
  end
end

function demonnic.chat:append(chat)
  local r = demonnic.chat.config.windowColors.r
  local g = demonnic.chat.config.windowColors.g
  local b = demonnic.chat.config.windowColors.b
  selectCurrentLine()
  local ofr,ofg,ofb = getFgColor()
  local obr,obg,obb = getBgColor()
  if demonnic.chat.config.preserveBackground then
    setBgColor(r,g,b)
  end
  copy()
  if demonnic.chat.config.timestamp then
    local timestamp = getTime(true, demonnic.chat.config.timestamp)
    local tsfg = {}
    local tsbg = {}
    local colorLeader = ""
    if demonnic.chat.config.timestampCustomColor then
      if type(demonnic.chat.config.timestampFG) == "string" then
        tsfg = color_table[demonnic.chat.config.timestampFG]
      else
        tsfg = demonnic.chat.config.timestampFG
      end
      if type(demonnic.chat.config.timestampBG) == "string" then
        tsbg = color_table[demonnic.chat.config.timestampBG]
      else
        tsbg = demonnic.chat.config.timestampBG
      end
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",tsfg[1],tsfg[2],tsfg[3],tsbg[1],tsbg[2],tsbg[3])
    else
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",ofr,ofg,ofb,obr,obg,obb)
    end
    local fullstamp = string.format("%s%s",colorLeader,timestamp)
      demonnic.chat.windows[chat]:decho(fullstamp)
      demonnic.chat.windows[chat]:echo(" ")
      if demonnic.chat.config.Alltab then 
        demonnic.chat.windows[demonnic.chat.config.Alltab]:decho(fullstamp)
        demonnic.chat.windows[demonnic.chat.config.Alltab]:echo(" ")
      end
  end
  
  -- Add colored channel prefixes based on TASK_LIST.md requirements
  local channelColors = {
    ["Group"] = "&lt;green&gt;[GSAY]&lt;reset&gt; ",      -- Bright green for GSAY
    ["OOC"] = "&lt;light_gray&gt;[OOC]&lt;reset&gt; ",        -- Silver/Light gray for OOC
    ["Tell"] = "&lt;magenta&gt;[TELL]&lt;reset&gt; ",    -- Bright magenta for TELLS
    ["Say"] = "&lt;white&gt;[SAY]&lt;reset&gt; ",        -- White for SAYS
    ["Auction"] = "&lt;gold&gt;[AUC]&lt;reset&gt; ",     -- Gold for AUC
    ["Chat"] = "&lt;cyan&gt;[CHAT]&lt;reset&gt; ",       -- Default cyan for other chat
    ["Congrats"] = "&lt;yellow&gt;[GRATS]&lt;reset&gt; ", -- Yellow for congrats
    ["Wiz"] = "&lt;purple&gt;[WIZ]&lt;reset&gt; "        -- Purple for wizard channel
  }
  
  -- Add channel prefix before the message
  if channelColors[chat] then
    demonnic.chat.windows[chat]:cecho(channelColors[chat])
    if demonnic.chat.config.Alltab then
      demonnic.chat.windows[demonnic.chat.config.Alltab]:cecho(channelColors[chat])
    end
  end
  
  demonnic.chat.windows[chat]:append()
  if demonnic.chat.config.gag then 
    deleteLine() 
    tempLineTrigger(1,1, [[if isPrompt() then deleteLine() end]])
  end
  if demonnic.chat.config.Alltab then appendBuffer(string.format("win%s", demonnic.chat.config.Alltab)) end
  if demonnic.chat.config.blink and chat ~= demonnic.chat.currentTab then 
    if not ((demonnic.chat.config.Alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll) then
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
  
  -- Sound notification logic - play for ALL channels when enabled
  if demonnic.chat.config.soundEnabled then
    -- Check if we should play sound
    local shouldPlaySound = true
    
    -- Don't play sound if we're viewing the specific channel tab (not "All")
    if demonnic.chat.currentTab ~= demonnic.chat.config.Alltab and chat == demonnic.chat.currentTab then
      shouldPlaySound = false
    end
    
    if shouldPlaySound then
      -- Check cooldown
      local currentTime = os.time()
      if currentTime - demonnic.chat.lastSoundTime >= demonnic.chat.config.soundCooldown then
        -- Construct sound file path - try package directory first
        local soundPath = getMudletHomeDir() .. "/LuminariGUI/" .. demonnic.chat.config.soundFile
        
        -- Check if file exists before playing
        local file = io.open(soundPath, "r")
        if file then
          file:close()
          playSoundFile(soundPath, demonnic.chat.config.soundVolume)
          demonnic.chat.lastSoundTime = currentTime
        else
          -- Try user's home directory as fallback
          soundPath = getMudletHomeDir() .. "/" .. demonnic.chat.config.soundFile
          file = io.open(soundPath, "r")
          if file then
            file:close()
            playSoundFile(soundPath, demonnic.chat.config.soundVolume)
            demonnic.chat.lastSoundTime = currentTime
          else
            -- Use system beep as final fallback
            playSoundFile("")  -- Empty string triggers system beep in Mudlet
            demonnic.chat.lastSoundTime = currentTime
          end
        end
      end
    end
  end
end



function demonnic.chat:blink()
  if demonnic.chat.blinkID then killTimer(demonnic.chat.blinkID) end
  if not demonnic.chat.config.blink then 
    demonnic.chat.blinkTimerOn = false
    return 
  end
  if not demonnic.chat.container.hidden then
    for tab,_ in pairs(demonnic.chat.tabsToBlink) do
      demonnic.chat.tabs[tab]:flash()
    end
  end
  demonnic.chat.blinkID = tempTimer(demonnic.chat.config.blinkTime, function () demonnic.chat:blink() end)
end

function demonnic.chat:topright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=0,
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:topleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=0,
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>demonnicOnStart</name>
							<packageName></packageName>
							<script>function demonnicOnStart()
  if demonnic.chat.use then
    -- Set the container now that GUI is initialized
    -- Use the inner container to account for title bar and padding
    if GUI.chatContainerInner then
      demonnic.chat.useContainer = GUI.chatContainerInner
    elseif GUI.chatContainer then
      -- Fallback to main container if inner doesn't exist
      demonnic.chat.useContainer = GUI.chatContainer
    else
      print("Warning: GUI.chatContainer not found. Chat system may not display properly.")
    end
    
    local success, err = pcall(demonnic.chat.create, demonnic.chat)
    if not success then
      print(string.format("Error initializing chat system: %s", err))
    end
  end
end</script>
							<eventHandlerList>
								<string>sysLoadEvent</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>echo functions</name>
							<packageName></packageName>
							<script>
function demonnic.chat:cecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  cecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    cecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:decho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  decho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    decho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:hecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  hecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    hecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:echo(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  echo(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    echo(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>demonnicOnInstall</name>
							<packageName></packageName>
							<script>function demonnicOnInstall(_, package)
  -- Check for both LuminariGUI and YATCO package names to handle mid-session imports
  if package:find("YATCO") or package:find("LuminariGUI") then
    demonnicOnStart()
  end
end</script>
							<eventHandlerList>
								<string>sysInstall</string>
							</eventHandlerList>
						</Script>
					</ScriptGroup>
				</ScriptGroup>
			</ScriptGroup>
			<Script isActive="no" isFolder="no">
				<name>Changelog</name>
				<packageName></packageName>
				<script>--Changelog

--[[


   1.) Changed the following to support moving chatbox to bottom:
	   
	   -Added GUI.Bottom to Create Background Script
	   -Changed bottom border in Set Borders Script from setBorderBottom(0) to setBorderBottom(h / 4)
	   -Now Utilizing GUI.Box2 fot chatbox at bottom.
	   -Rewrote createFrame() function to allow for automatic frame generating regardless of
		  box size. Using the function is no different.
	   -Adjusted chatContainer height to fit frame nicely.
	   -Adjusted chatContainer x and y to fit frame nicely.
	   -Changed GUI.chatContainer name from GUI.Box2 to GUI.chatContainer
		
			 
	 2.) Added the following to support adding buttons to Box3
	     
		 -Created a new Script named Button which handles buttons individually by row.
		 -Creating button drawing functions so that they will each be called in an init
		  alias to generate them row by row. This will make it easier to change buttons
		  in the future.
		 -Making Box3 smaller. We don't need as many buttons as we have room for and I
		  have ideas for new things to place below Box3!
		 -Box 5 and 6 created. 5 to be used for Legend/Room Info. 6 to be used for skill
		  cooldown icons.
		 -Buttons added in Buttons script. Callbacks there as well. Legend is a toggle and
		  Mudlet/ASCII are separate callbacks.
	     -Legend and room info script created in Room Info/Legend script and proper event
		  handlers added to config for room info.
		 -Added check to Capture Room Map trigger to only display ASCII map if 
		  GUI.buttonWindow.mudletOrAscii == "ASCII". 
				
				
	 3.) Changed the following to support release this week.
	   
	     -Commenting out box 6 draw frame function.
				
					 
	 4.) Various Bug Fixes:
	     
	     -Fixed the trigger for Group chat to capture others talking in group.
         -Fixed gauges so they can no longer overfill into the main buffer by adding:
       
          if pct_health &gt; 100 then
            GUI.Health:setValue(100, 100)
          else
            GUI.Health:setValue(pct_health, 100)
          end
  
          *Equivalent added for each gauge. May look to add an effect to show a bar
           is overfilled when an enemy rages in the future*

  
	 5.) Quality of life:
	     
		 -Added a function to delete a line and the following prompt. It can be
		  utilized in any trigger to delete any line and the prompt it would have
		  created, but I created it primarily for the chatbox. Function is called
		  using deleteLineP().
		 -Added toggles that are saved to a .lua on exit and loaded on load event.
		  Currently they're used to determine if you're shown in the group or not
		  and if you would like to gag chat from main buffer with the above
		  function. (deleteLineP())
			 
	     -

]]
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Movement</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>-1</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>Southwest</name>
				<packageName></packageName>
				<script></script>
				<command>southwest</command>
				<keyCode>49</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>South</name>
				<packageName></packageName>
				<script></script>
				<command>south</command>
				<keyCode>50</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Southeast</name>
				<packageName></packageName>
				<script></script>
				<command>southeast</command>
				<keyCode>51</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>West</name>
				<packageName></packageName>
				<script></script>
				<command>west</command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Look</name>
				<packageName></packageName>
				<script></script>
				<command>look</command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>East</name>
				<packageName></packageName>
				<script></script>
				<command>east</command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Northwest</name>
				<packageName></packageName>
				<script></script>
				<command>northwest</command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>North</name>
				<packageName></packageName>
				<script></script>
				<command>north</command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Northeast</name>
				<packageName></packageName>
				<script></script>
				<command>northeast</command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Inventory</name>
				<packageName></packageName>
				<script></script>
				<command>inv</command>
				<keyCode>47</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Scan</name>
				<packageName></packageName>
				<script></script>
				<command>scan</command>
				<keyCode>42</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Up</name>
				<packageName></packageName>
				<script></script>
				<command>up</command>
				<keyCode>45</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Down</name>
				<packageName></packageName>
				<script></script>
				<command>down</command>
				<keyCode>43</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
